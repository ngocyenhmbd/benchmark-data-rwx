coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj1	100	3.023125	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@A) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v1) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj2	100	0.029534	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@B) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_refl	100	0.020702	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : v0 => v1) (fun v1 : v0 => v1))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_trans	100	0.038726	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v1 <-> v2, v0 <-> v2) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v1 <-> v2) => match v6 as v7 in (_ /\ _) return (v0 <-> v2) with | conj v7 v8 => (fun (v7 : forall v7 : v1, v2) (v8 : forall v8 : v2, v1) => conj (fun v9 : v0 => v7 (v4 v9)) (fun v9 : v2 => v5 (v4 (v5 (v8 v9))))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_sym	100	0.024198	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return (v1 <-> v0) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v4 v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_l	100	0.048030	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 /\ v1 <-> v0 /\ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 /\ v1 => match v6 as v7 in (_ /\ _) return (v0 /\ v2) with | conj v7 v8 => (fun (v7 : v0) (v8 : v1) => conj v7 (v4 v8)) v7 v8 end) (fun v6 : v0 /\ v2 => match v6 as v7 in (_ /\ _) return (v0 /\ v1) with | conj v7 v8 => (fun (v7 : v0) (v8 : v2) => conj v7 (v5 v8)) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_r	100	0.045021	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 /\ v0 <-> v2 /\ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 /\ v0 => match v6 as v7 in (_ /\ _) return (v2 /\ v0) with | conj v7 v8 => (fun (v7 : v1) (v8 : v0) => conj (v4 v7) v8) v7 v8 end) (fun v6 : v2 /\ v0 => match v6 as v7 in (_ /\ _) return (v1 /\ v0) with | conj v7 v8 => (fun (v7 : v2) (v8 : v0) => conj (v5 v7) v8) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_l	100	0.045441	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 \/ v1 <-> v0 \/ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 \/ v1 => match v6 as v7 in (_ \/ _) return (v0 \/ v2) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v1 => or_intror (v4 v7)) v7 end) (fun v6 : v0 \/ v2 => match v6 as v7 in (_ \/ _) return (v0 \/ v1) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v2 => or_intror (v5 v7)) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_r	100	0.050671	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 \/ v0 <-> v2 \/ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 \/ v0 => match v6 as v7 in (_ \/ _) return (v2 \/ v0) with | or_introl v7 => (fun v7 : v1 => or_introl (v4 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end) (fun v6 : v2 \/ v0 => match v6 as v7 in (_ \/ _) return (v1 \/ v0) with | or_introl v7 => (fun v7 : v2 => or_introl (v5 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_l	100	0.032731	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v0, v1) <-> (forall v5 : v0, v2)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v0, v1) (v7 : v0) => v4 (v6 v7)) (fun (v6 : forall v6 : v0, v2) (v7 : v0) => v5 (v6 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_r	100	0.034702	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v1, v0) <-> (forall v5 : v2, v0)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v1, v0) (v7 : v2) => v6 (v5 v7)) (fun (v6 : forall v6 : v2, v0) (v7 : v1) => v6 (v4 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.not_iff_compat	100	0.021980	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => imp_iff_compat_r (@False) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.neg_false	100	0.034894	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : forall v1 : v0, @False => conj v1 (fun v2 : @False => False_ind v0 v2)) (fun v1 : v0 <-> @False => match v1 as v2 in (_ /\ _) return (forall v3 : v0, @False) with | conj v2 v3 => (fun (v2 : forall v2 : v0, @False) (v3 : forall v3 : @False, v0) => v2) v2 v3 end) : ~ v0 <-> (v0 <-> @False))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_l	100	0.068531	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v0 /\ v1 <-> v0 /\ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 /\ v1, v0 /\ v2) (v7 : forall v7 : v0 /\ v2, v0 /\ v1) => conj (fun v8 : v1 => let v9 : forall v9 : v0 /\ v1, v2 := fun v9 : v0 /\ v1 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v0) (v11 : v2) => v11) v10 v11 end in v9 (conj (v3 v8) v8)) (fun v8 : v2 => let v9 : forall v9 : v0 /\ v2, v1 := fun v9 : v0 /\ v2 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v0) (v11 : v1) => v11) v10 v11 end in v9 (conj (v4 v8) v8))) v6 v7 end) (and_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_r	100	0.065219	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v1 /\ v0 <-> v2 /\ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 /\ v0, v2 /\ v0) (v7 : forall v7 : v2 /\ v0, v1 /\ v0) => conj (fun v8 : v1 => let v9 : forall v9 : v1 /\ v0, v2 := fun v9 : v1 /\ v0 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v2) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v3 v8))) (fun v8 : v2 => let v9 : forall v9 : v2 /\ v0, v1 := fun v9 : v2 /\ v0 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v1) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v4 v8)))) v6 v7 end) (and_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_comm	100	0.043549	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 /\ v1 => match v2 as v3 in (_ /\ _) return (v1 /\ v0) with | conj v3 v4 => (fun (v3 : v0) (v4 : v1) => conj v4 v3) v3 v4 end) (fun v2 : v1 /\ v0 => match v2 as v3 in (_ /\ _) return (v0 /\ v1) with | conj v3 v4 => (fun (v3 : v1) (v4 : v0) => conj v4 v3) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_assoc	100	0.059441	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 /\ v1) /\ v2 => match v3 as v4 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v4 v5 => (fun (v4 : v0 /\ v1) (v5 : v2) => match v4 as v6 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v6 v7 => (fun (v6 : v0) (v7 : v1) => conj v6 (conj v7 v5)) v6 v7 end) v4 v5 end) (fun v3 : v0 /\ v1 /\ v2 => match v3 as v4 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v4 v5 => (fun (v4 : v0) (v5 : v1 /\ v2) => match v5 as v6 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v6 v7 => (fun (v6 : v1) (v7 : v2) => conj (conj v4 v6) v7) v6 v7 end) v4 v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_l	100	0.066772	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v0 \/ v1 <-> v0 \/ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 \/ v1, v0 \/ v2) (v7 : forall v7 : v0 \/ v2, v0 \/ v1) => conj (fun v8 : v1 => let v9 : v0 \/ v2 := v6 (or_intror v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 | or_intror v10 => (fun v10 : v2 => v10) v10 end) (fun v8 : v2 => let v9 : v0 \/ v1 := v7 (or_intror v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 | or_intror v10 => (fun v10 : v1 => v10) v10 end)) v6 v7 end) (or_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_r	100	0.070631	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v1 \/ v0 <-> v2 \/ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 \/ v0, v2 \/ v0) (v7 : forall v7 : v2 \/ v0, v1 \/ v0) => conj (fun v8 : v1 => let v9 : v2 \/ v0 := v6 (or_introl v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v2 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 end) (fun v8 : v2 => let v9 : v1 \/ v0 := v7 (or_introl v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v1 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 end)) v6 v7 end) (or_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_comm	100	0.048287	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 \/ v1 => match v2 as v3 in (_ \/ _) return (v1 \/ v0) with | or_introl v3 => (fun v3 : v0 => or_intror v3) v3 | or_intror v3 => (fun v3 : v1 => or_introl v3) v3 end) (fun v2 : v1 \/ v0 => match v2 as v3 in (_ \/ _) return (v0 \/ v1) with | or_introl v3 => (fun v3 : v1 => or_intror v3) v3 | or_intror v3 => (fun v3 : v0 => or_introl v3) v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_assoc	100	0.091918	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 \/ v1) \/ v2 => match v3 as v4 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v4 => (fun v4 : v0 \/ v1 => match v4 as v5 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v5 => (fun v5 : v0 => or_introl v5) v5 | or_intror v5 => (fun v5 : v1 => or_intror (or_introl v5)) v5 end) v4 | or_intror v4 => (fun v4 : v2 => or_intror (or_intror v4)) v4 end) (fun v3 : v0 \/ v1 \/ v2 => match v3 as v4 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v4 => (fun v4 : v0 => or_introl (or_introl v4)) v4 | or_intror v4 => (fun v4 : v1 \/ v2 => match v4 as v5 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v5 => (fun v5 : v1 => or_introl (or_intror v5)) v5 | or_intror v5 => (fun v5 : v2 => or_intror v5) v5 end) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_and	100	0.035627	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v3 v4) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_to_and	100	0.053857	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 <-> v1 => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end) (fun v2 : (forall v2 : v0, v1) /\ (forall v2 : v1, v0) => match v2 as v3 in (_ /\ _) return (v0 <-> v1) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.inst	100	0.042017	1	1	0	synth with cache (only 1: refine ((fun (v0 : @A) (v1 : forall v1 : @A, P v1) => v1 v0) : forall (v0 : @A) (v1 : all (fun v1 : @A => P v1)), P v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.gen	100	0.024230	1	1	0	synth with cache (only 1: refine ((fun (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0) (v3 : @A) => v1 v3 v2) : forall (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0), all (@P))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.absurd	100	0.015569	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : Prop) (v2 : v0) (v3 : forall v3 : v0, @False) => let v4 : @False := v3 v2 in match v4 as v5 in False return v1 with end) : forall (v0 v1 : Prop) (v2 : v0) (v3 : ~ v0), v1)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_sym	100	0.028117	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (v1 = @x) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans	100	0.045559	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @y = @z) => match v1 as v3 in (_ = v2) return (@x = v2) with | eq_refl => v0 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans_r	100	0.051865	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @z = @y) => match v1 as v3 in (_ = v2) return (forall v4 : @x = v2, @x = @z) with | eq_refl => fun v2 : @x = @z => v2 end v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.f_equal	100	0.040703	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.not_eq_sym	100	0.038774	1	1	0	synth with cache (only 1: refine ((fun (v0 : @x <> @y) (v1 : @y = @x) => v0 (match v1 as v3 in (_ = v2) return (forall v4 : v2 <> @y, v2 = @y) with | eq_refl => fun v2 : @y <> @y => eq_refl end v0)) : forall v0 : @x <> @y, @y <> @x)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_sind_r	100	0.023334	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, SProp) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_sind (fun v6 : v0 => v2 v6) v3 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_ind_r	100	0.021949	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Prop) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_ind v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rec_r	100	0.025014	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Set) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rec v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rect_r	100	0.023501	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rect v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep.f_equal_dep	100	0.049799	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (rew [@B] v2 in f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep2.f_equal_dep2	100	0.087271	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v2 v6) (v9 : v2 v7) (v10 : v6 = v7) => match v10 as v12 in (_ = v11) return (forall (v13 : v2 v11) (v14 : rew [v2] v12 in v8 = v13), rew [v3] f_equal v4 v12 in v5 v6 v8 = v5 v11 v13) with | eq_refl => fun (v11 : v2 v6) (v12 : rew [v2] eq_refl in v8 = v11) => match v12 as v14 in (_ = v13) return (rew [v3] f_equal v4 eq_refl in v5 v6 v8 = v5 v6 v13) with | eq_refl => eq_refl end end v9)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_r	100	0.037362	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v3) => match v4 as v7 in (_ = v6) return (forall v8 : v1 v6, rew [v1] v7 in rew <- [v1] v7 in v8 = v8) with | eq_refl => fun v6 : v1 v2 => eq_refl end v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_l	100	0.040312	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v2) => match v4 as v7 in (_ = v6) return (rew <- [v1] v7 in rew [v1] v7 in v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal2	100	0.045138	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 : forall (v3 : v0) (v4 : v1), v2) (v4 v5 : v0) (v6 v7 : v1) (v8 : v4 = v5) => match v8 as v10 in (_ = v9) return (forall v11 : v6 = v7, v3 v4 v6 = v3 v9 v7) with | eq_refl => fun v9 : v6 = v7 => match v9 as v11 in (_ = v10) return (v3 v4 v6 = v3 v4 v10) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal3	100	0.065690	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : Type) (v4 : forall (v4 : v0) (v5 : v1) (v6 : v2), v3) (v5 v6 : v0) (v7 v8 : v1) (v9 v10 : v2) (v11 : v5 = v6) => match v11 as v13 in (_ = v12) return (forall (v14 : v7 = v8) (v15 : v9 = v10), v4 v5 v7 v9 = v4 v12 v8 v10) with | eq_refl => fun v12 : v7 = v8 => match v12 as v14 in (_ = v13) return (forall v15 : v9 = v10, v4 v5 v7 v9 = v4 v5 v13 v10) with | eq_refl => fun v13 : v9 = v10 => match v13 as v15 in (_ = v14) return (v4 v5 v7 v9 = v4 v5 v7 v14) with | eq_refl => eq_refl end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal4	100	0.105680	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 : Type) (v5 : forall (v5 : v0) (v6 : v1) (v7 : v2) (v8 : v3), v4) (v6 v7 : v0) (v8 v9 : v1) (v10 v11 : v2) (v12 v13 : v3) (v14 : v6 = v7) => match v14 as v16 in (_ = v15) return (forall (v17 : v8 = v9) (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v15 v9 v11 v13) with | eq_refl => fun v15 : v8 = v9 => match v15 as v17 in (_ = v16) return (forall (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v6 v16 v11 v13) with | eq_refl => fun v16 : v10 = v11 => match v16 as v18 in (_ = v17) return (forall v19 : v12 = v13, v5 v6 v8 v10 v12 = v5 v6 v8 v17 v13) with | eq_refl => fun v17 : v12 = v13 => match v17 as v19 in (_ = v18) return (v5 v6 v8 v10 v12 = v5 v6 v8 v10 v18) with | eq_refl => eq_refl end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal5	100	0.100573	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 v5 : Type) (v6 : forall (v6 : v0) (v7 : v1) (v8 : v2) (v9 : v3) (v10 : v4), v5) (v7 v8 : v0) (v9 v10 : v1) (v11 v12 : v2) (v13 v14 : v3) (v15 v16 : v4) (v17 : v7 = v8) => match v17 as v19 in (_ = v18) return (forall (v20 : v9 = v10) (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v18 v10 v12 v14 v16) with | eq_refl => fun v18 : v9 = v10 => match v18 as v20 in (_ = v19) return (forall (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v19 v12 v14 v16) with | eq_refl => fun v19 : v11 = v12 => match v19 as v21 in (_ = v20) return (forall (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v9 v20 v14 v16) with | eq_refl => fun v20 : v13 = v14 => match v20 as v22 in (_ = v21) return (forall v23 : v15 = v16, v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v21 v16) with | eq_refl => fun v21 : v15 = v16 => match v21 as v23 in (_ = v22) return (v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v13 v22) with | eq_refl => eq_refl end end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal_compose	100	0.068176	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : forall v6 : v1, v2) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v6 (f_equal v5 v9) = f_equal (fun v10 : v0 => v6 (v5 v10)) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_l	100	0.035270	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans eq_refl v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_r	100	0.038957	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 eq_refl = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_involutive	100	0.037527	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_sym (eq_sym v5) = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_l	100	0.037118	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans (eq_sym v5) v5 = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_r	100	0.038547	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 (eq_sym v5) = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_assoc	100	0.061225	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 v4 : v0) (v5 : v1 = v2) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (eq_trans v5 (eq_trans v6 v9) = eq_trans (eq_trans v5 v6) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_map	100	0.054545	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v1, Type) (v3 : forall v3 : v0, v1) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v2 (v3 v4), rew [fun v10 : v0 => v2 (v3 v10)] v8 in v9 = rew [v2] f_equal v3 v8 in v9) with | eq_refl => fun v7 : v2 (v3 v4) => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map	100	0.074349	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v1 v2) (v6 : v1 v3) (v7 : v1 v4) (v8 : v2 = v3) (v9 : v3 = v4) (v10 : rew [v1] v8 in v5 = v6) (v11 : rew [v1] v9 in v6 = v7) => match v9 as v13 in (_ = v12) return (forall (v14 : v1 v12) (v15 : rew [v1] v13 in v6 = v14), rew [v1] eq_trans v8 v13 in v5 = v14) with | eq_refl => fun (v12 : v1 v3) (v13 : rew [v1] eq_refl in v6 = v12) => eq_trans v10 v13 end v7 v11)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst	100	0.049576	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v1 v3), v2 v3) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v4, rew [v2] v8 in v3 v4 v9 = v3 v7 (rew [v1] v8 in v9)) with | eq_refl => fun v7 : v1 v4 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst_map	100	0.059522	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v6 = v7) => match v8 as v10 in (_ = v9) return (forall v11 : v2 v6, rew [v3] f_equal v4 v10 in v5 v6 v11 = v5 v9 (rew [v2] v10 in v11)) with | eq_refl => fun v9 : v2 v6 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_swap	100	0.051964	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall (v7 : v1 v2) (v8 : v1 v5) (v9 : rew [v1] v6 in v7 = v8), v7 = rew <- [v1] v6 in v8) with | eq_refl => fun (v5 v6 : v1 v2) (v7 : rew [v1] eq_refl in v5 = v6) => v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_compose	100	0.061006	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) (v6 : v3 = v4) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] v8 in rew [v1] v5 in v9 = rew [v1] eq_trans v5 v8 in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_l	100	0.080688	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v2 = v1 v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 v3)) (v2 v3)) (fun v4 : v1 v3 = v1 v3 => match v2 v3 as v6 in (_ = v5) return (v1 v3 = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : v3 = v1 v3 := v2 v3 in let v5 : v0 := v1 v3 in match v4 as v7 in (_ = v6) return (match v7 as v9 in (_ = v8) return (v6 = v1 v8) with | eq_refl => eq_trans (eq_sym v7) (v2 v3) end = v2 v6) with | eq_refl => let v6 : v3 = v1 v3 := v2 v3 in let v7 : v0 := v1 v3 in match v6 as v9 in (_ = v8) return (eq_trans (eq_sym eq_refl) v9 = v9) with | eq_refl => eq_refl end end) eq_refl (eq_trans_sym_inv_l (v2 v3)) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_r	100	0.184830	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v1 v2 = v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 (v1 (v1 v3)))) (v2 (v1 (v1 v3)))) (fun v4 : v1 (v1 v3) = v1 (v1 v3) => match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : forall v4 : v0, v4 = v1 v4 := fun v4 : v0 => eq_sym (v2 v4) in (let v5 : f_equal v1 (v4 (v1 v3)) = v4 (v1 (v1 v3)) := eq_id_comm_l v1 v4 (v1 v3) in let v6 : v1 (v1 v3) = v1 (v1 (v1 v3)) := v4 (v1 (v1 v3)) in match v5 as v8 in (_ = v7) return (match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans v7 (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => let v7 : f_equal v1 (v4 v3) = v4 (v1 v3) := eq_id_comm_l v1 v4 v3 in let v8 : v1 v3 = v1 (v1 v3) := v4 (v1 v3) in match v7 as v10 in (_ = v9) return (match v2 v3 as v12 in (_ = v11) return (v1 (v1 v3) = v1 v11) with | eq_refl => eq_trans (f_equal v1 v9) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => (let v9 : v1 v3 = v3 := v2 v3 in match v9 as v11 in (_ = v10) return (match v11 as v13 in (_ = v12) return (v1 (v1 v10) = v1 v12) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (eq_sym v11))) (v2 (v1 (v1 v3))) end = v2 (v1 v10)) with | eq_refl => eq_ind_r (fun v10 : v1 (v1 (v1 v3)) = v1 (v1 v3) => v10 = v2 (v1 (v1 v3))) eq_refl (eq_trans_refl_l (v2 (v1 (v1 v3)))) : eq_trans (f_equal v1 (f_equal v1 (eq_sym eq_refl))) (v2 (v1 (v1 v3))) = v2 (v1 (v1 v3)) end) : match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (v4 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3) end end) : match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => eq_trans (v4 (v1 (v1 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) eq_refl (eq_trans_sym_inv_l (v2 (v1 (v1 v3)))) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_refl_map_distr	100	0.028889	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : v0) (v3 : forall v3 : v0, v1) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map_distr	100	0.061989	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v5 (eq_trans v6 v9) = eq_trans (f_equal v5 v6) (f_equal v5 v9)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_map_distr	100	0.061547	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : forall v4 : v0, v1) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (eq_sym (f_equal v4 v7) = f_equal v4 (eq_sym v7)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_distr	100	0.069224	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) => match v4 as v6 in (_ = v5) return (forall v7 : v5 = v3, eq_sym (eq_trans v6 v7) = eq_trans (eq_sym v7) (eq_sym v6)) with | eq_refl => fun v5 : v1 = v3 => match v5 as v7 in (_ = v6) return (eq_sym (eq_trans eq_refl v7) = eq_trans (eq_sym v7) (eq_sym eq_refl)) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_rew_distr	100	0.080671	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (forall (v8 : v6 = v4) (v9 : v1 v2), rew [v1] eq_trans v7 v8 in v9 = rew [v1] v8 in rew [v1] v7 in v9) with | eq_refl => fun v6 : v2 = v4 => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] eq_trans eq_refl v8 in v9 = rew [v1] v8 in rew [v1] eq_refl in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_const	100	0.027972	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall v7 : v1, rew [fun v8 : v0 => v1] v6 in v7 = v7) with | eq_refl => fun v5 : v1 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.unique_existence	100	0.073698	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) => conj (fun v2 : (exists v2 : v0, v1 v2) /\ uniqueness v1 => match v2 as v3 in (_ /\ _) return (exists ! v4 : v0, v1 v4) with | conj v3 v4 => (fun (v3 : exists v3 : v0, v1 v3) (v4 : uniqueness v1) => match v3 as v5 in (ex _) return (exists ! v6 : v0, v1 v6) with | ex_intro _ v5 v6 => (fun (v5 : v0) (v6 : v1 v5) => ex_intro (unique (fun v7 : v0 => v1 v7)) v5 (conj v6 (fun (v7 : v0) (v8 : v1 v7) => v4 v5 v7 v6 v8) : unique (fun v7 : v0 => v1 v7) v5)) v5 v6 end) v3 v4 end) (fun v2 : exists ! v2 : v0, v1 v2 => match v2 as v3 in (ex _) return ((exists v4 : v0, v1 v4) /\ uniqueness v1) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return ((exists v6 : v0, v1 v6) /\ uniqueness v1) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) => conj (ex_intro (fun v7 : v0 => v1 v7) v3 v5) ((fun (v7 v8 : v0) (v9 : v1 v7) (v10 : v1 v8) => eq_trans (eq_sym (v6 v7 v9)) (v6 v8 v10)) : uniqueness v1)) v5 v6 end) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_unique_domain_coincide	100	0.076551	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists ! v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (forall v4 : forall v4 : v0, Prop, (forall (v5 : v0) (v6 : v1 v5), v4 v5) <-> (exists v5 : v0, v1 v5 /\ v4 v5)) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return (forall v6 : forall v6 : v0, Prop, (forall (v7 : v0) (v8 : v1 v7), v6 v7) <-> (exists v7 : v0, v1 v7 /\ v6 v7)) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) (v7 : forall v7 : v0, Prop) => conj (fun v8 : forall (v8 : v0) (v9 : v1 v8), v7 v8 => ex_intro (fun v9 : v0 => v1 v9 /\ v7 v9) v3 (conj v5 (v8 v3 v5))) (fun v8 : exists v8 : v0, v1 v8 /\ v7 v8 => match v8 as v9 in (ex _) return (forall (v10 : v0) (v11 : v1 v10), v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v0) (v10 : v1 v9 /\ v7 v9) => match v10 as v11 in (_ /\ _) return (forall (v12 : v0) (v13 : v1 v12), v7 v12) with | conj v11 v12 => (fun (v11 : v1 v9) (v12 : v7 v9) (v13 : v0) (v14 : v1 v13) => let v15 : v9 = v13 := eq_trans (eq_sym (v6 v9 v11)) (v6 v13 v14) in match v15 as v17 in (_ = v16) return (forall v18 : v1 v16, v7 v16) with | eq_refl => fun v16 : v1 v9 => v12 end v14) v11 v12 end) v9 v10 end)) v5 v6 end) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_coincide_unique_domain	100	0.098448	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : forall v2 : v0, Prop, (forall (v3 : v0) (v4 : v1 v3), v2 v3) <-> (exists v3 : v0, v1 v3 /\ v2 v3)) => let v3 : (forall v3 : forall (v3 : v0) (v4 : v1 v3), v1 v3, exists v4 : v0, v1 v4 /\ v1 v4) /\ (forall (v3 : exists v3 : v0, v1 v3 /\ v1 v3) (v4 : v0) (v5 : v1 v4), v1 v4) := v2 v1 in match v3 as v4 in (_ /\ _) return (exists ! v5 : v0, v1 v5) with | conj v4 v5 => (fun (v4 : forall v4 : forall (v4 : v0) (v5 : v1 v4), v1 v4, exists v5 : v0, v1 v5 /\ v1 v5) (v5 : forall (v5 : exists v5 : v0, v1 v5 /\ v1 v5) (v6 : v0) (v7 : v1 v6), v1 v6) => let v6 : exists v6 : v0, v1 v6 /\ v1 v6 := v4 (fun (v6 : v0) (v7 : v1 v6) => v7) in match v6 as v7 in (ex _) return (exists ! v8 : v0, v1 v8) with | ex_intro _ v7 v8 => (fun (v7 : v0) (v8 : v1 v7 /\ v1 v7) => match v8 as v9 in (_ /\ _) return (exists ! v10 : v0, v1 v10) with | conj v9 v10 => (fun v9 v10 : v1 v7 => ex_intro (unique (fun v11 : v0 => v1 v11)) v7 (conj v9 (let v11 : (forall v11 : forall (v11 : v0) (v12 : v1 v11), v7 = v11, exists v12 : v0, v1 v12 /\ v7 = v12) /\ (forall (v11 : exists v11 : v0, v1 v11 /\ v7 = v11) (v12 : v0) (v13 : v1 v12), v7 = v12) := v2 (fun v11 : v0 => v7 = v11) in match v11 as v12 in (_ /\ _) return (forall (v13 : v0) (v14 : v1 v13), v7 = v13) with | conj v12 v13 => (fun (v12 : forall v12 : forall (v12 : v0) (v13 : v1 v12), v7 = v12, exists v13 : v0, v1 v13 /\ v7 = v13) (v13 : forall (v13 : exists v13 : v0, v1 v13 /\ v7 = v13) (v14 : v0) (v15 : v1 v14), v7 = v14) => v13 (ex_intro (fun v14 : v0 => v1 v14 /\ v7 = v14) v7 (conj v9 eq_refl))) v12 v13 end))) v9 v10 end) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.exists_inhabited	100	0.022272	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (inhabited v0) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : v1 v3) => inhabits v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.inhabited_covariant	100	0.019816	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, v1) (v3 : inhabited v0) => match v3 as v4 in (inhabited _) return (inhabited v1) with | inhabits v4 => (fun v4 : v0 => inhabits (v2 v4)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_stepl	100	0.021483	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) (v5 : v1 = v3) => eq_ind v1 (fun v6 : v0 => v6 = v2) v4 v3 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_stepl	100	0.030682	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v0 <-> v2, v2 <-> v1) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v0 <-> v2) => match v6 as v7 in (_ /\ _) return (v2 <-> v1) with | conj v7 v8 => (fun (v7 : forall v7 : v0, v2) (v8 : forall v8 : v2, v0) => conj (fun v9 : v2 => v4 (v5 (v4 (v8 v9)))) (fun v9 : v1 => v7 (v5 v9))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.eq_ex_uncurried	100	0.103980	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 v3 : v0) (v4 : v1 v2) (v5 : v1 v3) (v6 : exists v6 : v2 = v3, rew [v1] v6 in v4 = v5) => match v6 as v7 in (ex _) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v5) with | ex_intro _ v7 v8 => (fun (v7 : v2 = v3) (v8 : rew [v1] v7 in v4 = v5) => match v8 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v9) with | eq_refl => match v7 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v9 (rew [v1] v10 in v4)) with | eq_refl => eq_refl end : ex_intro v1 v2 v4 = ex_intro v1 v3 (rew [v1] v7 in v4) end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.rew_ex	100	0.132910	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : exists v4 : v2 v1, v3 v1 v4) (v5 : v0) (v6 : v1 = v5) => match v6 as v8 in (_ = v7) return (rew [fun v9 : v0 => exists v10 : v2 v9, v3 v9 v10] v8 in v4 = match v4 as v9 in (ex _) return (exists v10 : v2 v7, v3 v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) => ex_intro (v3 v7) (rew [v2] v8 in v9) match v8 as v12 in (_ = v11) return (v3 v11 (rew [v2] v12 in v9)) with | eq_refl => v10 end) v9 v10 end) with | eq_refl => match v4 as v7 in (ex _) return (rew [fun v8 : v0 => exists v9 : v2 v8, v3 v8 v9] eq_refl in v7 = match v7 as v8 in (ex _) return (exists v9 : v2 v1, v3 v1 v9) with | ex_intro _ v8 v9 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) => ex_intro (v3 v1) (rew [v2] eq_refl in v8) v9) v8 v9 end) with | ex_intro _ v7 v8 => (fun (v7 : v2 v1) (v8 : v3 v1 v7) => eq_refl) v7 v8 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.eq_ex2_uncurried	100	0.125171	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : v0, Prop) (v3 v4 : v0) (v5 : v1 v3) (v6 : v1 v4) (v7 : v2 v3) (v8 : v2 v4) (v9 : exists2 v9 : v3 = v4, rew [v1] v9 in v5 = v6 & rew [v2] v9 in v7 = v8) => match v9 as v10 in (ex2 _ _) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v8) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v3 = v4) (v11 : rew [v1] v10 in v5 = v6) (v12 : rew [v2] v10 in v7 = v8) => match v12 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v13) with | eq_refl => match v11 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v13 (rew [v2] v10 in v7)) with | eq_refl => match v10 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v13 (rew [v1] v14 in v5) (rew [v2] v14 in v7)) with | eq_refl => eq_refl : ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v3 (rew [v1] eq_refl in v5) (rew [v2] eq_refl in v7) end end end) v10 v11 v12 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.rew_ex2	100	0.184081	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : forall (v4 : v0) (v5 : v2 v4), Prop) (v5 : exists2 v5 : v2 v1, v3 v1 v5 & v4 v1 v5) (v6 : v0) (v7 : v1 = v6) => match v7 as v9 in (_ = v8) return (rew [fun v10 : v0 => exists2 v11 : v2 v10, v3 v10 v11 & v4 v10 v11] v9 in v5 = match v5 as v10 in (ex2 _ _) return (exists2 v11 : v2 v8, v3 v8 v11 & v4 v8 v11) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v2 v1) (v11 : v3 v1 v10) (v12 : v4 v1 v10) => ex_intro2 (v3 v8) (v4 v8) (rew [v2] v9 in v10) match v9 as v14 in (_ = v13) return (v3 v13 (rew [v2] v14 in v10)) with | eq_refl => v11 end match v9 as v14 in (_ = v13) return (v4 v13 (rew [v2] v14 in v10)) with | eq_refl => v12 end) v10 v11 v12 end) with | eq_refl => match v5 as v8 in (ex2 _ _) return (rew [fun v9 : v0 => exists2 v10 : v2 v9, v3 v9 v10 & v4 v9 v10] eq_refl in v8 = match v8 as v9 in (ex2 _ _) return (exists2 v10 : v2 v1, v3 v1 v10 & v4 v1 v10) with | ex_intro2 _ _ v9 v10 v11 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) (v11 : v4 v1 v9) => ex_intro2 (v3 v1) (v4 v1) (rew [v2] eq_refl in v9) v10 v11) v9 v10 v11 end) with | ex_intro2 _ _ v8 v9 v10 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) (v10 : v4 v1 v8) => eq_refl) v8 v9 v10 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_eq_iff	100	0.126747	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Eq <-> v0 == v1) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Eq => v2) (fun v3 : v0 == v1 => eq_refl)) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Eq => let v4 : forall v4 : @Eq = @Eq, v0 == v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, v0 == v1) with | eq_refl => fun v4 : @Lt = @Eq => (fun v5 : @Lt = @Eq => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (v0 == v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 == v1 => False_ind (@Lt = @Eq) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v1) (v1 < v1) (lt_compat v4 (reflexive_proper_proxy Equivalence_Reflexive v1))) v3 (irreflexivity (x:=v1)) : forall v4 : v0 < v1, @False) v2))) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Eq => let v4 : forall v4 : @Eq = @Eq, v0 == v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, v0 == v1) with | eq_refl => fun v4 : @Gt = @Eq => (fun v5 : @Gt = @Eq => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (v0 == v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 == v1 => False_ind (@Gt = @Eq) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v1 < v0) (v1 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v0 v1 v4)) v3 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_eq	100	0.038190	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => let v2 : forall (v2 v3 : @t) (v4 : (v2 ?= v3) = @Eq), v2 == v3 := fun v2 v3 : @t => match compare_eq_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Eq, v2 == v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Eq, v2 == v3) (v5 : forall v5 : v2 == v3, (v2 ?= v3) = @Eq) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_lt_iff	100	0.140173	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Lt <-> v0 < v1) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Lt => let v4 : forall v4 : @Lt = @Lt, v0 < v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, v0 < v1) with | eq_refl => fun v4 : @Eq = @Lt => (fun v5 : @Eq = @Lt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (v0 < v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 < v1 => False_ind (@Eq = @Lt) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v1) (v1 < v1) (lt_compat v4 (reflexive_proper_proxy Equivalence_Reflexive v1))) v2 (irreflexivity (x:=v1)) : forall v4 : v0 < v1, @False) v3))) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Lt => v2) (fun v3 : v0 < v1 => eq_refl)) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Lt => let v4 : forall v4 : @Lt = @Lt, v0 < v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, v0 < v1) with | eq_refl => fun v4 : @Gt = @Lt => (fun v5 : @Gt = @Lt => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (v0 < v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 < v1 => False_ind (@Gt = @Lt) (((fun v4 : v1 < v0 => proper_normalizes_proper (forall v5 : Prop, Prop) (flip_arrow (flip_atom Prop (@impl)) (flip_atom Prop (flip (@impl)))) (proper_flip_proper (subrelation_proper (@Morphisms_Prop.not_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (flip (@impl))) (flip2 (subrelation_refl (@impl)))))) (v0 < v1) (v0 < v0) (trans_co_impl_morphism StrictOrder_Transitive v1 v0 v4)) v2 (irreflexivity (x:=v0)) : forall v4 : v0 < v1, @False) v3))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_gt_iff	100	0.186093	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Gt <-> v1 < v0) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Gt => let v4 : forall v4 : @Gt = @Gt, v1 < v0 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, v1 < v0) with | eq_refl => fun v4 : @Eq = @Gt => (fun v5 : @Eq = @Gt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (v1 < v0) v6) v4 end in v4 eq_refl) (fun v3 : v1 < v0 => False_ind (@Eq = @Gt) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v1 < v0) (v1 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v0 v1 v4)) v2 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v3))) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Gt => let v4 : forall v4 : @Gt = @Gt, v1 < v0 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, v1 < v0) with | eq_refl => fun v4 : @Lt = @Gt => (fun v5 : @Lt = @Gt => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (v1 < v0) v6) v4 end in v4 eq_refl) (fun v3 : v1 < v0 => False_ind (@Lt = @Gt) (((fun v4 : v0 < v1 => proper_normalizes_proper (forall v5 : Prop, Prop) (flip_arrow (flip_atom Prop (@impl)) (flip_atom Prop (flip (@impl)))) (proper_flip_proper (subrelation_proper (@Morphisms_Prop.not_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (flip (@impl))) (flip2 (subrelation_refl (@impl)))))) (v1 < v0) (v1 < v1) (trans_co_impl_morphism StrictOrder_Transitive v0 v1 v4)) v2 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v3))) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Gt => v2) (fun v3 : v1 < v0 => eq_refl)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_nlt_iff	100	0.047059	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Lt) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Lt) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (compare_lt_iff v0 v1) (conj (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1) (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_ngt_iff	100	0.048970	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Gt <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Gt) (~ v1 < v0) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Gt) (v1 < v0) v2) (~ v1 < v0) (~ v1 < v0) (eq_proper_proxy (~ v1 < v0))) (compare_gt_iff v0 v1) (conj (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_compat	100	0.300097	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => (fun (v3 v4 : @t) (v5 : v3 == v4) => match compare_spec v1 v4 as v7 in (CompareSpec _ _ _ v6) return ((v0 ?= v3) = v6) with | CompEq _ _ v6 => (fun v6 : (v0 ?= v3) = @Eq <-> v0 == v3 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) ((v0 ?= v3) = @Eq) (v0 == v3) v6) (compare_eq_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) (v0 == v3) (v1 == v3) (PER_morphism (Equivalence_PER (@eq_equiv)) v0 v1 v6 v3 v3 (reflexive_proper_proxy Equivalence_Reflexive v3))) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) (v1 == v3) (v1 == v4) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) v3 v4 v6)) v5 (fun v6 : v1 == v4 => v6))) v6 | CompLt _ _ v6 => (fun v6 : (v0 ?= v3) = @Lt <-> v0 < v3 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) ((v0 ?= v3) = @Lt) (v0 < v3) v6) (compare_lt_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) (v0 < v3) (v1 < v3) (lt_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v3))) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) (v1 < v3) (v1 < v4) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v3 v4 v6)) v5 (fun v6 : v1 < v4 => v6))) v6 | CompGt _ _ v6 => (fun v6 : (v0 ?= v3) = @Gt <-> v3 < v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) ((v0 ?= v3) = @Gt) (v3 < v0) v6) (compare_gt_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) (v3 < v0) (v3 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v3) v0 v1 v6)) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) (v3 < v1) (v4 < v1) (lt_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v1))) v5 (fun v6 : v4 < v1 => v6))) v6 end) : (@eq ==> Logic.eq)%signature (compare v0) (compare v1)) : Proper (@eq ==> @eq ==> Logic.eq) (@compare))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_refl	100	0.038819	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => match compare_spec v0 v0 as v2 in (CompareSpec _ _ _ v1) return (v1 = @Eq) with | CompEq _ _ v1 => (fun v1 : v0 == v0 => eq_refl) v1 | CompLt _ _ v1 => (fun v1 : v0 < v0 => False_ind (@Lt = @Eq) (irreflexivity v1)) v1 | CompGt _ _ v1 => (fun v1 : v0 < v0 => False_ind (@Gt = @Eq) (irreflexivity v1)) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_antisym	100	0.151493	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return ((v1 ?= v0) = CompOpp v2) with | CompEq _ _ v2 => ((fun v2 : (v1 ?= v0) = @Eq <-> v1 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 == v1)) ((v1 ?= v0) = @Eq) (v1 == v0) v2) (compare_eq_iff v1 v0) (fun v2 : v0 == v1 => symmetry v2) : forall v2 : v0 == v1, (v1 ?= v0) = CompOpp (@Eq)) v2 | CompLt _ _ v2 => ((fun v2 : (v1 ?= v0) = @Gt <-> v0 < v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 < v1)) ((v1 ?= v0) = @Gt) (v0 < v1) v2) (compare_gt_iff v1 v0) (fun v2 : v0 < v1 => v2) : forall v2 : v0 < v1, (v1 ?= v0) = CompOpp (@Lt)) v2 | CompGt _ _ v2 => ((fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0)) ((v1 ?= v0) = @Lt) (v1 < v0) v2) (compare_lt_iff v1 v0) (fun v2 : v1 < v0 => v2) : forall v2 : v1 < v0, (v1 ?= v0) = CompOpp (@Gt)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_compat	100	0.057873	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_preorder	100	0.024651	1	1	0	synth with cache (only 1: refine {| PreOrder_Reflexive := (fun v0 : @t => OrderTac.le_refl v0) : Reflexive (@le); PreOrder_Transitive := (fun (v0 v1 v2 : @t) (v3 : v0 <= v1) (v4 : v1 <= v2) => OrderTac.not_gt_le ((fun v5 : v2 < v0 => (fun v6 : v1 < v0 => (fun v7 : v0 < v0 => OrderTac.lt_irrefl v7) (OrderTac.le_lt_trans v3 v6)) (OrderTac.le_lt_trans v4 v5)) : ~ v2 < v0)) : Transitive (@le) |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_order	100	0.049611	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj (OrderTac.not_gt_le ((fun v3 : v1 < v0 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2)) : ~ v1 < v0) : v0 <= v1) (OrderTac.not_gt_le ((fun v3 : v0 < v1 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3)) : ~ v0 < v1) : v1 <= v0)) (fun v2 : v0 <= v1 <= v0 => and_ind (fun (v3 : v0 <= v1) (v4 : v1 <= v0) => OrderTac.not_neq_eq ((fun v5 : v0 ~= v1 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v5)) (OrderTac.le_antisym v3 v4)) : ~ v0 ~= v1) : v0 == v1) v2)) : PartialOrder (@eq) (@le))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_antisym	100	0.017559	1	1	0	synth with cache (only 1: refine (partial_order_antisym (@le_order))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_not_gt_iff	100	0.033864	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 <= v1 => (fun v3 : v1 < v0 => False_ind (@False) ((fun v4 : v0 < v0 => OrderTac.lt_irrefl v4) (OrderTac.le_lt_trans v2 v3)) : @False) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (let v3 : v0 <= v1 := OrderTac.not_gt_le v2 in OrderTac.not_gt_le ((fun v4 : v1 < v0 => (fun v5 : v0 < v0 => OrderTac.lt_irrefl v5) (OrderTac.le_lt_trans v3 v4)) : ~ v1 < v0)) : v0 <= v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.lt_not_ge_iff	100	0.033867	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 < v1 => (fun v3 : v1 <= v0 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.le_lt_trans v3 v2)) : @False) : ~ v1 <= v0) (fun v2 : ~ v1 <= v0 => (let v3 : v0 < v1 := OrderTac.not_ge_lt v2 in OrderTac.not_ge_lt ((fun v4 : v1 <= v0 => (fun v5 : v1 < v1 => OrderTac.lt_irrefl v5) (OrderTac.le_lt_trans v4 v3)) : ~ v1 <= v0)) : v0 < v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_or_gt	100	0.063329	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <= v1 <-> v0 < v1 \/ v0 == v1 => subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 <= v1) (v0 < v1 \/ v0 == v1) v2 (v1 < v0) (v1 < v0) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0))) (le_lteq v0 v1) (let v2 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v3 : @comparison := v0 ?= v1 in match v2 as v5 in (CompareSpec _ _ _ v4) return ((v0 < v1 \/ v0 == v1) \/ v1 < v0) with | CompEq _ _ v4 => (fun v4 : v0 == v1 => or_introl (or_intror v4)) v4 | CompLt _ _ v4 => (fun v4 : v0 < v1 => or_introl (or_introl v4)) v4 | CompGt _ _ v4 => (fun v4 : v1 < v0 => or_intror v4) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.lt_or_ge	100	0.072496	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => (fun v2 : v1 <= v0 <-> v1 < v0 \/ v1 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 < v1)) (v1 <= v0) (v1 < v0 \/ v1 == v0) v2) (le_lteq v1 v0) (let v2 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v3 : @comparison := v0 ?= v1 in match v2 as v5 in (CompareSpec _ _ _ v4) return (v0 < v1 \/ v1 < v0 \/ v1 == v0) with | CompEq _ _ v4 => (fun v4 : v0 == v1 => or_intror (or_intror (OrderTac.not_neq_eq ((fun v5 : v1 ~= v0 => (fun v6 : v1 ~= v1 => v6 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v5 v4)) : ~ v1 ~= v0) : v1 == v0))) v4 | CompLt _ _ v4 => (fun v4 : v0 < v1 => or_introl v4) v4 | CompGt _ _ v4 => (fun v4 : v1 < v0 => or_intror (or_introl v4)) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.eq_is_le_ge	100	0.050530	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj (OrderTac.not_gt_le ((fun v3 : v1 < v0 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2)) : ~ v1 < v0) : v0 <= v1) (OrderTac.not_gt_le ((fun v3 : v0 < v1 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3)) : ~ v0 < v1) : v1 <= v0)) (fun v2 : v0 <= v1 <= v0 => and_ind (fun (v3 : v0 <= v1) (v4 : v1 <= v0) => OrderTac.not_neq_eq ((fun v5 : v0 ~= v1 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v5)) (OrderTac.le_antisym v3 v4)) : ~ v0 ~= v1) : v0 == v1) v2))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.compare_le_iff	100	0.033827	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <= v1 <-> ~ v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <= v1) (~ v1 < v0) v2) (le_not_gt_iff v0 v1) (compare_ngt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.compare_ge_iff	100	0.033888	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v1 <= v0 <-> ~ v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) (~ v0 < v1) v2) (le_not_gt_iff v1 v0) (compare_nlt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.lt_dec	100	0.032724	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.if_eq_dec	100	0.157566	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : Type) (v3 v4 : v2) => let v5 : {v0 == v1} + {v0 ~= v1} := eq_dec v0 v1 in match v5 as v6 in ({_} + {_}) return (match v6 as v7 in ({_} + {_}) return v2 with | left v7 => (fun v7 : v0 == v1 => v3) v7 | right v7 => (fun v7 : v0 ~= v1 => v4) v7 end = match v0 ?= v1 as v7 in comparison return v2 with | Eq => v3 | _ => v4 end) with | left v6 => (fun v6 : v0 == v1 => let v7 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v8 : @comparison := v0 ?= v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (v3 = match v9 as v11 in comparison return v2 with | Eq => v3 | _ => v4 end) with | CompEq _ _ v9 => (fun v9 : v0 == v1 => Logic.eq_refl) v9 | CompLt _ _ v9 => (fun v9 : v0 < v1 => False_ind (v3 = v4) ((fun v10 : v1 < v1 => OrderTac.lt_irrefl v10) (OrderTac.eq_lt (OrderTac.eq_sym v6) v9))) v9 | CompGt _ _ v9 => (fun v9 : v1 < v0 => False_ind (v3 = v4) ((fun v10 : v1 < v1 => OrderTac.lt_irrefl v10) (OrderTac.lt_eq v9 v6))) v9 end) v6 | right v6 => (fun v6 : v0 ~= v1 => let v7 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v8 : @comparison := v0 ?= v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (v4 = match v9 as v11 in comparison return v2 with | Eq => v3 | _ => v4 end) with | CompEq _ _ v9 => (fun v9 : v0 == v1 => False_ind (v4 = v3) ((fun v10 : v1 ~= v1 => v10 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v9) v6))) v9 | CompLt _ _ v9 => (fun v9 : v0 < v1 => Logic.eq_refl) v9 | CompGt _ _ v9 => (fun v9 : v1 < v0 => Logic.eq_refl) v9 end) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.eqb_alt	100	0.052562	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @t => if_eq_dec v0 v1 (@true) (@false)) : forall v0 v1 : @t, eqb v0 v1 = match v0 ?= v1 as v2 in comparison return (@bool) with | Eq => @true | _ => @false end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.eqb_compat	100	0.222602	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => (fun (v3 v4 : @t) (v5 : v3 == v4) => eq_ind_r (fun v6 : @bool => v6 = eqb v1 v4) (eq_ind_r (fun v6 : @bool => match v0 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end = v6) ((fun v6 : v0 == v1 => trans_co_eq_inv_impl_morphism eq_Transitive match v0 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (f_equal (fun v7 : @comparison => match v7 as v8 in comparison return (@bool) with | Eq => @true | _ => @false end) (compare_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v3))) match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (eq_proper_proxy match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end)) v2 ((fun v6 : v3 == v4 => trans_co_eq_inv_impl_morphism eq_Transitive match v1 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (f_equal (fun v7 : @comparison => match v7 as v8 in comparison return (@bool) with | Eq => @true | _ => @false end) (Reflexive_partial_app_morphism (@compare_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v3 v4 v6)) match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (eq_proper_proxy match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end)) v5 Logic.eq_refl)) (eqb_alt v1 v4)) (eqb_alt v0 v3)) : (@eq ==> Logic.eq)%signature (eqb v0) (eqb v1)) : Proper (@eq ==> @eq ==> Logic.eq) (@eqb))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_not_eq	100	0.032192	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : v0 < v1) => (fun v3 : v0 == v1 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v3) v2))) : v0 ~= v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_eq	100	0.043749	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_lt	100	0.045170	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_eq	100	0.035273	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 <= v1) (v4 : v1 == v2) => let v5 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v3 in (fun v6 : v2 < v0 => False_ind (@False) ((fun v7 : OrderTac.OTF.le v0 v2 => (fun v8 : v0 < v0 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v7 v6)) (OrderTac.le_eq v5 v4))) : v0 <= v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_le	100	0.035914	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 == v1) (v4 : v1 <= v2) => let v5 : OrderTac.OTF.le v1 v2 := OrderTac.not_gt_le v4 in (fun v6 : v2 < v0 => False_ind (@False) ((fun v7 : v2 < v1 => (fun v8 : v1 < v1 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v5 v7)) (OrderTac.lt_eq v6 v3))) : v0 <= v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.neq_eq	100	0.035200	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_neq	100	0.033865	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_lt_trans	100	0.032069	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_le_trans	100	0.034178	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_trans	100	0.034740	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_antisym	100	0.034311	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_neq	100	0.033818	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : v0 <= v1) (v3 : v0 ~= v1) => let v4 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v2 in OrderTac.not_ge_lt ((fun v5 : OrderTac.OTF.le v1 v0 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v3)) (OrderTac.le_antisym v4 v5)) : ~ OrderTac.OTF.le v1 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.neq_sym	100	0.026100	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_le	100	0.024971	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.gt_not_eq	100	0.024988	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_not_lt	100	0.026710	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_not_gt	100	0.026541	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_not_gt	100	0.025364	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_is_nlt_ngt	100	0.248328	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj ((fun v3 : v0 < v1 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3))) : v1 <= v0) ((fun v3 : v1 < v0 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2))) : v0 <= v1)) (fun v2 : v1 <= v0 /\ v0 <= v1 => and_ind (fun (v3 : v1 <= v0) (v4 : v0 <= v1) => let v5 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v4 in let v6 : OrderTac.OTF.le v1 v0 := OrderTac.not_gt_le v3 in OrderTac.not_neq_eq ((fun v7 : v0 ~= v1 => (fun v8 : v1 == v0 => (fun v9 : v0 ~= v0 => v9 (OrderTac.eq_refl v0)) (OrderTac.neq_eq v7 v8)) (OrderTac.le_antisym v6 v5)) : ~ v0 ~= v1)) v2))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.lt_strorder	100	0.015987	1	1	0	synth with cache (only 1: refine (flip_StrictOrder (@O.lt_strorder) : StrictOrder (@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.lt_compat	100	0.034086	1	1	0	synth with cache (only 1: refine (flip_proper (@O.lt_compat) : Proper (@eq ==> @eq ==> @iff) (@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.le_lteq	100	0.070698	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @O.t => (((fun v2 : O.le v1 v0 <-> O.lt v1 v0 \/ O.eq v1 v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (O.le v1 v0) (O.lt v1 v0 \/ O.eq v1 v0) v2 (O.lt v1 v0 \/ eq v0 v1) (O.lt v1 v0 \/ eq v0 v1) (eq_proper_proxy (O.lt v1 v0 \/ eq v0 v1))) (O.le_lteq v1 v0) (conj (fun v2 : O.lt v1 v0 \/ O.eq v1 v0 => or_ind (fun v3 : O.lt v1 v0 => or_introl v3) (fun v3 : O.eq v1 v0 => or_intror (symmetry v3 : eq v0 v1)) v2) (fun v2 : O.lt v1 v0 \/ eq v0 v1 => or_ind (fun v3 : O.lt v1 v0 => or_introl v3) (fun v3 : eq v0 v1 => or_intror (symmetry v3 : O.eq v1 v0)) v2)) : flip (@O.le) v0 v1 <-> flip (@O.lt) v0 v1 \/ eq v0 v1) : flip (@O.le) v0 v1 <-> lt v0 v1 \/ eq v0 v1) : le v0 v1 <-> lt v0 v1 \/ eq v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.compare_spec	100	0.065387	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @O.t => ((((let v2 : CompareSpec (O.eq v1 v0) (O.lt v1 v0) (O.lt v0 v1) (O.compare v1 v0) := O.compare_spec v1 v0 in let v3 : @comparison := O.compare v1 v0 in match v2 as v5 in (CompareSpec _ _ _ v4) return (CompSpec (@O.eq) (fun v6 v7 : @O.t => O.lt v7 v6) v0 v1 v4) with | CompEq _ _ v4 => (fun v4 : O.eq v1 v0 => CompEq (O.lt v1 v0) (O.lt v0 v1) (symmetry v4) : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Eq)) v4 | CompLt _ _ v4 => (fun v4 : O.lt v1 v0 => CompLt (O.eq v0 v1) (O.lt v0 v1) v4 : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Lt)) v4 | CompGt _ _ v4 => (fun v4 : O.lt v0 v1 => CompGt (O.eq v0 v1) (O.lt v1 v0) v4 : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Gt)) v4 end) : CompSpec (@O.eq) (flip (@O.lt)) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@O.eq) (@lt) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@eq) (@lt) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@eq) (@lt) v0 v1 (compare v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_spec	100	0.110039	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (match v0 ?= v1 as v2 in comparison return (forall v3 : (v0 ?= v1) = v2, CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) v2) with | Eq => fun v2 : (v0 ?= v1) = @Eq => CompEq (v0 < v1) (v1 < v0) (let v3 : forall (v3 v4 : @t) (v5 : (v3 ?= v4) = @Eq), v3 == v4 := fun v3 v4 : @t => match compare_eq_iff v3 v4 as v5 in (_ /\ _) return (forall v6 : (v3 ?= v4) = @Eq, v3 == v4) with | conj v5 v6 => (fun (v5 : forall v5 : (v3 ?= v4) = @Eq, v3 == v4) (v6 : forall v6 : v3 == v4, (v3 ?= v4) = @Eq) => v5) v5 v6 end in v3 v0 v1 v2) | Lt => fun v2 : (v0 ?= v1) = @Lt => CompLt (v0 == v1) (v1 < v0) (let v3 : forall (v3 v4 : @t) (v5 : (v3 ?= v4) = @Lt), v3 < v4 := fun v3 v4 : @t => match compare_lt_iff v3 v4 as v5 in (_ /\ _) return (forall v6 : (v3 ?= v4) = @Lt, v3 < v4) with | conj v5 v6 => (fun (v5 : forall v5 : (v3 ?= v4) = @Lt, v3 < v4) (v6 : forall v6 : v3 < v4, (v3 ?= v4) = @Lt) => v5) v5 v6 end in v3 v0 v1 v2) | Gt => fun v2 : (v0 ?= v1) = @Gt => CompGt (v0 == v1) (v0 < v1) (let v3 : CompOpp (v1 ?= v0) = @Gt := eq_ind (v0 ?= v1) (fun v3 : @comparison => v3 = @Gt) v2 (CompOpp (v1 ?= v0)) (compare_antisym v1 v0) in let v4 : forall (v4 v5 : @t) (v6 : (v4 ?= v5) = @Lt), v4 < v5 := fun v4 v5 : @t => match compare_lt_iff v4 v5 as v6 in (_ /\ _) return (forall v7 : (v4 ?= v5) = @Lt, v4 < v5) with | conj v6 v7 => (fun (v6 : forall v6 : (v4 ?= v5) = @Lt, v4 < v5) (v7 : forall v7 : v4 < v5, (v4 ?= v5) = @Lt) => v6) v6 v7 end in v4 v1 v0 ((fun v5 : CompOpp (v1 ?= v0) = @Gt <-> (v1 ?= v0) = CompOpp (@Gt) => iff_impl_subrelation (CompOpp (v1 ?= v0) = @Gt) ((v1 ?= v0) = CompOpp (@Gt)) v5) (CompOpp_iff (v1 ?= v0) (@Gt)) v3)) end : forall v2 : (v0 ?= v1) = (v0 ?= v1), CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1)) eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_eq	100	0.037973	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => let v2 : forall (v2 v3 : @t) (v4 : (v2 ?= v3) = @Eq), v2 == v3 := fun v2 v3 : @t => match compare_eq_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Eq, v2 == v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Eq, v2 == v3) (v5 : forall v5 : v2 == v3, (v2 ?= v3) = @Eq) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_refl	100	0.036148	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v1 == v2), (v1 ?= v2) = @Eq := fun v1 v2 : @t => match compare_eq_iff v1 v2 as v3 in (_ /\ _) return (forall v4 : v1 == v2, (v1 ?= v2) = @Eq) with | conj v3 v4 => (fun (v3 : forall v3 : (v1 ?= v2) = @Eq, v1 == v2) (v4 : forall v4 : v1 == v2, (v1 ?= v2) = @Eq) => v4) v3 v4 end in v1 v0 v0 (reflexivity v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_gt_iff	100	0.053042	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v2)) (compare_lt_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 = @Gt <-> (v1 ?= v0) = @Lt) ((fun v2 : CompOpp (v1 ?= v0) = @Gt <-> (v1 ?= v0) = CompOpp (@Gt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) = @Gt) ((v1 ?= v0) = CompOpp (@Gt)) v2 ((v1 ?= v0) = @Lt) ((v1 ?= v0) = @Lt) (eq_proper_proxy ((v1 ?= v0) = @Lt))) (CompOpp_iff (v1 ?= v0) (@Gt)) (reflexivity ((v1 ?= v0) = @Lt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_ge_iff	100	0.059069	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v2)) (compare_le_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 <> @Lt <-> (v1 ?= v0) <> @Gt) ((fun v2 : CompOpp (v1 ?= v0) = @Lt <-> (v1 ?= v0) = CompOpp (@Lt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) <> @Lt) ((v1 ?= v0) <> CompOpp (@Lt)) (Morphisms_Prop.not_iff_morphism (CompOpp (v1 ?= v0) = @Lt) ((v1 ?= v0) = CompOpp (@Lt)) v2) ((v1 ?= v0) <> @Gt) ((v1 ?= v0) <> @Gt) (eq_proper_proxy ((v1 ?= v0) <> @Gt))) (CompOpp_iff (v1 ?= v0) (@Lt)) (reflexivity ((v1 ?= v0) <> @Gt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_ngt_iff	100	0.048129	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Gt <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Gt) (~ v1 < v0) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Gt) (v1 < v0) v2) (~ v1 < v0) (~ v1 < v0) (eq_proper_proxy (~ v1 < v0))) (compare_gt_iff v0 v1) (conj (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nlt_iff	100	0.047216	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Lt) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Lt) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (compare_lt_iff v0 v1) (conj (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1) (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nle_iff	100	0.202534	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (~ v0 <= v1) (~ (v0 ?= v1) <> @Gt) (Morphisms_Prop.not_iff_morphism (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2))) (compare_le_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Gt <-> ~ v3 <> @Gt) with | Eq => conj (fun v3 : @Eq = @Gt => let v4 : forall v4 : @Gt = @Gt, ~ @Eq <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, ~ @Eq <> @Gt) with | eq_refl => fun v4 : @Eq = @Gt => (fun v5 : @Eq = @Gt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (~ @Eq <> @Gt) v6) v4 end in v4 eq_refl) (fun v3 : ~ @Eq <> @Gt => let v4 : @False := v3 ((fun v4 : @Eq = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Eq = @Gt => (fun v6 : @Eq = @Gt => let v7 : @False := eq_ind (@Eq) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Eq <> @Gt) in match v4 as v5 in False return (@Eq = @Gt) with end) | Lt => conj (fun v3 : @Lt = @Gt => let v4 : forall v4 : @Gt = @Gt, ~ @Lt <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, ~ @Lt <> @Gt) with | eq_refl => fun v4 : @Lt = @Gt => (fun v5 : @Lt = @Gt => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (~ @Lt <> @Gt) v6) v4 end in v4 eq_refl) (fun v3 : ~ @Lt <> @Gt => let v4 : @False := v3 ((fun v4 : @Lt = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Lt = @Gt => (fun v6 : @Lt = @Gt => let v7 : @False := eq_ind (@Lt) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Lt <> @Gt) in match v4 as v5 in False return (@Lt = @Gt) with end) | Gt => conj (fun v3 : @Gt = @Gt => (fun v4 : @Gt <> @Gt => False_ind (@False) (v4 eq_refl)) : ~ @Gt <> @Gt) (fun v3 : ~ @Gt <> @Gt => eq_refl) end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nge_iff	100	0.054844	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) = @Gt <-> ~ v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (~ v1 <= v0) ((v1 ?= v0) = @Gt) (symmetry v2)) (compare_nle_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 = @Lt <-> (v1 ?= v0) = @Gt) ((fun v2 : CompOpp (v1 ?= v0) = @Lt <-> (v1 ?= v0) = CompOpp (@Lt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) = @Lt) ((v1 ?= v0) = CompOpp (@Lt)) v2 ((v1 ?= v0) = @Gt) ((v1 ?= v0) = @Gt) (eq_proper_proxy ((v1 ?= v0) = @Gt))) (CompOpp_iff (v1 ?= v0) (@Lt)) (reflexivity ((v1 ?= v0) = @Gt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.lt_irrefl	100	0.053492	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => (fun v1 : (v0 ?= v0) = @Lt <-> v0 < v0 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v0) ((v0 ?= v0) = @Lt) (symmetry v1)) (compare_lt_iff v0 v0) (eq_ind_r (fun v1 : @comparison => v1 <> @Lt) ((fun v1 : @Eq = @Lt => let v2 : forall v2 : @Lt = @Lt, @False := match v1 as v3 in (_ = v2) return (forall v4 : v2 = @Lt, @False) with | eq_refl => fun v2 : @Eq = @Lt => (fun v3 : @Eq = @Lt => let v4 : @False := eq_ind (@Eq) (fun v4 : @comparison => match v4 as v5 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v3 in False_ind (@False) v4) v2 end in v2 eq_refl) : @Eq <> @Lt) (compare_refl v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.lt_eq_cases	100	0.367587	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 < v1 \/ v0 == v1) ((v0 ?= v1) = @Lt \/ v0 == v1) (Morphisms_Prop.or_iff_morphism (v0 < v1) ((v0 ?= v1) = @Lt) (symmetry v2) (v0 == v1) (v0 == v1) (reflexive_proper_proxy (@iff_Reflexive) (v0 == v1)))) (compare_lt_iff v0 v1) ((fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2) ((v0 ?= v1) = @Lt \/ v0 == v1) ((v0 ?= v1) = @Lt \/ v0 == v1) (eq_proper_proxy ((v0 ?= v1) = @Lt \/ v0 == v1))) (compare_le_iff v0 v1) ((fun v2 : (v0 ?= v1) = @Eq <-> v0 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v0 ?= v1) = @Lt \/ v0 == v1) ((v0 ?= v1) = @Lt \/ (v0 ?= v1) = @Eq) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) ((v0 ?= v1) = @Lt)) (v0 == v1) ((v0 ?= v1) = @Eq) (symmetry v2))) (compare_eq_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 <> @Gt <-> v3 = @Lt \/ v3 = @Eq) with | Eq => conj (fun v3 : @Eq <> @Gt => or_intror eq_refl) (fun v3 : @Eq = @Lt \/ @Eq = @Eq => (fun v4 : @Eq = @Gt => or_ind (fun v5 : @Eq = @Lt => let v6 : forall v6 : @Lt = @Lt, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Lt, @False) with | eq_refl => fun v6 : @Eq = @Lt => (fun v7 : @Eq = @Lt => let v8 : @False := eq_ind (@Eq) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Eq = @Eq => let v6 : forall v6 : @Gt = @Gt, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Gt, @False) with | eq_refl => fun v6 : @Eq = @Gt => (fun v7 : @Eq = @Gt => let v8 : @False := eq_ind (@Eq) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Eq <> @Gt) | Lt => conj (fun v3 : @Lt <> @Gt => or_introl eq_refl) (fun v3 : @Lt = @Lt \/ @Lt = @Eq => (fun v4 : @Lt = @Gt => or_ind (fun v5 : @Lt = @Lt => let v6 : forall v6 : @Gt = @Gt, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Gt, @False) with | eq_refl => fun v6 : @Lt = @Gt => (fun v7 : @Lt = @Gt => let v8 : @False := eq_ind (@Lt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Lt = @Eq => let v6 : forall v6 : @Eq = @Eq, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Eq, @False) with | eq_refl => fun v6 : @Lt = @Eq => (fun v7 : @Lt = @Eq => let v8 : @False := eq_ind (@Lt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Lt <> @Gt) | Gt => conj (fun v3 : @Gt <> @Gt => let v4 : @False := let v4 : @Gt = @Gt := eq_refl in v3 v4 in (fun v5 : @False => False_ind (@Gt = @Lt \/ @Gt = @Eq) v5) v4) (fun v3 : @Gt = @Lt \/ @Gt = @Eq => (fun v4 : @Gt = @Gt => or_ind (fun v5 : @Gt = @Lt => let v6 : forall v6 : @Lt = @Lt, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Lt, @False) with | eq_refl => fun v6 : @Gt = @Lt => (fun v7 : @Gt = @Lt => let v8 : @False := eq_ind (@Gt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Gt = @Eq => let v6 : forall v6 : @Eq = @Eq, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Eq, @False) with | eq_refl => fun v6 : @Gt = @Eq => (fun v7 : @Gt = @Eq => let v8 : @False := eq_ind (@Gt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Gt <> @Gt) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_spec0	100	0.025535	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => iff_reflect (v0 <= v1) (v0 <=? v1) (symmetry (leb_le v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_spec	100	0.073750	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match leb_spec0 v0 v1 as v3 in (reflect _ v2) return (BoolSpec (v0 <= v1) (v1 < v0) v2) with | ReflectT _ v2 => (fun v2 : v0 <= v1 => BoolSpecT (v1 < v0) v2) v2 | ReflectF _ v2 => (fun v2 : ~ v0 <= v1 => BoolSpecF (v0 <= v1) ((fun v3 : (v1 ?= v0) = @Lt <-> v1 < v0 => iff_flip_impl_subrelation (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v3)) (compare_lt_iff v1 v0) ((fun v3 : (v1 ?= v0) = @Lt <-> ~ v0 <= v1 => iff_flip_impl_subrelation ((v1 ?= v0) = @Lt) (~ v0 <= v1) v3) (compare_nge_iff v1 v0) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_spec0	100	0.025171	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => iff_reflect (v0 < v1) (v0 <? v1) (symmetry (ltb_lt v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_spec	100	0.049579	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match ltb_spec0 v0 v1 as v3 in (reflect _ v2) return (BoolSpec (v0 < v1) (v1 <= v0) v2) with | ReflectT _ v2 => (fun v2 : v0 < v1 => BoolSpecT (v1 <= v0) v2) v2 | ReflectF _ v2 => (fun v2 : ~ v0 < v1 => BoolSpecF (v0 < v1) ((fun v3 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => iff_flip_impl_subrelation (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v3)) (compare_le_iff v1 v0) ((fun v3 : (v1 ?= v0) <> @Gt <-> ~ v0 < v1 => iff_flip_impl_subrelation ((v1 ?= v0) <> @Gt) (~ v0 < v1) v3) (compare_ngt_iff v1 v0) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_nle	100	0.049265	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <=? v1 <> @true <-> v0 <=? v1 = @false => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @false) (v0 <=? v1 <> @true) (symmetry v2) (~ v0 <= v1) (~ v0 <= v1) (eq_proper_proxy (~ v0 <= v1))) (not_true_iff_false (v0 <=? v1)) ((fun v2 : v0 <=? v1 = @true <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 <> @true) (~ v0 <= v1) (Morphisms_Prop.not_iff_morphism (v0 <=? v1 = @true) (v0 <= v1) v2) (~ v0 <= v1) (~ v0 <= v1) (eq_proper_proxy (~ v0 <= v1))) (leb_le v0 v1) (reflexivity (~ v0 <= v1))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_gt	100	0.049078	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <=? v1 = @false <-> ~ v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @false) (~ v0 <= v1) v2 (v1 < v0) (v1 < v0) (eq_proper_proxy (v1 < v0))) (leb_nle v0 v1) ((fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v2)) (compare_lt_iff v1 v0) ((fun v2 : (v1 ?= v0) = @Lt <-> ~ v0 <= v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v1 ?= v0) = @Lt) (~ v0 <= v1) v2) (compare_nge_iff v1 v0) (reflexivity (~ v0 <= v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_nlt	100	0.051921	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <? v1 <> @true <-> v0 <? v1 = @false => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @false) (v0 <? v1 <> @true) (symmetry v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (not_true_iff_false (v0 <? v1)) ((fun v2 : v0 <? v1 = @true <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 <> @true) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism (v0 <? v1 = @true) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (ltb_lt v0 v1) (reflexivity (~ v0 < v1))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_ge	100	0.050502	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <? v1 = @false <-> ~ v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @false) (~ v0 < v1) v2 (v1 <= v0) (v1 <= v0) (eq_proper_proxy (v1 <= v0))) (ltb_nlt v0 v1) ((fun v2 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v2)) (compare_le_iff v1 v0) ((fun v2 : (v1 ?= v0) <> @Gt <-> ~ v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v1 ?= v0) <> @Gt) (~ v0 < v1) v2) (compare_ngt_iff v1 v0) (reflexivity (~ v0 < v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_refl	100	0.053554	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v1 <= v2), v1 <=? v2 = @true := fun v1 v2 : @t => match leb_le v1 v2 as v3 in (_ /\ _) return (forall v4 : v1 <= v2, v1 <=? v2 = @true) with | conj v3 v4 => (fun (v3 : forall v3 : v1 <=? v2 = @true, v1 <= v2) (v4 : forall v4 : v1 <= v2, v1 <=? v2 = @true) => v4) v3 v4 end in v1 v0 v0 (let v2 : forall (v2 v3 : @t) (v4 : v2 < v3 \/ v2 == v3), v2 <= v3 := fun v2 v3 : @t => match lt_eq_cases v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 <= v3, v2 < v3 \/ v2 == v3) (v5 : forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) => v5) v4 v5 end in v2 v0 v0 (or_intror (reflexivity v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_antisym	100	0.049979	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v1 <=? v0) (negb (v0 <? v1)) ((fun v2 : negb (v0 <? v1) = @true <-> v0 <? v1 = @false => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (negb (v0 <? v1) = @true) (v0 <? v1 = @false) v2) (negb_true_iff (v0 <? v1)) ((fun v2 : v1 <=? v0 = @true <-> v1 <= v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v1 <=? v0 = @true) (v1 <= v0) v2 (v0 <? v1 = @false) (v0 <? v1 = @false) (eq_proper_proxy (v0 <? v1 = @false))) (leb_le v1 v0) ((fun v2 : v0 <? v1 = @false <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <? v1 = @false) (v1 <= v0) v2) (ltb_ge v0 v1) (reflexivity (v1 <= v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_irrefl	100	0.053854	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v2 <= v1), v1 <? v2 = @false := fun v1 v2 : @t => match ltb_ge v1 v2 as v3 in (_ /\ _) return (forall v4 : v2 <= v1, v1 <? v2 = @false) with | conj v3 v4 => (fun (v3 : forall v3 : v1 <? v2 = @false, v2 <= v1) (v4 : forall v4 : v2 <= v1, v1 <? v2 = @false) => v4) v3 v4 end in v1 v0 v0 (let v2 : forall (v2 v3 : @t) (v4 : v2 < v3 \/ v2 == v3), v2 <= v3 := fun v2 v3 : @t => match lt_eq_cases v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 <= v3, v2 < v3 \/ v2 == v3) (v5 : forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) => v5) v4 v5 end in v2 v0 v0 (or_intror (reflexivity v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_antisym	100	0.053242	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v1 <? v0) (negb (v0 <=? v1)) ((fun v2 : negb (v0 <=? v1) = @true <-> v0 <=? v1 = @false => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (negb (v0 <=? v1) = @true) (v0 <=? v1 = @false) v2) (negb_true_iff (v0 <=? v1)) ((fun v2 : v1 <? v0 = @true <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v1 <? v0 = @true) (v1 < v0) v2 (v0 <=? v1 = @false) (v0 <=? v1 = @false) (eq_proper_proxy (v0 <=? v1 = @false))) (ltb_lt v1 v0) ((fun v2 : v0 <=? v1 = @false <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <=? v1 = @false) (v1 < v0) v2) (leb_gt v0 v1) (reflexivity (v1 < v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.eqb_compare	100	0.275806	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 =? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Eq => @true | _ => @false end ((fun v2 : (v0 =? v1) = @true <-> v0 == v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 =? v1) = @true) (v0 == v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true))) (eqb_eq v0 v1) ((fun v2 : (v0 ?= v1) = @Eq <-> v0 == v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 == v1) ((v0 ?= v1) = @Eq) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true))) (compare_eq_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Eq <-> match v3 as v4 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) with | Eq => conj (fun v3 : @Eq = @Eq => eq_refl) (fun v3 : @true = @true => eq_refl) | Lt => conj (fun v3 : @Lt = @Eq => let v4 : forall v4 : @Eq = @Eq, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, @false = @true) with | eq_refl => fun v4 : @Lt = @Eq => (fun v5 : @Lt = @Eq => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Lt = @Eq := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Lt = @Eq) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Lt = @Eq) v6) v4 end in v4 eq_refl) | Gt => conj (fun v3 : @Gt = @Eq => let v4 : forall v4 : @Eq = @Eq, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, @false = @true) with | eq_refl => fun v4 : @Gt = @Eq => (fun v5 : @Gt = @Eq => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt = @Eq := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt = @Eq) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt = @Eq) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_compare	100	0.271477	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 <? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Lt => @true | _ => @false end ((fun v2 : v0 <? v1 = @true <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @true) (v0 < v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true))) (ltb_lt v0 v1) ((fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 < v1) ((v0 ?= v1) = @Lt) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true))) (compare_lt_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Lt <-> match v3 as v4 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) with | Eq => conj (fun v3 : @Eq = @Lt => let v4 : forall v4 : @Lt = @Lt, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, @false = @true) with | eq_refl => fun v4 : @Eq = @Lt => (fun v5 : @Eq = @Lt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Eq = @Lt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Eq = @Lt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Eq = @Lt) v6) v4 end in v4 eq_refl) | Lt => conj (fun v3 : @Lt = @Lt => eq_refl) (fun v3 : @true = @true => eq_refl) | Gt => conj (fun v3 : @Gt = @Lt => let v4 : forall v4 : @Lt = @Lt, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, @false = @true) with | eq_refl => fun v4 : @Gt = @Lt => (fun v5 : @Gt = @Lt => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt = @Lt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt = @Lt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt = @Lt) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_compare	100	0.268779	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 <=? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Gt => @false | _ => @true end ((fun v2 : v0 <=? v1 = @true <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @true) (v0 <= v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true))) (leb_le v0 v1) ((fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true))) (compare_le_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 <> @Gt <-> match v3 as v4 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) with | Eq => conj (fun v3 : @Eq <> @Gt => eq_refl) (fun v3 : @true = @true => (fun v4 : @Eq = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Eq = @Gt => (fun v6 : @Eq = @Gt => let v7 : @False := eq_ind (@Eq) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Eq <> @Gt) | Lt => conj (fun v3 : @Lt <> @Gt => eq_refl) (fun v3 : @true = @true => (fun v4 : @Lt = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Lt = @Gt => (fun v6 : @Lt = @Gt => let v7 : @False := eq_ind (@Lt) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Lt <> @Gt) | Gt => conj (fun v3 : @Gt <> @Gt => False_ind (@false = @true) (v3 eq_refl)) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt <> @Gt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt <> @Gt) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_nonneg	100	0.144311	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : v0 <= 0 \/ 0 < v0 := le_gt_cases v0 0 in match v1 as v2 in (_ \/ _) return (0 <= log2 v0) with | or_introl v2 => (fun v2 : v0 <= 0 => (fun v3 : log2 v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (log2 v0) 0 v3) (log2_nonpos v0 v2) (reflexivity 0)) v2 | or_intror v2 => (fun v2 : 0 < v0 => let v3 : 2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0) := log2_spec v0 v2 in match v3 as v4 in (_ /\ _) return (0 <= log2 v0) with | conj v4 v5 => (fun (v4 : 2 ^ log2 v0 <= v0) (v5 : v0 < 2 ^ S (log2 v0)) => let v6 : forall (v6 v7 : @t) (v8 : v6 < S v7), v6 <= v7 := fun v6 v7 : @t => match lt_succ_r v6 v7 as v8 in (_ /\ _) return (forall v9 : v6 < S v7, v6 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : v6 < S v7, v6 <= v7) (v9 : forall v9 : v6 <= v7, v6 < S v7) => v8) v8 v9 end in v6 0 (log2 v0) (let v7 : forall (v7 : @t) (v8 : 1 < 2) (v9 : 1 < 2 ^ v7), 0 < v7 := fun (v7 : @t) (v8 : 1 < 2) => match pow_gt_1 2 v7 v8 as v9 in (_ /\ _) return (forall v10 : 1 < 2 ^ v7, 0 < v7) with | conj v9 v10 => (fun (v9 : forall v9 : 0 < v7, 1 < 2 ^ v7) (v10 : forall v10 : 1 < 2 ^ v7, 0 < v7) => v10) v9 v10 end in v7 (S (log2 v0)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : 2 <= 1 => (fun v11 : 0 < 2 => (fun v12 : 0 < 2 ^ S (log2 v0) => (fun v13 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v10 v9)) (Private_OrderTac.Tac.lt_trans v2 v5)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) (Private_OrderTac.Tac.not_ge_lt ((fun v8 : 2 ^ S (log2 v0) <= 1 => (fun v9 : 1 < 2 ^ S (log2 v0) => (fun v10 : 2 ^ S (log2 v0) < 2 ^ S (log2 v0) => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v9)) (Private_OrderTac.Tac.le_lt_trans ((fun v9 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 0) 1 (symmetry v9) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (@one_succ) ((fun v9 : S 0 <= v0 <-> 0 < v0 => iff_impl_subrelation (0 < v0) (S 0 <= v0) (symmetry v9)) (le_succ_l 0 v0) v2)) v5)) : ~ 2 ^ S (log2 v0) <= 1)))) v4 v5 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_unique	100	0.377667	1	1
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_wd	100	0.114869	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => let v3 : v0 <= 0 \/ 0 < v0 := le_gt_cases v0 0 in match v3 as v4 in (_ \/ _) return (log2 v0 == log2 v1) with | or_introl v4 => (fun v4 : v0 <= 0 => (fun v5 : log2 v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 v0) 0 v5 (log2 v1) (log2 v1) (eq_proper_proxy (log2 v1))) (log2_nonpos v0 v4) ((fun v5 : log2 v1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (log2 v1) 0 v5) (log2_nonpos v1 ((fun v5 : v0 == v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v1 v0 (symmetry v5) 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) v2 v4)) (reflexivity 0))) v4 | or_intror v4 => (fun v4 : 0 < v0 => log2_unique v0 (log2 v1) (log2_nonneg v1) ((fun v5 : v0 == v1 => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ log2 v1 <= v0) (2 ^ log2 v1 <= v1) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ log2 v1)) v0 v1 v5) (v0 < 2 ^ S (log2 v1)) (v1 < 2 ^ S (log2 v1)) (lt_wd v0 v1 v5 (2 ^ S (log2 v1)) (2 ^ S (log2 v1)) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ S (log2 v1))))) v2 (log2_spec v1 ((fun v5 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) v0 v1 v5) v2 v4)))) v4 end) : Proper (@eq ==> @eq) (@log2))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_spec_alt	100	0.463432	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => let v2 : 2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0) := log2_spec v0 v1 in match v2 as v3 in (_ /\ _) return (exists v4 : @t, v0 == 2 ^ log2 v0 + v4 /\ 0 <= v4 < 2 ^ log2 v0) with | conj v3 v4 => (fun (v3 : 2 ^ log2 v0 <= v0) (v4 : v0 < 2 ^ S (log2 v0)) => let v5 : exists v5 : @t, v0 == v5 + 2 ^ log2 v0 /\ 0 <= v5 := le_exists_sub (2 ^ log2 v0) v0 v3 in match v5 as v6 in (ex _) return (exists v7 : @t, v0 == 2 ^ log2 v0 + v7 /\ 0 <= v7 < 2 ^ log2 v0) with | ex_intro _ v6 v7 => (fun (v6 : @t) (v7 : v0 == v6 + 2 ^ log2 v0 /\ 0 <= v6) => match v7 as v8 in (_ /\ _) return (exists v9 : @t, v0 == 2 ^ log2 v0 + v9 /\ 0 <= v9 < 2 ^ log2 v0) with | conj v8 v9 => (fun (v8 : v0 == v6 + 2 ^ log2 v0) (v9 : 0 <= v6) => ex_intro (fun v10 : @t => v0 == 2 ^ log2 v0 + v10 /\ 0 <= v10 < 2 ^ log2 v0) v6 (conj ((fun v10 : 2 ^ log2 v0 + v6 == v6 + 2 ^ log2 v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (2 ^ log2 v0 + v6) (v6 + 2 ^ log2 v0) v10) (add_comm (2 ^ log2 v0) v6) v8) (conj v9 (let v10 : forall v10 : v6 + 2 ^ log2 v0 < 2 ^ log2 v0 + 2 ^ log2 v0, v6 < 2 ^ log2 v0 := match add_lt_mono_r v6 (2 ^ log2 v0) (2 ^ log2 v0) as v10 in (_ /\ _) return (forall v11 : v6 + 2 ^ log2 v0 < 2 ^ log2 v0 + 2 ^ log2 v0, v6 < 2 ^ log2 v0) with | conj v10 v11 => (fun (v10 : forall v10 : v6 < 2 ^ log2 v0, v6 + 2 ^ log2 v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (v11 : forall v11 : v6 + 2 ^ log2 v0 < 2 ^ log2 v0 + 2 ^ log2 v0, v6 < 2 ^ log2 v0) => v11) v10 v11 end in v10 ((fun v11 : v0 == v6 + 2 ^ log2 v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v6 + 2 ^ log2 v0) v0 (symmetry v11) (2 ^ log2 v0 + 2 ^ log2 v0) (2 ^ log2 v0 + 2 ^ log2 v0) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ log2 v0 + 2 ^ log2 v0))) v8 ((fun v11 : 2 ^ S (log2 v0) == 2 * 2 ^ log2 v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 < 2 ^ S (log2 v0)) (v0 < 2 * 2 ^ log2 v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ S (log2 v0)) (2 * 2 ^ log2 v0) v11) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0))) (pow_succ_r 2 (log2 v0) (log2_nonneg v0)) ((fun v11 : 2 == S 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 < 2 * 2 ^ log2 v0) (v0 < S 1 * 2 ^ log2 v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 * 2 ^ log2 v0) (S 1 * 2 ^ log2 v0) (mul_wd 2 (S 1) v11 (2 ^ log2 v0) (2 ^ log2 v0) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ log2 v0)))) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0))) (@two_succ) ((fun v11 : S 1 * 2 ^ log2 v0 == 1 * 2 ^ log2 v0 + 2 ^ log2 v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 < S 1 * 2 ^ log2 v0) (v0 < 1 * 2 ^ log2 v0 + 2 ^ log2 v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (S 1 * 2 ^ log2 v0) (1 * 2 ^ log2 v0 + 2 ^ log2 v0) v11) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0))) (mul_succ_l 1 (2 ^ log2 v0)) ((fun v11 : 1 * 2 ^ log2 v0 == 2 ^ log2 v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 < 1 * 2 ^ log2 v0 + 2 ^ log2 v0) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (1 * 2 ^ log2 v0 + 2 ^ log2 v0) (2 ^ log2 v0 + 2 ^ log2 v0) (add_wd (1 * 2 ^ log2 v0) (2 ^ log2 v0) v11 (2 ^ log2 v0) (2 ^ log2 v0) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ log2 v0)))) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 2 ^ log2 v0 + 2 ^ log2 v0))) (mul_1_l (2 ^ log2 v0)) (fun v11 : v0 < 2 ^ log2 v0 + 2 ^ log2 v0 => v11)))) v4)))))) v8 v9 end) v6 v7 end) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_unique'	100	0.345328	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v1) (v4 : 0 <= v2 < 2 ^ v1) => match v4 as v5 in (_ /\ _) return (forall v6 : v0 == 2 ^ v1 + v2, log2 v0 == v1) with | conj v5 v6 => (fun (v5 : 0 <= v2) (v6 : v2 < 2 ^ v1) (v7 : v0 == 2 ^ v1 + v2) => log2_unique v0 v1 v3 ((fun v8 : v0 == 2 ^ v1 + v2 => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ v1 <= v0) (2 ^ v1 <= 2 ^ v1 + v2) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1)) v0 (2 ^ v1 + v2) v8) (v0 < 2 ^ S v1) (2 ^ v1 + v2 < 2 ^ S v1) (lt_wd v0 (2 ^ v1 + v2) v8 (2 ^ S v1) (2 ^ S v1) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ S v1)))) v7 (conj ((fun v8 : 2 ^ v1 + 0 == 2 ^ v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ v1) (2 ^ v1 + 0) (symmetry v8) (2 ^ v1 + v2) (2 ^ v1 + v2) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1 + v2))) (add_0_r (2 ^ v1)) (let v8 : forall (v8 v9 v10 : @t) (v11 : v8 <= v9), v10 + v8 <= v10 + v9 := fun v8 v9 v10 : @t => match add_le_mono_l v8 v9 v10 as v11 in (_ /\ _) return (forall v12 : v8 <= v9, v10 + v8 <= v10 + v9) with | conj v11 v12 => (fun (v11 : forall v11 : v8 <= v9, v10 + v8 <= v10 + v9) (v12 : forall v12 : v10 + v8 <= v10 + v9, v8 <= v9) => v11) v11 v12 end in v8 0 v2 (2 ^ v1) v5)) ((fun v8 : 2 ^ S v1 == 2 * 2 ^ v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1 + v2)) (2 ^ S v1) (2 * 2 ^ v1) v8) (pow_succ_r 2 v1 (Private_OrderTac.Tac.not_gt_le ((fun v8 : v1 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v3 v8)) : ~ v1 < 0))) ((fun v8 : 2 == S 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1 + v2)) (2 * 2 ^ v1) (S 1 * 2 ^ v1) (mul_wd 2 (S 1) v8 (2 ^ v1) (2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1)))) (@two_succ) ((fun v8 : S 1 * 2 ^ v1 == 1 * 2 ^ v1 + 2 ^ v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1 + v2)) (S 1 * 2 ^ v1) (1 * 2 ^ v1 + 2 ^ v1) v8) (mul_succ_l 1 (2 ^ v1)) ((fun v8 : 1 * 2 ^ v1 == 2 ^ v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1 + v2)) (1 * 2 ^ v1 + 2 ^ v1) (2 ^ v1 + 2 ^ v1) (add_wd (1 * 2 ^ v1) (2 ^ v1) v8 (2 ^ v1) (2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1)))) (mul_1_l (2 ^ v1)) (let v8 : forall (v8 v9 v10 : @t) (v11 : v8 < v9), v10 + v8 < v10 + v9 := fun v8 v9 v10 : @t => match add_lt_mono_l v8 v9 v10 as v11 in (_ /\ _) return (forall v12 : v8 < v9, v10 + v8 < v10 + v9) with | conj v11 v12 => (fun (v11 : forall v11 : v8 < v9, v10 + v8 < v10 + v9) (v12 : forall v12 : v10 + v8 < v10 + v9, v8 < v9) => v11) v11 v12 end in v8 v2 (2 ^ v1) (2 ^ v1) v6)))))))) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_pow2	100	0.053877	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 <= v0) => log2_unique' (2 ^ v0) v0 0 v1 (conj ((fun (v2 : 0 < 1) (v3 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2)) (pow_pos_nonneg 2 v0 ((fun (v2 : 0 < 1) (v3 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v4 : 2 <= 0 => (fun v5 : 0 < 2 => (fun v6 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.le_lt_trans v4 v5)) (Private_OrderTac.Tac.lt_trans v2 v3)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v2 : 0 < 1) (v3 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v4 : v0 < 0 => (fun v5 : 0 < 2 => (fun v6 : v0 < 2 => (fun v7 : v0 < 1 => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v1 v4)) (Private_OrderTac.Tac.lt_trans v4 v2)) (Private_OrderTac.Tac.lt_trans v4 v5)) (Private_OrderTac.Tac.lt_trans v2 v3)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)))) ((fun v2 : 2 ^ v0 + 0 == 2 ^ v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (2 ^ v0 + 0) (2 ^ v0) v2) (add_0_r (2 ^ v0)) (reflexivity (2 ^ v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_pred_pow2	100	0.324624	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => let v2 : S (P v0) == v0 := (fun v2 : S (P v0) == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S (P v0)) v0 v2 v0 v0 (eq_proper_proxy v0)) (lt_succ_pred 0 v0 v1) (reflexivity v0) in log2_unique (P (2 ^ v0)) (P v0) (let v3 : forall (v3 v4 : @t) (v5 : v3 < S v4), v3 <= v4 := fun v3 v4 : @t => match lt_succ_r v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 < S v4, v3 <= v4) with | conj v5 v6 => (fun (v5 : forall v5 : v3 < S v4, v3 <= v4) (v6 : forall v6 : v3 <= v4, v3 < S v4) => v5) v5 v6 end in v3 0 (P v0) (Private_OrderTac.Tac.not_ge_lt ((fun v4 : S (P v0) <= 0 => (fun v5 : v0 <= 0 => (fun v6 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.le_lt_trans v5 v1)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v2) v4)) : ~ S (P v0) <= 0))) ((fun v3 : S (P (2 ^ v0)) <= 2 ^ S (P v0) <-> P (2 ^ v0) < 2 ^ S (P v0) => Reflexive_partial_app_morphism (subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (2 ^ P v0 <= P (2 ^ v0))) (P (2 ^ v0) < 2 ^ S (P v0)) (S (P (2 ^ v0)) <= 2 ^ S (P v0)) (symmetry v3)) (le_succ_l (P (2 ^ v0)) (2 ^ S (P v0))) ((fun v3 : 2 ^ P v0 < S (P (2 ^ v0)) <-> 2 ^ P v0 <= P (2 ^ v0) => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ P v0 <= P (2 ^ v0)) (2 ^ P v0 < S (P (2 ^ v0))) (symmetry v3) (S (P (2 ^ v0)) <= 2 ^ S (P v0)) (S (P (2 ^ v0)) <= 2 ^ S (P v0)) (reflexive_proper_proxy (@iff_Reflexive) (S (P (2 ^ v0)) <= 2 ^ S (P v0)))) (lt_succ_r (2 ^ P v0) (P (2 ^ v0))) ((fun v3 : S (P v0) == v0 => Reflexive_partial_app_morphism (subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (2 ^ P v0 < S (P (2 ^ v0)))) (S (P (2 ^ v0)) <= 2 ^ S (P v0)) (S (P (2 ^ v0)) <= 2 ^ v0) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive (S (P (2 ^ v0)))) (2 ^ S (P v0)) (2 ^ v0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (S (P v0)) v0 v3))) v2 ((fun v3 : S (P (2 ^ v0)) == 2 ^ v0 => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ P v0 < S (P (2 ^ v0))) (2 ^ P v0 < 2 ^ v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ P v0)) (S (P (2 ^ v0))) (2 ^ v0) v3) (S (P (2 ^ v0)) <= 2 ^ v0) (2 ^ v0 <= 2 ^ v0) (le_wd (S (P (2 ^ v0))) (2 ^ v0) v3 (2 ^ v0) (2 ^ v0) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v0)))) (lt_succ_pred 0 (2 ^ v0) (pow_pos_nonneg 2 v0 ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v5 : 2 <= 0 => (fun v6 : 0 < 2 => (fun v7 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v5 v6)) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v1 v5)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)))) (conj (let v3 : forall (v3 v4 v5 : @t) (v6 : 1 < v3) (v7 : 0 <= v5) (v8 : v4 < v5), v3 ^ v4 < v3 ^ v5 := fun (v3 v4 v5 : @t) (v6 : 1 < v3) (v7 : 0 <= v5) => match pow_lt_mono_r_iff v3 v4 v5 v6 v7 as v8 in (_ /\ _) return (forall v9 : v4 < v5, v3 ^ v4 < v3 ^ v5) with | conj v8 v9 => (fun (v8 : forall v8 : v4 < v5, v3 ^ v4 < v3 ^ v5) (v9 : forall v9 : v3 ^ v4 < v3 ^ v5, v4 < v5) => v8) v8 v9 end in v3 2 (P v0) v0 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : 2 <= 1 => (fun v7 : 0 < 2 => (fun v8 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v6 v5)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : v0 < 0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v1 v6)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)) ((fun v4 : P v0 < v0 <-> S (P v0) < S v0 => iff_flip_impl_subrelation (P v0 < v0) (S (P v0) < S v0) v4) (succ_lt_mono (P v0) v0) ((fun v4 : S (P v0) == v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (S (P v0)) v0 v4 (S v0) (S v0) (reflexive_proper_proxy Equivalence_Reflexive (S v0))) v2 (lt_succ_diag_r v0)))) (reflexivity (2 ^ v0))))))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_1	100	0.027799	1	1	0	synth with cache (only 1: refine ((fun v0 : 2 ^ 0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 1) (log2 (2 ^ 0)) (log2_wd 1 (2 ^ 0) (symmetry v0)) 0 0 (eq_proper_proxy 0)) (pow_0_r 2) (log2_pow2 0 (reflexivity 0)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_2	100	0.030918	1	1	0	synth with cache (only 1: refine ((fun v0 : 2 ^ 1 == 2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 2) (log2 (2 ^ 1)) (log2_wd 2 (2 ^ 1) (symmetry v0)) 1 1 (eq_proper_proxy 1)) (pow_1_r 2) (log2_pow2 1 ((fun (v0 : 0 < 1) (v1 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v2 : 1 < 0 => (fun v3 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v3) (Private_OrderTac.Tac.lt_trans v0 v2)) : ~ 1 < 0)) (@lt_0_1) (@lt_1_2))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_pos	100	0.569788	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 1 < v0) => let v2 : 0 < v0 := (fun (v2 : 0 < 1) (v3 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v4 : v0 <= 0 => (fun v5 : 0 < 2 => (fun v6 : 0 < v0 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v4 v6)) (Private_OrderTac.Tac.lt_trans v2 v1)) (Private_OrderTac.Tac.lt_trans v2 v3)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2) in let v3 : 0 <= log2 v0 := log2_nonneg v0 in match (fun v4 : 0 <= log2 v0 <-> 0 < log2 v0 \/ 0 == log2 v0 => iff_impl_subrelation (0 <= log2 v0) (0 < log2 v0 \/ 0 == log2 v0) v4) (lt_eq_cases 0 (log2 v0)) v3 as v4 in (_ \/ _) return (0 < log2 v0) with | or_introl v4 => (fun v4 : 0 < log2 v0 => v4) v4 | or_intror v4 => (fun v4 : 0 == log2 v0 => (fun v5 : 0 == log2 v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0)) (2 ^ 0 <= v0 < 2 ^ S 0) (and_iff_morphism (2 ^ log2 v0 <= v0) (2 ^ 0 <= v0) (le_wd (2 ^ log2 v0) (2 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (log2 v0) 0 (symmetry v5)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (v0 < 2 ^ S (log2 v0)) (v0 < 2 ^ S 0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ S (log2 v0)) (2 ^ S 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (S (log2 v0)) (S 0) (succ_wd (log2 v0) 0 (symmetry v5))))) (0 < log2 v0) (0 < 0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (log2 v0) 0 (symmetry v5))) v4 ((fun v5 : 2 ^ S 0 == 2 * 2 ^ 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ 0 <= v0 < 2 ^ S 0) (2 ^ 0 <= v0 < 2 * 2 ^ 0) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (2 ^ 0 <= v0)) (v0 < 2 ^ S 0) (v0 < 2 * 2 ^ 0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ S 0) (2 * 2 ^ 0) v5)) (0 < 0) (0 < 0) (reflexive_proper_proxy (@iff_Reflexive) (0 < 0))) (pow_succ_r 2 0 (Private_OrderTac.Tac.le_refl 0)) ((fun v5 : 2 ^ 0 == 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ 0 <= v0 < 2 * 2 ^ 0) (1 <= v0 < 2 * 1) (and_iff_morphism (2 ^ 0 <= v0) (1 <= v0) (le_wd (2 ^ 0) 1 v5 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (v0 < 2 * 2 ^ 0) (v0 < 2 * 1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 * 2 ^ 0) (2 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (2 ^ 0) 1 v5))) (0 < 0) (0 < 0) (reflexive_proper_proxy (@iff_Reflexive) (0 < 0))) (pow_0_r 2) ((fun v5 : 2 * 1 == 2 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (1 <= v0 < 2 * 1) (1 <= v0 < 2) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (1 <= v0)) (v0 < 2 * 1) (v0 < 2) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 * 1) 2 v5)) (0 < 0) (0 < 0) (reflexive_proper_proxy (@iff_Reflexive) (0 < 0))) (mul_1_r 2) (fun v5 : 1 <= v0 < 2 => match v5 as v6 in (_ /\ _) return (0 < 0) with | conj v6 v7 => (fun (v6 : 1 <= v0) (v7 : v0 < 2) => let v8 : forall (v8 v9 : @t) (v10 : v8 < S v9), v8 <= v9 := fun v8 v9 : @t => match lt_succ_r v8 v9 as v10 in (_ /\ _) return (forall v11 : v8 < S v9, v8 <= v9) with | conj v10 v11 => (fun (v10 : forall v10 : v8 < S v9, v8 <= v9) (v11 : forall v11 : v8 <= v9, v8 < S v9) => v10) v10 v11 end in let v9 : v0 <= 1 := v8 v0 1 ((fun v9 : 2 == S 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) 2 (S 1) v9) (@two_succ) v7) in False_ind (0 < 0) ((fun v10 : log2 v0 < v0 => (fun v11 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v9 v1)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v4) v2))) v6 v7 end)))) (log2_spec v0 v2)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_null	100	0.111256	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (fun v1 : log2 v0 == 0 => let v2 : v0 <= 1 \/ 1 < v0 := le_gt_cases v0 1 in match v2 as v3 in (_ \/ _) return (v0 <= 1) with | or_introl v3 => (fun v3 : v0 <= 1 => v3) v3 | or_intror v3 => (fun v3 : 1 < v0 => (fun v4 : 0 < log2 v0 => Private_OrderTac.Tac.not_gt_le ((fun v5 : 1 < v0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_eq v4 v1)) : ~ 1 < v0)) (log2_pos v0 v3)) v3 end) (fun v1 : v0 <= 1 => match (fun v2 : v0 <= 1 <-> v0 < 1 \/ v0 == 1 => iff_impl_subrelation (v0 <= 1) (v0 < 1 \/ v0 == 1) v2) (lt_eq_cases v0 1) v1 as v2 in (_ \/ _) return (log2 v0 == 0) with | or_introl v2 => (fun v2 : v0 < 1 => log2_nonpos v0 (let v3 : forall (v3 v4 : @t) (v5 : v3 < S v4), v3 <= v4 := fun v3 v4 : @t => match lt_succ_r v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 < S v4, v3 <= v4) with | conj v5 v6 => (fun (v5 : forall v5 : v3 < S v4, v3 <= v4) (v6 : forall v6 : v3 <= v4, v3 < S v4) => v5) v5 v6 end in v3 v0 0 ((fun v4 : 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (S 0) 1 (symmetry v4)) (@one_succ) v2))) v2 | or_intror v2 => (fun v2 : v0 == 1 => (fun v3 : v0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 v0) (log2 1) (log2_wd v0 1 v3) 0 0 (eq_proper_proxy 0)) v2 (@log2_1)) v2 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_le_mono	100	0.265488	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : v0 <= v1) => let v3 : v0 <= 0 \/ 0 < v0 := le_gt_cases v0 0 in match v3 as v4 in (_ \/ _) return (log2 v0 <= log2 v1) with | or_introl v4 => (fun v4 : v0 <= 0 => (fun v5 : log2 v0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) 0 v5 (log2 v1) (log2 v1) (reflexive_proper_proxy Equivalence_Reflexive (log2 v1))) (log2_nonpos v0 ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : 0 < v0 => (fun v8 : 0 < 2 => (fun v9 : v0 < 2 => (fun v10 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v4 v7)) (Private_OrderTac.Tac.le_lt_trans v4 v8)) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ 0 < v0)) (@lt_0_1) (@lt_1_2))) (log2_nonneg v1)) v4 | or_intror v4 => (fun v4 : 0 < v0 => let v5 : 0 < v1 := Private_OrderTac.Tac.not_ge_lt ((fun v5 : v1 <= 0 => (fun v6 : v1 < v0 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v2 v6)) (Private_OrderTac.Tac.le_lt_trans v5 v4)) : ~ v1 <= 0) in let v6 : 2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0) := log2_spec v0 v4 in match v6 as v7 in (_ /\ _) return (log2 v0 <= log2 v1) with | conj v7 v8 => (fun (v7 : 2 ^ log2 v0 <= v0) (v8 : v0 < 2 ^ S (log2 v0)) => let v9 : 2 ^ log2 v1 <= v1 < 2 ^ S (log2 v1) := log2_spec v1 v5 in match v9 as v10 in (_ /\ _) return (log2 v0 <= log2 v1) with | conj v10 v11 => (fun (v10 : 2 ^ log2 v1 <= v1) (v11 : v1 < 2 ^ S (log2 v1)) => let v12 : forall (v12 v13 : @t) (v14 : v12 < S v13), v12 <= v13 := fun v12 v13 : @t => match lt_succ_r v12 v13 as v14 in (_ /\ _) return (forall v15 : v12 < S v13, v12 <= v13) with | conj v14 v15 => (fun (v14 : forall v14 : v12 < S v13, v12 <= v13) (v15 : forall v15 : v12 <= v13, v12 < S v13) => v14) v14 v15 end in v12 (log2 v0) (log2 v1) (let v13 : forall (v13 v14 : @t) (v15 : 1 < 2) (v16 : 0 <= v14) (v17 : 2 ^ v13 < 2 ^ v14), v13 < v14 := fun (v13 v14 : @t) (v15 : 1 < 2) (v16 : 0 <= v14) => match pow_lt_mono_r_iff 2 v13 v14 v15 v16 as v17 in (_ /\ _) return (forall v18 : 2 ^ v13 < 2 ^ v14, v13 < v14) with | conj v17 v18 => (fun (v17 : forall v17 : v13 < v14, 2 ^ v13 < 2 ^ v14) (v18 : forall v18 : 2 ^ v13 < 2 ^ v14, v13 < v14) => v18) v17 v18 end in v13 (log2 v0) (S (log2 v1)) ((fun (v14 : 0 < 1) (v15 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v16 : 2 <= 1 => (fun v17 : 0 < 2 => (fun v18 : 0 < 2 ^ S (log2 v1) => (fun v19 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v19) (Private_OrderTac.Tac.le_lt_trans v16 v15)) (Private_OrderTac.Tac.lt_trans v5 v11)) (Private_OrderTac.Tac.lt_trans v14 v15)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) (le_le_succ_r 0 (log2 v1) (log2_nonneg v1)) ((fun (v14 : 0 < 1) (v15 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v16 : 2 ^ S (log2 v1) <= 2 ^ log2 v0 => (fun v17 : 0 < 2 => (fun v18 : 0 < 2 ^ S (log2 v1) => (fun v19 : v0 < 2 ^ S (log2 v1) => (fun v20 : 2 ^ log2 v0 < 2 ^ S (log2 v1) => (fun v21 : 2 ^ S (log2 v1) < 2 ^ S (log2 v1) => Private_OrderTac.Tac.lt_irrefl v21) (Private_OrderTac.Tac.le_lt_trans v16 v20)) (Private_OrderTac.Tac.le_lt_trans v7 v19)) (Private_OrderTac.Tac.le_lt_trans v2 v11)) (Private_OrderTac.Tac.lt_trans v5 v11)) (Private_OrderTac.Tac.lt_trans v14 v15)) : ~ 2 ^ S (log2 v1) <= 2 ^ log2 v0)) (@lt_0_1) (@lt_1_2)))) v10 v11 end) v7 v8 end) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_lt_cancel	100	0.241065	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : log2 v0 < log2 v1) => let v3 : v1 <= 0 \/ 0 < v1 := le_gt_cases v1 0 in match v3 as v4 in (_ \/ _) return (v0 < v1) with | or_introl v4 => (fun v4 : v1 <= 0 => (fun v5 : 0 <= log2 v0 => Private_OrderTac.Tac.not_ge_lt ((fun v6 : v1 <= v0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v5 ((fun v7 : log2 v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0)) (log2 v1) 0 v7) (log2_nonpos v1 v4) v2))) : ~ v1 <= v0)) (log2_nonneg v0)) v4 | or_intror v4 => (fun v4 : 0 < v1 => let v5 : v0 <= 0 \/ 0 < v0 := le_gt_cases v0 0 in match v5 as v6 in (_ \/ _) return (v0 < v1) with | or_introl v6 => (fun v6 : v0 <= 0 => Private_OrderTac.Tac.not_ge_lt ((fun v7 : v1 <= v0 => (fun v8 : v0 < v1 => (fun v9 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v7 v8)) (Private_OrderTac.Tac.le_lt_trans v6 v4)) : ~ v1 <= v0)) v6 | or_intror v6 => (fun v6 : 0 < v0 => let v7 : 2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0) := log2_spec v0 v6 in match v7 as v8 in (_ /\ _) return (v0 < v1) with | conj v8 v9 => (fun (v8 : 2 ^ log2 v0 <= v0) (v9 : v0 < 2 ^ S (log2 v0)) => let v10 : 2 ^ log2 v1 <= v1 < 2 ^ S (log2 v1) := log2_spec v1 v4 in match v10 as v11 in (_ /\ _) return (v0 < v1) with | conj v11 v12 => (fun (v11 : 2 ^ log2 v1 <= v1) (v12 : v1 < 2 ^ S (log2 v1)) => let v13 : forall (v13 v14 : @t) (v15 : v13 < v14), S v13 <= v14 := fun v13 v14 : @t => match le_succ_l v13 v14 as v15 in (_ /\ _) return (forall v16 : v13 < v14, S v13 <= v14) with | conj v15 v16 => (fun (v15 : forall v15 : S v13 <= v14, v13 < v14) (v16 : forall v16 : v13 < v14, S v13 <= v14) => v16) v15 v16 end in let v14 : S (log2 v0) <= log2 v1 := v13 (log2 v0) (log2 v1) v2 in let v15 : forall (v15 v16 : @t) (v17 : 1 < 2) (v18 : 0 <= v16) (v19 : v15 <= v16), 2 ^ v15 <= 2 ^ v16 := fun (v15 v16 : @t) (v17 : 1 < 2) (v18 : 0 <= v16) => match pow_le_mono_r_iff 2 v15 v16 v17 v18 as v19 in (_ /\ _) return (forall v20 : v15 <= v16, 2 ^ v15 <= 2 ^ v16) with | conj v19 v20 => (fun (v19 : forall v19 : v15 <= v16, 2 ^ v15 <= 2 ^ v16) (v20 : forall v20 : 2 ^ v15 <= 2 ^ v16, v15 <= v16) => v19) v19 v20 end in let v16 : 2 ^ S (log2 v0) <= 2 ^ log2 v1 := v15 (S (log2 v0)) (log2 v1) ((fun (v16 : 0 < 1) (v17 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v18 : 2 <= 1 => (fun v19 : 0 < 2 => (fun v20 : 0 < 2 ^ S (log2 v0) => (fun v21 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v21) (Private_OrderTac.Tac.le_lt_trans v18 v17)) (Private_OrderTac.Tac.lt_trans v6 v9)) (Private_OrderTac.Tac.lt_trans v16 v17)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) (log2_nonneg v1) v14 in (fun (v17 : 0 < 1) (v18 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v19 : v1 <= v0 => (fun v20 : 0 < 2 => (fun v21 : 0 < 2 ^ S (log2 v0) => (fun v22 : v1 < 2 ^ S (log2 v0) => (fun v23 : 2 ^ log2 v1 < 2 ^ S (log2 v0) => (fun v24 : 2 ^ S (log2 v0) < 2 ^ S (log2 v0) => Private_OrderTac.Tac.lt_irrefl v24) (Private_OrderTac.Tac.le_lt_trans v16 v23)) (Private_OrderTac.Tac.le_lt_trans v11 v22)) (Private_OrderTac.Tac.le_lt_trans v19 v9)) (Private_OrderTac.Tac.lt_trans v6 v9)) (Private_OrderTac.Tac.lt_trans v17 v18)) : ~ v1 <= v0)) (@lt_0_1) (@lt_1_2)) v11 v12 end) v8 v9 end) v6 end) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_le_pow2	100	0.483491	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) => conj (fun v3 : 2 ^ v1 <= v0 => let v4 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v4 as v5 in (_ \/ _) return (v1 <= log2 v0) with | or_introl v5 => (fun v5 : v1 < 0 => (fun v6 : 0 <= log2 v0 => Private_OrderTac.Tac.not_gt_le ((fun v7 : log2 v0 < v1 => (fun v8 : log2 v0 < 0 => (fun v9 : log2 v0 < v0 => (fun v10 : v1 < v0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v6 v8)) (Private_OrderTac.Tac.lt_trans v5 v2)) (Private_OrderTac.Tac.lt_trans v8 v2)) (Private_OrderTac.Tac.lt_trans v7 v5)) : ~ log2 v0 < v1)) (log2_nonneg v0)) v5 | or_intror v5 => (fun v5 : 0 <= v1 => (fun v6 : log2 (2 ^ v1) == v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v1 (log2 (2 ^ v1)) (symmetry v6) (log2 v0) (log2 v0) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0))) (log2_pow2 v1 v5) (log2_le_mono (2 ^ v1) v0 v3)) v5 end) (fun v3 : v1 <= log2 v0 => transitivity (pow_le_mono_r 2 v1 (log2 v0) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : 2 <= 0 => (fun v7 : 0 < 2 => (fun v8 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v6 v7)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : log2 v0 < v1 => (fun v7 : 0 < 2 => (fun v8 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v3 v6)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ log2 v0 < v1)) (@lt_0_1) (@lt_1_2))) (let v4 : 2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0) := log2_spec v0 v2 in match v4 as v5 in (_ /\ _) return (2 ^ log2 v0 <= v0) with | conj v5 v6 => (fun (v5 : 2 ^ log2 v0 <= v0) (v6 : v0 < 2 ^ S (log2 v0)) => v5) v5 v6 end)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_lt_pow2	100	0.257173	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) => conj (fun v3 : v0 < 2 ^ v1 => let v4 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v4 as v5 in (_ \/ _) return (log2 v0 < v1) with | or_introl v5 => (fun v5 : v1 < 0 => Private_OrderTac.Tac.not_ge_lt ((fun v6 : v1 <= log2 v0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v2 ((fun v7 : 2 ^ v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ v1) 0 v7) (pow_neg_r 2 v1 (Private_OrderTac.Tac.not_ge_lt ((fun v7 : 0 <= v1 => (fun v8 : 0 < 2 ^ v1 => (fun v9 : v1 < 2 ^ v1 => (fun v10 : v1 < v0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v7 v5)) (Private_OrderTac.Tac.lt_trans v5 v2)) (Private_OrderTac.Tac.lt_trans v5 v8)) (Private_OrderTac.Tac.lt_trans v2 v3)) : ~ 0 <= v1))) v3))) : ~ v1 <= log2 v0)) v5 | or_intror v5 => (fun v5 : 0 <= v1 => let v6 : forall (v6 v7 : @t) (v8 : 1 < 2) (v9 : 0 <= v7) (v10 : 2 ^ v6 < 2 ^ v7), v6 < v7 := fun (v6 v7 : @t) (v8 : 1 < 2) (v9 : 0 <= v7) => match pow_lt_mono_r_iff 2 v6 v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : 2 ^ v6 < 2 ^ v7, v6 < v7) with | conj v10 v11 => (fun (v10 : forall v10 : v6 < v7, 2 ^ v6 < 2 ^ v7) (v11 : forall v11 : 2 ^ v6 < 2 ^ v7, v6 < v7) => v11) v10 v11 end in v6 (log2 v0) v1 ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : 2 <= 1 => (fun v10 : 0 < 2 => (fun v11 : 0 < 2 ^ v1 => (fun v12 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v9 v8)) (Private_OrderTac.Tac.lt_trans v2 v3)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v9 : v1 < 0 => (fun v10 : 0 < 2 => (fun v11 : v1 < 2 => (fun v12 : v1 < 1 => (fun v13 : 0 < 2 ^ v1 => (fun v14 : v1 < 2 ^ v1 => (fun v15 : v1 < v0 => (fun v16 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v5 v9)) (Private_OrderTac.Tac.lt_trans v9 v2)) (Private_OrderTac.Tac.lt_trans v9 v13)) (Private_OrderTac.Tac.lt_trans v2 v3)) (Private_OrderTac.Tac.lt_trans v9 v7)) (Private_OrderTac.Tac.lt_trans v9 v10)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)) (le_lt_trans (2 ^ log2 v0) v0 (2 ^ v1) (let v7 : 2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0) := log2_spec v0 v2 in match v7 as v8 in (_ /\ _) return (2 ^ log2 v0 <= v0) with | conj v8 v9 => (fun (v8 : 2 ^ log2 v0 <= v0) (v9 : v0 < 2 ^ S (log2 v0)) => v8) v8 v9 end) v3)) v5 end) (fun v3 : log2 v0 < v1 => let v4 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v4 as v5 in (_ \/ _) return (v0 < 2 ^ v1) with | or_introl v5 => (fun v5 : v1 < 0 => (fun v6 : 0 <= log2 v0 => Private_OrderTac.Tac.not_ge_lt ((fun v7 : 2 ^ v1 <= v0 => (fun v8 : log2 v0 < 0 => (fun v9 : log2 v0 < v0 => (fun v10 : v1 < v0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v6 v8)) (Private_OrderTac.Tac.lt_trans v5 v2)) (Private_OrderTac.Tac.lt_trans v8 v2)) (Private_OrderTac.Tac.lt_trans v3 v5)) : ~ 2 ^ v1 <= v0)) (log2_nonneg v0)) v5 | or_intror v5 => (fun v5 : 0 <= v1 => log2_lt_cancel v0 (2 ^ v1) ((fun v6 : log2 (2 ^ v1) == v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0)) (log2 (2 ^ v1)) v1 v6) (log2_pow2 v1 v5) v3)) v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_lt_lin	100	0.086289	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => let v2 : forall (v2 v3 : @t) (v4 : 1 < 2) (v5 : 0 <= v3) (v6 : 2 ^ v2 < 2 ^ v3), v2 < v3 := fun (v2 v3 : @t) (v4 : 1 < 2) (v5 : 0 <= v3) => match pow_lt_mono_r_iff 2 v2 v3 v4 v5 as v6 in (_ /\ _) return (forall v7 : 2 ^ v2 < 2 ^ v3, v2 < v3) with | conj v6 v7 => (fun (v6 : forall v6 : v2 < v3, 2 ^ v2 < 2 ^ v3) (v7 : forall v7 : 2 ^ v2 < 2 ^ v3, v2 < v3) => v7) v6 v7 end in v2 (log2 v0) v0 ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v5 : 2 <= 1 => (fun v6 : 0 < 2 => (fun v7 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v5 v4)) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v1 v5)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)) (le_lt_trans (2 ^ log2 v0) v0 (2 ^ v0) (let v3 : 2 ^ log2 v0 <= v0 < 2 ^ S (log2 v0) := log2_spec v0 v1 in match v3 as v4 in (_ /\ _) return (2 ^ log2 v0 <= v0) with | conj v4 v5 => (fun (v4 : 2 ^ log2 v0 <= v0) (v5 : v0 < 2 ^ S (log2 v0)) => v4) v4 v5 end) (pow_gt_lin_r 2 v0 ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v5 : 2 <= 1 => (fun v6 : 0 < 2 => (fun v7 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v5 v4)) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v1 v5)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_le_lin	100	0.082405	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 <= v0) => match (fun v2 : 0 <= v0 <-> 0 < v0 \/ 0 == v0 => iff_impl_subrelation (0 <= v0) (0 < v0 \/ 0 == v0) v2) (lt_eq_cases 0 v0) v1 as v2 in (_ \/ _) return (log2 v0 <= v0) with | or_introl v2 => (fun v2 : 0 < v0 => lt_le_incl (log2 v0) v0 (log2_lt_lin v0 v2)) v2 | or_intror v2 => (fun v2 : 0 == v0 => (fun v3 : 0 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) (log2 0) (log2_wd v0 0 (symmetry v3)) v0 0 (symmetry v3)) v2 ((fun v3 : log2 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 0) 0 v3 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (log2_nonpos 0 (Private_OrderTac.Tac.le_refl 0)) (Private_OrderTac.Tac.le_refl 0))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_mul_below	100	0.226813	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 < v1) => let v4 : forall (v4 v5 : @t) (v6 : 0 < v4) (v7 : 2 ^ v5 <= v4), v5 <= log2 v4 := fun (v4 v5 : @t) (v6 : 0 < v4) => match log2_le_pow2 v4 v5 v6 as v7 in (_ /\ _) return (forall v8 : 2 ^ v5 <= v4, v5 <= log2 v4) with | conj v7 v8 => (fun (v7 : forall v7 : 2 ^ v5 <= v4, v5 <= log2 v4) (v8 : forall v8 : v5 <= log2 v4, 2 ^ v5 <= v4) => v7) v7 v8 end in v4 (v0 * v1) (log2 v0 + log2 v1) (mul_pos_pos v0 v1 ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v7 : v0 <= 0 => (fun v8 : 0 < 2 => (fun v9 : v0 < 2 => (fun v10 : v0 < 1 => (fun v11 : v0 < v1 => (fun v12 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v7 v2)) (Private_OrderTac.Tac.le_lt_trans v7 v3)) (Private_OrderTac.Tac.le_lt_trans v7 v5)) (Private_OrderTac.Tac.le_lt_trans v7 v8)) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v7 : v1 <= 0 => (fun v8 : 0 < 2 => (fun v9 : v1 < 2 => (fun v10 : v1 < 1 => (fun v11 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v7 v3)) (Private_OrderTac.Tac.le_lt_trans v7 v5)) (Private_OrderTac.Tac.le_lt_trans v7 v8)) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun v5 : 2 ^ (log2 v0 + log2 v1) == 2 ^ log2 v0 * 2 ^ log2 v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ (log2 v0 + log2 v1)) (2 ^ log2 v0 * 2 ^ log2 v1) v5 (v0 * v1) (v0 * v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v1))) (pow_add_r 2 (log2 v0) (log2 v1) (log2_nonneg v0) (log2_nonneg v1)) (mul_le_mono_nonneg (2 ^ log2 v0) v0 (2 ^ log2 v1) v1 (pow_nonneg 2 (log2 v0) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : 2 < 0 => (fun v8 : 1 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v5 v8)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ 2 < 0)) (@lt_0_1) (@lt_1_2))) (let v5 : forall (v5 : @t) (v6 : 0 < v5), 2 ^ log2 v5 <= v5 := fun (v5 : @t) (v6 : 0 < v5) => match log2_spec v5 v6 as v7 in (_ /\ _) return (2 ^ log2 v5 <= v5) with | conj v7 v8 => (fun (v7 : 2 ^ log2 v5 <= v5) (v8 : v5 < 2 ^ S (log2 v5)) => v7) v7 v8 end in v5 v0 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : v0 <= 0 => (fun v9 : 0 < 2 => (fun v10 : v0 < 2 => (fun v11 : v0 < 1 => (fun v12 : v0 < v1 => (fun v13 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v8 v2)) (Private_OrderTac.Tac.le_lt_trans v8 v3)) (Private_OrderTac.Tac.le_lt_trans v8 v6)) (Private_OrderTac.Tac.le_lt_trans v8 v9)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2))) (pow_nonneg 2 (log2 v1) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : 2 < 0 => (fun v8 : 1 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v5 v8)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ 2 < 0)) (@lt_0_1) (@lt_1_2))) (let v5 : forall (v5 : @t) (v6 : 0 < v5), 2 ^ log2 v5 <= v5 := fun (v5 : @t) (v6 : 0 < v5) => match log2_spec v5 v6 as v7 in (_ /\ _) return (2 ^ log2 v5 <= v5) with | conj v7 v8 => (fun (v7 : 2 ^ log2 v5 <= v5) (v8 : v5 < 2 ^ S (log2 v5)) => v7) v7 v8 end in v5 v1 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : v1 <= 0 => (fun v9 : 0 < 2 => (fun v10 : v1 < 2 => (fun v11 : v1 < 1 => (fun v12 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v8 v3)) (Private_OrderTac.Tac.le_lt_trans v8 v6)) (Private_OrderTac.Tac.le_lt_trans v8 v9)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_mul_above	100	0.566882	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 <= v0) (v3 : 0 <= v1) => match (fun v4 : 0 <= v0 <-> 0 < v0 \/ 0 == v0 => iff_impl_subrelation (0 <= v0) (0 < v0 \/ 0 == v0) v4) (lt_eq_cases 0 v0) v2 as v4 in (_ \/ _) return (log2 (v0 * v1) <= log2 v0 + log2 v1 + 1) with | or_introl v4 => (fun v4 : 0 < v0 => match (fun v5 : 0 <= v1 <-> 0 < v1 \/ 0 == v1 => iff_impl_subrelation (0 <= v1) (0 < v1 \/ 0 == v1) v5) (lt_eq_cases 0 v1) v3 as v5 in (_ \/ _) return (log2 (v0 * v1) <= log2 v0 + log2 v1 + 1) with | or_introl v5 => (fun v5 : 0 < v1 => let v6 : forall (v6 v7 : @t) (v8 : v6 < S v7), v6 <= v7 := fun v6 v7 : @t => match lt_succ_r v6 v7 as v8 in (_ /\ _) return (forall v9 : v6 < S v7, v6 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : v6 < S v7, v6 <= v7) (v9 : forall v9 : v6 <= v7, v6 < S v7) => v8) v8 v9 end in v6 (log2 (v0 * v1)) (log2 v0 + log2 v1 + 1) ((fun v7 : log2 v0 + log2 v1 + 1 == S (log2 v0 + log2 v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 * v1))) (S (log2 v0 + log2 v1 + 1)) (S (S (log2 v0 + log2 v1))) (succ_wd (log2 v0 + log2 v1 + 1) (S (log2 v0 + log2 v1)) v7)) (add_1_r (log2 v0 + log2 v1)) ((fun v7 : log2 v0 + S (log2 v1) == S (log2 v0 + log2 v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 * v1))) (S (S (log2 v0 + log2 v1))) (S (log2 v0 + S (log2 v1))) (succ_wd (S (log2 v0 + log2 v1)) (log2 v0 + S (log2 v1)) (symmetry v7))) (add_succ_r (log2 v0) (log2 v1)) ((fun v7 : S (log2 v0) + S (log2 v1) == S (log2 v0 + S (log2 v1)) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 * v1))) (S (log2 v0 + S (log2 v1))) (S (log2 v0) + S (log2 v1)) (symmetry v7)) (add_succ_l (log2 v0) (S (log2 v1))) (let v7 : forall (v7 v8 : @t) (v9 : 0 < v7) (v10 : v7 < 2 ^ v8), log2 v7 < v8 := fun (v7 v8 : @t) (v9 : 0 < v7) => match log2_lt_pow2 v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 < 2 ^ v8, log2 v7 < v8) with | conj v10 v11 => (fun (v10 : forall v10 : v7 < 2 ^ v8, log2 v7 < v8) (v11 : forall v11 : log2 v7 < v8, v7 < 2 ^ v8) => v10) v10 v11 end in v7 (v0 * v1) (S (log2 v0) + S (log2 v1)) (mul_pos_pos v0 v1 ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : v0 <= 0 => (fun v11 : 0 < 2 => (fun v12 : v0 < 2 => (fun v13 : v0 < 1 => (fun v14 : v0 < v1 => (fun v15 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v10 v4)) (Private_OrderTac.Tac.le_lt_trans v10 v5)) (Private_OrderTac.Tac.le_lt_trans v10 v8)) (Private_OrderTac.Tac.le_lt_trans v10 v11)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : v1 <= 0 => (fun v11 : 0 < 2 => (fun v12 : v1 < 2 => (fun v13 : v1 < 1 => (fun v14 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.le_lt_trans v10 v5)) (Private_OrderTac.Tac.le_lt_trans v10 v8)) (Private_OrderTac.Tac.le_lt_trans v10 v11)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun v8 : 2 ^ (S (log2 v0) + S (log2 v1)) == 2 ^ S (log2 v0) * 2 ^ S (log2 v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v1)) (2 ^ (S (log2 v0) + S (log2 v1))) (2 ^ S (log2 v0) * 2 ^ S (log2 v1)) v8) (pow_add_r 2 (S (log2 v0)) (S (log2 v1)) (le_le_succ_r 0 (log2 v0) (log2_nonneg v0)) (le_le_succ_r 0 (log2 v1) (log2_nonneg v1))) (mul_lt_mono_nonneg v0 (2 ^ S (log2 v0)) v1 (2 ^ S (log2 v1)) (Private_OrderTac.Tac.not_gt_le ((fun v8 : v0 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v4 v8)) : ~ v0 < 0)) (let v8 : forall (v8 : @t) (v9 : 0 < v8), v8 < 2 ^ S (log2 v8) := fun (v8 : @t) (v9 : 0 < v8) => match log2_spec v8 v9 as v10 in (_ /\ _) return (v8 < 2 ^ S (log2 v8)) with | conj v10 v11 => (fun (v10 : 2 ^ log2 v8 <= v8) (v11 : v8 < 2 ^ S (log2 v8)) => v11) v10 v11 end in v8 v0 v4) (Private_OrderTac.Tac.not_gt_le ((fun v8 : v1 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v5 v8)) : ~ v1 < 0)) (let v8 : forall (v8 : @t) (v9 : 0 < v8), v8 < 2 ^ S (log2 v8) := fun (v8 : @t) (v9 : 0 < v8) => match log2_spec v8 v9 as v10 in (_ /\ _) return (v8 < 2 ^ S (log2 v8)) with | conj v10 v11 => (fun (v10 : 2 ^ log2 v8 <= v8) (v11 : v8 < 2 ^ S (log2 v8)) => v11) v10 v11 end in v8 v1 v5)))))))) v5 | or_intror v5 => (fun v5 : 0 == v1 => (fun v6 : 0 == v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (v0 * v1)) (log2 (v0 * 0)) (log2_wd (v0 * v1) (v0 * 0) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v1 0 (symmetry v6))) (log2 v0 + log2 v1 + 1) (log2 v0 + log2 0 + 1) (add_wd (log2 v0 + log2 v1) (log2 v0 + log2 0) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0)) (log2 v1) (log2 0) (log2_wd v1 0 (symmetry v6))) 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1))) v5 ((fun v6 : v0 * 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (v0 * 0)) (log2 0) (log2_wd (v0 * 0) 0 v6) (log2 v0 + log2 0 + 1) (log2 v0 + log2 0 + 1) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 0 + 1))) (mul_0_r v0) ((fun v6 : log2 v0 + log2 0 + 1 == S (log2 v0 + log2 0) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 0)) (log2 v0 + log2 0 + 1) (S (log2 v0 + log2 0)) v6) (add_1_r (log2 v0 + log2 0)) ((fun v6 : log2 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 0) 0 v6 (S (log2 v0 + log2 0)) (S (log2 v0 + 0)) (succ_wd (log2 v0 + log2 0) (log2 v0 + 0) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0)) (log2 0) 0 v6))) (log2_nonpos 0 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2))) (le_le_succ_r 0 (log2 v0 + 0) (add_nonneg_nonneg (log2 v0) 0 (log2_nonneg v0) ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2)))))))) v5 end) v4 | or_intror v4 => (fun v4 : 0 == v0 => (fun v5 : 0 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (v0 * v1)) (log2 (0 * v1)) (log2_wd (v0 * v1) (0 * v1) (mul_wd v0 0 (symmetry v5) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2 v0 + log2 v1 + 1) (log2 0 + log2 v1 + 1) (add_wd (log2 v0 + log2 v1) (log2 0 + log2 v1) (add_wd (log2 v0) (log2 0) (log2_wd v0 0 (symmetry v5)) (log2 v1) (log2 v1) (reflexive_proper_proxy Equivalence_Reflexive (log2 v1))) 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1))) v4 ((fun v5 : log2 0 + log2 v1 + 1 == S (log2 0 + log2 v1) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 (0 * v1))) (log2 0 + log2 v1 + 1) (S (log2 0 + log2 v1)) v5) (add_1_r (log2 0 + log2 v1)) ((fun v5 : 0 * v1 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (0 * v1)) (log2 0) (log2_wd (0 * v1) 0 v5) (S (log2 0 + log2 v1)) (S (log2 0 + log2 v1)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 0 + log2 v1)))) (mul_0_l v1) ((fun v5 : log2 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 0) 0 v5 (S (log2 0 + log2 v1)) (S (0 + log2 v1)) (succ_wd (log2 0 + log2 v1) (0 + log2 v1) (add_wd (log2 0) 0 v5 (log2 v1) (log2 v1) (reflexive_proper_proxy Equivalence_Reflexive (log2 v1))))) (log2_nonpos 0 ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2))) (le_le_succ_r 0 (0 + log2 v1) (add_nonneg_nonneg 0 (log2 v1) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2)) (log2_nonneg v1))))))) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_mul_pow2	100	0.357662	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 <= v1) => log2_unique (v0 * 2 ^ v1) (v1 + log2 v0) (add_nonneg_nonneg v1 (log2 v0) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : v1 < 0 => (fun v7 : 0 < 2 => (fun v8 : v1 < 2 => (fun v9 : v1 < 1 => (fun v10 : v1 < v0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v3 v6)) (Private_OrderTac.Tac.lt_trans v6 v2)) (Private_OrderTac.Tac.lt_trans v6 v4)) (Private_OrderTac.Tac.lt_trans v6 v7)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)) (log2_nonneg v0)) (conj ((fun v4 : 2 ^ (v1 + log2 v0) == 2 ^ v1 * 2 ^ log2 v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ (v1 + log2 v0)) (2 ^ v1 * 2 ^ log2 v0) v4 (v0 * 2 ^ v1) (v0 * 2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1))) (pow_add_r 2 v1 (log2 v0) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : v1 < 0 => (fun v7 : 0 < 2 => (fun v8 : v1 < 2 => (fun v9 : v1 < 1 => (fun v10 : v1 < v0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v3 v6)) (Private_OrderTac.Tac.lt_trans v6 v2)) (Private_OrderTac.Tac.lt_trans v6 v4)) (Private_OrderTac.Tac.lt_trans v6 v7)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)) (log2_nonneg v0)) ((fun v4 : 2 ^ v1 * 2 ^ log2 v0 == 2 ^ log2 v0 * 2 ^ v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ v1 * 2 ^ log2 v0) (2 ^ log2 v0 * 2 ^ v1) v4 (v0 * 2 ^ v1) (v0 * 2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1))) (mul_comm (2 ^ v1) (2 ^ log2 v0)) (mul_le_mono_nonneg_r (2 ^ log2 v0) v0 (2 ^ v1) (pow_nonneg 2 v1 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : 2 < 0 => (fun v7 : 1 < 0 => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.lt_trans v4 v7)) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ 2 < 0)) (@lt_0_1) (@lt_1_2))) (let v4 : forall (v4 : @t) (v5 : 0 < v4), 2 ^ log2 v4 <= v4 := fun (v4 : @t) (v5 : 0 < v4) => match log2_spec v4 v5 as v6 in (_ /\ _) return (2 ^ log2 v4 <= v4) with | conj v6 v7 => (fun (v6 : 2 ^ log2 v4 <= v4) (v7 : v4 < 2 ^ S (log2 v4)) => v6) v6 v7 end in v4 v0 v2)))) ((fun v4 : v1 + S (log2 v0) == S (v1 + log2 v0) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1)) (2 ^ S (v1 + log2 v0)) (2 ^ (v1 + S (log2 v0))) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (S (v1 + log2 v0)) (v1 + S (log2 v0)) (symmetry v4))) (add_succ_r v1 (log2 v0)) ((fun v4 : 2 ^ (v1 + S (log2 v0)) == 2 ^ v1 * 2 ^ S (log2 v0) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1)) (2 ^ (v1 + S (log2 v0))) (2 ^ v1 * 2 ^ S (log2 v0)) v4) (pow_add_r 2 v1 (S (log2 v0)) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : v1 < 0 => (fun v7 : 0 < 2 => (fun v8 : v1 < 2 => (fun v9 : v1 < 1 => (fun v10 : v1 < v0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v3 v6)) (Private_OrderTac.Tac.lt_trans v6 v2)) (Private_OrderTac.Tac.lt_trans v6 v4)) (Private_OrderTac.Tac.lt_trans v6 v7)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)) (le_le_succ_r 0 (log2 v0) (log2_nonneg v0))) ((fun v4 : v0 * 2 ^ v1 == 2 ^ v1 * v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * 2 ^ v1) (2 ^ v1 * v0) v4 (2 ^ v1 * 2 ^ S (log2 v0)) (2 ^ v1 * 2 ^ S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1 * 2 ^ S (log2 v0)))) (mul_comm v0 (2 ^ v1)) (let v4 : forall (v4 v5 v6 : @t) (v7 : 0 < v4) (v8 : v5 < v6), v4 * v5 < v4 * v6 := fun (v4 v5 v6 : @t) (v7 : 0 < v4) => match mul_lt_mono_pos_l v4 v5 v6 v7 as v8 in (_ /\ _) return (forall v9 : v5 < v6, v4 * v5 < v4 * v6) with | conj v8 v9 => (fun (v8 : forall v8 : v5 < v6, v4 * v5 < v4 * v6) (v9 : forall v9 : v4 * v5 < v4 * v6, v5 < v6) => v8) v8 v9 end in v4 (2 ^ v1) v0 (2 ^ S (log2 v0)) (pow_pos_nonneg 2 v1 ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v7 : 2 <= 0 => (fun v8 : 0 < 2 => (fun v9 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v7 v8)) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : v1 < 0 => (fun v8 : 0 < 2 => (fun v9 : v1 < 2 => (fun v10 : v1 < 1 => (fun v11 : v1 < v0 => (fun v12 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v3 v7)) (Private_OrderTac.Tac.lt_trans v7 v2)) (Private_OrderTac.Tac.lt_trans v7 v5)) (Private_OrderTac.Tac.lt_trans v7 v8)) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2))) (let v5 : forall (v5 : @t) (v6 : 0 < v5), v5 < 2 ^ S (log2 v5) := fun (v5 : @t) (v6 : 0 < v5) => match log2_spec v5 v6 as v7 in (_ /\ _) return (v5 < 2 ^ S (log2 v5)) with | conj v7 v8 => (fun (v7 : 2 ^ log2 v5 <= v5) (v8 : v5 < 2 ^ S (log2 v5)) => v8) v7 v8 end in v5 v0 v2)))))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_double	100	0.854016	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => (fun v2 : 2 ^ 1 == 2 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (v0 * 2 ^ 1) == 1 + log2 v0) (log2 (v0 * 2) == 1 + log2 v0) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (v0 * 2 ^ 1)) (log2 (v0 * 2)) (log2_wd (v0 * 2 ^ 1) (v0 * 2) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ 1) 2 v2)) (1 + log2 v0) (1 + log2 v0) (reflexive_proper_proxy Equivalence_Reflexive (1 + log2 v0))) (log2 (2 * v0) == S (log2 v0)) (log2 (2 * v0) == S (log2 v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2 (2 * v0) == S (log2 v0)))) (pow_1_r 2) ((fun v2 : 1 + log2 v0 == S (log2 v0) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (v0 * 2) == 1 + log2 v0) (log2 (v0 * 2) == S (log2 v0)) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (1 + log2 v0) (S (log2 v0)) v2) (log2 (2 * v0) == S (log2 v0)) (log2 (2 * v0) == S (log2 v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2 (2 * v0) == S (log2 v0)))) (add_1_l (log2 v0)) ((fun v2 : 2 == S 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (v0 * 2) == S (log2 v0)) (log2 (v0 * S 1) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (v0 * 2)) (log2 (v0 * S 1)) (log2_wd (v0 * 2) (v0 * S 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) 2 (S 1) v2)) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (log2 (2 * v0) == S (log2 v0)) (log2 (S 1 * v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (2 * v0)) (log2 (S 1 * v0)) (log2_wd (2 * v0) (S 1 * v0) (mul_wd 2 (S 1) v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0))))) (@two_succ) ((fun v2 : 1 == S 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (v0 * S 1) == S (log2 v0)) (log2 (v0 * S (S 0)) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (v0 * S 1)) (log2 (v0 * S (S 0))) (log2_wd (v0 * S 1) (v0 * S (S 0)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (S 1) (S (S 0)) (succ_wd 1 (S 0) v2))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (log2 (S 1 * v0) == S (log2 v0)) (log2 (S (S 0) * v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (S 1 * v0)) (log2 (S (S 0) * v0)) (log2_wd (S 1 * v0) (S (S 0) * v0) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v2) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0))))) (@one_succ) ((fun v2 : v0 * S (S 0) == v0 * S 0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (v0 * S (S 0)) == S (log2 v0)) (log2 (v0 * S 0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (v0 * S (S 0))) (log2 (v0 * S 0 + v0)) (log2_wd (v0 * S (S 0)) (v0 * S 0 + v0) v2) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (log2 (S (S 0) * v0) == S (log2 v0)) (log2 (S (S 0) * v0) == S (log2 v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2 (S (S 0) * v0) == S (log2 v0)))) (mul_succ_r v0 (S 0)) ((fun v2 : v0 * S 0 == v0 * 0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (v0 * S 0 + v0) == S (log2 v0)) (log2 (v0 * 0 + v0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (v0 * S 0 + v0)) (log2 (v0 * 0 + v0 + v0)) (log2_wd (v0 * S 0 + v0) (v0 * 0 + v0 + v0) (add_wd (v0 * S 0) (v0 * 0 + v0) v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (log2 (S (S 0) * v0) == S (log2 v0)) (log2 (S (S 0) * v0) == S (log2 v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2 (S (S 0) * v0) == S (log2 v0)))) (mul_succ_r v0 0) ((fun v2 : v0 * 0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (v0 * 0 + v0 + v0) == S (log2 v0)) (log2 (0 + v0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (v0 * 0 + v0 + v0)) (log2 (0 + v0 + v0)) (log2_wd (v0 * 0 + v0 + v0) (0 + v0 + v0) (add_wd (v0 * 0 + v0) (0 + v0) (add_wd (v0 * 0) 0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (log2 (S (S 0) * v0) == S (log2 v0)) (log2 (S (S 0) * v0) == S (log2 v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2 (S (S 0) * v0) == S (log2 v0)))) (mul_0_r v0) ((fun v2 : S (S 0) * v0 == S 0 * v0 + v0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (log2 (0 + v0 + v0) == S (log2 v0))) (log2 (S (S 0) * v0) == S (log2 v0)) (log2 (S 0 * v0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (S (S 0) * v0)) (log2 (S 0 * v0 + v0)) (log2_wd (S (S 0) * v0) (S 0 * v0 + v0) v2) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0))))) (mul_succ_l (S 0) v0) ((fun v2 : S 0 * v0 == 0 * v0 + v0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (log2 (0 + v0 + v0) == S (log2 v0))) (log2 (S 0 * v0 + v0) == S (log2 v0)) (log2 (0 * v0 + v0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (S 0 * v0 + v0)) (log2 (0 * v0 + v0 + v0)) (log2_wd (S 0 * v0 + v0) (0 * v0 + v0 + v0) (add_wd (S 0 * v0) (0 * v0 + v0) v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0))))) (mul_succ_l 0 v0) ((fun v2 : 0 * v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (log2 (0 + v0 + v0) == S (log2 v0))) (log2 (0 * v0 + v0 + v0) == S (log2 v0)) (log2 (0 + v0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (0 * v0 + v0 + v0)) (log2 (0 + v0 + v0)) (log2_wd (0 * v0 + v0 + v0) (0 + v0 + v0) (add_wd (0 * v0 + v0) (0 + v0) (add_wd (0 * v0) 0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0))))) (mul_0_l v0) ((fun v2 : 0 + v0 == v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2 (0 + v0 + v0) == S (log2 v0)) (log2 (v0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (0 + v0 + v0)) (log2 (v0 + v0)) (log2_wd (0 + v0 + v0) (v0 + v0) (add_wd (0 + v0) v0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (log2 (0 + v0 + v0) == S (log2 v0)) (log2 (v0 + v0) == S (log2 v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2 (0 + v0 + v0)) (log2 (v0 + v0)) (log2_wd (0 + v0 + v0) (v0 + v0) (add_wd (0 + v0) v0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0))))) (add_0_l v0) (fun v2 : log2 (v0 + v0) == S (log2 v0) => v2))))))))))) (log2_mul_pow2 v0 1 v1 (@le_0_1)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_same	100	0.082409	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 < v1) (v4 : log2 v0 == log2 v1) => log2_lt_cancel v0 (2 * v1) ((fun v5 : log2 (2 * v1) == S (log2 v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0)) (log2 (2 * v1)) (S (log2 v1)) v5) (log2_double v1 v3) ((fun v5 : log2 v0 == log2 v1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) (log2 v1) v5 (S (log2 v1)) (S (log2 v1)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v1)))) v4 (lt_succ_diag_r (log2 v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_succ_le	100	0.293525	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (log2 (S v0) <= S (log2 v0)) with | or_introl v2 => (fun v2 : 0 < v0 => let v3 : forall (v3 v4 : @t) (v5 : 1 < 2) (v6 : 0 <= v4) (v7 : 2 ^ v3 <= 2 ^ v4), v3 <= v4 := fun (v3 v4 : @t) (v5 : 1 < 2) (v6 : 0 <= v4) => match pow_le_mono_r_iff 2 v3 v4 v5 v6 as v7 in (_ /\ _) return (forall v8 : 2 ^ v3 <= 2 ^ v4, v3 <= v4) with | conj v7 v8 => (fun (v7 : forall v7 : v3 <= v4, 2 ^ v3 <= 2 ^ v4) (v8 : forall v8 : 2 ^ v3 <= 2 ^ v4, v3 <= v4) => v8) v7 v8 end in v3 (log2 (S v0)) (S (log2 v0)) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : 2 <= 1 => (fun v7 : 0 < 2 => (fun v8 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v6 v5)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) (le_le_succ_r 0 (log2 v0) (log2_nonneg v0)) (transitivity (let v4 : forall (v4 : @t) (v5 : 0 < v4), 2 ^ log2 v4 <= v4 := fun (v4 : @t) (v5 : 0 < v4) => match log2_spec v4 v5 as v6 in (_ /\ _) return (2 ^ log2 v4 <= v4) with | conj v6 v7 => (fun (v6 : 2 ^ log2 v4 <= v4) (v7 : v4 < 2 ^ S (log2 v4)) => v6) v6 v7 end in v4 (S v0) (let v5 : forall (v5 v6 : @t) (v7 : v5 <= v6), v5 < S v6 := fun v5 v6 : @t => match lt_succ_r v5 v6 as v7 in (_ /\ _) return (forall v8 : v5 <= v6, v5 < S v6) with | conj v7 v8 => (fun (v7 : forall v7 : v5 < S v6, v5 <= v6) (v8 : forall v8 : v5 <= v6, v5 < S v6) => v8) v7 v8 end in v5 0 v0 (Private_OrderTac.Tac.not_gt_le ((fun v6 : v0 < 0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v2 v6)) : ~ v0 < 0)))) (let v4 : forall (v4 v5 : @t) (v6 : v4 < v5), S v4 <= v5 := fun v4 v5 : @t => match le_succ_l v4 v5 as v6 in (_ /\ _) return (forall v7 : v4 < v5, S v4 <= v5) with | conj v6 v7 => (fun (v6 : forall v6 : S v4 <= v5, v4 < v5) (v7 : forall v7 : v4 < v5, S v4 <= v5) => v7) v6 v7 end in v4 v0 (2 ^ S (log2 v0)) (let v5 : forall (v5 : @t) (v6 : 0 < v5), v5 < 2 ^ S (log2 v5) := fun (v5 : @t) (v6 : 0 < v5) => match log2_spec v5 v6 as v7 in (_ /\ _) return (v5 < 2 ^ S (log2 v5)) with | conj v7 v8 => (fun (v7 : 2 ^ log2 v5 <= v5) (v8 : v5 < 2 ^ S (log2 v5)) => v8) v7 v8 end in v5 v0 v2)))) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (log2 (S v0) <= S (log2 v0)) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : 0 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (S v0)) (log2 (S 0)) (log2_wd (S v0) (S 0) (succ_wd v0 0 (symmetry v4))) (S (log2 v0)) (S (log2 0)) (succ_wd (log2 v0) (log2 0) (log2_wd v0 0 (symmetry v4)))) v3 ((fun v4 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (S 0)) (log2 1) (log2_wd (S 0) 1 (symmetry v4)) (S (log2 0)) (S (log2 0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 0)))) (@one_succ) ((fun v4 : log2 1 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 1) 0 v4 (S (log2 0)) (S (log2 0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 0)))) (@log2_1) (le_le_succ_r 0 (log2 0) (log2_nonneg 0))))) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : log2 (S v0) == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (S v0)) 0 v4 (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (log2_nonpos (S v0) ((fun v4 : S v0 <= 0 <-> v0 < 0 => iff_flip_impl_subrelation (S v0 <= 0) (v0 < 0) v4) (le_succ_l v0 0) v3)) ((fun v4 : log2 v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (S (log2 v0)) (S 0) (succ_wd (log2 v0) 0 v4)) (log2_nonpos v0 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : 0 < v0 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v3 v6)) : ~ 0 < v0)) (@lt_0_1) (@lt_1_2))) (le_le_succ_r 0 0 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2))))) v3 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_succ_or	100	0.108628	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : log2 (S v0) <= log2 v0 \/ log2 v0 < log2 (S v0) := le_gt_cases (log2 (S v0)) (log2 v0) in match v1 as v2 in (_ \/ _) return (log2 (S v0) == S (log2 v0) \/ log2 (S v0) == log2 v0) with | or_introl v2 => (fun v2 : log2 (S v0) <= log2 v0 => or_intror ((fun v3 : log2 v0 <= log2 (S v0) => Private_OrderTac.Tac.not_neq_eq ((fun v4 : log2 (S v0) ~= log2 v0 => (fun v5 : log2 (S v0) == log2 v0 => (fun v6 : log2 v0 ~= log2 v0 => v6 (Private_OrderTac.Tac.eq_refl (log2 v0))) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v5) v4)) (Private_OrderTac.Tac.le_antisym v2 v3)) : ~ log2 (S v0) ~= log2 v0)) (log2_le_mono v0 (S v0) (le_succ_diag_r v0)))) v2 | or_intror v2 => (fun v2 : log2 v0 < log2 (S v0) => or_introl (let v3 : forall (v3 v4 : @t) (v5 : v3 < v4), S v3 <= v4 := fun v3 v4 : @t => match le_succ_l v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 < v4, S v3 <= v4) with | conj v5 v6 => (fun (v5 : forall v5 : S v3 <= v4, v3 < v4) (v6 : forall v6 : v3 < v4, S v3 <= v4) => v6) v5 v6 end in let v4 : S (log2 v0) <= log2 (S v0) := v3 (log2 v0) (log2 (S v0)) v2 in (fun v5 : log2 (S v0) <= S (log2 v0) => Private_OrderTac.Tac.not_neq_eq ((fun v6 : log2 (S v0) ~= S (log2 v0) => (fun v7 : S (log2 v0) == log2 (S v0) => (fun v8 : log2 (S v0) ~= log2 (S v0) => v8 (Private_OrderTac.Tac.eq_refl (log2 (S v0)))) (Private_OrderTac.Tac.neq_eq v6 v7)) (Private_OrderTac.Tac.le_antisym v4 v5)) : ~ log2 (S v0) ~= S (log2 v0))) (log2_succ_le v0))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_eq_succ_is_pow2	100	0.573783	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : log2 (S v0) == S (log2 v0)) => let v2 : v0 <= 0 \/ 0 < v0 := le_gt_cases v0 0 in match v2 as v3 in (_ \/ _) return (exists v4 : @t, S v0 == 2 ^ v4) with | or_introl v3 => (fun v3 : v0 <= 0 => (fun v4 : 0 < S 0 => False_ind (exists v5 : @t, S v0 == 2 ^ v5) ((fun v5 : S 0 < S 0 => (fun v6 : v0 <= S 0 => Private_OrderTac.Tac.lt_irrefl v5) (Private_OrderTac.Tac.le_eq v3 ((fun v6 : log2 v0 == 0 => trans_co_impl_morphism Equivalence_Transitive (S (log2 v0)) (S 0) (succ_wd (log2 v0) 0 v6)) (proj2 (log2_null v0) ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v8 : 1 < v0 => (fun v9 : S (log2 v0) < 1 => (fun v10 : v0 <= S (log2 v0) => (fun v11 : S (log2 v0) < v0 => (fun v12 : S (log2 v0) < 2 => (fun v13 : v0 < 2 => (fun v14 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.le_lt_trans v10 v11)) (Private_OrderTac.Tac.le_lt_trans v10 v12)) (Private_OrderTac.Tac.lt_trans v9 v7)) (Private_OrderTac.Tac.lt_trans v9 v8)) (Private_OrderTac.Tac.le_eq v3 ((fun v10 : log2 (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2 (S v0)) 0 v10 (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (proj2 (log2_null (S v0)) (let v10 : forall (v10 v11 : @t) (v12 : v10 < v11), S v10 <= v11 := fun v10 v11 : @t => match le_succ_l v10 v11 as v12 in (_ /\ _) return (forall v13 : v10 < v11, S v10 <= v11) with | conj v12 v13 => (fun (v12 : forall v12 : S v10 <= v11, v10 < v11) (v13 : forall v13 : v10 < v11, S v10 <= v11) => v13) v12 v13 end in v10 v0 1 ((fun (v11 : 0 < 1) (v12 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v13 : 1 <= v0 => (fun v14 : 0 < 2 => (fun v15 : v0 < 2 => (fun v16 : v0 < 1 => (fun v17 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v13 v16)) (Private_OrderTac.Tac.le_lt_trans v3 v11)) (Private_OrderTac.Tac.le_lt_trans v3 v14)) (Private_OrderTac.Tac.lt_trans v11 v12)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1))) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v9 : log2 (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2 (S v0)) 0 v9 (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (proj2 (log2_null (S v0)) (let v9 : forall (v9 v10 : @t) (v11 : v9 < v10), S v9 <= v10 := fun v9 v10 : @t => match le_succ_l v9 v10 as v11 in (_ /\ _) return (forall v12 : v9 < v10, S v9 <= v10) with | conj v11 v12 => (fun (v11 : forall v11 : S v9 <= v10, v9 < v10) (v12 : forall v12 : v9 < v10, S v9 <= v10) => v12) v11 v12 end in v9 v0 1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : 1 <= v0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v12 v15)) (Private_OrderTac.Tac.le_lt_trans v3 v10)) (Private_OrderTac.Tac.le_lt_trans v3 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1)) v6)) : ~ 1 < v0)) (@lt_0_1) (@lt_1_2))) ((fun v6 : log2 (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2 (S v0)) 0 v6 (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (proj2 (log2_null (S v0)) (let v6 : forall (v6 v7 : @t) (v8 : v6 < v7), S v6 <= v7 := fun v6 v7 : @t => match le_succ_l v6 v7 as v8 in (_ /\ _) return (forall v9 : v6 < v7, S v6 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : S v6 <= v7, v6 < v7) (v9 : forall v9 : v6 < v7, S v6 <= v7) => v9) v8 v9 end in v6 v0 1 ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : 1 <= v0 => (fun v10 : 0 < 2 => (fun v11 : v0 < 2 => (fun v12 : v0 < 1 => (fun v13 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v9 v12)) (Private_OrderTac.Tac.le_lt_trans v3 v7)) (Private_OrderTac.Tac.le_lt_trans v3 v10)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1)))) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v5 : log2 v0 == 0 => trans_co_impl_morphism Equivalence_Transitive (S (log2 v0)) (S 0) (succ_wd (log2 v0) 0 v5)) (proj2 (log2_null v0) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : 1 < v0 => (fun v8 : S (log2 v0) < 1 => (fun v9 : v0 <= S (log2 v0) => (fun v10 : S (log2 v0) < v0 => (fun v11 : S (log2 v0) < 2 => (fun v12 : v0 < 2 => (fun v13 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v9 v10)) (Private_OrderTac.Tac.le_lt_trans v9 v11)) (Private_OrderTac.Tac.lt_trans v8 v6)) (Private_OrderTac.Tac.lt_trans v8 v7)) (Private_OrderTac.Tac.le_eq v3 ((fun v9 : log2 (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2 (S v0)) 0 v9 (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (proj2 (log2_null (S v0)) (let v9 : forall (v9 v10 : @t) (v11 : v9 < v10), S v9 <= v10 := fun v9 v10 : @t => match le_succ_l v9 v10 as v11 in (_ /\ _) return (forall v12 : v9 < v10, S v9 <= v10) with | conj v11 v12 => (fun (v11 : forall v11 : S v9 <= v10, v9 < v10) (v12 : forall v12 : v9 < v10, S v9 <= v10) => v12) v11 v12 end in v9 v0 1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : 1 <= v0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v12 v15)) (Private_OrderTac.Tac.le_lt_trans v3 v10)) (Private_OrderTac.Tac.le_lt_trans v3 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1))) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v8 : log2 (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2 (S v0)) 0 v8 (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (proj2 (log2_null (S v0)) (let v8 : forall (v8 v9 : @t) (v10 : v8 < v9), S v8 <= v9 := fun v8 v9 : @t => match le_succ_l v8 v9 as v10 in (_ /\ _) return (forall v11 : v8 < v9, S v8 <= v9) with | conj v10 v11 => (fun (v10 : forall v10 : S v8 <= v9, v8 < v9) (v11 : forall v11 : v8 < v9, S v8 <= v9) => v11) v10 v11 end in v8 v0 1 ((fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v11 : 1 <= v0 => (fun v12 : 0 < 2 => (fun v13 : v0 < 2 => (fun v14 : v0 < 1 => (fun v15 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v11 v14)) (Private_OrderTac.Tac.le_lt_trans v3 v9)) (Private_OrderTac.Tac.le_lt_trans v3 v12)) (Private_OrderTac.Tac.lt_trans v9 v10)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1)) v5)) : ~ 1 < v0)) (@lt_0_1) (@lt_1_2))) ((fun v5 : log2 (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2 (S v0)) 0 v5 (S (log2 v0)) (S (log2 v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 v0)))) (proj2 (log2_null (S v0)) (let v5 : forall (v5 v6 : @t) (v7 : v5 < v6), S v5 <= v6 := fun v5 v6 : @t => match le_succ_l v5 v6 as v7 in (_ /\ _) return (forall v8 : v5 < v6, S v5 <= v6) with | conj v7 v8 => (fun (v7 : forall v7 : S v5 <= v6, v5 < v6) (v8 : forall v8 : v5 < v6, S v5 <= v6) => v8) v7 v8 end in v5 v0 1 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : 1 <= v0 => (fun v9 : 0 < 2 => (fun v10 : v0 < 2 => (fun v11 : v0 < 1 => (fun v12 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v8 v11)) (Private_OrderTac.Tac.le_lt_trans v3 v6)) (Private_OrderTac.Tac.le_lt_trans v3 v9)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1))) v4))) (lt_succ_diag_r 0)) v3 | or_intror v3 => (fun v3 : 0 < v0 => let v4 : 0 < S v0 := let v4 : forall (v4 v5 : @t) (v6 : v4 <= v5), v4 < S v5 := fun v4 v5 : @t => match lt_succ_r v4 v5 as v6 in (_ /\ _) return (forall v7 : v4 <= v5, v4 < S v5) with | conj v6 v7 => (fun (v6 : forall v6 : v4 < S v5, v4 <= v5) (v7 : forall v7 : v4 <= v5, v4 < S v5) => v7) v6 v7 end in v4 0 v0 (Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v3 v5)) : ~ v0 < 0)) in ex_intro (fun v5 : @t => S v0 == 2 ^ v5) (log2 (S v0)) ((fun v5 : S v0 <= 2 ^ S (log2 v0) <-> v0 < 2 ^ S (log2 v0) => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (2 ^ log2 (S v0) <= S v0)) (forall v6 : v0 < 2 ^ S (log2 v0), S v0 == 2 ^ log2 (S v0)) (forall v6 : S v0 <= 2 ^ S (log2 v0), S v0 == 2 ^ log2 (S v0)) (iff_iff_iff_impl_morphism (v0 < 2 ^ S (log2 v0)) (S v0 <= 2 ^ S (log2 v0)) (symmetry v5) (S v0 == 2 ^ log2 (S v0)) (S v0 == 2 ^ log2 (S v0)) (reflexive_proper_proxy (@iff_Reflexive) (S v0 == 2 ^ log2 (S v0))))) (le_succ_l v0 (2 ^ S (log2 v0))) ((fun v5 : log2 (S v0) == S (log2 v0) => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (2 ^ log2 (S v0) <= S v0)) (forall v6 : S v0 <= 2 ^ S (log2 v0), S v0 == 2 ^ log2 (S v0)) (forall v6 : S v0 <= 2 ^ log2 (S v0), S v0 == 2 ^ log2 (S v0)) (iff_iff_iff_impl_morphism (S v0 <= 2 ^ S (log2 v0)) (S v0 <= 2 ^ log2 (S v0)) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive (S v0)) (2 ^ S (log2 v0)) (2 ^ log2 (S v0)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (S (log2 v0)) (log2 (S v0)) (symmetry v5))) (S v0 == 2 ^ log2 (S v0)) (S v0 == 2 ^ log2 (S v0)) (reflexive_proper_proxy (@iff_Reflexive) (S v0 == 2 ^ log2 (S v0))))) v1 (fun (v5 : 2 ^ log2 (S v0) <= S v0) (v6 : S v0 <= 2 ^ log2 (S v0)) => Private_OrderTac.Tac.not_neq_eq ((fun v7 : S v0 ~= 2 ^ log2 (S v0) => (fun v8 : 2 ^ log2 (S v0) == S v0 => (fun v9 : S v0 ~= S v0 => v9 (Private_OrderTac.Tac.eq_refl (S v0))) (Private_OrderTac.Tac.neq_eq v7 v8)) (Private_OrderTac.Tac.le_antisym v5 v6)) : ~ S v0 ~= 2 ^ log2 (S v0)))) (proj1 (log2_spec (S v0) v4)) (proj2 (log2_spec v0 v3)))) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_eq_succ_iff_pow2	100	0.273399	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => conj (log2_eq_succ_is_pow2 v0) (fun v2 : exists v2 : @t, S v0 == 2 ^ v2 => match v2 as v3 in (ex _) return (log2 (S v0) == S (log2 v0)) with | ex_intro _ v3 v4 => (fun (v3 : @t) (v4 : S v0 == 2 ^ v3) => let v5 : 0 < v3 := let v5 : forall (v5 : @t) (v6 : 1 < 2) (v7 : 1 < 2 ^ v5), 0 < v5 := fun (v5 : @t) (v6 : 1 < 2) => match pow_gt_1 2 v5 v6 as v7 in (_ /\ _) return (forall v8 : 1 < 2 ^ v5, 0 < v5) with | conj v7 v8 => (fun (v7 : forall v7 : 0 < v5, 1 < 2 ^ v5) (v8 : forall v8 : 1 < 2 ^ v5, 0 < v5) => v8) v7 v8 end in v5 v3 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : 2 <= 1 => (fun v9 : 0 < 2 => (fun v10 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v7)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun v6 : S v0 == 2 ^ v3 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (2 ^ v3) (S v0) (symmetry v6)) v4 ((fun v6 : 1 == S 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (S 0) v6 (S v0) (S v0) (reflexive_proper_proxy Equivalence_Reflexive (S v0))) (@one_succ) ((fun v6 : 0 < v0 <-> S 0 < S v0 => iff_flip_impl_subrelation (S 0 < S v0) (0 < v0) (symmetry v6)) (succ_lt_mono 0 v0) v1))) in (fun v6 : S v0 == 2 ^ v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 (S v0)) (log2 (2 ^ v3)) (log2_wd (S v0) (2 ^ v3) v6) (S (log2 v0)) (S (log2 v0)) (eq_proper_proxy (S (log2 v0)))) v4 ((fun v6 : log2 (2 ^ v3) == v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 (2 ^ v3)) v3 v6 (S (log2 v0)) (S (log2 v0)) (eq_proper_proxy (S (log2 v0)))) (log2_pow2 v3 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v8 : v3 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v5 v8)) : ~ v3 < 0)) (@lt_0_1) (@lt_1_2))) (let v6 : default_relation v0 (P (2 ^ v3)) := succ_inj v0 (P (2 ^ v3)) ((fun v6 : S v0 == 2 ^ v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S v0) (2 ^ v3) v6 (S (P (2 ^ v3))) (S (P (2 ^ v3))) (eq_proper_proxy (S (P (2 ^ v3))))) v4 (symmetry (lt_succ_pred 0 (2 ^ v3) ((fun v6 : S v0 == 2 ^ v3 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (2 ^ v3) (S v0) (symmetry v6)) v4 ((fun v6 : 0 < S v0 <-> 0 <= v0 => iff_flip_impl_subrelation (0 < S v0) (0 <= v0) v6) (lt_succ_r 0 v0) (Private_OrderTac.Tac.not_gt_le ((fun v6 : v0 < 0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v1 v6)) : ~ v0 < 0))))))) : default_relation v0 (P (2 ^ v3)) in ((fun v7 : v0 == P (2 ^ v3) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (S (log2 v0)) (S (log2 (P (2 ^ v3)))) (succ_wd (log2 v0) (log2 (P (2 ^ v3))) (log2_wd v0 (P (2 ^ v3)) v7)) ((fun v8 : log2 (P (2 ^ v3)) == P v3 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (S (log2 (P (2 ^ v3)))) (S (P v3)) (succ_wd (log2 (P (2 ^ v3))) (P v3) v8)) (log2_pred_pow2 v3 v5) (symmetry (lt_succ_pred 0 v3 v5)))) : forall v7 : default_relation v0 (P (2 ^ v3)), v3 == S (log2 v0)) v6))) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_succ_double	100	0.827433	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => (fun v2 : 2 * v0 + 1 == S (2 * v0) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 (2 * v0 + 1)) (log2 (S (2 * v0))) (log2_wd (2 * v0 + 1) (S (2 * v0)) v2) (S (log2 v0)) (S (log2 v0)) (eq_proper_proxy (S (log2 v0)))) (add_1_r (2 * v0)) (let v2 : log2 (S (2 * v0)) == S (log2 (2 * v0)) \/ log2 (S (2 * v0)) == log2 (2 * v0) := log2_succ_or (2 * v0) in match v2 as v3 in (_ \/ _) return (log2 (S (2 * v0)) == S (log2 v0)) with | or_introl v3 => (fun v3 : log2 (S (2 * v0)) == S (log2 (2 * v0)) => False_ind (log2 (S (2 * v0)) == S (log2 v0)) (let v4 : exists v4 : @t, S (2 * v0) == 2 ^ v4 := log2_eq_succ_is_pow2 (2 * v0) v3 in match v4 as v5 in (ex _) return (@False) with | ex_intro _ v5 v6 => (fun (v5 : @t) (v6 : S (2 * v0) == 2 ^ v5) => let v7 : v5 < 0 \/ v5 == 0 \/ 0 < v5 := lt_trichotomy v5 0 in match v7 as v8 in (_ \/ _) return (@False) with | or_introl v8 => (fun v8 : v5 < 0 => let v9 : 0 < 2 * v0 := mul_pos_pos 2 v0 ((fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v11 : 2 <= 0 => (fun v12 : 0 < 2 => (fun v13 : v5 < 2 => (fun v14 : v5 < 1 => (fun v15 : v5 < v0 => (fun v16 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v11 v12)) (Private_OrderTac.Tac.lt_trans v8 v1)) (Private_OrderTac.Tac.lt_trans v8 v9)) (Private_OrderTac.Tac.lt_trans v8 v12)) (Private_OrderTac.Tac.lt_trans v9 v10)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) v1 in let v10 : forall (v10 v11 : @t) (v12 : v10 < v11), S v10 < S v11 := fun v10 v11 : @t => match succ_lt_mono v10 v11 as v12 in (_ /\ _) return (forall v13 : v10 < v11, S v10 < S v11) with | conj v12 v13 => (fun (v12 : forall v12 : v10 < v11, S v10 < S v11) (v13 : forall v13 : S v10 < S v11, v10 < v11) => v12) v12 v13 end in let v11 : S 0 < S (2 * v0) := v10 0 (2 * v0) v9 in (fun (v12 : 0 < 1) (v13 : 1 < 2) => False_ind (@False) ((fun v14 : 1 < 0 => (fun v15 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.lt_trans v12 v14)) (Private_OrderTac.Tac.lt_eq ((fun v14 : 1 == S 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 0) 1 (symmetry v14) (S (2 * v0)) (S (2 * v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (2 * v0)))) (@one_succ) v11) ((fun v14 : 2 ^ v5 == 0 => trans_co_impl_morphism Equivalence_Transitive (2 ^ v5) 0 v14) (pow_neg_r 2 v5 v8) v6)))) (@lt_0_1) (@lt_1_2)) v8 | or_intror v8 => (fun v8 : v5 == 0 \/ 0 < v5 => match v8 as v9 in (_ \/ _) return (@False) with | or_introl v9 => (fun v9 : v5 == 0 => let v10 : 0 < 2 * v0 := mul_pos_pos 2 v0 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : 2 <= 0 => (fun v13 : 0 < 2 => (fun v14 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) v1 in let v11 : forall (v11 v12 : @t) (v13 : v11 < v12), S v11 < S v12 := fun v11 v12 : @t => match succ_lt_mono v11 v12 as v13 in (_ /\ _) return (forall v14 : v11 < v12, S v11 < S v12) with | conj v13 v14 => (fun (v13 : forall v13 : v11 < v12, S v11 < S v12) (v14 : forall v14 : S v11 < S v12, v11 < v12) => v13) v13 v14 end in let v12 : S 0 < S (2 * v0) := v11 0 (2 * v0) v10 in (fun (v13 : 0 < 1) (v14 : 1 < 2) => False_ind (@False) ((fun v15 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.lt_eq ((fun v15 : 1 == S 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 0) 1 (symmetry v15) (S (2 * v0)) (S (2 * v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (2 * v0)))) (@one_succ) v12) ((fun v15 : 2 ^ 0 == 1 => trans_co_impl_morphism Equivalence_Transitive (2 ^ 0) 1 v15) (pow_0_r 2) ((fun v15 : v5 == 0 => trans_co_impl_morphism Equivalence_Transitive (2 ^ v5) (2 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) v5 0 v15)) v9 v6))))) (@lt_0_1) (@lt_1_2)) v9 | or_intror v9 => (fun v9 : 0 < v5 => let v10 : S (P v5) == v5 := lt_succ_pred 0 v5 v9 in let v11 : v0 < 2 ^ P v5 \/ 2 ^ P v5 <= v0 := lt_ge_cases v0 (2 ^ P v5) in match v11 as v12 in (_ \/ _) return (@False) with | or_introl v12 => (fun v12 : v0 < 2 ^ P v5 => (fun v13 : 1 + 2 * v0 == S (2 * v0) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (1 + 2 * v0 < 2 * 2 ^ P v5) (S (2 * v0) < 2 * 2 ^ P v5) (lt_wd (1 + 2 * v0) (S (2 * v0)) v13 (2 * 2 ^ P v5) (2 * 2 ^ P v5) (reflexive_proper_proxy Equivalence_Reflexive (2 * 2 ^ P v5))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (add_1_l (2 * v0)) (fun v13 : S (2 * v0) < 2 * 2 ^ P v5 => False_ind (@False) ((fun v14 : 2 * 2 ^ P v5 < 2 * 2 ^ P v5 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v14 : 2 ^ S (P v5) == 2 * 2 ^ P v5 => trans_co_impl_morphism Equivalence_Transitive (2 ^ S (P v5)) (2 * 2 ^ P v5) v14) (pow_succ_r 2 (P v5) ((fun v14 : 0 < S (P v5) <-> 0 <= P v5 => iff_flip_impl_subrelation (0 <= P v5) (0 < S (P v5)) (symmetry v14)) (lt_succ_r 0 (P v5)) ((fun v14 : S (P v5) == v5 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (S (P v5)) v5 v14) v10 v9))) ((fun v14 : S (P v5) == v5 => trans_co_impl_morphism Equivalence_Transitive (2 ^ v5) (2 ^ S (P v5)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) v5 (S (P v5)) (symmetry v14))) v10 v6))) v13))) (mul_2_mono_l v0 (2 ^ P v5) v12)) v12 | or_intror v12 => (fun v12 : 2 ^ P v5 <= v0 => let v13 : forall (v13 v14 : @t) (v15 : S v13 <= v14), v13 < v14 := fun v13 v14 : @t => match le_succ_l v13 v14 as v15 in (_ /\ _) return (forall v16 : S v13 <= v14, v13 < v14) with | conj v15 v16 => (fun (v15 : forall v15 : S v13 <= v14, v13 < v14) (v16 : forall v16 : v13 < v14, S v13 <= v14) => v15) v15 v16 end in let v14 : 2 * v0 < 2 * v0 := v13 (2 * v0) (2 * v0) ((fun v14 : S (2 * v0) == 2 * 2 ^ P v5 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (2 * 2 ^ P v5) (S (2 * v0)) (symmetry v14) (2 * v0) (2 * v0) (reflexive_proper_proxy Equivalence_Reflexive (2 * v0))) ((fun v14 : 2 ^ S (P v5) == 2 * 2 ^ P v5 => trans_co_impl_morphism Equivalence_Transitive (2 ^ S (P v5)) (2 * 2 ^ P v5) v14) (pow_succ_r 2 (P v5) ((fun v14 : 0 < S (P v5) <-> 0 <= P v5 => iff_flip_impl_subrelation (0 <= P v5) (0 < S (P v5)) (symmetry v14)) (lt_succ_r 0 (P v5)) ((fun v14 : S (P v5) == v5 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (S (P v5)) v5 v14) v10 v9))) ((fun v14 : S (P v5) == v5 => trans_co_impl_morphism Equivalence_Transitive (2 ^ v5) (2 ^ S (P v5)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) v5 (S (P v5)) (symmetry v14))) v10 v6)) ((fun v14 : 2 ^ P v5 <= v0 <-> 2 * 2 ^ P v5 <= 2 * v0 => iff_impl_subrelation (2 ^ P v5 <= v0) (2 * 2 ^ P v5 <= 2 * v0) v14) (mul_le_mono_pos_l (2 ^ P v5) v0 2 ((fun (v14 : 0 < 1) (v15 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v16 : 2 <= 0 => (fun v17 : 0 < 2 => (fun v18 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v16 v17)) (Private_OrderTac.Tac.lt_trans v14 v15)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2))) v12)) in False_ind (@False) (Private_OrderTac.Tac.lt_irrefl v14)) v12 end) v9 end) v8 end) v5 v6 end)) v3 | or_intror v3 => (fun v3 : log2 (S (2 * v0)) == log2 (2 * v0) => (fun v4 : log2 (S (2 * v0)) == log2 (2 * v0) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 (S (2 * v0))) (log2 (2 * v0)) v4 (S (log2 v0)) (S (log2 v0)) (eq_proper_proxy (S (log2 v0)))) v3 ((fun v4 : log2 (2 * v0) == S (log2 v0) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 (2 * v0)) (S (log2 v0)) v4 (S (log2 v0)) (S (log2 v0)) (eq_proper_proxy (S (log2 v0)))) (log2_double v0 v1) (reflexivity (S (log2 v0))))) v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.log2_add_le	100	1.346567	1	1
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2Prop.add_log2_lt	100	1.318498	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 < v1) => (fun v4 : 2 == S 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 v1)) (2 * log2 (v0 + v1)) (S 1 * log2 (v0 + v1)) (mul_wd 2 (S 1) v4 (log2 (v0 + v1)) (log2 (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 + v1))))) (@two_succ) ((fun v4 : 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 v1)) (S 1 * log2 (v0 + v1)) (S (S 0) * log2 (v0 + v1)) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v4) (log2 (v0 + v1)) (log2 (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 + v1))))) (@one_succ) ((fun v4 : S (S 0) * log2 (v0 + v1) == S 0 * log2 (v0 + v1) + log2 (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 v1)) (S (S 0) * log2 (v0 + v1)) (S 0 * log2 (v0 + v1) + log2 (v0 + v1)) v4) (mul_succ_l (S 0) (log2 (v0 + v1))) ((fun v4 : S 0 * log2 (v0 + v1) == 0 * log2 (v0 + v1) + log2 (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 v1)) (S 0 * log2 (v0 + v1) + log2 (v0 + v1)) (0 * log2 (v0 + v1) + log2 (v0 + v1) + log2 (v0 + v1)) (add_wd (S 0 * log2 (v0 + v1)) (0 * log2 (v0 + v1) + log2 (v0 + v1)) v4 (log2 (v0 + v1)) (log2 (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 + v1))))) (mul_succ_l 0 (log2 (v0 + v1))) ((fun v4 : 0 * log2 (v0 + v1) == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 v1)) (0 * log2 (v0 + v1) + log2 (v0 + v1) + log2 (v0 + v1)) (0 + log2 (v0 + v1) + log2 (v0 + v1)) (add_wd (0 * log2 (v0 + v1) + log2 (v0 + v1)) (0 + log2 (v0 + v1)) (add_wd (0 * log2 (v0 + v1)) 0 v4 (log2 (v0 + v1)) (log2 (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 + v1)))) (log2 (v0 + v1)) (log2 (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 + v1))))) (mul_0_l (log2 (v0 + v1))) ((fun v4 : 0 + log2 (v0 + v1) == log2 (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 v1)) (0 + log2 (v0 + v1) + log2 (v0 + v1)) (log2 (v0 + v1) + log2 (v0 + v1)) (add_wd (0 + log2 (v0 + v1)) (log2 (v0 + v1)) v4 (log2 (v0 + v1)) (log2 (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 + v1))))) (add_0_l (log2 (v0 + v1))) (let v4 : log2 v0 <= log2 (v0 + v1) := log2_le_mono v0 (v0 + v1) ((fun v4 : v0 + 0 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v0 (v0 + 0) (symmetry v4) (v0 + v1) (v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1))) (add_0_r v0) (add_le_mono v0 v0 0 v1 (Private_OrderTac.Tac.le_refl v0) (Private_OrderTac.Tac.not_gt_le ((fun v4 : v1 < 0 => (fun v5 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v5) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ v1 < 0)))) in let v5 : log2 v1 <= log2 (v0 + v1) := log2_le_mono v1 (v0 + v1) ((fun v5 : 0 + v1 == v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v1 (0 + v1) (symmetry v5) (v0 + v1) (v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1))) (add_0_l v1) (add_le_mono 0 v0 v1 v1 (Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v2 v5)) : ~ v0 < 0)) (Private_OrderTac.Tac.le_refl v1))) in match (fun v6 : log2 v0 <= log2 (v0 + v1) <-> log2 v0 < log2 (v0 + v1) \/ log2 v0 == log2 (v0 + v1) => iff_impl_subrelation (log2 v0 <= log2 (v0 + v1)) (log2 v0 < log2 (v0 + v1) \/ log2 v0 == log2 (v0 + v1)) v6) (lt_eq_cases (log2 v0) (log2 (v0 + v1))) v4 as v6 in (_ \/ _) return (log2 v0 + log2 v1 < log2 (v0 + v1) + log2 (v0 + v1)) with | or_introl v6 => (fun v6 : log2 v0 < log2 (v0 + v1) => lt_le_trans (log2 v0 + log2 v1) (log2 (v0 + v1) + log2 v1) (log2 (v0 + v1) + log2 (v0 + v1)) (let v7 : forall (v7 v8 v9 : @t) (v10 : v7 < v8), v7 + v9 < v8 + v9 := fun v7 v8 v9 : @t => match add_lt_mono_r v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 < v8, v7 + v9 < v8 + v9) with | conj v10 v11 => (fun (v10 : forall v10 : v7 < v8, v7 + v9 < v8 + v9) (v11 : forall v11 : v7 + v9 < v8 + v9, v7 < v8) => v10) v10 v11 end in v7 (log2 v0) (log2 (v0 + v1)) (log2 v1) v6) (let v7 : forall (v7 v8 v9 : @t) (v10 : v7 <= v8), v9 + v7 <= v9 + v8 := fun v7 v8 v9 : @t => match add_le_mono_l v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 <= v8, v9 + v7 <= v9 + v8) with | conj v10 v11 => (fun (v10 : forall v10 : v7 <= v8, v9 + v7 <= v9 + v8) (v11 : forall v11 : v9 + v7 <= v9 + v8, v7 <= v8) => v10) v10 v11 end in v7 (log2 v1) (log2 (v0 + v1)) (log2 (v0 + v1)) v5)) v6 | or_intror v6 => (fun v6 : log2 v0 == log2 (v0 + v1) => (fun v7 : log2 v0 == log2 (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0 + log2 v1)) (log2 (v0 + v1) + log2 (v0 + v1)) (log2 v0 + log2 (v0 + v1)) (add_wd (log2 (v0 + v1)) (log2 v0) (symmetry v7) (log2 (v0 + v1)) (log2 (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2 (v0 + v1))))) v6 (let v7 : forall (v7 v8 v9 : @t) (v10 : v7 < v8), v9 + v7 < v9 + v8 := fun v7 v8 v9 : @t => match add_lt_mono_l v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 < v8, v9 + v7 < v9 + v8) with | conj v10 v11 => (fun (v10 : forall v10 : v7 < v8, v9 + v7 < v9 + v8) (v11 : forall v11 : v9 + v7 < v9 + v8, v7 < v8) => v10) v10 v11 end in v7 (log2 v1) (log2 (v0 + v1)) (log2 v0) match (fun v8 : log2 v1 <= log2 (v0 + v1) <-> log2 v1 < log2 (v0 + v1) \/ log2 v1 == log2 (v0 + v1) => iff_impl_subrelation (log2 v1 <= log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1) \/ log2 v1 == log2 (v0 + v1)) v8) (lt_eq_cases (log2 v1) (log2 (v0 + v1))) v5 as v8 in (_ \/ _) return (log2 v1 < log2 (v0 + v1)) with | or_introl v8 => (fun v8 : log2 v1 < log2 (v0 + v1) => v8) v8 | or_intror v8 => (fun v8 : log2 v1 == log2 (v0 + v1) => let v9 : log2 (v0 + v1) == log2 v0 := symmetry v6 in let v10 : v0 + v1 < 2 * v0 := log2_same (v0 + v1) v0 (add_pos_pos v0 v1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v0 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : v0 < v1 => (fun v17 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v12 v2)) (Private_OrderTac.Tac.le_lt_trans v12 v3)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v1 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v1 < 2 => (fun v15 : v1 < 1 => (fun v16 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v12 v3)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v0 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : v0 < v1 => (fun v17 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v12 v2)) (Private_OrderTac.Tac.le_lt_trans v12 v3)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) v9 in let v11 : log2 (v0 + v1) == log2 v1 := symmetry v8 in let v12 : v0 + v1 < 2 * v1 := log2_same (v0 + v1) v1 (add_pos_pos v0 v1 ((fun (v12 : 0 < 1) (v13 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v14 : v0 <= 0 => (fun v15 : 0 < 2 => (fun v16 : v0 < 2 => (fun v17 : v0 < 1 => (fun v18 : v0 < v1 => (fun v19 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v19) (Private_OrderTac.Tac.le_lt_trans v14 v2)) (Private_OrderTac.Tac.le_lt_trans v14 v3)) (Private_OrderTac.Tac.le_lt_trans v14 v12)) (Private_OrderTac.Tac.le_lt_trans v14 v15)) (Private_OrderTac.Tac.lt_trans v12 v13)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v12 : 0 < 1) (v13 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v14 : v1 <= 0 => (fun v15 : 0 < 2 => (fun v16 : v1 < 2 => (fun v17 : v1 < 1 => (fun v18 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v14 v3)) (Private_OrderTac.Tac.le_lt_trans v14 v12)) (Private_OrderTac.Tac.le_lt_trans v14 v15)) (Private_OrderTac.Tac.lt_trans v12 v13)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun (v12 : 0 < 1) (v13 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v14 : v1 <= 0 => (fun v15 : 0 < 2 => (fun v16 : v1 < 2 => (fun v17 : v1 < 1 => (fun v18 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v14 v3)) (Private_OrderTac.Tac.le_lt_trans v14 v12)) (Private_OrderTac.Tac.le_lt_trans v14 v15)) (Private_OrderTac.Tac.lt_trans v12 v13)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2)) v11 in (fun v13 : 2 == S 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < 2 * v0) (v0 + v1 < S 1 * v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (2 * v0) (S 1 * v0) (mul_wd 2 (S 1) v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < 2 * v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < S 1 * v1, log2 v1 < log2 (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < 2 * v1) (v0 + v1 < S 1 * v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (2 * v1) (S 1 * v1) (mul_wd 2 (S 1) v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2 v1 < log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2 v1 < log2 (v0 + v1))))) (@two_succ) ((fun v13 : 1 == S 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < S 1 * v0) (v0 + v1 < S (S 0) * v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 1 * v0) (S (S 0) * v0) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v13) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < S 1 * v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < S 1 * v1) (v0 + v1 < S (S 0) * v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 1 * v1) (S (S 0) * v1) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v13) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2 v1 < log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2 v1 < log2 (v0 + v1))))) (@one_succ) ((fun v13 : S (S 0) * v0 == S 0 * v0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < S (S 0) * v0) (v0 + v1 < S 0 * v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S (S 0) * v0) (S 0 * v0 + v0) v13) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)))) (mul_succ_l (S 0) v0) ((fun v13 : S 0 * v0 == 0 * v0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < S 0 * v0 + v0) (v0 + v1 < 0 * v0 + v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 0 * v0 + v0) (0 * v0 + v0 + v0) (add_wd (S 0 * v0) (0 * v0 + v0) v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)))) (mul_succ_l 0 v0) ((fun v13 : S (S 0) * v1 == S 0 * v1 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < 0 * v0 + v0 + v0)) (forall v14 : v0 + v1 < S (S 0) * v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < S 0 * v1 + v1, log2 v1 < log2 (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < S (S 0) * v1) (v0 + v1 < S 0 * v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S (S 0) * v1) (S 0 * v1 + v1) v13) (log2 v1 < log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2 v1 < log2 (v0 + v1))))) (mul_succ_l (S 0) v1) ((fun v13 : S 0 * v1 == 0 * v1 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < 0 * v0 + v0 + v0)) (forall v14 : v0 + v1 < S 0 * v1 + v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2 v1 < log2 (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < S 0 * v1 + v1) (v0 + v1 < 0 * v1 + v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 0 * v1 + v1) (0 * v1 + v1 + v1) (add_wd (S 0 * v1) (0 * v1 + v1) v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2 v1 < log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2 v1 < log2 (v0 + v1))))) (mul_succ_l 0 v1) ((fun v13 : 0 * v0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < 0 * v0 + v0 + v0) (v0 + v1 < 0 + v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 * v0 + v0 + v0) (0 + v0 + v0) (add_wd (0 * v0 + v0) (0 + v0) (add_wd (0 * v0) 0 v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2 v1 < log2 (v0 + v1)))) (mul_0_l v0) ((fun v13 : 0 * v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < 0 + v0 + v0)) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < 0 + v1 + v1, log2 v1 < log2 (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < 0 * v1 + v1 + v1) (v0 + v1 < 0 + v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 * v1 + v1 + v1) (0 + v1 + v1) (add_wd (0 * v1 + v1) (0 + v1) (add_wd (0 * v1) 0 v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2 v1 < log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2 v1 < log2 (v0 + v1))))) (mul_0_l v1) ((fun v13 : 0 + v0 == v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < 0 + v0 + v0) (v0 + v1 < v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 + v0 + v0) (v0 + v0) (add_wd (0 + v0) v0 v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < 0 + v1 + v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < 0 + v1 + v1, log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < 0 + v1 + v1, log2 v1 < log2 (v0 + v1)))) (add_0_l v0) ((fun v13 : 0 + v1 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < v0 + v0)) (forall v14 : v0 + v1 < 0 + v1 + v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < v1 + v1, log2 v1 < log2 (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < 0 + v1 + v1) (v0 + v1 < v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 + v1 + v1) (v1 + v1) (add_wd (0 + v1) v1 v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2 v1 < log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2 v1 < log2 (v0 + v1))))) (add_0_l v1) ((fun v13 : v1 < v0 <-> v0 + v1 < v0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < v0 + v0) (v1 < v0) (symmetry v13) (forall v14 : v0 + v1 < v1 + v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 + v1 < v1 + v1, log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < v1 + v1, log2 v1 < log2 (v0 + v1)))) (add_lt_mono_l v1 v0 v0) ((fun v13 : v0 < v1 <-> v0 + v1 < v1 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0)) (forall v14 : v0 + v1 < v1 + v1, log2 v1 < log2 (v0 + v1)) (forall v14 : v0 < v1, log2 v1 < log2 (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < v1 + v1) (v0 < v1) (symmetry v13) (log2 v1 < log2 (v0 + v1)) (log2 v1 < log2 (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2 v1 < log2 (v0 + v1))))) (add_lt_mono_r v0 v1 v1) (fun (v13 : v1 < v0) (v14 : v0 < v1) => Private_OrderTac.Tac.not_ge_lt ((fun v15 : log2 (v0 + v1) <= log2 v1 => (fun v16 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.lt_trans v13 v14)) : ~ log2 (v0 + v1) <= log2 v1))))))))))))) v10 v12) v8 end)) v6 end)))))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_eqn0	100	0.054605	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : v0 <= 1) => match compare_spec 1 v0 as v3 in (CompareSpec _ _ _ v2) return (match v2 as v4 in comparison return (@t) with | Lt => S (log2 (P v0)) | _ => 0 end == 0) with | CompEq _ _ v2 => (fun v2 : 1 == v0 => Private_OrderTac.Tac.eq_refl 0) v2 | CompLt _ _ v2 => (fun v2 : 1 < v0 => Private_OrderTac.Tac.not_neq_eq ((fun v3 : S (log2 (P v0)) ~= 0 => (fun v4 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v4) (Private_OrderTac.Tac.le_lt_trans v1 v2)) : ~ S (log2 (P v0)) ~= 0)) v2 | CompGt _ _ v2 => (fun v2 : v0 < 1 => Private_OrderTac.Tac.eq_refl 0) v2 end : log2_up v0 == 0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_eqn	100	0.068246	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 1 < v0) => match compare_spec 1 v0 as v3 in (CompareSpec _ _ _ v2) return (match v2 as v4 in comparison return (@t) with | Lt => S (log2 (P v0)) | _ => 0 end == S (log2 (P v0))) with | CompEq _ _ v2 => (fun v2 : 1 == v0 => Private_OrderTac.Tac.not_neq_eq ((fun v3 : 0 ~= S (log2 (P v0)) => (fun v4 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v4) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v2) v1)) : ~ 0 ~= S (log2 (P v0)))) v2 | CompLt _ _ v2 => (fun v2 : 1 < v0 => Private_OrderTac.Tac.eq_refl (S (log2 (P v0)))) v2 | CompGt _ _ v2 => (fun v2 : v0 < 1 => Private_OrderTac.Tac.not_neq_eq ((fun v3 : 0 ~= S (log2 (P v0)) => (fun v4 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v4) (Private_OrderTac.Tac.lt_trans v1 v2)) : ~ 0 ~= S (log2 (P v0)))) v2 end : log2_up v0 == S (log2 (P v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_spec	100	0.333536	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 1 < v0) => (fun v2 : log2_up v0 == S (log2 (P v0)) => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ P (log2_up v0) < v0) (2 ^ P (S (log2 (P v0))) < v0) (lt_wd (2 ^ P (log2_up v0)) (2 ^ P (S (log2 (P v0)))) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (P (log2_up v0)) (P (S (log2 (P v0)))) (pred_wd (log2_up v0) (S (log2 (P v0))) v2)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (v0 <= 2 ^ log2_up v0) (v0 <= 2 ^ S (log2 (P v0))) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ log2_up v0) (2 ^ S (log2 (P v0))) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (log2_up v0) (S (log2 (P v0))) v2))) (log2_up_eqn v0 v1) ((fun v2 : P (S (log2 (P v0))) == log2 (P v0) => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ P (S (log2 (P v0))) < v0) (2 ^ log2 (P v0) < v0) (lt_wd (2 ^ P (S (log2 (P v0)))) (2 ^ log2 (P v0)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (P (S (log2 (P v0)))) (log2 (P v0)) v2) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (v0 <= 2 ^ S (log2 (P v0))) (v0 <= 2 ^ S (log2 (P v0))) (reflexive_proper_proxy (@iff_Reflexive) (v0 <= 2 ^ S (log2 (P v0))))) (pred_succ (log2 (P v0))) ((fun v2 : S (P v0) == v0 => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ log2 (P v0) < v0) (2 ^ log2 (P v0) < S (P v0)) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ log2 (P v0))) v0 (S (P v0)) (symmetry v2)) (v0 <= 2 ^ S (log2 (P v0))) (S (P v0) <= 2 ^ S (log2 (P v0))) (le_wd v0 (S (P v0)) (symmetry v2) (2 ^ S (log2 (P v0))) (2 ^ S (log2 (P v0))) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ S (log2 (P v0)))))) (lt_succ_pred 1 v0 v1) ((fun v2 : 2 ^ log2 (P v0) < S (P v0) <-> 2 ^ log2 (P v0) <= P v0 => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ log2 (P v0) < S (P v0)) (2 ^ log2 (P v0) <= P v0) v2 (S (P v0) <= 2 ^ S (log2 (P v0))) (S (P v0) <= 2 ^ S (log2 (P v0))) (reflexive_proper_proxy (@iff_Reflexive) (S (P v0) <= 2 ^ S (log2 (P v0))))) (lt_succ_r (2 ^ log2 (P v0)) (P v0)) ((fun v2 : S (P v0) <= 2 ^ S (log2 (P v0)) <-> P v0 < 2 ^ S (log2 (P v0)) => Reflexive_partial_app_morphism (subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (2 ^ log2 (P v0) <= P v0)) (S (P v0) <= 2 ^ S (log2 (P v0))) (P v0 < 2 ^ S (log2 (P v0))) v2) (le_succ_l (P v0) (2 ^ S (log2 (P v0)))) (log2_spec (P v0) (let v2 : forall (v2 v3 : @t) (v4 : S v2 < S v3), v2 < v3 := fun v2 v3 : @t => match succ_lt_mono v2 v3 as v4 in (_ /\ _) return (forall v5 : S v2 < S v3, v2 < v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 < v3, S v2 < S v3) (v5 : forall v5 : S v2 < S v3, v2 < v3) => v5) v4 v5 end in v2 0 (P v0) ((fun v3 : S (P v0) == v0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S 0)) (S (P v0)) v0 v3) (lt_succ_pred 1 v0 v1) ((fun v3 : 1 == S 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (S 0) 1 (symmetry v3) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (@one_succ) v1)))))))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_nonpos	100	0.033041	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : v0 <= 0) => log2_up_eqn0 v0 ((fun (v2 : 0 < 1) (v3 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v4 : 1 < v0 => (fun v5 : 0 < v0 => (fun v6 : 0 < 2 => (fun v7 : v0 < 2 => (fun v8 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v1 v5)) (Private_OrderTac.Tac.le_lt_trans v1 v6)) (Private_OrderTac.Tac.lt_trans v2 v3)) (Private_OrderTac.Tac.lt_trans v2 v4)) : ~ 1 < v0)) (@lt_0_1) (@lt_1_2)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_wd	100	0.285918	1	1	0	synth with cache (only 1: refine (let v0 : Proper (@eq ==> @eq ==> Logic.eq) (@compare) := (((fun (v0 v1 : @t) (v2 : v0 == v1) (v3 v4 : @t) (v5 : v3 == v4) => match compare_spec v0 v3 as v7 in (CompareSpec _ _ _ v6) return (v6 = compare v1 v4) with | CompEq _ _ v6 => match compare_spec v1 v4 as v7 in (CompareSpec _ _ _ v6) return (forall v8 : v0 == v3, @Eq = v6) with | CompEq _ _ v6 => (fun (v6 : v1 == v4) (v7 : v0 == v3) => Logic.eq_refl) v6 | CompLt _ _ v6 => (fun (v6 : v1 < v4) (v7 : v0 == v3) => False_ind (@Eq = @Lt) ((fun v8 : v3 == v1 => (fun v9 : v1 == v4 => (fun v10 : v4 < v4 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v9) v6)) (Private_OrderTac.Tac.eq_trans (Private_OrderTac.Tac.eq_sym v8) v5)) (Private_OrderTac.Tac.eq_trans (Private_OrderTac.Tac.eq_sym v7) v2))) v6 | CompGt _ _ v6 => (fun (v6 : v4 < v1) (v7 : v0 == v3) => False_ind (@Eq = @Gt) ((fun v8 : v3 == v1 => (fun v9 : v1 == v4 => (fun v10 : v4 < v4 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.lt_eq v6 v9)) (Private_OrderTac.Tac.eq_trans (Private_OrderTac.Tac.eq_sym v8) v5)) (Private_OrderTac.Tac.eq_trans (Private_OrderTac.Tac.eq_sym v7) v2))) v6 end v6 | CompLt _ _ v6 => match compare_spec v1 v4 as v7 in (CompareSpec _ _ _ v6) return (forall v8 : v0 < v3, @Lt = v6) with | CompEq _ _ v6 => (fun (v6 : v1 == v4) (v7 : v0 < v3) => False_ind (@Lt = @Eq) ((fun v8 : v0 == v4 => (fun v9 : v4 < v3 => (fun v10 : v4 < v4 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.lt_eq v9 v5)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v8) v7)) (Private_OrderTac.Tac.eq_trans v2 v6))) v6 | CompLt _ _ v6 => (fun (v6 : v1 < v4) (v7 : v0 < v3) => Logic.eq_refl) v6 | CompGt _ _ v6 => (fun (v6 : v4 < v1) (v7 : v0 < v3) => False_ind (@Lt = @Gt) ((fun v8 : v0 < v4 => (fun v9 : v1 < v4 => (fun v10 : v4 < v4 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.lt_trans v6 v9)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v2) v8)) (Private_OrderTac.Tac.lt_eq v7 v5))) v6 end v6 | CompGt _ _ v6 => match compare_spec v1 v4 as v7 in (CompareSpec _ _ _ v6) return (forall v8 : v3 < v0, @Gt = v6) with | CompEq _ _ v6 => (fun (v6 : v1 == v4) (v7 : v3 < v0) => False_ind (@Gt = @Eq) ((fun v8 : v0 == v4 => (fun v9 : v3 < v4 => (fun v10 : v4 < v4 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v5) v9)) (Private_OrderTac.Tac.lt_eq v7 v8)) (Private_OrderTac.Tac.eq_trans v2 v6))) v6 | CompLt _ _ v6 => (fun (v6 : v1 < v4) (v7 : v3 < v0) => False_ind (@Gt = @Lt) ((fun v8 : v4 < v0 => (fun v9 : v4 < v1 => (fun v10 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.lt_trans v6 v9)) (Private_OrderTac.Tac.lt_eq v8 v2)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v5) v7))) v6 | CompGt _ _ v6 => (fun (v6 : v4 < v1) (v7 : v3 < v0) => Logic.eq_refl) v6 end v6 end) : forall (v0 v1 : @t) (v2 : v0 == v1), (@eq ==> Logic.eq)%signature (compare v0) (compare v1)) : (@eq ==> @eq ==> Logic.eq)%signature (@compare) (@compare)) : Proper (@eq ==> @eq ==> Logic.eq) (@compare) in (fun (v1 v2 : @t) (v3 : v1 == v2) => (fun v4 : v1 == v2 => reflexive_proper (@eq) match compare 1 v1 as v5 in comparison return (@t) with | Lt => S (log2 (P v1)) | _ => 0 end match compare 1 v2 as v5 in comparison return (@t) with | Lt => S (log2 (P v1)) | _ => 0 end (f_equal (fun v5 : @comparison => match v5 as v6 in comparison return (@t) with | Lt => S (log2 (P v1)) | _ => 0 end) (Reflexive_partial_app_morphism v0 (reflexive_proper_proxy Equivalence_Reflexive 1) v1 v2 v4)) match compare 1 v2 as v5 in comparison return (@t) with | Lt => S (log2 (P v2)) | _ => 0 end match compare 1 v2 as v5 in comparison return (@t) with | Lt => S (log2 (P v2)) | _ => 0 end (eq_proper_proxy match compare 1 v2 as v5 in comparison return (@t) with | Lt => S (log2 (P v2)) | _ => 0 end)) v3 match compare 1 v2 as v4 in comparison return (match v4 as v5 in comparison return (@t) with | Lt => S (log2 (P v1)) | _ => 0 end == match v4 as v5 in comparison return (@t) with | Lt => S (log2 (P v2)) | _ => 0 end) with | Lt => (fun v4 : v1 == v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S (log2 (P v1))) (S (log2 (P v2))) (succ_wd (log2 (P v1)) (log2 (P v2)) (log2_wd (P v1) (P v2) (pred_wd v1 v2 v4))) (S (log2 (P v2))) (S (log2 (P v2))) (eq_proper_proxy (S (log2 (P v2))))) v3 (reflexivity (S (log2 (P v2)))) | _ => reflexivity 0 end : log2_up v1 == log2_up v2) : Proper (@eq ==> @eq) (@log2_up))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_nonneg	100	0.042682	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match compare_spec 1 v0 as v2 in (CompareSpec _ _ _ v1) return (0 <= match v1 as v3 in comparison return (@t) with | Lt => S (log2 (P v0)) | _ => 0 end) with | CompEq _ _ v1 => (fun v1 : 1 == v0 => Private_OrderTac.Tac.le_refl 0) v1 | CompLt _ _ v1 => (fun v1 : 1 < v0 => le_le_succ_r 0 (log2 (P v0)) (log2_nonneg (P v0))) v1 | CompGt _ _ v1 => (fun v1 : v0 < 1 => Private_OrderTac.Tac.le_refl 0) v1 end : 0 <= log2_up v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_unique	100	0.446571	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v1) (v3 : 2 ^ P v1 < v0 <= 2 ^ v1) => match v3 as v4 in (_ /\ _) return (log2_up v0 == v1) with | conj v4 v5 => (fun (v4 : 2 ^ P v1 < v0) (v5 : v0 <= 2 ^ v1) => let v6 : 1 < v0 := le_lt_trans 1 (2 ^ P v1) v0 ((fun v6 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (S 0) v6 (2 ^ P v1) (2 ^ P v1) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ P v1))) (@one_succ) (let v6 : forall (v6 v7 : @t) (v8 : v6 < v7), S v6 <= v7 := fun v6 v7 : @t => match le_succ_l v6 v7 as v8 in (_ /\ _) return (forall v9 : v6 < v7, S v6 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : S v6 <= v7, v6 < v7) (v9 : forall v9 : v6 < v7, S v6 <= v7) => v9) v8 v9 end in v6 0 (2 ^ P v1) (pow_pos_nonneg 2 (P v1) ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : 2 <= 0 => (fun v10 : 0 < 2 => (fun v11 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v9 v10)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) (let v7 : forall (v7 v8 : @t) (v9 : v7 < S v8), v7 <= v8 := fun v7 v8 : @t => match lt_succ_r v7 v8 as v9 in (_ /\ _) return (forall v10 : v7 < S v8, v7 <= v8) with | conj v9 v10 => (fun (v9 : forall v9 : v7 < S v8, v7 <= v8) (v10 : forall v10 : v7 <= v8, v7 < S v8) => v9) v9 v10 end in v7 0 (P v1) ((fun v8 : S (P v1) == v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (S (P v1)) v1 v8) (lt_succ_pred 0 v1 v2) v2))))) v4 in let v7 : 0 <= log2_up v0 := log2_up_nonneg v0 in let v8 : 2 ^ P (log2_up v0) < v0 <= 2 ^ log2_up v0 := log2_up_spec v0 v6 in match v8 as v9 in (_ /\ _) return (log2_up v0 == v1) with | conj v9 v10 => (fun (v9 : 2 ^ P (log2_up v0) < v0) (v10 : v0 <= 2 ^ log2_up v0) => let v11 : v1 <= log2_up v0 := let v11 : forall (v11 v12 : @t) (v13 : v11 < S v12), v11 <= v12 := fun v11 v12 : @t => match lt_succ_r v11 v12 as v13 in (_ /\ _) return (forall v14 : v11 < S v12, v11 <= v12) with | conj v13 v14 => (fun (v13 : forall v13 : v11 < S v12, v11 <= v12) (v14 : forall v14 : v11 <= v12, v11 < S v12) => v13) v13 v14 end in v11 v1 (log2_up v0) ((fun v12 : S (P v1) == v1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v1 (S (P v1)) (symmetry v12) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (lt_succ_pred 0 v1 v2) ((fun v12 : P v1 < log2_up v0 <-> S (P v1) < S (log2_up v0) => iff_flip_impl_subrelation (S (P v1) < S (log2_up v0)) (P v1 < log2_up v0) (symmetry v12)) (succ_lt_mono (P v1) (log2_up v0)) (let v12 : forall (v12 v13 : @t) (v14 : 1 < 2) (v15 : 0 <= v13) (v16 : 2 ^ v12 < 2 ^ v13), v12 < v13 := fun (v12 v13 : @t) (v14 : 1 < 2) (v15 : 0 <= v13) => match pow_lt_mono_r_iff 2 v12 v13 v14 v15 as v16 in (_ /\ _) return (forall v17 : 2 ^ v12 < 2 ^ v13, v12 < v13) with | conj v16 v17 => (fun (v16 : forall v16 : v12 < v13, 2 ^ v12 < 2 ^ v13) (v17 : forall v17 : 2 ^ v12 < 2 ^ v13, v12 < v13) => v17) v16 v17 end in v12 (P v1) (log2_up v0) ((fun (v13 : 0 < 1) (v14 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v15 : 2 <= 1 => (fun v16 : 0 < 2 => (fun v17 : 0 < v0 => (fun v18 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v15 v14)) (Private_OrderTac.Tac.lt_trans v13 v6)) (Private_OrderTac.Tac.lt_trans v13 v14)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v13 : 0 < 1) (v14 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v15 : log2_up v0 < 0 => (fun v16 : 0 < 2 => (fun v17 : log2_up v0 < 2 => (fun v18 : log2_up v0 < 1 => (fun v19 : log2_up v0 < v0 => (fun v20 : 0 < v0 => (fun v21 : log2_up v0 < v1 => (fun v22 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v22) (Private_OrderTac.Tac.le_lt_trans v7 v15)) (Private_OrderTac.Tac.lt_trans v15 v2)) (Private_OrderTac.Tac.lt_trans v13 v6)) (Private_OrderTac.Tac.lt_trans v18 v6)) (Private_OrderTac.Tac.lt_trans v15 v13)) (Private_OrderTac.Tac.lt_trans v15 v16)) (Private_OrderTac.Tac.lt_trans v13 v14)) : ~ log2_up v0 < 0)) (@lt_0_1) (@lt_1_2)) ((fun (v13 : 0 < 1) (v14 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v15 : 2 ^ log2_up v0 <= 2 ^ P v1 => (fun v16 : 0 < 2 => (fun v17 : 0 < v0 => (fun v18 : 2 ^ log2_up v0 < v0 => (fun v19 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v19) (Private_OrderTac.Tac.le_lt_trans v10 v18)) (Private_OrderTac.Tac.le_lt_trans v15 v4)) (Private_OrderTac.Tac.lt_trans v13 v6)) (Private_OrderTac.Tac.lt_trans v13 v14)) : ~ 2 ^ log2_up v0 <= 2 ^ P v1)) (@lt_0_1) (@lt_1_2))))) in let v12 : 0 < log2_up v0 := Private_OrderTac.Tac.not_ge_lt ((fun v12 : log2_up v0 <= 0 => (fun v13 : 0 == log2_up v0 => (fun v14 : log2_up v0 < v1 => (fun v15 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v11 v14)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v13) v2)) (Private_OrderTac.Tac.le_antisym v7 v12)) : ~ log2_up v0 <= 0) in let v13 : log2_up v0 <= v1 := let v13 : forall (v13 v14 : @t) (v15 : v13 < S v14), v13 <= v14 := fun v13 v14 : @t => match lt_succ_r v13 v14 as v15 in (_ /\ _) return (forall v16 : v13 < S v14, v13 <= v14) with | conj v15 v16 => (fun (v15 : forall v15 : v13 < S v14, v13 <= v14) (v16 : forall v16 : v13 <= v14, v13 < S v14) => v15) v15 v16 end in v13 (log2_up v0) v1 ((fun v14 : S (P (log2_up v0)) == log2_up v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up v0) (S (P (log2_up v0))) (symmetry v14) (S v1) (S v1) (reflexive_proper_proxy Equivalence_Reflexive (S v1))) (lt_succ_pred 0 (log2_up v0) v12) ((fun v14 : P (log2_up v0) < v1 <-> S (P (log2_up v0)) < S v1 => iff_flip_impl_subrelation (S (P (log2_up v0)) < S v1) (P (log2_up v0) < v1) (symmetry v14)) (succ_lt_mono (P (log2_up v0)) v1) (let v14 : forall (v14 v15 : @t) (v16 : 1 < 2) (v17 : 0 <= v15) (v18 : 2 ^ v14 < 2 ^ v15), v14 < v15 := fun (v14 v15 : @t) (v16 : 1 < 2) (v17 : 0 <= v15) => match pow_lt_mono_r_iff 2 v14 v15 v16 v17 as v18 in (_ /\ _) return (forall v19 : 2 ^ v14 < 2 ^ v15, v14 < v15) with | conj v18 v19 => (fun (v18 : forall v18 : v14 < v15, 2 ^ v14 < 2 ^ v15) (v19 : forall v19 : 2 ^ v14 < 2 ^ v15, v14 < v15) => v19) v18 v19 end in v14 (P (log2_up v0)) v1 ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v17 : 2 <= 1 => (fun v18 : 0 < 2 => (fun v19 : 0 < v0 => (fun v20 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v20) (Private_OrderTac.Tac.le_lt_trans v17 v16)) (Private_OrderTac.Tac.lt_trans v15 v6)) (Private_OrderTac.Tac.lt_trans v15 v16)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v17 : v1 < 0 => (fun v18 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.lt_trans v2 v17)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)) ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v17 : 2 ^ v1 <= 2 ^ P (log2_up v0) => (fun v18 : 0 < 2 => (fun v19 : 0 < v0 => (fun v20 : 2 ^ v1 < v0 => (fun v21 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v21) (Private_OrderTac.Tac.le_lt_trans v5 v20)) (Private_OrderTac.Tac.le_lt_trans v17 v9)) (Private_OrderTac.Tac.lt_trans v15 v6)) (Private_OrderTac.Tac.lt_trans v15 v16)) : ~ 2 ^ v1 <= 2 ^ P (log2_up v0))) (@lt_0_1) (@lt_1_2))))) in Private_OrderTac.Tac.not_neq_eq ((fun v14 : log2_up v0 ~= v1 => (fun v15 : v1 == log2_up v0 => (fun v16 : log2_up v0 ~= log2_up v0 => (fun v17 : 0 < log2_up v0 => v16 (Private_OrderTac.Tac.eq_refl (log2_up v0))) (Private_OrderTac.Tac.lt_eq v2 v15)) (Private_OrderTac.Tac.neq_eq v14 v15)) (Private_OrderTac.Tac.le_antisym v11 v13)) : ~ log2_up v0 ~= v1)) v9 v10 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_pow2	100	0.184696	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 <= v0) => match (fun v2 : 0 <= v0 <-> 0 < v0 \/ 0 == v0 => iff_impl_subrelation (0 <= v0) (0 < v0 \/ 0 == v0) v2) (lt_eq_cases 0 v0) v1 as v2 in (_ \/ _) return (log2_up (2 ^ v0) == v0) with | or_introl v2 => (fun v2 : 0 < v0 => log2_up_unique (2 ^ v0) v0 v2 (conj (pow_lt_mono_r 2 (P v0) v0 ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v5 : 2 <= 1 => (fun v6 : 0 < 2 => (fun v7 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v5 v4)) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v2 v5)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)) ((fun v3 : S (P v0) == v0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (P v0)) v0 (S (P v0)) (symmetry v3)) (lt_succ_pred 0 v0 v2) (let v3 : forall (v3 v4 : @t) (v5 : v3 <= v4), v3 < S v4 := fun v3 v4 : @t => match lt_succ_r v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 <= v4, v3 < S v4) with | conj v5 v6 => (fun (v5 : forall v5 : v3 < S v4, v3 <= v4) (v6 : forall v6 : v3 <= v4, v3 < S v4) => v6) v5 v6 end in v3 (P v0) (P v0) (reflexivity (P v0))))) (Private_OrderTac.Tac.le_refl (2 ^ v0)))) v2 | or_intror v2 => (fun v2 : 0 == v0 => (fun v3 : 0 == v0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (2 ^ v0)) (log2_up (2 ^ 0)) (log2_up_wd (2 ^ v0) (2 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) v0 0 (symmetry v3))) v0 0 (symmetry v3)) v2 ((fun v3 : 2 ^ 0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up (2 ^ 0)) (log2_up 1) (log2_up_wd (2 ^ 0) 1 v3) 0 0 (eq_proper_proxy 0)) (pow_0_r 2) ((fun v3 : log2_up 1 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up 1) 0 v3 0 0 (eq_proper_proxy 0)) (log2_up_eqn0 1 (reflexivity 1)) (reflexivity 0)))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_succ_pow2	100	0.102305	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 <= v0) => (fun v2 : log2_up (S (2 ^ v0)) == S (log2 (P (S (2 ^ v0)))) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up (S (2 ^ v0))) (S (log2 (P (S (2 ^ v0))))) v2 (S v0) (S v0) (eq_proper_proxy (S v0))) (log2_up_eqn (S (2 ^ v0)) ((fun v2 : 1 == S 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (S 0) v2 (S (2 ^ v0)) (S (2 ^ v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (2 ^ v0)))) (@one_succ) ((fun v2 : 0 < 2 ^ v0 <-> S 0 < S (2 ^ v0) => iff_flip_impl_subrelation (S 0 < S (2 ^ v0)) (0 < 2 ^ v0) (symmetry v2)) (succ_lt_mono 0 (2 ^ v0)) (pow_pos_nonneg 2 v0 ((fun (v2 : 0 < 1) (v3 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v4 : 2 <= 0 => (fun v5 : 0 < 2 => (fun v6 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.le_lt_trans v4 v5)) (Private_OrderTac.Tac.lt_trans v2 v3)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v2 : 0 < 1) (v3 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v4 : v0 < 0 => (fun v5 : 0 < 2 => (fun v6 : v0 < 2 => (fun v7 : v0 < 1 => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v1 v4)) (Private_OrderTac.Tac.lt_trans v4 v2)) (Private_OrderTac.Tac.lt_trans v4 v5)) (Private_OrderTac.Tac.lt_trans v2 v3)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)))))) ((fun v2 : P (S (2 ^ v0)) == 2 ^ v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S (log2 (P (S (2 ^ v0))))) (S (log2 (2 ^ v0))) (succ_wd (log2 (P (S (2 ^ v0)))) (log2 (2 ^ v0)) (log2_wd (P (S (2 ^ v0))) (2 ^ v0) v2)) (S v0) (S v0) (eq_proper_proxy (S v0))) (pred_succ (2 ^ v0)) ((fun v2 : log2 (2 ^ v0) == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S (log2 (2 ^ v0))) (S v0) (succ_wd (log2 (2 ^ v0)) v0 v2) (S v0) (S v0) (eq_proper_proxy (S v0))) (log2_pow2 v0 v1) (reflexivity (S v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_1	100	0.019352	1	1	0	synth with cache (only 1: refine (log2_up_eqn0 1 (reflexivity 1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_2	100	0.033608	1	1	0	synth with cache (only 1: refine ((fun v0 : 2 ^ 1 == 2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up 2) (log2_up (2 ^ 1)) (log2_up_wd 2 (2 ^ 1) (symmetry v0)) 1 1 (eq_proper_proxy 1)) (pow_1_r 2) (log2_up_pow2 1 ((fun (v0 : 0 < 1) (v1 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v2 : 1 < 0 => (fun v3 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v3) (Private_OrderTac.Tac.lt_trans v0 v2)) : ~ 1 < 0)) (@lt_0_1) (@lt_1_2))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.le_log2_log2_up	100	0.449533	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match compare_spec 1 v0 as v2 in (CompareSpec _ _ _ v1) return (log2 v0 <= match v1 as v3 in comparison return (@t) with | Lt => S (log2 (P v0)) | _ => 0 end) with | CompEq _ _ v1 => (fun v1 : 1 == v0 => (fun v2 : 1 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) (log2 1) (log2_wd v0 1 (symmetry v2)) 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) v1 ((fun v2 : log2 1 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 1) 0 v2 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (@log2_1) (Private_OrderTac.Tac.le_refl 0))) v1 | CompLt _ _ v1 => (fun v1 : 1 < v0 => (fun v2 : S (P v0) == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) (log2 (S (P v0))) (log2_wd v0 (S (P v0)) (symmetry v2)) (S (log2 (P v0))) (S (log2 (P v0))) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 (P v0))))) (lt_succ_pred 1 v0 v1) (log2_succ_le (P v0))) v1 | CompGt _ _ v1 => (fun v1 : v0 < 1 => (fun v2 : log2 v0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) 0 v2 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (log2_nonpos v0 ((fun v2 : v0 < S 0 <-> v0 <= 0 => iff_flip_impl_subrelation (v0 <= 0) (v0 < S 0) (symmetry v2)) (lt_succ_r v0 0) ((fun v2 : 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (S 0) 1 (symmetry v2)) (@one_succ) v1))) (Private_OrderTac.Tac.le_refl 0)) v1 end : log2 v0 <= log2_up v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.le_log2_up_succ_log2	100	0.092895	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match compare_spec 1 v0 as v2 in (CompareSpec _ _ _ v1) return (match v1 as v3 in comparison return (@t) with | Lt => S (log2 (P v0)) | _ => 0 end <= S (log2 v0)) with | CompEq _ _ v1 => (fun v1 : 1 == v0 => le_le_succ_r 0 (log2 v0) (log2_nonneg v0)) v1 | CompLt _ _ v1 => (fun v1 : 1 < v0 => (fun v2 : log2 (P v0) <= log2 v0 <-> S (log2 (P v0)) <= S (log2 v0) => iff_flip_impl_subrelation (S (log2 (P v0)) <= S (log2 v0)) (log2 (P v0) <= log2 v0) (symmetry v2)) (succ_le_mono (log2 (P v0)) (log2 v0)) (log2_le_mono (P v0) v0 ((fun v2 : S (P v0) == v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (P v0)) v0 (S (P v0)) (symmetry v2)) (lt_succ_pred 1 v0 v1) (le_succ_diag_r (P v0))))) v1 | CompGt _ _ v1 => (fun v1 : v0 < 1 => le_le_succ_r 0 (log2 v0) (log2_nonneg v0)) v1 end : log2_up v0 <= S (log2 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_log2_up_spec	100	0.289310	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => conj (let v2 : forall (v2 : @t) (v3 : 0 < v2), 2 ^ log2 v2 <= v2 := fun (v2 : @t) (v3 : 0 < v2) => match log2_spec v2 v3 as v4 in (_ /\ _) return (2 ^ log2 v2 <= v2) with | conj v4 v5 => (fun (v4 : 2 ^ log2 v2 <= v2) (v5 : v2 < 2 ^ S (log2 v2)) => v4) v4 v5 end in v2 v0 v1) match (fun v2 : 1 <= v0 <-> 1 < v0 \/ 1 == v0 => iff_impl_subrelation (1 <= v0) (1 < v0 \/ 1 == v0) v2) (lt_eq_cases 1 v0) ((fun v2 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 0) 1 (symmetry v2) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (@one_succ) ((fun v2 : S 0 <= v0 <-> 0 < v0 => iff_impl_subrelation (0 < v0) (S 0 <= v0) (symmetry v2)) (le_succ_l 0 v0) v1)) as v2 in (_ \/ _) return (v0 <= 2 ^ log2_up v0) with | or_introl v2 => (fun v2 : 1 < v0 => let v3 : forall (v3 : @t) (v4 : 1 < v3), v3 <= 2 ^ log2_up v3 := fun (v3 : @t) (v4 : 1 < v3) => match log2_up_spec v3 v4 as v5 in (_ /\ _) return (v3 <= 2 ^ log2_up v3) with | conj v5 v6 => (fun (v5 : 2 ^ P (log2_up v3) < v3) (v6 : v3 <= 2 ^ log2_up v3) => v6) v5 v6 end in v3 v0 v2) v2 | or_intror v2 => (fun v2 : 1 == v0 => (fun v3 : 1 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v0 1 (symmetry v3) (2 ^ log2_up v0) (2 ^ log2_up 1) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (log2_up v0) (log2_up 1) (log2_up_wd v0 1 (symmetry v3)))) v2 ((fun v3 : log2_up 1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (2 ^ log2_up 1) (2 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (log2_up 1) 0 v3)) (@log2_up_1) ((fun v3 : 2 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (2 ^ 0) 1 v3) (pow_0_r 2) (reflexivity 1)))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_log2_up_exact	100	0.257622	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => conj (fun v2 : log2 v0 == log2_up v0 => ex_intro (fun v3 : @t => v0 == 2 ^ v3) (log2 v0) ((fun v3 : log2 v0 == log2_up v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ log2 v0 <= v0 <= 2 ^ log2_up v0) (2 ^ log2 v0 <= v0 <= 2 ^ log2 v0) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (2 ^ log2 v0 <= v0)) (v0 <= 2 ^ log2_up v0) (v0 <= 2 ^ log2 v0) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ log2_up v0) (2 ^ log2 v0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (log2_up v0) (log2 v0) (symmetry v3)))) (v0 == 2 ^ log2 v0) (v0 == 2 ^ log2 v0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 2 ^ log2 v0))) v2 (fun v3 : 2 ^ log2 v0 <= v0 <= 2 ^ log2 v0 => match v3 as v4 in (_ /\ _) return (v0 == 2 ^ log2 v0) with | conj v4 v5 => (fun (v4 : 2 ^ log2 v0 <= v0) (v5 : v0 <= 2 ^ log2 v0) => Private_OrderTac.Tac.not_neq_eq ((fun v6 : v0 ~= 2 ^ log2 v0 => (fun v7 : 2 ^ log2 v0 == v0 => (fun v8 : v0 ~= v0 => v8 (Private_OrderTac.Tac.eq_refl v0)) (Private_OrderTac.Tac.neq_eq v6 v7)) (Private_OrderTac.Tac.le_antisym v4 v5)) : ~ v0 ~= 2 ^ log2 v0)) v4 v5 end) (log2_log2_up_spec v0 v1))) (fun v2 : exists v2 : @t, v0 == 2 ^ v2 => match v2 as v3 in (ex _) return (log2 v0 == log2_up v0) with | ex_intro _ v3 v4 => (fun (v3 : @t) (v4 : v0 == 2 ^ v3) => (fun v5 : v0 == 2 ^ v3 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) (log2 (2 ^ v3)) (log2_wd v0 (2 ^ v3) v5) (log2_up v0) (log2_up (2 ^ v3)) (log2_up_wd v0 (2 ^ v3) v5)) v4 (let v5 : 0 <= v3 \/ v3 < 0 := le_gt_cases 0 v3 in match v5 as v6 in (_ \/ _) return (log2 (2 ^ v3) == log2_up (2 ^ v3)) with | or_introl v6 => (fun v6 : 0 <= v3 => (fun v7 : log2 (2 ^ v3) == v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 (2 ^ v3)) v3 v7 (log2_up (2 ^ v3)) (log2_up (2 ^ v3)) (eq_proper_proxy (log2_up (2 ^ v3)))) (log2_pow2 v3 v6) ((fun v7 : log2_up (2 ^ v3) == v3 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (log2_up (2 ^ v3)) v3 v7) (log2_up_pow2 v3 v6) (reflexivity v3))) v6 | or_intror v6 => (fun v6 : v3 < 0 => (fun v7 : 2 ^ v3 == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 (2 ^ v3)) (log2 0) (log2_wd (2 ^ v3) 0 v7) (log2_up (2 ^ v3)) (log2_up 0) (log2_up_wd (2 ^ v3) 0 v7)) (pow_neg_r 2 v3 v6) ((fun v7 : log2 0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2 0) 0 v7 (log2_up 0) (log2_up 0) (eq_proper_proxy (log2_up 0))) (log2_nonpos 0 (reflexivity 0)) ((fun v7 : log2_up 0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (log2_up 0) 0 v7) (log2_up_nonpos 0 (reflexivity 0)) (reflexivity 0)))) v6 end)) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_pos	100	0.066022	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 1 < v0) => (fun v2 : log2_up v0 == S (log2 (P v0)) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (log2_up v0) (S (log2 (P v0))) v2) (log2_up_eqn v0 v1) (let v2 : forall (v2 v3 : @t) (v4 : v2 <= v3), v2 < S v3 := fun v2 v3 : @t => match lt_succ_r v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 <= v3, v2 < S v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 < S v3, v2 <= v3) (v5 : forall v5 : v2 <= v3, v2 < S v3) => v5) v4 v5 end in v2 0 (log2 (P v0)) (log2_nonneg (P v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_null	100	0.048750	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (fun v1 : log2_up v0 == 0 => let v2 : v0 <= 1 \/ 1 < v0 := le_gt_cases v0 1 in match v2 as v3 in (_ \/ _) return (v0 <= 1) with | or_introl v3 => (fun v3 : v0 <= 1 => v3) v3 | or_intror v3 => (fun v3 : 1 < v0 => (fun v4 : 0 < log2_up v0 => Private_OrderTac.Tac.not_gt_le ((fun v5 : 1 < v0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_eq v4 v1)) : ~ 1 < v0)) (log2_up_pos v0 v3)) v3 end) (fun v1 : v0 <= 1 => log2_up_eqn0 v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_le_mono	100	0.244762	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : v0 <= v1) => let v3 : v0 <= 1 \/ 1 < v0 := le_gt_cases v0 1 in match v3 as v4 in (_ \/ _) return (log2_up v0 <= log2_up v1) with | or_introl v4 => (fun v4 : v0 <= 1 => (fun v5 : log2_up v0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up v0) 0 v5 (log2_up v1) (log2_up v1) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v1))) (log2_up_eqn0 v0 v4) (log2_up_nonneg v1)) v4 | or_intror v4 => (fun v4 : 1 < v0 => (fun v5 : log2_up v0 == S (log2 (P v0)) => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up v0) (S (log2 (P v0))) v5 (log2_up v1) (log2_up v1) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v1))) (log2_up_eqn v0 (Private_OrderTac.Tac.not_ge_lt ((fun v5 : v0 <= 1 => (fun v6 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.le_lt_trans v5 v4)) : ~ v0 <= 1))) ((fun v5 : log2_up v1 == S (log2 (P v1)) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 (P v0)))) (log2_up v1) (S (log2 (P v1))) v5) (log2_up_eqn v1 (Private_OrderTac.Tac.not_ge_lt ((fun v5 : v1 <= 1 => (fun v6 : v1 < v0 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v2 v6)) (Private_OrderTac.Tac.le_lt_trans v5 v4)) : ~ v1 <= 1))) ((fun v5 : log2 (P v0) <= log2 (P v1) <-> S (log2 (P v0)) <= S (log2 (P v1)) => iff_flip_impl_subrelation (S (log2 (P v0)) <= S (log2 (P v1))) (log2 (P v0) <= log2 (P v1)) (symmetry v5)) (succ_le_mono (log2 (P v0)) (log2 (P v1))) (log2_le_mono (P v0) (P v1) (let v5 : forall (v5 v6 : @t) (v7 : S v5 <= S v6), v5 <= v6 := fun v5 v6 : @t => match succ_le_mono v5 v6 as v7 in (_ /\ _) return (forall v8 : S v5 <= S v6, v5 <= v6) with | conj v7 v8 => (fun (v7 : forall v7 : v5 <= v6, S v5 <= S v6) (v8 : forall v8 : S v5 <= S v6, v5 <= v6) => v8) v7 v8 end in v5 (P v0) (P v1) ((fun v6 : S (P v0) == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (S (P v0)) v0 v6 (S (P v1)) (S (P v1)) (reflexive_proper_proxy Equivalence_Reflexive (S (P v1)))) (lt_succ_pred 1 v0 (Private_OrderTac.Tac.not_ge_lt ((fun v6 : v0 <= 1 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v6 v4)) : ~ v0 <= 1))) ((fun v6 : S (P v1) == v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (S (P v1)) v1 v6) (lt_succ_pred 1 v1 (Private_OrderTac.Tac.not_ge_lt ((fun v6 : v1 <= 1 => (fun v7 : v1 < v0 => (fun v8 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v2 v7)) (Private_OrderTac.Tac.le_lt_trans v6 v4)) : ~ v1 <= 1))) (Private_OrderTac.Tac.not_gt_le ((fun v6 : v1 < v0 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v2 v6)) : ~ v1 < v0))))))))) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_lt_cancel	100	0.309801	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : log2_up v0 < log2_up v1) => let v3 : v1 <= 1 \/ 1 < v1 := le_gt_cases v1 1 in match v3 as v4 in (_ \/ _) return (v0 < v1) with | or_introl v4 => (fun v4 : v1 <= 1 => (fun v5 : 0 <= log2_up v0 => Private_OrderTac.Tac.not_ge_lt ((fun v6 : v1 <= v0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v5 ((fun v7 : log2_up v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0)) (log2_up v1) 0 v7) (log2_up_eqn0 v1 v4) v2))) : ~ v1 <= v0)) (log2_up_nonneg v0)) v4 | or_intror v4 => (fun v4 : 1 < v1 => let v5 : v0 <= 1 \/ 1 < v0 := le_gt_cases v0 1 in match v5 as v6 in (_ \/ _) return (v0 < v1) with | or_introl v6 => (fun v6 : v0 <= 1 => Private_OrderTac.Tac.not_ge_lt ((fun v7 : v1 <= v0 => (fun v8 : v0 < v1 => (fun v9 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v7 v8)) (Private_OrderTac.Tac.le_lt_trans v6 v4)) : ~ v1 <= v0)) v6 | or_intror v6 => (fun v6 : 1 < v0 => let v7 : P v0 < P v1 := log2_lt_cancel (P v0) (P v1) ((fun v7 : log2 (P v0) < log2 (P v1) <-> S (log2 (P v0)) < S (log2 (P v1)) => iff_impl_subrelation (S (log2 (P v0)) < S (log2 (P v1))) (log2 (P v0) < log2 (P v1)) (symmetry v7)) (succ_lt_mono (log2 (P v0)) (log2 (P v1))) ((fun v7 : log2_up v1 == S (log2 (P v1)) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 (P v0)))) (log2_up v1) (S (log2 (P v1))) v7) (log2_up_eqn v1 (Private_OrderTac.Tac.not_ge_lt ((fun v7 : v1 <= 1 => (fun v8 : v1 < v0 => (fun v9 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v7 v4)) (Private_OrderTac.Tac.le_lt_trans v7 v6)) : ~ v1 <= 1))) ((fun v7 : log2_up v0 == S (log2 (P v0)) => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2_up v0) (S (log2 (P v0))) v7 (log2_up v1) (log2_up v1) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v1))) (log2_up_eqn v0 (Private_OrderTac.Tac.not_ge_lt ((fun v7 : v0 <= 1 => (fun v8 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v7 v6)) : ~ v0 <= 1))) v2))) in let v8 : forall (v8 v9 : @t) (v10 : v8 < v9), S v8 < S v9 := fun v8 v9 : @t => match succ_lt_mono v8 v9 as v10 in (_ /\ _) return (forall v11 : v8 < v9, S v8 < S v9) with | conj v10 v11 => (fun (v10 : forall v10 : v8 < v9, S v8 < S v9) (v11 : forall v11 : S v8 < S v9, v8 < v9) => v10) v10 v11 end in let v9 : S (P v0) < S (P v1) := v8 (P v0) (P v1) v7 in Private_OrderTac.Tac.not_ge_lt ((fun v10 : v1 <= v0 => (fun v11 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v10 ((fun v11 : S (P v1) == v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (S (P v1)) v1 v11) (lt_succ_pred 1 v1 (Private_OrderTac.Tac.not_ge_lt ((fun v11 : v1 <= 1 => (fun v12 : 1 < S (P v1) => (fun v13 : v1 < S (P v1) => (fun v14 : v1 < v0 => (fun v15 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v11 v4)) (Private_OrderTac.Tac.le_lt_trans v11 v6)) (Private_OrderTac.Tac.le_lt_trans v11 v12)) (Private_OrderTac.Tac.lt_trans v6 ((fun v12 : S (P v0) == v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S (P v0)) v0 v12 (S (P v1)) (S (P v1)) (reflexive_proper_proxy Equivalence_Reflexive (S (P v1)))) (lt_succ_pred 1 v0 (Private_OrderTac.Tac.not_ge_lt ((fun v12 : v0 <= 1 => (fun v13 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v12 v6)) : ~ v0 <= 1))) v9))) : ~ v1 <= 1))) ((fun v11 : S (P v0) == v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S (P v0)) v0 v11 (S (P v1)) (S (P v1)) (reflexive_proper_proxy Equivalence_Reflexive (S (P v1)))) (lt_succ_pred 1 v0 (Private_OrderTac.Tac.not_ge_lt ((fun v11 : v0 <= 1 => (fun v12 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v11 v6)) : ~ v0 <= 1))) v9)))) : ~ v1 <= v0)) v6 end) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_lt_pow2	100	0.262880	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) => conj (fun v3 : 2 ^ v1 < v0 => let v4 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v4 as v5 in (_ \/ _) return (v1 < log2_up v0) with | or_introl v5 => (fun v5 : v1 < 0 => (fun v6 : 0 <= log2_up v0 => Private_OrderTac.Tac.not_ge_lt ((fun v7 : log2_up v0 <= v1 => (fun v8 : v1 < v0 => (fun v9 : log2_up v0 < v0 => (fun v10 : log2_up v0 < 0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v6 v10)) (Private_OrderTac.Tac.le_lt_trans v7 v5)) (Private_OrderTac.Tac.le_lt_trans v7 v8)) (Private_OrderTac.Tac.lt_trans v5 v2)) : ~ log2_up v0 <= v1)) (log2_up_nonneg v0)) v5 | or_intror v5 => (fun v5 : 0 <= v1 => let v6 : forall (v6 v7 : @t) (v8 : 1 < 2) (v9 : 0 <= v7) (v10 : 2 ^ v6 < 2 ^ v7), v6 < v7 := fun (v6 v7 : @t) (v8 : 1 < 2) (v9 : 0 <= v7) => match pow_lt_mono_r_iff 2 v6 v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : 2 ^ v6 < 2 ^ v7, v6 < v7) with | conj v10 v11 => (fun (v10 : forall v10 : v6 < v7, 2 ^ v6 < 2 ^ v7) (v11 : forall v11 : 2 ^ v6 < 2 ^ v7, v6 < v7) => v11) v10 v11 end in v6 v1 (log2_up v0) ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : 2 <= 1 => (fun v10 : 0 < 2 => (fun v11 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v9 v8)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) (log2_up_nonneg v0) (lt_le_trans (2 ^ v1) v0 (2 ^ log2_up v0) v3 (let v7 : forall v7 : 1 < v0, v0 <= 2 ^ log2_up v0 := fun v7 : 1 < v0 => match log2_up_spec v0 v7 as v8 in (_ /\ _) return (v0 <= 2 ^ log2_up v0) with | conj v8 v9 => (fun (v8 : 2 ^ P (log2_up v0) < v0) (v9 : v0 <= 2 ^ log2_up v0) => v9) v8 v9 end in v7 (le_lt_trans 1 (2 ^ v1) v0 ((fun v8 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (S 0) v8 (2 ^ v1) (2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1))) (@one_succ) ((fun v8 : S 0 <= 2 ^ v1 <-> 0 < 2 ^ v1 => iff_flip_impl_subrelation (S 0 <= 2 ^ v1) (0 < 2 ^ v1) v8) (le_succ_l 0 (2 ^ v1)) (pow_pos_nonneg 2 v1 ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : 2 <= 0 => (fun v11 : 0 < 2 => (fun v12 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v10 v11)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v10 : v1 < 0 => (fun v11 : 0 < 2 => (fun v12 : v1 < 2 => (fun v13 : v1 < 1 => (fun v14 : v1 < v0 => (fun v15 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v5 v10)) (Private_OrderTac.Tac.lt_trans v10 v2)) (Private_OrderTac.Tac.lt_trans v10 v8)) (Private_OrderTac.Tac.lt_trans v10 v11)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2))))) v3)))) v5 end) (fun v3 : v1 < log2_up v0 => let v4 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v4 as v5 in (_ \/ _) return (2 ^ v1 < v0) with | or_introl v5 => (fun v5 : v1 < 0 => (fun v6 : 2 ^ v1 == 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ v1) 0 v6 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (pow_neg_r 2 v1 v5) v2) v5 | or_intror v5 => (fun v5 : 0 <= v1 => log2_up_lt_cancel (2 ^ v1) v0 ((fun v6 : log2_up (2 ^ v1) == v1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) v1 (log2_up (2 ^ v1)) (symmetry v6) (log2_up v0) (log2_up v0) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0))) (log2_up_pow2 v1 v5) v3)) v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_le_pow2	100	0.211615	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) => conj (fun v3 : v0 <= 2 ^ v1 => let v4 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v4 as v5 in (_ \/ _) return (log2_up v0 <= v1) with | or_introl v5 => (fun v5 : v1 < 0 => Private_OrderTac.Tac.not_gt_le ((fun v6 : v1 < log2_up v0 => (fun v7 : v1 < v0 => (fun v8 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans ((fun v8 : 2 ^ v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ v1) 0 v8) (pow_neg_r 2 v1 (Private_OrderTac.Tac.not_ge_lt ((fun v8 : 0 <= v1 => (fun v9 : v1 < v0 => (fun v10 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v5)) (Private_OrderTac.Tac.lt_trans v5 v2)) : ~ 0 <= v1))) v3) v2)) (Private_OrderTac.Tac.lt_trans v5 v2)) : ~ v1 < log2_up v0)) v5 | or_intror v5 => (fun v5 : 0 <= v1 => (fun v6 : log2_up (2 ^ v1) == v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0)) v1 (log2_up (2 ^ v1)) (symmetry v6)) (log2_up_pow2 v1 v5) (log2_up_le_mono v0 (2 ^ v1) v3)) v5 end) (fun v3 : log2_up v0 <= v1 => transitivity (let v4 : forall (v4 : @t) (v5 : 0 < v4), v4 <= 2 ^ log2_up v4 := fun (v4 : @t) (v5 : 0 < v4) => match log2_log2_up_spec v4 v5 as v6 in (_ /\ _) return (v4 <= 2 ^ log2_up v4) with | conj v6 v7 => (fun (v6 : 2 ^ log2 v4 <= v4) (v7 : v4 <= 2 ^ log2_up v4) => v7) v6 v7 end in v4 v0 v2) (pow_le_mono_r 2 (log2_up v0) v1 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : 2 <= 0 => (fun v7 : 0 < 2 => (fun v8 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v6 v7)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : v1 < log2_up v0 => (fun v7 : 0 < 2 => (fun v8 : log2_up v0 < log2_up v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v3 v6)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ v1 < log2_up v0)) (@lt_0_1) (@lt_1_2)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_lt_lin	100	0.390151	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => let v2 : S (P v0) == v0 := lt_succ_pred 0 v0 v1 in (fun v3 : S (P v0) == v0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0)) v0 (S (P v0)) (symmetry v3)) v2 (let v3 : forall (v3 v4 : @t) (v5 : v3 <= v4), v3 < S v4 := fun v3 v4 : @t => match lt_succ_r v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 <= v4, v3 < S v4) with | conj v5 v6 => (fun (v5 : forall v5 : v3 < S v4, v3 <= v4) (v6 : forall v6 : v3 <= v4, v3 < S v4) => v6) v5 v6 end in v3 (log2_up v0) (P v0) (let v4 : forall (v4 v5 : @t) (v6 : 0 < v4) (v7 : v4 <= 2 ^ v5), log2_up v4 <= v5 := fun (v4 v5 : @t) (v6 : 0 < v4) => match log2_up_le_pow2 v4 v5 v6 as v7 in (_ /\ _) return (forall v8 : v4 <= 2 ^ v5, log2_up v4 <= v5) with | conj v7 v8 => (fun (v7 : forall v7 : v4 <= 2 ^ v5, log2_up v4 <= v5) (v8 : forall v8 : log2_up v4 <= v5, v4 <= 2 ^ v5) => v7) v7 v8 end in v4 v0 (P v0) v1 ((fun v5 : S (P v0) == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v0 (S (P v0)) (symmetry v5) (2 ^ P v0) (2 ^ P v0) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ P v0))) v2 (let v5 : forall (v5 v6 : @t) (v7 : v5 < v6), S v5 <= v6 := fun v5 v6 : @t => match le_succ_l v5 v6 as v7 in (_ /\ _) return (forall v8 : v5 < v6, S v5 <= v6) with | conj v7 v8 => (fun (v7 : forall v7 : S v5 <= v6, v5 < v6) (v8 : forall v8 : v5 < v6, S v5 <= v6) => v8) v7 v8 end in v5 (P v0) (2 ^ P v0) (pow_gt_lin_r 2 (P v0) ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : 2 <= 1 => (fun v9 : 0 < 2 => (fun v10 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v7)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ 2 <= 1)) (@lt_0_1) (@lt_1_2)) (let v6 : forall (v6 v7 : @t) (v8 : v6 < S v7), v6 <= v7 := fun v6 v7 : @t => match lt_succ_r v6 v7 as v8 in (_ /\ _) return (forall v9 : v6 < S v7, v6 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : v6 < S v7, v6 <= v7) (v9 : forall v9 : v6 <= v7, v6 < S v7) => v8) v8 v9 end in v6 0 (P v0) (Private_OrderTac.Tac.not_ge_lt ((fun v7 : S (P v0) <= 0 => (fun v8 : v0 <= 0 => (fun v9 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v8 v1)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v2) v7)) : ~ S (P v0) <= 0)))))))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_le_lin	100	0.113098	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 <= v0) => match (fun v2 : 0 <= v0 <-> 0 < v0 \/ 0 == v0 => iff_impl_subrelation (0 <= v0) (0 < v0 \/ 0 == v0) v2) (lt_eq_cases 0 v0) v1 as v2 in (_ \/ _) return (log2_up v0 <= v0) with | or_introl v2 => (fun v2 : 0 < v0 => lt_le_incl (log2_up v0) v0 (log2_up_lt_lin v0 v2)) v2 | or_intror v2 => (fun v2 : 0 == v0 => (fun v3 : 0 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up v0) (log2_up 0) (log2_up_wd v0 0 (symmetry v3)) v0 0 (symmetry v3)) v2 ((fun v3 : log2_up 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up 0) 0 v3 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (log2_up_nonpos 0 (Private_OrderTac.Tac.le_refl 0)) (Private_OrderTac.Tac.le_refl 0))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_mul_above	100	0.540097	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 <= v0) (v3 : 0 <= v1) => let v4 : 0 <= log2_up v0 := log2_up_nonneg v0 in let v5 : 0 <= log2_up v1 := log2_up_nonneg v1 in match (fun v6 : 0 <= v0 <-> 0 < v0 \/ 0 == v0 => iff_impl_subrelation (0 <= v0) (0 < v0 \/ 0 == v0) v6) (lt_eq_cases 0 v0) v2 as v6 in (_ \/ _) return (log2_up (v0 * v1) <= log2_up v0 + log2_up v1) with | or_introl v6 => (fun v6 : 0 < v0 => match (fun v7 : 0 <= v1 <-> 0 < v1 \/ 0 == v1 => iff_impl_subrelation (0 <= v1) (0 < v1 \/ 0 == v1) v7) (lt_eq_cases 0 v1) v3 as v7 in (_ \/ _) return (log2_up (v0 * v1) <= log2_up v0 + log2_up v1) with | or_introl v7 => (fun v7 : 0 < v1 => let v8 : forall (v8 v9 : @t) (v10 : 0 < v8) (v11 : v8 <= 2 ^ v9), log2_up v8 <= v9 := fun (v8 v9 : @t) (v10 : 0 < v8) => match log2_up_le_pow2 v8 v9 v10 as v11 in (_ /\ _) return (forall v12 : v8 <= 2 ^ v9, log2_up v8 <= v9) with | conj v11 v12 => (fun (v11 : forall v11 : v8 <= 2 ^ v9, log2_up v8 <= v9) (v12 : forall v12 : log2_up v8 <= v9, v8 <= 2 ^ v9) => v11) v11 v12 end in v8 (v0 * v1) (log2_up v0 + log2_up v1) (mul_pos_pos v0 v1 ((fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v11 : v0 <= 0 => (fun v12 : 0 < 2 => (fun v13 : v0 < 2 => (fun v14 : v0 < 1 => (fun v15 : v0 < v1 => (fun v16 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v11 v6)) (Private_OrderTac.Tac.le_lt_trans v11 v7)) (Private_OrderTac.Tac.le_lt_trans v11 v9)) (Private_OrderTac.Tac.le_lt_trans v11 v12)) (Private_OrderTac.Tac.lt_trans v9 v10)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v11 : v1 <= 0 => (fun v12 : 0 < 2 => (fun v13 : v1 < 2 => (fun v14 : v1 < 1 => (fun v15 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v11 v7)) (Private_OrderTac.Tac.le_lt_trans v11 v9)) (Private_OrderTac.Tac.le_lt_trans v11 v12)) (Private_OrderTac.Tac.lt_trans v9 v10)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun v9 : 2 ^ (log2_up v0 + log2_up v1) == 2 ^ log2_up v0 * 2 ^ log2_up v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v1)) (2 ^ (log2_up v0 + log2_up v1)) (2 ^ log2_up v0 * 2 ^ log2_up v1) v9) (pow_add_r 2 (log2_up v0) (log2_up v1) v4 v5) (mul_le_mono_nonneg v0 (2 ^ log2_up v0) v1 (2 ^ log2_up v1) ((fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v11 : v0 < 0 => (fun v12 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.lt_trans v6 v11)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)) (let v9 : forall (v9 : @t) (v10 : 0 < v9), v9 <= 2 ^ log2_up v9 := fun (v9 : @t) (v10 : 0 < v9) => match log2_log2_up_spec v9 v10 as v11 in (_ /\ _) return (v9 <= 2 ^ log2_up v9) with | conj v11 v12 => (fun (v11 : 2 ^ log2 v9 <= v9) (v12 : v9 <= 2 ^ log2_up v9) => v12) v11 v12 end in v9 v0 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v0 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : v0 < v1 => (fun v17 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v12 v6)) (Private_OrderTac.Tac.le_lt_trans v12 v7)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v11 : v1 < 0 => (fun v12 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.lt_trans v7 v11)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)) (let v9 : forall (v9 : @t) (v10 : 0 < v9), v9 <= 2 ^ log2_up v9 := fun (v9 : @t) (v10 : 0 < v9) => match log2_log2_up_spec v9 v10 as v11 in (_ /\ _) return (v9 <= 2 ^ log2_up v9) with | conj v11 v12 => (fun (v11 : 2 ^ log2 v9 <= v9) (v12 : v9 <= 2 ^ log2_up v9) => v12) v11 v12 end in v9 v1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v1 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v1 < 2 => (fun v15 : v1 < 1 => (fun v16 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v12 v7)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2)))))) v7 | or_intror v7 => (fun v7 : 0 == v1 => (fun v8 : 0 == v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (v0 * v1)) (log2_up (v0 * 0)) (log2_up_wd (v0 * v1) (v0 * 0) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v1 0 (symmetry v8))) (log2_up v0 + log2_up v1) (log2_up v0 + log2_up 0) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0)) (log2_up v1) (log2_up 0) (log2_up_wd v1 0 (symmetry v8)))) v7 ((fun v8 : v0 * 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (v0 * 0)) (log2_up 0) (log2_up_wd (v0 * 0) 0 v8) (log2_up v0 + log2_up 0) (log2_up v0 + log2_up 0) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up 0))) (mul_0_r v0) ((fun v8 : log2_up 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up 0) 0 v8 (log2_up v0 + log2_up 0) (log2_up v0 + 0) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0)) (log2_up 0) 0 v8)) (log2_up_nonpos 0 ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2))) (add_nonneg_nonneg (log2_up v0) 0 ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v10 : log2_up v0 < 0 => (fun v11 : v1 < 1 => (fun v12 : v1 < v0 => (fun v13 : log2_up v0 < v1 => (fun v14 : v1 <= log2_up v1 => (fun v15 : v1 <= log2_up v0 => (fun v16 : log2_up v0 < v0 => (fun v17 : log2_up v0 < 1 => (fun v18 : log2_up v0 < 2 => (fun v19 : v1 < 2 => (fun v20 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v20) (Private_OrderTac.Tac.le_lt_trans v15 v13)) (Private_OrderTac.Tac.lt_trans v11 v9)) (Private_OrderTac.Tac.lt_trans v17 v9)) (Private_OrderTac.Tac.lt_trans v13 v11)) (Private_OrderTac.Tac.lt_trans v13 v12)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v7) v4)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v7) v5)) (Private_OrderTac.Tac.lt_eq v10 v7)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v7) v6)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v7) v8)) : ~ log2_up v0 < 0)) (@lt_0_1) (@lt_1_2)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2)))))) v7 end) v6 | or_intror v6 => (fun v6 : 0 == v0 => (fun v7 : 0 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (v0 * v1)) (log2_up (0 * v1)) (log2_up_wd (v0 * v1) (0 * v1) (mul_wd v0 0 (symmetry v7) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2_up v0 + log2_up v1) (log2_up 0 + log2_up v1) (add_wd (log2_up v0) (log2_up 0) (log2_up_wd v0 0 (symmetry v7)) (log2_up v1) (log2_up v1) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v1)))) v6 ((fun v7 : 0 * v1 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (0 * v1)) (log2_up 0) (log2_up_wd (0 * v1) 0 v7) (log2_up 0 + log2_up v1) (log2_up 0 + log2_up v1) (reflexive_proper_proxy Equivalence_Reflexive (log2_up 0 + log2_up v1))) (mul_0_l v1) ((fun v7 : log2_up 0 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up 0) 0 v7 (log2_up 0 + log2_up v1) (0 + log2_up v1) (add_wd (log2_up 0) 0 v7 (log2_up v1) (log2_up v1) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v1)))) (log2_up_nonpos 0 ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2))) (add_nonneg_nonneg 0 (log2_up v1) ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2)) ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v9 : log2_up v1 < 0 => (fun v10 : v0 < 1 => (fun v11 : log2_up v1 < v0 => (fun v12 : v0 <= log2_up v1 => (fun v13 : v0 <= log2_up v0 => (fun v14 : v0 <= v1 => (fun v15 : log2_up v1 < 1 => (fun v16 : log2_up v1 < 2 => (fun v17 : v0 < 2 => (fun v18 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v12 v11)) (Private_OrderTac.Tac.lt_trans v10 v8)) (Private_OrderTac.Tac.lt_trans v15 v8)) (Private_OrderTac.Tac.lt_trans v11 v10)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v6) v3)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v6) v4)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v6) v5)) (Private_OrderTac.Tac.lt_eq v9 v6)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v6) v7)) : ~ log2_up v1 < 0)) (@lt_0_1) (@lt_1_2)))))) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_mul_below	100	0.960457	1	1
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_mul_pow2	100	0.680262	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 <= v1) => match (fun v4 : 1 <= v0 <-> 1 < v0 \/ 1 == v0 => iff_impl_subrelation (1 <= v0) (1 < v0 \/ 1 == v0) v4) (lt_eq_cases 1 v0) ((fun v4 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 0) 1 (symmetry v4) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (@one_succ) ((fun v4 : S 0 <= v0 <-> 0 < v0 => iff_impl_subrelation (0 < v0) (S 0 <= v0) (symmetry v4)) (le_succ_l 0 v0) v2)) as v4 in (_ \/ _) return (log2_up (v0 * 2 ^ v1) == v1 + log2_up v0) with | or_introl v4 => (fun v4 : 1 < v0 => log2_up_unique (v0 * 2 ^ v1) (v1 + log2_up v0) (add_nonneg_pos v1 (log2_up v0) v3 (log2_up_pos v0 v4)) (conj (let v5 : S (P (log2_up v0)) == log2_up v0 := lt_succ_pred 0 (log2_up v0) (log2_up_pos v0 v4) in (fun v6 : S (P (log2_up v0)) == log2_up v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ P (v1 + log2_up v0)) (2 ^ P (v1 + S (P (log2_up v0)))) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (P (v1 + log2_up v0)) (P (v1 + S (P (log2_up v0)))) (pred_wd (v1 + log2_up v0) (v1 + S (P (log2_up v0))) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) (log2_up v0) (S (P (log2_up v0))) (symmetry v6)))) (v0 * 2 ^ v1) (v0 * 2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1))) v5 ((fun v6 : v1 + S (P (log2_up v0)) == S (v1 + P (log2_up v0)) => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ P (v1 + S (P (log2_up v0)))) (2 ^ P (S (v1 + P (log2_up v0)))) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (P (v1 + S (P (log2_up v0)))) (P (S (v1 + P (log2_up v0)))) (pred_wd (v1 + S (P (log2_up v0))) (S (v1 + P (log2_up v0))) v6)) (v0 * 2 ^ v1) (v0 * 2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1))) (add_succ_r v1 (P (log2_up v0))) ((fun v6 : P (S (v1 + P (log2_up v0))) == v1 + P (log2_up v0) => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ P (S (v1 + P (log2_up v0)))) (2 ^ (v1 + P (log2_up v0))) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (P (S (v1 + P (log2_up v0)))) (v1 + P (log2_up v0)) v6) (v0 * 2 ^ v1) (v0 * 2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1))) (pred_succ (v1 + P (log2_up v0))) ((fun v6 : 2 ^ (v1 + P (log2_up v0)) == 2 ^ v1 * 2 ^ P (log2_up v0) => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ (v1 + P (log2_up v0))) (2 ^ v1 * 2 ^ P (log2_up v0)) v6 (v0 * 2 ^ v1) (v0 * 2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1))) (pow_add_r 2 v1 (P (log2_up v0)) v3 ((fun v6 : 0 < S (P (log2_up v0)) <-> 0 <= P (log2_up v0) => iff_flip_impl_subrelation (0 <= P (log2_up v0)) (0 < S (P (log2_up v0))) (symmetry v6)) (lt_succ_r 0 (P (log2_up v0))) ((fun v6 : S (P (log2_up v0)) == log2_up v0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (S (P (log2_up v0))) (log2_up v0) v6) v5 (log2_up_pos v0 v4)))) ((fun v6 : 2 ^ v1 * 2 ^ P (log2_up v0) == 2 ^ P (log2_up v0) * 2 ^ v1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (2 ^ v1 * 2 ^ P (log2_up v0)) (2 ^ P (log2_up v0) * 2 ^ v1) v6 (v0 * 2 ^ v1) (v0 * 2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1))) (mul_comm (2 ^ v1) (2 ^ P (log2_up v0))) (let v6 : forall (v6 v7 v8 : @t) (v9 : 0 < v6) (v10 : v7 < v8), v7 * v6 < v8 * v6 := fun (v6 v7 v8 : @t) (v9 : 0 < v6) => match mul_lt_mono_pos_r v6 v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 < v8, v7 * v6 < v8 * v6) with | conj v10 v11 => (fun (v10 : forall v10 : v7 < v8, v7 * v6 < v8 * v6) (v11 : forall v11 : v7 * v6 < v8 * v6, v7 < v8) => v10) v10 v11 end in v6 (2 ^ v1) (2 ^ P (log2_up v0)) v0 (pow_pos_nonneg 2 v1 ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : 2 <= 0 => (fun v10 : 0 < 2 => (fun v11 : 0 < v0 => (fun v12 : 2 < v0 => (fun v13 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v9 v10)) (Private_OrderTac.Tac.le_lt_trans v9 v11)) (Private_OrderTac.Tac.lt_trans v7 v4)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v9 : v1 < 0 => (fun v10 : 0 < 2 => (fun v11 : v1 < 2 => (fun v12 : v1 < 1 => (fun v13 : v1 < v0 => (fun v14 : 0 < v0 => (fun v15 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v3 v9)) (Private_OrderTac.Tac.lt_trans v7 v4)) (Private_OrderTac.Tac.lt_trans v12 v4)) (Private_OrderTac.Tac.lt_trans v9 v7)) (Private_OrderTac.Tac.lt_trans v9 v10)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2))) (let v7 : forall (v7 : @t) (v8 : 1 < v7), 2 ^ P (log2_up v7) < v7 := fun (v7 : @t) (v8 : 1 < v7) => match log2_up_spec v7 v8 as v9 in (_ /\ _) return (2 ^ P (log2_up v7) < v7) with | conj v9 v10 => (fun (v9 : 2 ^ P (log2_up v7) < v7) (v10 : v7 <= 2 ^ log2_up v7) => v9) v9 v10 end in v7 v0 v4))))))) ((fun v5 : 2 ^ (v1 + log2_up v0) == 2 ^ v1 * 2 ^ log2_up v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 2 ^ v1)) (2 ^ (v1 + log2_up v0)) (2 ^ v1 * 2 ^ log2_up v0) v5) (pow_add_r 2 v1 (log2_up v0) v3 (log2_up_nonneg v0)) ((fun v5 : v0 * 2 ^ v1 == 2 ^ v1 * v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * 2 ^ v1) (2 ^ v1 * v0) v5 (2 ^ v1 * 2 ^ log2_up v0) (2 ^ v1 * 2 ^ log2_up v0) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1 * 2 ^ log2_up v0))) (mul_comm v0 (2 ^ v1)) (mul_le_mono_nonneg_l v0 (2 ^ log2_up v0) (2 ^ v1) (pow_nonneg 2 v1 ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : 2 < 0 => (fun v8 : 1 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v5 v8)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ 2 < 0)) (@lt_0_1) (@lt_1_2))) (let v5 : forall (v5 : @t) (v6 : 1 < v5), v5 <= 2 ^ log2_up v5 := fun (v5 : @t) (v6 : 1 < v5) => match log2_up_spec v5 v6 as v7 in (_ /\ _) return (v5 <= 2 ^ log2_up v5) with | conj v7 v8 => (fun (v7 : 2 ^ P (log2_up v5) < v5) (v8 : v5 <= 2 ^ log2_up v5) => v8) v7 v8 end in v5 v0 v4)))))) v4 | or_intror v4 => (fun v4 : 1 == v0 => (fun v5 : 1 == v0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (v0 * 2 ^ v1)) (log2_up (1 * 2 ^ v1)) (log2_up_wd (v0 * 2 ^ v1) (1 * 2 ^ v1) (mul_wd v0 1 (symmetry v5) (2 ^ v1) (2 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (2 ^ v1)))) (v1 + log2_up v0) (v1 + log2_up 1) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) (log2_up v0) (log2_up 1) (log2_up_wd v0 1 (symmetry v5)))) v4 ((fun v5 : 1 * 2 ^ v1 == 2 ^ v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up (1 * 2 ^ v1)) (log2_up (2 ^ v1)) (log2_up_wd (1 * 2 ^ v1) (2 ^ v1) v5) (v1 + log2_up 1) (v1 + log2_up 1) (eq_proper_proxy (v1 + log2_up 1))) (mul_1_l (2 ^ v1)) ((fun v5 : log2_up 1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v1 + log2_up 1) (v1 + 0) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) (log2_up 1) 0 v5)) (@log2_up_1) ((fun v5 : v1 + 0 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v1 + 0) v1 v5) (add_0_r v1) ((fun v5 : log2_up (2 ^ v1) == v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up (2 ^ v1)) v1 v5 v1 v1 (eq_proper_proxy v1)) (log2_up_pow2 v1 v3) (reflexivity v1)))))) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_double	100	0.837722	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => (fun v2 : 2 ^ 1 == 2 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (v0 * 2 ^ 1) == 1 + log2_up v0) (log2_up (v0 * 2) == 1 + log2_up v0) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (v0 * 2 ^ 1)) (log2_up (v0 * 2)) (log2_up_wd (v0 * 2 ^ 1) (v0 * 2) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (2 ^ 1) 2 v2)) (1 + log2_up v0) (1 + log2_up v0) (reflexive_proper_proxy Equivalence_Reflexive (1 + log2_up v0))) (log2_up (2 * v0) == S (log2_up v0)) (log2_up (2 * v0) == S (log2_up v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (2 * v0) == S (log2_up v0)))) (pow_1_r 2) ((fun v2 : 1 + log2_up v0 == S (log2_up v0) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (v0 * 2) == 1 + log2_up v0) (log2_up (v0 * 2) == S (log2_up v0)) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (1 + log2_up v0) (S (log2_up v0)) v2) (log2_up (2 * v0) == S (log2_up v0)) (log2_up (2 * v0) == S (log2_up v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (2 * v0) == S (log2_up v0)))) (add_1_l (log2_up v0)) ((fun v2 : 2 == S 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (v0 * 2) == S (log2_up v0)) (log2_up (v0 * S 1) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (v0 * 2)) (log2_up (v0 * S 1)) (log2_up_wd (v0 * 2) (v0 * S 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) 2 (S 1) v2)) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up (2 * v0) == S (log2_up v0)) (log2_up (S 1 * v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (2 * v0)) (log2_up (S 1 * v0)) (log2_up_wd (2 * v0) (S 1 * v0) (mul_wd 2 (S 1) v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0))))) (@two_succ) ((fun v2 : 1 == S 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (v0 * S 1) == S (log2_up v0)) (log2_up (v0 * S (S 0)) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (v0 * S 1)) (log2_up (v0 * S (S 0))) (log2_up_wd (v0 * S 1) (v0 * S (S 0)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (S 1) (S (S 0)) (succ_wd 1 (S 0) v2))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up (S 1 * v0) == S (log2_up v0)) (log2_up (S (S 0) * v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (S 1 * v0)) (log2_up (S (S 0) * v0)) (log2_up_wd (S 1 * v0) (S (S 0) * v0) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v2) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0))))) (@one_succ) ((fun v2 : v0 * S (S 0) == v0 * S 0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (v0 * S (S 0)) == S (log2_up v0)) (log2_up (v0 * S 0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (v0 * S (S 0))) (log2_up (v0 * S 0 + v0)) (log2_up_wd (v0 * S (S 0)) (v0 * S 0 + v0) v2) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up (S (S 0) * v0) == S (log2_up v0)) (log2_up (S (S 0) * v0) == S (log2_up v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (S (S 0) * v0) == S (log2_up v0)))) (mul_succ_r v0 (S 0)) ((fun v2 : v0 * S 0 == v0 * 0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (v0 * S 0 + v0) == S (log2_up v0)) (log2_up (v0 * 0 + v0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (v0 * S 0 + v0)) (log2_up (v0 * 0 + v0 + v0)) (log2_up_wd (v0 * S 0 + v0) (v0 * 0 + v0 + v0) (add_wd (v0 * S 0) (v0 * 0 + v0) v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up (S (S 0) * v0) == S (log2_up v0)) (log2_up (S (S 0) * v0) == S (log2_up v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (S (S 0) * v0) == S (log2_up v0)))) (mul_succ_r v0 0) ((fun v2 : v0 * 0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (v0 * 0 + v0 + v0) == S (log2_up v0)) (log2_up (0 + v0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (v0 * 0 + v0 + v0)) (log2_up (0 + v0 + v0)) (log2_up_wd (v0 * 0 + v0 + v0) (0 + v0 + v0) (add_wd (v0 * 0 + v0) (0 + v0) (add_wd (v0 * 0) 0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up (S (S 0) * v0) == S (log2_up v0)) (log2_up (S (S 0) * v0) == S (log2_up v0)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (S (S 0) * v0) == S (log2_up v0)))) (mul_0_r v0) ((fun v2 : S (S 0) * v0 == S 0 * v0 + v0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (0 + v0 + v0) == S (log2_up v0))) (log2_up (S (S 0) * v0) == S (log2_up v0)) (log2_up (S 0 * v0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (S (S 0) * v0)) (log2_up (S 0 * v0 + v0)) (log2_up_wd (S (S 0) * v0) (S 0 * v0 + v0) v2) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0))))) (mul_succ_l (S 0) v0) ((fun v2 : S 0 * v0 == 0 * v0 + v0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (0 + v0 + v0) == S (log2_up v0))) (log2_up (S 0 * v0 + v0) == S (log2_up v0)) (log2_up (0 * v0 + v0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (S 0 * v0 + v0)) (log2_up (0 * v0 + v0 + v0)) (log2_up_wd (S 0 * v0 + v0) (0 * v0 + v0 + v0) (add_wd (S 0 * v0) (0 * v0 + v0) v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0))))) (mul_succ_l 0 v0) ((fun v2 : 0 * v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (log2_up (0 + v0 + v0) == S (log2_up v0))) (log2_up (0 * v0 + v0 + v0) == S (log2_up v0)) (log2_up (0 + v0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (0 * v0 + v0 + v0)) (log2_up (0 + v0 + v0)) (log2_up_wd (0 * v0 + v0 + v0) (0 + v0 + v0) (add_wd (0 * v0 + v0) (0 + v0) (add_wd (0 * v0) 0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0))))) (mul_0_l v0) ((fun v2 : 0 + v0 == v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (log2_up (0 + v0 + v0) == S (log2_up v0)) (log2_up (v0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (0 + v0 + v0)) (log2_up (v0 + v0)) (log2_up_wd (0 + v0 + v0) (v0 + v0) (add_wd (0 + v0) v0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up (0 + v0 + v0) == S (log2_up v0)) (log2_up (v0 + v0) == S (log2_up v0)) (PER_morphism (Equivalence_PER (@eq_equiv)) (log2_up (0 + v0 + v0)) (log2_up (v0 + v0)) (log2_up_wd (0 + v0 + v0) (v0 + v0) (add_wd (0 + v0) v0 v2 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0))))) (add_0_l v0) (fun v2 : log2_up (v0 + v0) == S (log2_up v0) => v2))))))))))) (log2_up_mul_pow2 v0 1 v1 (@le_0_1)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_same	100	0.099289	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 < v1) (v4 : log2_up v0 == log2_up v1) => log2_up_lt_cancel v0 (2 * v1) ((fun v5 : log2_up (2 * v1) == S (log2_up v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0)) (log2_up (2 * v1)) (S (log2_up v1)) v5) (log2_up_double v1 v3) ((fun v5 : log2_up v0 == log2_up v1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up v0) (log2_up v1) v5 (S (log2_up v1)) (S (log2_up v1)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v1)))) v4 (lt_succ_diag_r (log2_up v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_succ_le	100	0.832408	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 1 < v0 \/ 1 == v0 \/ v0 < 1 := lt_trichotomy 1 v0 in match v1 as v2 in (_ \/ _) return (log2_up (S v0) <= S (log2_up v0)) with | or_introl v2 => (fun v2 : 1 < v0 => (fun v3 : log2_up (S v0) == S (log2 (P (S v0))) => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (S v0)) (S (log2 (P (S v0)))) v3 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up_eqn (S v0) (let v3 : forall (v3 v4 : @t) (v5 : v3 <= v4), v3 < S v4 := fun v3 v4 : @t => match lt_succ_r v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 <= v4, v3 < S v4) with | conj v5 v6 => (fun (v5 : forall v5 : v3 < S v4, v3 <= v4) (v6 : forall v6 : v3 <= v4, v3 < S v4) => v6) v5 v6 end in v3 1 v0 (Private_OrderTac.Tac.not_gt_le ((fun v4 : v0 < 1 => (fun v5 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v5) (Private_OrderTac.Tac.lt_trans v2 v4)) : ~ v0 < 1)))) ((fun v3 : log2_up v0 == S (log2 (P v0)) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 (P (S v0))))) (S (log2_up v0)) (S (S (log2 (P v0)))) (succ_wd (log2_up v0) (S (log2 (P v0))) v3)) (log2_up_eqn v0 v2) ((fun v3 : P (S v0) == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (S (log2 (P (S v0)))) (S (log2 v0)) (succ_wd (log2 (P (S v0))) (log2 v0) (log2_wd (P (S v0)) v0 v3)) (S (S (log2 (P v0)))) (S (S (log2 (P v0)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S (log2 (P v0)))))) (pred_succ v0) ((fun v3 : log2 v0 <= S (log2 (P v0)) <-> S (log2 v0) <= S (S (log2 (P v0))) => iff_flip_impl_subrelation (S (log2 v0) <= S (S (log2 (P v0)))) (log2 v0 <= S (log2 (P v0))) (symmetry v3)) (succ_le_mono (log2 v0) (S (log2 (P v0)))) ((fun v3 : S (P v0) == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2 v0) (log2 (S (P v0))) (log2_wd v0 (S (P v0)) (symmetry v3)) (S (log2 (P v0))) (S (log2 (P v0))) (reflexive_proper_proxy Equivalence_Reflexive (S (log2 (P v0))))) (lt_succ_pred 1 v0 v2) (log2_succ_le (P v0))))))) v2 | or_intror v2 => (fun v2 : 1 == v0 \/ v0 < 1 => match v2 as v3 in (_ \/ _) return (log2_up (S v0) <= S (log2_up v0)) with | or_introl v3 => (fun v3 : 1 == v0 => (fun v4 : 1 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (S v0)) (log2_up (S 1)) (log2_up_wd (S v0) (S 1) (succ_wd v0 1 (symmetry v4))) (S (log2_up v0)) (S (log2_up 1)) (succ_wd (log2_up v0) (log2_up 1) (log2_up_wd v0 1 (symmetry v4)))) v3 ((fun v4 : 2 == S 1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (S 1)) (log2_up 2) (log2_up_wd (S 1) 2 (symmetry v4)) (S (log2_up 1)) (S (log2_up 1)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up 1)))) (@two_succ) ((fun v4 : log2_up 1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up 2)) (S (log2_up 1)) (S 0) (succ_wd (log2_up 1) 0 v4)) (@log2_up_1) ((fun v4 : log2_up 2 == 1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up 2) 1 v4 (S 0) (S 0) (reflexive_proper_proxy Equivalence_Reflexive (S 0))) (@log2_up_2) ((fun v4 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (S 0) v4 (S 0) (S 0) (reflexive_proper_proxy Equivalence_Reflexive (S 0))) (@one_succ) (reflexivity (S 0))))))) v3 | or_intror v3 => (fun v3 : v0 < 1 => (fun v4 : log2_up (S v0) == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (S v0)) 0 v4 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (log2_up_eqn0 (S v0) ((fun v4 : S v0 <= 1 <-> v0 < 1 => iff_flip_impl_subrelation (S v0 <= 1) (v0 < 1) v4) (le_succ_l v0 1) v3)) ((fun v4 : log2_up v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (S (log2_up v0)) (S 0) (succ_wd (log2_up v0) 0 v4)) (log2_up_eqn0 v0 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : 1 < v0 => (fun v7 : 0 < v0 => (fun v8 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.lt_trans v3 v6)) (Private_OrderTac.Tac.lt_trans v4 v6)) : ~ 1 < v0)) (@lt_0_1) (@lt_1_2))) (le_le_succ_r 0 0 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.le_refl 0) (@lt_0_1) (@lt_1_2))))) v3 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_succ_or	100	0.176044	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : log2_up (S v0) <= log2_up v0 \/ log2_up v0 < log2_up (S v0) := le_gt_cases (log2_up (S v0)) (log2_up v0) in match v1 as v2 in (_ \/ _) return (log2_up (S v0) == S (log2_up v0) \/ log2_up (S v0) == log2_up v0) with | or_introl v2 => (fun v2 : log2_up (S v0) <= log2_up v0 => or_intror ((fun v3 : log2_up v0 <= log2_up (S v0) => Private_OrderTac.Tac.not_neq_eq ((fun v4 : log2_up (S v0) ~= log2_up v0 => (fun v5 : log2_up (S v0) == log2_up v0 => (fun v6 : log2_up v0 ~= log2_up v0 => v6 (Private_OrderTac.Tac.eq_refl (log2_up v0))) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v5) v4)) (Private_OrderTac.Tac.le_antisym v2 v3)) : ~ log2_up (S v0) ~= log2_up v0)) (log2_up_le_mono v0 (S v0) (le_succ_diag_r v0)))) v2 | or_intror v2 => (fun v2 : log2_up v0 < log2_up (S v0) => or_introl (let v3 : forall (v3 v4 : @t) (v5 : v3 < v4), S v3 <= v4 := fun v3 v4 : @t => match le_succ_l v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 < v4, S v3 <= v4) with | conj v5 v6 => (fun (v5 : forall v5 : S v3 <= v4, v3 < v4) (v6 : forall v6 : v3 < v4, S v3 <= v4) => v6) v5 v6 end in let v4 : S (log2_up v0) <= log2_up (S v0) := v3 (log2_up v0) (log2_up (S v0)) v2 in (fun v5 : log2_up (S v0) <= S (log2_up v0) => Private_OrderTac.Tac.not_neq_eq ((fun v6 : log2_up (S v0) ~= S (log2_up v0) => (fun v7 : S (log2_up v0) == log2_up (S v0) => (fun v8 : log2_up (S v0) ~= log2_up (S v0) => v8 (Private_OrderTac.Tac.eq_refl (log2_up (S v0)))) (Private_OrderTac.Tac.neq_eq v6 v7)) (Private_OrderTac.Tac.le_antisym v4 v5)) : ~ log2_up (S v0) ~= S (log2_up v0))) (log2_up_succ_le v0))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_eq_succ_is_pow2	100	0.663144	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : log2_up (S v0) == S (log2_up v0)) => let v2 : v0 <= 0 \/ 0 < v0 := le_gt_cases v0 0 in match v2 as v3 in (_ \/ _) return (exists v4 : @t, v0 == 2 ^ v4) with | or_introl v3 => (fun v3 : v0 <= 0 => (fun v4 : 0 < S 0 => False_ind (exists v5 : @t, v0 == 2 ^ v5) ((fun v5 : S 0 < S 0 => (fun v6 : v0 <= S 0 => Private_OrderTac.Tac.lt_irrefl v5) (Private_OrderTac.Tac.le_eq v3 ((fun v6 : log2_up v0 == 0 => trans_co_impl_morphism Equivalence_Transitive (S (log2_up v0)) (S 0) (succ_wd (log2_up v0) 0 v6)) (proj2 (log2_up_null v0) ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v8 : 1 < v0 => (fun v9 : S (log2_up v0) < 1 => (fun v10 : v0 <= S (log2_up v0) => (fun v11 : S (log2_up v0) < v0 => (fun v12 : S (log2_up v0) < 2 => (fun v13 : v0 < 2 => (fun v14 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.le_lt_trans v10 v11)) (Private_OrderTac.Tac.le_lt_trans v10 v12)) (Private_OrderTac.Tac.lt_trans v9 v7)) (Private_OrderTac.Tac.lt_trans v9 v8)) (Private_OrderTac.Tac.le_eq v3 ((fun v10 : log2_up (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2_up (S v0)) 0 v10 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (proj2 (log2_up_null (S v0)) (let v10 : forall (v10 v11 : @t) (v12 : v10 < v11), S v10 <= v11 := fun v10 v11 : @t => match le_succ_l v10 v11 as v12 in (_ /\ _) return (forall v13 : v10 < v11, S v10 <= v11) with | conj v12 v13 => (fun (v12 : forall v12 : S v10 <= v11, v10 < v11) (v13 : forall v13 : v10 < v11, S v10 <= v11) => v13) v12 v13 end in v10 v0 1 ((fun (v11 : 0 < 1) (v12 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v13 : 1 <= v0 => (fun v14 : 0 < 2 => (fun v15 : v0 < 2 => (fun v16 : v0 < 1 => (fun v17 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v13 v16)) (Private_OrderTac.Tac.le_lt_trans v3 v11)) (Private_OrderTac.Tac.le_lt_trans v3 v14)) (Private_OrderTac.Tac.lt_trans v11 v12)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1))) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v9 : log2_up (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2_up (S v0)) 0 v9 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (proj2 (log2_up_null (S v0)) (let v9 : forall (v9 v10 : @t) (v11 : v9 < v10), S v9 <= v10 := fun v9 v10 : @t => match le_succ_l v9 v10 as v11 in (_ /\ _) return (forall v12 : v9 < v10, S v9 <= v10) with | conj v11 v12 => (fun (v11 : forall v11 : S v9 <= v10, v9 < v10) (v12 : forall v12 : v9 < v10, S v9 <= v10) => v12) v11 v12 end in v9 v0 1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : 1 <= v0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v12 v15)) (Private_OrderTac.Tac.le_lt_trans v3 v10)) (Private_OrderTac.Tac.le_lt_trans v3 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1)) v6)) : ~ 1 < v0)) (@lt_0_1) (@lt_1_2))) ((fun v6 : log2_up (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2_up (S v0)) 0 v6 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (proj2 (log2_up_null (S v0)) (let v6 : forall (v6 v7 : @t) (v8 : v6 < v7), S v6 <= v7 := fun v6 v7 : @t => match le_succ_l v6 v7 as v8 in (_ /\ _) return (forall v9 : v6 < v7, S v6 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : S v6 <= v7, v6 < v7) (v9 : forall v9 : v6 < v7, S v6 <= v7) => v9) v8 v9 end in v6 v0 1 ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : 1 <= v0 => (fun v10 : 0 < 2 => (fun v11 : v0 < 2 => (fun v12 : v0 < 1 => (fun v13 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v9 v12)) (Private_OrderTac.Tac.le_lt_trans v3 v7)) (Private_OrderTac.Tac.le_lt_trans v3 v10)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1)))) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v5 : log2_up v0 == 0 => trans_co_impl_morphism Equivalence_Transitive (S (log2_up v0)) (S 0) (succ_wd (log2_up v0) 0 v5)) (proj2 (log2_up_null v0) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : 1 < v0 => (fun v8 : S (log2_up v0) < 1 => (fun v9 : v0 <= S (log2_up v0) => (fun v10 : S (log2_up v0) < v0 => (fun v11 : S (log2_up v0) < 2 => (fun v12 : v0 < 2 => (fun v13 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v9 v10)) (Private_OrderTac.Tac.le_lt_trans v9 v11)) (Private_OrderTac.Tac.lt_trans v8 v6)) (Private_OrderTac.Tac.lt_trans v8 v7)) (Private_OrderTac.Tac.le_eq v3 ((fun v9 : log2_up (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2_up (S v0)) 0 v9 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (proj2 (log2_up_null (S v0)) (let v9 : forall (v9 v10 : @t) (v11 : v9 < v10), S v9 <= v10 := fun v9 v10 : @t => match le_succ_l v9 v10 as v11 in (_ /\ _) return (forall v12 : v9 < v10, S v9 <= v10) with | conj v11 v12 => (fun (v11 : forall v11 : S v9 <= v10, v9 < v10) (v12 : forall v12 : v9 < v10, S v9 <= v10) => v12) v11 v12 end in v9 v0 1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : 1 <= v0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v12 v15)) (Private_OrderTac.Tac.le_lt_trans v3 v10)) (Private_OrderTac.Tac.le_lt_trans v3 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1))) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v8 : log2_up (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2_up (S v0)) 0 v8 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (proj2 (log2_up_null (S v0)) (let v8 : forall (v8 v9 : @t) (v10 : v8 < v9), S v8 <= v9 := fun v8 v9 : @t => match le_succ_l v8 v9 as v10 in (_ /\ _) return (forall v11 : v8 < v9, S v8 <= v9) with | conj v10 v11 => (fun (v10 : forall v10 : S v8 <= v9, v8 < v9) (v11 : forall v11 : v8 < v9, S v8 <= v9) => v11) v10 v11 end in v8 v0 1 ((fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v11 : 1 <= v0 => (fun v12 : 0 < 2 => (fun v13 : v0 < 2 => (fun v14 : v0 < 1 => (fun v15 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v11 v14)) (Private_OrderTac.Tac.le_lt_trans v3 v9)) (Private_OrderTac.Tac.le_lt_trans v3 v12)) (Private_OrderTac.Tac.lt_trans v9 v10)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1)) v5)) : ~ 1 < v0)) (@lt_0_1) (@lt_1_2))) ((fun v5 : log2_up (S v0) == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (log2_up (S v0)) 0 v5 (S (log2_up v0)) (S (log2_up v0)) (reflexive_proper_proxy Equivalence_Reflexive (S (log2_up v0)))) (proj2 (log2_up_null (S v0)) (let v5 : forall (v5 v6 : @t) (v7 : v5 < v6), S v5 <= v6 := fun v5 v6 : @t => match le_succ_l v5 v6 as v7 in (_ /\ _) return (forall v8 : v5 < v6, S v5 <= v6) with | conj v7 v8 => (fun (v7 : forall v7 : S v5 <= v6, v5 < v6) (v8 : forall v8 : v5 < v6, S v5 <= v6) => v8) v7 v8 end in v5 v0 1 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : 1 <= v0 => (fun v9 : 0 < 2 => (fun v10 : v0 < 2 => (fun v11 : v0 < 1 => (fun v12 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v8 v11)) (Private_OrderTac.Tac.le_lt_trans v3 v6)) (Private_OrderTac.Tac.le_lt_trans v3 v9)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ 1 <= v0)) (@lt_0_1) (@lt_1_2)))) v1))) v4))) (lt_succ_diag_r 0)) v3 | or_intror v3 => (fun v3 : 0 < v0 => let v4 : 1 < S v0 := (fun v4 : 1 == S 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (S 0) v4 (S v0) (S v0) (reflexive_proper_proxy Equivalence_Reflexive (S v0))) (@one_succ) ((fun v4 : 0 < v0 <-> S 0 < S v0 => iff_flip_impl_subrelation (S 0 < S v0) (0 < v0) (symmetry v4)) (succ_lt_mono 0 v0) v3) in ex_intro (fun v5 : @t => v0 == 2 ^ v5) (log2_up v0) ((fun v5 : log2_up (S v0) == S (log2_up v0) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ P (log2_up (S v0)) < S v0) (2 ^ P (S (log2_up v0)) < S v0) (lt_wd (2 ^ P (log2_up (S v0))) (2 ^ P (S (log2_up v0))) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (P (log2_up (S v0))) (P (S (log2_up v0))) (pred_wd (log2_up (S v0)) (S (log2_up v0)) v5)) (S v0) (S v0) (reflexive_proper_proxy Equivalence_Reflexive (S v0))) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0) (reflexive_proper_proxy (@iff_Reflexive) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0))) v1 ((fun v5 : P (S (log2_up v0)) == log2_up v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ P (S (log2_up v0)) < S v0) (2 ^ log2_up v0 < S v0) (lt_wd (2 ^ P (S (log2_up v0))) (2 ^ log2_up v0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 2) (P (S (log2_up v0))) (log2_up v0) v5) (S v0) (S v0) (reflexive_proper_proxy Equivalence_Reflexive (S v0))) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0) (reflexive_proper_proxy (@iff_Reflexive) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0))) (pred_succ (log2_up v0)) ((fun v5 : 2 ^ log2_up v0 < S v0 <-> 2 ^ log2_up v0 <= v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 ^ log2_up v0 < S v0) (2 ^ log2_up v0 <= v0) v5 (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0) (reflexive_proper_proxy (@iff_Reflexive) (forall v6 : v0 <= 2 ^ log2_up v0, v0 == 2 ^ log2_up v0))) (lt_succ_r (2 ^ log2_up v0) v0) (fun (v5 : 2 ^ log2_up v0 <= v0) (v6 : v0 <= 2 ^ log2_up v0) => Private_OrderTac.Tac.not_neq_eq ((fun v7 : v0 ~= 2 ^ log2_up v0 => (fun v8 : 2 ^ log2_up v0 == v0 => (fun v9 : v0 ~= v0 => v9 (Private_OrderTac.Tac.eq_refl v0)) (Private_OrderTac.Tac.neq_eq v7 v8)) (Private_OrderTac.Tac.le_antisym v5 v6)) : ~ v0 ~= 2 ^ log2_up v0)))) (proj1 (log2_up_spec (S v0) v4)) (proj2 (log2_log2_up_spec v0 v3)))) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_eq_succ_iff_pow2	100	0.217933	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => conj (log2_up_eq_succ_is_pow2 v0) (fun v2 : exists v2 : @t, v0 == 2 ^ v2 => match v2 as v3 in (ex _) return (log2_up (S v0) == S (log2_up v0)) with | ex_intro _ v3 v4 => (fun (v3 : @t) (v4 : v0 == 2 ^ v3) => let v5 : v3 < 0 \/ 0 <= v3 := lt_ge_cases v3 0 in match v5 as v6 in (_ \/ _) return (log2_up (S v0) == S (log2_up v0)) with | or_introl v6 => (fun v6 : v3 < 0 => Private_OrderTac.Tac.not_neq_eq ((fun v7 : log2_up (S v0) ~= S (log2_up v0) => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.lt_eq v1 ((fun v8 : 2 ^ v3 == 0 => trans_co_impl_morphism Equivalence_Transitive (2 ^ v3) 0 v8) (pow_neg_r 2 v3 (Private_OrderTac.Tac.not_ge_lt ((fun v8 : 0 <= v3 => (fun v9 : 0 < 2 ^ v3 => (fun v10 : v3 < 2 ^ v3 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v8 v6)) (Private_OrderTac.Tac.lt_trans v6 v9)) (Private_OrderTac.Tac.lt_eq v1 v4)) : ~ 0 <= v3))) v4))) : ~ log2_up (S v0) ~= S (log2_up v0))) v6 | or_intror v6 => (fun v6 : 0 <= v3 => (fun v7 : v0 == 2 ^ v3 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (log2_up (S v0)) (log2_up (S (2 ^ v3))) (log2_up_wd (S v0) (S (2 ^ v3)) (succ_wd v0 (2 ^ v3) v7)) (S (log2_up v0)) (S (log2_up (2 ^ v3))) (succ_wd (log2_up v0) (log2_up (2 ^ v3)) (log2_up_wd v0 (2 ^ v3) v7))) v4 ((fun v7 : log2_up (2 ^ v3) == v3 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (S (log2_up (2 ^ v3))) (S v3) (succ_wd (log2_up (2 ^ v3)) v3 v7)) (log2_up_pow2 v3 ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v9 : v3 < 0 => (fun v10 : 0 < 2 ^ v3 => (fun v11 : v3 < 2 ^ v3 => (fun v12 : 0 < 2 => (fun v13 : v3 < 2 => (fun v14 : v3 < 1 => (fun v15 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v6 v9)) (Private_OrderTac.Tac.lt_trans v9 v7)) (Private_OrderTac.Tac.lt_trans v9 v12)) (Private_OrderTac.Tac.lt_trans v7 v8)) (Private_OrderTac.Tac.lt_trans v9 v10)) (Private_OrderTac.Tac.lt_eq v1 v4)) : ~ v3 < 0)) (@lt_0_1) (@lt_1_2))) ((fun v7 : log2_up (S (2 ^ v3)) == S v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up (S (2 ^ v3))) (S v3) v7 (S v3) (S v3) (eq_proper_proxy (S v3))) (log2_up_succ_pow2 v3 v6) (reflexivity (S v3))))) v6 end) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_succ_double	100	0.298877	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => (fun v2 : log2_up (2 * v0 + 1) == S (log2 (P (2 * v0 + 1))) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (log2_up (2 * v0 + 1)) (S (log2 (P (2 * v0 + 1)))) v2 (2 + log2 v0) (2 + log2 v0) (eq_proper_proxy (2 + log2 v0))) (log2_up_eqn (2 * v0 + 1) (le_lt_trans 1 (0 + 1) (2 * v0 + 1) ((fun v2 : 0 + 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (0 + 1) (S 0) v2) (add_1_r 0) ((fun v2 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (S 0) v2 (S 0) (S 0) (reflexive_proper_proxy Equivalence_Reflexive (S 0))) (@one_succ) (reflexivity (S 0)))) (let v2 : forall (v2 v3 v4 : @t) (v5 : v2 < v3), v2 + v4 < v3 + v4 := fun v2 v3 v4 : @t => match add_lt_mono_r v2 v3 v4 as v5 in (_ /\ _) return (forall v6 : v2 < v3, v2 + v4 < v3 + v4) with | conj v5 v6 => (fun (v5 : forall v5 : v2 < v3, v2 + v4 < v3 + v4) (v6 : forall v6 : v2 + v4 < v3 + v4, v2 < v3) => v5) v5 v6 end in v2 0 (2 * v0) 1 (mul_pos_pos 2 v0 ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v5 : 2 <= 0 => (fun v6 : 0 < 2 => (fun v7 : 2 < 2 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v5 v6)) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ 2 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v3 : 0 < 1) (v4 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v5 : v0 <= 0 => (fun v6 : 0 < 2 => (fun v7 : v0 < 2 => (fun v8 : v0 < 1 => (fun v9 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v5 v1)) (Private_OrderTac.Tac.le_lt_trans v5 v3)) (Private_OrderTac.Tac.le_lt_trans v5 v6)) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)))))) ((fun v2 : 2 * v0 + 1 == S (2 * v0) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S (log2 (P (2 * v0 + 1)))) (S (log2 (P (S (2 * v0))))) (succ_wd (log2 (P (2 * v0 + 1))) (log2 (P (S (2 * v0)))) (log2_wd (P (2 * v0 + 1)) (P (S (2 * v0))) (pred_wd (2 * v0 + 1) (S (2 * v0)) v2))) (2 + log2 v0) (2 + log2 v0) (eq_proper_proxy (2 + log2 v0))) (add_1_r (2 * v0)) ((fun v2 : P (S (2 * v0)) == 2 * v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S (log2 (P (S (2 * v0))))) (S (log2 (2 * v0))) (succ_wd (log2 (P (S (2 * v0)))) (log2 (2 * v0)) (log2_wd (P (S (2 * v0))) (2 * v0) v2)) (2 + log2 v0) (2 + log2 v0) (eq_proper_proxy (2 + log2 v0))) (pred_succ (2 * v0)) ((fun v2 : log2 (2 * v0) == S (log2 v0) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (S (log2 (2 * v0))) (S (S (log2 v0))) (succ_wd (log2 (2 * v0)) (S (log2 v0)) v2) (2 + log2 v0) (2 + log2 v0) (eq_proper_proxy (2 + log2 v0))) (log2_double v0 v1) ((fun v2 : 2 == S 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (2 + log2 v0) (S 1 + log2 v0) (add_wd 2 (S 1) v2 (log2 v0) (log2 v0) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0)))) (@two_succ) ((fun v2 : 1 == S 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (S 1 + log2 v0) (S (S 0) + log2 v0) (add_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v2) (log2 v0) (log2 v0) (reflexive_proper_proxy Equivalence_Reflexive (log2 v0)))) (@one_succ) ((fun v2 : S (S 0) + log2 v0 == S (S 0 + log2 v0) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (S (S 0) + log2 v0) (S (S 0 + log2 v0)) v2) (add_succ_l (S 0) (log2 v0)) ((fun v2 : S 0 + log2 v0 == S (0 + log2 v0) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (S (S 0 + log2 v0)) (S (S (0 + log2 v0))) (succ_wd (S 0 + log2 v0) (S (0 + log2 v0)) v2)) (add_succ_l 0 (log2 v0)) ((fun v2 : 0 + log2 v0 == log2 v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (S (S (0 + log2 v0))) (S (S (log2 v0))) (succ_wd (S (0 + log2 v0)) (S (log2 v0)) (succ_wd (0 + log2 v0) (log2 v0) v2))) (add_0_l (log2 v0)) (reflexivity (S (S (log2 v0)))))))))))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.log2_up_add_le	100	0.625003	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : v0 ~= 1) (v3 : v1 ~= 1) => let v4 : v0 < 1 \/ v0 == 1 \/ 1 < v0 := lt_trichotomy v0 1 in match v4 as v5 in (_ \/ _) return (log2_up (v0 + v1) <= log2_up v0 + log2_up v1) with | or_introl v5 => (fun v5 : v0 < 1 => (fun v6 : log2_up v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))) (log2_up v0 + log2_up v1) (0 + log2_up v1) (add_wd (log2_up v0) 0 v6 (log2_up v1) (log2_up v1) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v1)))) (log2_up_eqn0 v0 (Private_OrderTac.Tac.not_gt_le ((fun v6 : 1 < v0 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ 1 < v0))) ((fun v6 : 0 + log2_up v1 == log2_up v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))) (0 + log2_up v1) (log2_up v1) v6) (add_0_l (log2_up v1)) (log2_up_le_mono (v0 + v1) v1 ((fun v6 : 0 + v1 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) v1 (0 + v1) (symmetry v6)) (add_0_l v1) (add_le_mono v0 0 v1 v1 ((fun v6 : v0 < S 0 <-> v0 <= 0 => iff_impl_subrelation (v0 < S 0) (v0 <= 0) v6) (lt_succ_r v0 0) ((fun v6 : 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) 1 (S 0) v6) (@one_succ) v5)) (reflexivity v1)))))) v5 | or_intror v5 => (fun v5 : v0 == 1 \/ 1 < v0 => match v5 as v6 in (_ \/ _) return (log2_up (v0 + v1) <= log2_up v0 + log2_up v1) with | or_introl v6 => (fun v6 : v0 == 1 => Private_OrderTac.Tac.not_gt_le ((fun v7 : log2_up v0 + log2_up v1 < log2_up (v0 + v1) => (fun v8 : 1 ~= 1 => v8 (Private_OrderTac.Tac.eq_refl 1)) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v6) v2)) : ~ log2_up v0 + log2_up v1 < log2_up (v0 + v1))) v6 | or_intror v6 => (fun v6 : 1 < v0 => let v7 : v1 < 1 \/ v1 == 1 \/ 1 < v1 := lt_trichotomy v1 1 in match v7 as v8 in (_ \/ _) return (log2_up (v0 + v1) <= log2_up v0 + log2_up v1) with | or_introl v8 => (fun v8 : v1 < 1 => (fun v9 : log2_up v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))) (log2_up v0 + log2_up v1) (log2_up v0 + 0) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0)) (log2_up v1) 0 v9)) (log2_up_eqn0 v1 (Private_OrderTac.Tac.not_gt_le ((fun v9 : 1 < v1 => (fun v10 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ 1 < v1))) ((fun v9 : log2_up v0 + 0 == log2_up v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))) (log2_up v0 + 0) (log2_up v0) v9) (add_0_r (log2_up v0)) (log2_up_le_mono (v0 + v1) v0 ((fun v9 : v0 + 0 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) v0 (v0 + 0) (symmetry v9)) (add_0_r v0) (add_le_mono v0 v0 v1 0 (reflexivity v0) ((fun v9 : v1 < S 0 <-> v1 <= 0 => iff_impl_subrelation (v1 < S 0) (v1 <= 0) v9) (lt_succ_r v1 0) ((fun v9 : 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v1) 1 (S 0) v9) (@one_succ) v8))))))) v8 | or_intror v8 => (fun v8 : v1 == 1 \/ 1 < v1 => match v8 as v9 in (_ \/ _) return (log2_up (v0 + v1) <= log2_up v0 + log2_up v1) with | or_introl v9 => (fun v9 : v1 == 1 => Private_OrderTac.Tac.not_gt_le ((fun v10 : log2_up v0 + log2_up v1 < log2_up (v0 + v1) => (fun v11 : 1 ~= 1 => v11 (Private_OrderTac.Tac.eq_refl 1)) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v9) v3)) : ~ log2_up v0 + log2_up v1 < log2_up (v0 + v1))) v9 | or_intror v9 => (fun v9 : 1 < v1 => transitivity (log2_up_le_mono (v0 + v1) (v0 * v1) (add_le_mul v0 v1 v6 v9)) (log2_up_mul_above v0 v1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v12 : v0 < 0 => (fun v13 : 1 < 0 => (fun v14 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.lt_trans v10 v13)) (Private_OrderTac.Tac.lt_trans v6 v12)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)) ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v12 : v1 < 0 => (fun v13 : 1 < 0 => (fun v14 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.lt_trans v10 v13)) (Private_OrderTac.Tac.lt_trans v9 v12)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)))) v9 end) v8 end) v6 end) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZLog.NZLog2UpProp.add_log2_up_lt	100	1.268505	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 < v1) => (fun v4 : 2 == S 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up v1)) (2 * log2_up (v0 + v1)) (S 1 * log2_up (v0 + v1)) (mul_wd 2 (S 1) v4 (log2_up (v0 + v1)) (log2_up (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))))) (@two_succ) ((fun v4 : 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up v1)) (S 1 * log2_up (v0 + v1)) (S (S 0) * log2_up (v0 + v1)) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v4) (log2_up (v0 + v1)) (log2_up (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))))) (@one_succ) ((fun v4 : S (S 0) * log2_up (v0 + v1) == S 0 * log2_up (v0 + v1) + log2_up (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up v1)) (S (S 0) * log2_up (v0 + v1)) (S 0 * log2_up (v0 + v1) + log2_up (v0 + v1)) v4) (mul_succ_l (S 0) (log2_up (v0 + v1))) ((fun v4 : S 0 * log2_up (v0 + v1) == 0 * log2_up (v0 + v1) + log2_up (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up v1)) (S 0 * log2_up (v0 + v1) + log2_up (v0 + v1)) (0 * log2_up (v0 + v1) + log2_up (v0 + v1) + log2_up (v0 + v1)) (add_wd (S 0 * log2_up (v0 + v1)) (0 * log2_up (v0 + v1) + log2_up (v0 + v1)) v4 (log2_up (v0 + v1)) (log2_up (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))))) (mul_succ_l 0 (log2_up (v0 + v1))) ((fun v4 : 0 * log2_up (v0 + v1) == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up v1)) (0 * log2_up (v0 + v1) + log2_up (v0 + v1) + log2_up (v0 + v1)) (0 + log2_up (v0 + v1) + log2_up (v0 + v1)) (add_wd (0 * log2_up (v0 + v1) + log2_up (v0 + v1)) (0 + log2_up (v0 + v1)) (add_wd (0 * log2_up (v0 + v1)) 0 v4 (log2_up (v0 + v1)) (log2_up (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1)))) (log2_up (v0 + v1)) (log2_up (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))))) (mul_0_l (log2_up (v0 + v1))) ((fun v4 : 0 + log2_up (v0 + v1) == log2_up (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up v1)) (0 + log2_up (v0 + v1) + log2_up (v0 + v1)) (log2_up (v0 + v1) + log2_up (v0 + v1)) (add_wd (0 + log2_up (v0 + v1)) (log2_up (v0 + v1)) v4 (log2_up (v0 + v1)) (log2_up (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))))) (add_0_l (log2_up (v0 + v1))) (let v4 : log2_up v0 <= log2_up (v0 + v1) := log2_up_le_mono v0 (v0 + v1) ((fun v4 : v0 + 0 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v0 (v0 + 0) (symmetry v4) (v0 + v1) (v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1))) (add_0_r v0) (add_le_mono v0 v0 0 v1 (Private_OrderTac.Tac.le_refl v0) (Private_OrderTac.Tac.not_gt_le ((fun v4 : v1 < 0 => (fun v5 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v5) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ v1 < 0)))) in let v5 : log2_up v1 <= log2_up (v0 + v1) := log2_up_le_mono v1 (v0 + v1) ((fun v5 : 0 + v1 == v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v1 (0 + v1) (symmetry v5) (v0 + v1) (v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1))) (add_0_l v1) (add_le_mono 0 v0 v1 v1 (Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v2 v5)) : ~ v0 < 0)) (Private_OrderTac.Tac.le_refl v1))) in match (fun v6 : log2_up v0 <= log2_up (v0 + v1) <-> log2_up v0 < log2_up (v0 + v1) \/ log2_up v0 == log2_up (v0 + v1) => iff_impl_subrelation (log2_up v0 <= log2_up (v0 + v1)) (log2_up v0 < log2_up (v0 + v1) \/ log2_up v0 == log2_up (v0 + v1)) v6) (lt_eq_cases (log2_up v0) (log2_up (v0 + v1))) v4 as v6 in (_ \/ _) return (log2_up v0 + log2_up v1 < log2_up (v0 + v1) + log2_up (v0 + v1)) with | or_introl v6 => (fun v6 : log2_up v0 < log2_up (v0 + v1) => lt_le_trans (log2_up v0 + log2_up v1) (log2_up (v0 + v1) + log2_up v1) (log2_up (v0 + v1) + log2_up (v0 + v1)) (let v7 : forall (v7 v8 v9 : @t) (v10 : v7 < v8), v7 + v9 < v8 + v9 := fun v7 v8 v9 : @t => match add_lt_mono_r v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 < v8, v7 + v9 < v8 + v9) with | conj v10 v11 => (fun (v10 : forall v10 : v7 < v8, v7 + v9 < v8 + v9) (v11 : forall v11 : v7 + v9 < v8 + v9, v7 < v8) => v10) v10 v11 end in v7 (log2_up v0) (log2_up (v0 + v1)) (log2_up v1) v6) (let v7 : forall (v7 v8 v9 : @t) (v10 : v7 <= v8), v9 + v7 <= v9 + v8 := fun v7 v8 v9 : @t => match add_le_mono_l v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 <= v8, v9 + v7 <= v9 + v8) with | conj v10 v11 => (fun (v10 : forall v10 : v7 <= v8, v9 + v7 <= v9 + v8) (v11 : forall v11 : v9 + v7 <= v9 + v8, v7 <= v8) => v10) v10 v11 end in v7 (log2_up v1) (log2_up (v0 + v1)) (log2_up (v0 + v1)) v5)) v6 | or_intror v6 => (fun v6 : log2_up v0 == log2_up (v0 + v1) => (fun v7 : log2_up v0 == log2_up (v0 + v1) => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (log2_up v0 + log2_up v1)) (log2_up (v0 + v1) + log2_up (v0 + v1)) (log2_up v0 + log2_up (v0 + v1)) (add_wd (log2_up (v0 + v1)) (log2_up v0) (symmetry v7) (log2_up (v0 + v1)) (log2_up (v0 + v1)) (reflexive_proper_proxy Equivalence_Reflexive (log2_up (v0 + v1))))) v6 (let v7 : forall (v7 v8 v9 : @t) (v10 : v7 < v8), v9 + v7 < v9 + v8 := fun v7 v8 v9 : @t => match add_lt_mono_l v7 v8 v9 as v10 in (_ /\ _) return (forall v11 : v7 < v8, v9 + v7 < v9 + v8) with | conj v10 v11 => (fun (v10 : forall v10 : v7 < v8, v9 + v7 < v9 + v8) (v11 : forall v11 : v9 + v7 < v9 + v8, v7 < v8) => v10) v10 v11 end in v7 (log2_up v1) (log2_up (v0 + v1)) (log2_up v0) match (fun v8 : log2_up v1 <= log2_up (v0 + v1) <-> log2_up v1 < log2_up (v0 + v1) \/ log2_up v1 == log2_up (v0 + v1) => iff_impl_subrelation (log2_up v1 <= log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1) \/ log2_up v1 == log2_up (v0 + v1)) v8) (lt_eq_cases (log2_up v1) (log2_up (v0 + v1))) v5 as v8 in (_ \/ _) return (log2_up v1 < log2_up (v0 + v1)) with | or_introl v8 => (fun v8 : log2_up v1 < log2_up (v0 + v1) => v8) v8 | or_intror v8 => (fun v8 : log2_up v1 == log2_up (v0 + v1) => let v9 : log2_up (v0 + v1) == log2_up v0 := symmetry v6 in let v10 : v0 + v1 < 2 * v0 := log2_up_same (v0 + v1) v0 (add_pos_pos v0 v1 ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v0 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : v0 < v1 => (fun v17 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v12 v2)) (Private_OrderTac.Tac.le_lt_trans v12 v3)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v1 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v1 < 2 => (fun v15 : v1 < 1 => (fun v16 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v12 v3)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun (v10 : 0 < 1) (v11 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v12 : v0 <= 0 => (fun v13 : 0 < 2 => (fun v14 : v0 < 2 => (fun v15 : v0 < 1 => (fun v16 : v0 < v1 => (fun v17 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v12 v2)) (Private_OrderTac.Tac.le_lt_trans v12 v3)) (Private_OrderTac.Tac.le_lt_trans v12 v10)) (Private_OrderTac.Tac.le_lt_trans v12 v13)) (Private_OrderTac.Tac.lt_trans v10 v11)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) v9 in let v11 : log2_up (v0 + v1) == log2_up v1 := symmetry v8 in let v12 : v0 + v1 < 2 * v1 := log2_up_same (v0 + v1) v1 (add_pos_pos v0 v1 ((fun (v12 : 0 < 1) (v13 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v14 : v0 <= 0 => (fun v15 : 0 < 2 => (fun v16 : v0 < 2 => (fun v17 : v0 < 1 => (fun v18 : v0 < v1 => (fun v19 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v19) (Private_OrderTac.Tac.le_lt_trans v14 v2)) (Private_OrderTac.Tac.le_lt_trans v14 v3)) (Private_OrderTac.Tac.le_lt_trans v14 v12)) (Private_OrderTac.Tac.le_lt_trans v14 v15)) (Private_OrderTac.Tac.lt_trans v12 v13)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v12 : 0 < 1) (v13 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v14 : v1 <= 0 => (fun v15 : 0 < 2 => (fun v16 : v1 < 2 => (fun v17 : v1 < 1 => (fun v18 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v14 v3)) (Private_OrderTac.Tac.le_lt_trans v14 v12)) (Private_OrderTac.Tac.le_lt_trans v14 v15)) (Private_OrderTac.Tac.lt_trans v12 v13)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2))) ((fun (v12 : 0 < 1) (v13 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v14 : v1 <= 0 => (fun v15 : 0 < 2 => (fun v16 : v1 < 2 => (fun v17 : v1 < 1 => (fun v18 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v14 v3)) (Private_OrderTac.Tac.le_lt_trans v14 v12)) (Private_OrderTac.Tac.le_lt_trans v14 v15)) (Private_OrderTac.Tac.lt_trans v12 v13)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2)) v11 in (fun v13 : 2 == S 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < 2 * v0) (v0 + v1 < S 1 * v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (2 * v0) (S 1 * v0) (mul_wd 2 (S 1) v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < 2 * v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < S 1 * v1, log2_up v1 < log2_up (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < 2 * v1) (v0 + v1 < S 1 * v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (2 * v1) (S 1 * v1) (mul_wd 2 (S 1) v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2_up v1 < log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up v1 < log2_up (v0 + v1))))) (@two_succ) ((fun v13 : 1 == S 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < S 1 * v0) (v0 + v1 < S (S 0) * v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 1 * v0) (S (S 0) * v0) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v13) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < S 1 * v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < S 1 * v1) (v0 + v1 < S (S 0) * v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 1 * v1) (S (S 0) * v1) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v13) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2_up v1 < log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up v1 < log2_up (v0 + v1))))) (@one_succ) ((fun v13 : S (S 0) * v0 == S 0 * v0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < S (S 0) * v0) (v0 + v1 < S 0 * v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S (S 0) * v0) (S 0 * v0 + v0) v13) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)))) (mul_succ_l (S 0) v0) ((fun v13 : S 0 * v0 == 0 * v0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < S 0 * v0 + v0) (v0 + v1 < 0 * v0 + v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 0 * v0 + v0) (0 * v0 + v0 + v0) (add_wd (S 0 * v0) (0 * v0 + v0) v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)))) (mul_succ_l 0 v0) ((fun v13 : S (S 0) * v1 == S 0 * v1 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < 0 * v0 + v0 + v0)) (forall v14 : v0 + v1 < S (S 0) * v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < S 0 * v1 + v1, log2_up v1 < log2_up (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < S (S 0) * v1) (v0 + v1 < S 0 * v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S (S 0) * v1) (S 0 * v1 + v1) v13) (log2_up v1 < log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up v1 < log2_up (v0 + v1))))) (mul_succ_l (S 0) v1) ((fun v13 : S 0 * v1 == 0 * v1 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < 0 * v0 + v0 + v0)) (forall v14 : v0 + v1 < S 0 * v1 + v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < S 0 * v1 + v1) (v0 + v1 < 0 * v1 + v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (S 0 * v1 + v1) (0 * v1 + v1 + v1) (add_wd (S 0 * v1) (0 * v1 + v1) v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2_up v1 < log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up v1 < log2_up (v0 + v1))))) (mul_succ_l 0 v1) ((fun v13 : 0 * v0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < 0 * v0 + v0 + v0) (v0 + v1 < 0 + v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 * v0 + v0 + v0) (0 + v0 + v0) (add_wd (0 * v0 + v0) (0 + v0) (add_wd (0 * v0) 0 v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2_up v1 < log2_up (v0 + v1)))) (mul_0_l v0) ((fun v13 : 0 * v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < 0 + v0 + v0)) (forall v14 : v0 + v1 < 0 * v1 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < 0 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < 0 * v1 + v1 + v1) (v0 + v1 < 0 + v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 * v1 + v1 + v1) (0 + v1 + v1) (add_wd (0 * v1 + v1) (0 + v1) (add_wd (0 * v1) 0 v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2_up v1 < log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up v1 < log2_up (v0 + v1))))) (mul_0_l v1) ((fun v13 : 0 + v0 == v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < 0 + v0 + v0) (v0 + v1 < v0 + v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 + v0 + v0) (v0 + v0) (add_wd (0 + v0) v0 v13 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0))) (forall v14 : v0 + v1 < 0 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < 0 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < 0 + v1 + v1, log2_up v1 < log2_up (v0 + v1)))) (add_0_l v0) ((fun v13 : 0 + v1 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 + v1 < v0 + v0)) (forall v14 : v0 + v1 < 0 + v1 + v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < v1 + v1, log2_up v1 < log2_up (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < 0 + v1 + v1) (v0 + v1 < v1 + v1) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) (0 + v1 + v1) (v1 + v1) (add_wd (0 + v1) v1 v13 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) (log2_up v1 < log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up v1 < log2_up (v0 + v1))))) (add_0_l v1) ((fun v13 : v1 < v0 <-> v0 + v1 < v0 + v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 + v1 < v0 + v0) (v1 < v0) (symmetry v13) (forall v14 : v0 + v1 < v1 + v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 + v1 < v1 + v1, log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (forall v14 : v0 + v1 < v1 + v1, log2_up v1 < log2_up (v0 + v1)))) (add_lt_mono_l v1 v0 v0) ((fun v13 : v0 < v1 <-> v0 + v1 < v1 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0)) (forall v14 : v0 + v1 < v1 + v1, log2_up v1 < log2_up (v0 + v1)) (forall v14 : v0 < v1, log2_up v1 < log2_up (v0 + v1)) (iff_iff_iff_impl_morphism (v0 + v1 < v1 + v1) (v0 < v1) (symmetry v13) (log2_up v1 < log2_up (v0 + v1)) (log2_up v1 < log2_up (v0 + v1)) (reflexive_proper_proxy (@iff_Reflexive) (log2_up v1 < log2_up (v0 + v1))))) (add_lt_mono_r v0 v1 v1) (fun (v13 : v1 < v0) (v14 : v0 < v1) => Private_OrderTac.Tac.not_ge_lt ((fun v15 : log2_up (v0 + v1) <= log2_up v1 => (fun v16 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.lt_trans v13 v14)) : ~ log2_up (v0 + v1) <= log2_up v1))))))))))))) v10 v12) v8 end)) v6 end)))))))).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelCompFun_Instances.RelCompFun_Reflexive	100	0.021288	2	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelCompFun_Instances.RelCompFun_Symmetric	100	0.015473	2	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelCompFun_Instances.RelCompFun_Transitive	100	0.020310	2	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelCompFun_Instances.RelCompFun_Irreflexive	100	0.020882	2	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.RelProd_Reflexive	100	0.016971	2	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.RelProd_Symmetric	100	0.022429	2	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.RelProd_Transitive	100	0.020181	2	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.FstRel_ProdRel	100	0.125614	1	1	0	synth with cache (only 1: refine ((fun v0 : @A * @B => (fun v1 : @A * @B => conj (fun v2 : (@RA @@1)%signature v0 v1 => conj v2 (@I)) (fun v2 : (@RA * (fun v2 v3 : @B => @True))%signature v0 v1 => and_ind (fun (v3 : (@RA @@1)%signature v0 v1) (v4 : ((fun v4 v5 : @B => @True) @@2)%signature v0 v1) => v3) v2)) : pointwise_lifting (@iff) (Tcons (@A * @B) (@Tnil)) ((@RA @@1)%signature v0) ((@RA * (fun v1 v2 : @B => @True))%signature v0)) : relation_equivalence (@RA @@1) (@RA * (fun v0 v1 : @B => @True)))).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.SndRel_ProdRel	100	0.111669	1	1	0	synth with cache (only 1: refine ((fun v0 : @A * @B => (fun v1 : @A * @B => conj (fun v2 : (@RB @@2)%signature v0 v1 => conj (@I) v2) (fun v2 : ((fun v2 v3 : @A => @True) * @RB)%signature v0 v1 => and_ind (fun (v3 : ((fun v3 v4 : @A => @True) @@1)%signature v0 v1) (v4 : (@RB @@2)%signature v0 v1) => v4) v2)) : pointwise_lifting (@iff) (Tcons (@A * @B) (@Tnil)) ((@RB @@2)%signature v0) (((fun v1 v2 : @A => @True) * @RB)%signature v0)) : relation_equivalence (@RB @@2) ((fun v0 v1 : @A => @True) * @RB))).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.FstRel_sub	100	0.077752	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @A * @B) (v2 : (@RA * @RB)%signature v0 v1) => and_ind (fun (v3 : (@RA @@1)%signature v0 v1) (v4 : (@RB @@2)%signature v0 v1) => v3) v2) : subrelation (@RA * @RB) (@RA @@1))).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.SndRel_sub	100	0.088553	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @A * @B) (v2 : (@RA * @RB)%signature v0 v1) => and_ind (fun (v3 : (@RA @@1)%signature v0 v1) (v4 : (@RB @@2)%signature v0 v1) => v4) v2) : subrelation (@RA * @RB) (@RB @@2))).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.pair_compat	100	0.101576	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @A) (v2 : RA v0 v1) => (fun (v3 v4 : @B) (v5 : RB v3 v4) => conj v2 v5) : (@RB ==> @RA * @RB)%signature (pair v0) (pair v1)) : Proper (@RA ==> @RB ==> @RA * @RB) pair)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.fst_compat	100	0.124999	1	1	0	synth with cache (only 1: refine ((fun v0 : @A * @B => match v0 as v1 in (_ * _)%type return (forall (v2 : @A * @B) (v3 : (@RA * @RB)%signature v1 v2), RA (Fst v1) (Fst v2)) with | (v1, v2) => (fun (v1 : @A) (v2 : @B) (v3 : @A * @B) => match v3 as v4 in (_ * _)%type return (forall v5 : (@RA * @RB)%signature (v1, v2) v4, RA (Fst (v1, v2)) (Fst v4)) with | (v4, v5) => (fun (v4 : @A) (v5 : @B) (v6 : (@RA * @RB)%signature (v1, v2) (v4, v5)) => match v6 as v7 in (_ /\ _) return (RA (Fst (v1, v2)) (Fst (v4, v5))) with | conj v7 v8 => (fun (v7 : (@RA @@1)%signature (v1, v2) (v4, v5)) (v8 : (@RB @@2)%signature (v1, v2) (v4, v5)) => v7 : RA (Fst (v1, v2)) (Fst (v4, v5))) v7 v8 end) v4 v5 end) v1 v2 end) : Proper (@RA * @RB ==> @RA) Fst)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.snd_compat	100	0.135469	1	1	0	synth with cache (only 1: refine ((fun v0 : @A * @B => match v0 as v1 in (_ * _)%type return (forall (v2 : @A * @B) (v3 : (@RA * @RB)%signature v1 v2), RB (Snd v1) (Snd v2)) with | (v1, v2) => (fun (v1 : @A) (v2 : @B) (v3 : @A * @B) => match v3 as v4 in (_ * _)%type return (forall v5 : (@RA * @RB)%signature (v1, v2) v4, RB (Snd (v1, v2)) (Snd v4)) with | (v4, v5) => (fun (v4 : @A) (v5 : @B) (v6 : (@RA * @RB)%signature (v1, v2) (v4, v5)) => match v6 as v7 in (_ /\ _) return (RB (Snd (v1, v2)) (Snd (v4, v5))) with | conj v7 v8 => (fun (v7 : (@RA @@1)%signature (v1, v2) (v4, v5)) (v8 : (@RB @@2)%signature (v1, v2) (v4, v5)) => v8 : RB (Snd (v1, v2)) (Snd (v4, v5))) v7 v8 end) v4 v5 end) v1 v2 end) : Proper (@RA * @RB ==> @RB) Snd)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.RelationPairs.RelProd_Instances.RelCompFun_compat	100	0.041392	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Sorted_merge	100	1.332577	0	1
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Permuted_merge	100	0.170675	0	1
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Sorted_merge_list_to_stack	100	0.136895	1	1	0	synth with cache (only 1: refine (fun v0 : list (option (list (@t))) => list_ind (fun v1 : list (option (list (@t))) => forall (v2 : list (@t)) (v3 : SortedStack v1) (v4 : LocallySorted (fun v4 v5 : @t => v4 <=? v5) v2), SortedStack (merge_list_to_stack v1 v2)) (fun (v1 : list (@t)) (v2 : SortedStack [ ]) (v3 : LocallySorted (fun v3 v4 : @t => v3 <=? v4) v1) => conj v3 v2 : SortedStack (merge_list_to_stack [ ] v1)) (fun (v1 : option (list (@t))) (v2 : list (option (list (@t)))) (v3 : forall (v3 : list (@t)) (v4 : SortedStack v2) (v5 : LocallySorted (fun v5 v6 : @t => v5 <=? v6) v3), SortedStack (merge_list_to_stack v2 v3)) => match v1 as v4 in (option _) return (forall (v5 : list (@t)) (v6 : SortedStack (v4 :: v2)) (v7 : LocallySorted (fun v7 v8 : @t => v7 <=? v8) v5), SortedStack (merge_list_to_stack (v4 :: v2) v5)) with | Some v4 => (fun (v4 v5 : list (@t)) (v6 : SortedStack (Some v4 :: v2)) (v7 : LocallySorted (fun v7 v8 : @t => v7 <=? v8) v5) => v3 (merge v4 v5) match v6 as v8 in (_ /\ _) return (SortedStack v2) with | conj v8 v9 => (fun (v8 : LocallySorted (fun v8 v9 : @t => v8 <=? v9) v4) (v9 : SortedStack v2) => v9) v8 v9 end (Sorted_merge v4 v5 match v6 as v8 in (_ /\ _) return (LocallySorted (fun v9 v10 : @t => v9 <=? v10) v4) with | conj v8 v9 => (fun (v8 : LocallySorted (fun v8 v9 : @t => v8 <=? v9) v4) (v9 : SortedStack v2) => v8) v8 v9 end v7) : SortedStack (merge_list_to_stack (Some v4 :: v2) v5)) v4 | None => fun (v4 : list (@t)) (v5 : SortedStack (None :: v2)) (v6 : LocallySorted (fun v6 v7 : @t => v6 <=? v7) v4) => conj v6 v5 : SortedStack (merge_list_to_stack (None :: v2) v4) end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Permuted_merge_list_to_stack	100	0.120722	1	1	0	synth with cache (only 1: refine (fun v0 : list (option (list (@t))) => list_ind (fun v1 : list (option (list (@t))) => forall v2 : list (@t), Permutation (v2 ++ flatten_stack v1) (flatten_stack (merge_list_to_stack v1 v2))) ((fun v1 : list (@t) => reflexivity (v1 ++ [ ])) : forall v1 : list (@t), Permutation (v1 ++ flatten_stack [ ]) (flatten_stack (merge_list_to_stack [ ] v1))) (fun (v1 : option (list (@t))) (v2 : list (option (list (@t)))) (v3 : forall v3 : list (@t), Permutation (v3 ++ flatten_stack v2) (flatten_stack (merge_list_to_stack v2 v3))) => match v1 as v4 in (option _) return (forall v5 : list (@t), Permutation (v5 ++ flatten_stack (v4 :: v2)) (flatten_stack (merge_list_to_stack (v4 :: v2) v5))) with | Some v4 => (fun v4 : list (@t) => (fun v5 : list (@t) => eq_ind_r (fun v6 : list (@t) => Permutation v6 (flatten_stack (merge_list_to_stack v2 (merge v4 v5)))) (transitivity (Permutation_app_tail (flatten_stack v2) (transitivity (Permutation_app_comm v5 v4) (Permuted_merge v4 v5))) (v3 (merge v4 v5))) (app_assoc v5 v4 (flatten_stack v2))) : forall v5 : list (@t), Permutation (v5 ++ flatten_stack (Some v4 :: v2)) (flatten_stack (merge_list_to_stack (Some v4 :: v2) v5))) v4 | None => (fun v4 : list (@t) => reflexivity (v4 ++ flatten_stack v2)) : forall v4 : list (@t), Permutation (v4 ++ flatten_stack (None :: v2)) (flatten_stack (merge_list_to_stack (None :: v2) v4)) end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Sorted_merge_stack	100	0.116142	1	1	0	synth with cache (only 1: refine (fun v0 : list (option (list (@t))) => list_ind (fun v1 : list (option (list (@t))) => forall v2 : SortedStack v1, LocallySorted (fun v3 v4 : @t => v3 <=? v4) (merge_stack v1)) ((fun v1 : @True => LSorted_nil (fun v2 v3 : @t => v2 <=? v3)) : forall v1 : SortedStack [ ], LocallySorted (fun v2 v3 : @t => v2 <=? v3) (merge_stack [ ])) (fun (v1 : option (list (@t))) (v2 : list (option (list (@t)))) (v3 : forall v3 : SortedStack v2, LocallySorted (fun v4 v5 : @t => v4 <=? v5) (merge_stack v2)) => match v1 as v4 in (option _) return (forall v5 : SortedStack (v4 :: v2), LocallySorted (fun v6 v7 : @t => v6 <=? v7) (merge_stack (v4 :: v2))) with | Some v4 => (fun v4 : list (@t) => (fun v5 : LocallySorted (fun v5 v6 : @t => v5 <=? v6) v4 /\ SortedStack v2 => Sorted_merge v4 (merge_stack v2) (and_ind (fun (v6 : LocallySorted (fun v6 v7 : @t => v6 <=? v7) v4) (v7 : SortedStack v2) => let v8 : LocallySorted (fun v8 v9 : @t => v8 <=? v9) (merge_stack v2) := v3 v7 in v6) v5) (and_ind (fun (v6 : LocallySorted (fun v6 v7 : @t => v6 <=? v7) v4) (v7 : SortedStack v2) => let v8 : LocallySorted (fun v8 v9 : @t => v8 <=? v9) (merge_stack v2) := v3 v7 in v8) v5)) : forall v5 : SortedStack (Some v4 :: v2), LocallySorted (fun v6 v7 : @t => v6 <=? v7) (merge_stack (Some v4 :: v2))) v4 | None => (fun v4 : SortedStack v2 => v3 v4) : forall v4 : SortedStack (None :: v2), LocallySorted (fun v5 v6 : @t => v5 <=? v6) (merge_stack (None :: v2)) end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Permuted_merge_stack	100	0.092593	1	1	0	synth with cache (only 1: refine (fun v0 : list (option (list (@t))) => list_ind (fun v1 : list (option (list (@t))) => Permutation (flatten_stack v1) (merge_stack v1)) (perm_nil (@t) : Permutation (flatten_stack [ ]) (merge_stack [ ])) (fun (v1 : option (list (@t))) (v2 : list (option (list (@t)))) (v3 : Permutation (flatten_stack v2) (merge_stack v2)) => match v1 as v4 in (option _) return (Permutation (flatten_stack (v4 :: v2)) (merge_stack (v4 :: v2))) with | Some v4 => (fun v4 : list (@t) => transitivity (Permutation_app_head v4 v3) (Permuted_merge v4 (merge_stack v2)) : Permutation (flatten_stack (Some v4 :: v2)) (merge_stack (Some v4 :: v2))) v4 | None => v3 : Permutation (flatten_stack (None :: v2)) (merge_stack (None :: v2)) end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Sorted_iter_merge	100	0.073254	1	1	0	synth with cache (only 1: refine (fun (v0 : list (option (list (@t)))) (v1 : list (@t)) (v2 : SortedStack v0) => list_ind (fun v3 : list (@t) => forall (v4 : list (option (list (@t)))) (v5 : SortedStack v4), LocallySorted (fun v6 v7 : @t => v6 <=? v7) (iter_merge v4 v3)) (fun (v3 : list (option (list (@t)))) (v4 : SortedStack v3) => Sorted_merge_stack v3 v4 : LocallySorted (fun v5 v6 : @t => v5 <=? v6) (iter_merge v3 [ ])) (fun (v3 : @t) (v4 : list (@t)) (v5 : forall (v5 : list (option (list (@t)))) (v6 : SortedStack v5), LocallySorted (fun v7 v8 : @t => v7 <=? v8) (iter_merge v5 v4)) (v6 : list (option (list (@t)))) (v7 : SortedStack v6) => (let v8 : LocallySorted (fun v8 v9 : @t => v8 <=? v9) [v3] := LSorted_cons1 (fun v8 v9 : @t => v8 <=? v9) v3 in v5 (merge_list_to_stack v6 [v3]) (Sorted_merge_list_to_stack v6 [v3] v7 v8)) : LocallySorted (fun v8 v9 : @t => v8 <=? v9) (iter_merge v6 (v3 :: v4))) v1 v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Permuted_iter_merge	100	0.115186	1	1	0	synth with cache (only 1: refine (fun v0 : list (@t) => list_ind (fun v1 : list (@t) => forall v2 : list (option (list (@t))), Permutation (flatten_stack v2 ++ v1) (iter_merge v2 v1)) ((fun v1 : list (option (list (@t))) => eq_ind_r (fun v2 : list (@t) => Permutation v2 (merge_stack v1)) (Permuted_merge_stack v1) (app_nil_r (flatten_stack v1))) : forall v1 : list (option (list (@t))), Permutation (flatten_stack v1 ++ [ ]) (iter_merge v1 [ ])) (fun (v1 : @t) (v2 : list (@t)) (v3 : forall v3 : list (option (list (@t))), Permutation (flatten_stack v3 ++ v2) (iter_merge v3 v2)) => (fun v4 : list (option (list (@t))) => eq_ind_r (fun v5 : list (@t) => Permutation v5 (iter_merge (merge_list_to_stack v4 [v1]) v2)) (transitivity (Permutation_app_tail v2 (transitivity (Permutation_app_comm (flatten_stack v4) [v1]) (Permuted_merge_list_to_stack v4 [v1]))) (v3 (merge_list_to_stack v4 [v1]))) (app_assoc (flatten_stack v4) [v1] v2)) : forall v4 : list (option (list (@t))), Permutation (flatten_stack v4 ++ v1 :: v2) (iter_merge v4 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Sorted_sort	100	0.038996	1	1	0	synth with cache (only 1: refine (fun v0 : list (@t) => Sorted_iter_merge [ ] v0 (@I))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.LocallySorted_sort	100	0.059557	1	1	0	synth with cache (only 1: refine (fun v0 : list (@t) => let v1 : forall (v1 : Type) (v2 : forall v2 v3 : v1, Prop) (v3 : list v1) (v4 : LocallySorted v2 v3), Sorted.Sorted v2 v3 := fun (v1 : Type) (v2 : forall v2 v3 : v1, Prop) (v3 : list v1) => match Sorted_LocallySorted_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : LocallySorted v2 v3, Sorted.Sorted v2 v3) with | conj v4 v5 => (fun (v4 : forall v4 : Sorted.Sorted v2 v3, LocallySorted v2 v3) (v5 : forall v5 : LocallySorted v2 v3, Sorted.Sorted v2 v3) => v5) v4 v5 end in v1 (@t) (fun v2 v3 : @t => v2 <=? v3) (sort v0) (Sorted_sort v0))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.Permuted_sort	100	0.032571	1	1	0	synth with cache (only 1: refine (fun v0 : list (@t) => Permuted_iter_merge v0 [ ])).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.Sort.StronglySorted_sort	100	0.049944	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@t)) (v1 : Transitive (fun v1 v2 : @t => v1 <=? v2)) => Sorted_StronglySorted v1 (LocallySorted_sort v0))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Mergesort.NatOrder.leb_total	100	0.075533	1	1	0	synth with cache (only 1: refine (fun v0 : @nat => nat_ind (fun v1 : @nat => forall v2 : @nat, v1 <=? v2 \/ v2 <=? v1) (fun v1 : @nat => match v1 as v2 in nat return (0 <=? v2 \/ v2 <=? 0) with | 0 => or_intror (eq_refl : @true) : 0 <=? 0 \/ 0 <=? 0 | S v2 => (fun v2 : @nat => or_introl (eq_refl : @true) : 0 <=? S v2 \/ S v2 <=? 0) v2 end) (fun (v1 : @nat) (v2 : forall v2 : @nat, v1 <=? v2 \/ v2 <=? v1) (v3 : @nat) => match v3 as v4 in nat return (S v1 <=? v4 \/ v4 <=? S v1) with | 0 => or_intror (eq_refl : @true) : S v1 <=? 0 \/ 0 <=? S v1 | S v4 => (fun v4 : @nat => v2 v4 : S v1 <=? S v4 \/ S v4 <=? S v1) v4 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inf_iff	100	0.191621	1	1	0	synth with cache (only 1: refine (fun (v0 : @X.t) (v1 : list (@X.t)) => conj (fun v2 : HdRel (@X.lt) v0 v1 => match v2 as v4 in (HdRel _ _ v3) return (inf v0 v3 = @true) with | HdRel_nil _ _ => Logic.eq_refl : inf v0 nil = @true | HdRel_cons _ _ v3 v4 v5 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : X.lt v0 v3) => eq_ind_r (fun v6 : @comparison => match v6 as v7 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) Logic.eq_refl ((fun v6 : X.compare v0 v3 = @Lt <-> X.lt v0 v3 => iff_impl_subrelation (X.lt v0 v3) (X.compare v0 v3 = @Lt) (symmetry v6)) (compare_lt_iff v0 v3) v5) : inf v0 (v3 :: v4) = @true) v3 v4 v5 end) (fun v2 : inf v0 v1 = @true => match v1 as v3 in (list _) return (forall v4 : inf v0 v3 = @true, HdRel (@X.lt) v0 v3) with | nil => fun v3 : inf v0 nil = @true => HdRel_nil (@X.lt) v0 : HdRel (@X.lt) v0 nil | v3 :: v4 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : inf v0 (v3 :: v4) = @true) => (match X.compare v0 v3 as v6 in comparison return (forall (v7 : X.compare v0 v3 = v6) (v8 : match v6 as v8 in comparison return (@bool) with | Lt => @true | _ => @false end = @true), HdRel (@X.lt) v0 (v3 :: v4)) with | Eq => fun (v6 : X.compare v0 v3 = @Eq) (v7 : @false = @true) => let v8 : @False := eq_ind (@false) (fun v8 : @bool => match v8 as v9 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v7 in False_ind (HdRel (@X.lt) v0 (v3 :: v4)) v8 | Lt => fun (v6 : X.compare v0 v3 = @Lt) (v7 : @true = @true) => HdRel_cons (@X.lt) v0 v3 v4 ((fun v8 : X.compare v0 v3 = @Lt <-> X.lt v0 v3 => iff_impl_subrelation (X.compare v0 v3 = @Lt) (X.lt v0 v3) v8) (compare_lt_iff v0 v3) v6) | Gt => fun (v6 : X.compare v0 v3 = @Gt) (v7 : @false = @true) => let v8 : @False := eq_ind (@false) (fun v8 : @bool => match v8 as v9 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v7 in False_ind (HdRel (@X.lt) v0 (v3 :: v4)) v8 end : forall (v6 : X.compare v0 v3 = X.compare v0 v3) (v7 : match X.compare v0 v3 as v7 in comparison return (@bool) with | Lt => @true | _ => @false end = @true), HdRel (@X.lt) v0 (v3 :: v4)) Logic.eq_refl v5 : HdRel (@X.lt) v0 (v3 :: v4)) v3 v4 end v2))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.isok_iff	100	0.184588	1	1	0	synth with cache (only 1: refine (fun v0 : list (@X.t) => conj (fun v1 : Sorted (@X.lt) v0 => Sorted_ind (fun v2 : list (@X.t) => Ok v2) Logic.eq_refl (fun (v2 : @X.t) (v3 : list (@X.t)) (v4 : Sorted (@X.lt) v3) (v5 : Ok v3) (v6 : HdRel (@X.lt) v2 v3) => (fun v7 : inf v2 v3 && isok v3 = @true <-> inf v2 v3 = @true /\ isok v3 = @true => iff_flip_impl_subrelation (inf v2 v3 && isok v3 = @true) (inf v2 v3 = @true /\ isok v3 = @true) v7) (andb_true_iff (inf v2 v3) (isok v3)) (conj ((fun v7 : HdRel (@X.lt) v2 v3 <-> inf v2 v3 = @true => iff_impl_subrelation (HdRel (@X.lt) v2 v3) (inf v2 v3 = @true) v7) (inf_iff v2 v3) v6) v5)) v1) (fun v1 : Ok v0 => list_ind (fun v2 : list (@X.t) => forall v3 : Ok v2, Sorted (@X.lt) v2) (fun v2 : Ok nil => Sorted_nil (@X.lt)) (fun (v2 : @X.t) (v3 : list (@X.t)) (v4 : forall v4 : Ok v3, Sorted (@X.lt) v3) (v5 : Ok (v2 :: v3)) => match (fun v6 : HdRel (@X.lt) v2 v3 <-> inf v2 v3 = @true => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (inf v2 v3 = @true) (HdRel (@X.lt) v2 v3) (symmetry v6) (isok v3 = @true) (isok v3 = @true) (reflexive_proper_proxy (@iff_Reflexive) (isok v3 = @true))) (inf_iff v2 v3) ((fun v6 : inf v2 v3 && isok v3 = @true <-> inf v2 v3 = @true /\ isok v3 = @true => iff_impl_subrelation (inf v2 v3 && isok v3 = @true) (inf v2 v3 = @true /\ isok v3 = @true) v6) (andb_true_iff (inf v2 v3) (isok v3)) v5) as v6 in (_ /\ _) return (Sorted (@X.lt) (v2 :: v3)) with | conj v6 v7 => (fun (v6 : HdRel (@X.lt) v2 v3) (v7 : isok v3 = @true) => Sorted_cons (let v8 : Sorted (@X.lt) v3 := v4 v7 in v8) (let v8 : Sorted (@X.lt) v3 := v4 v7 in v6)) v6 v7 end) v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.isok_Ok	100	0.033474	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : list (@X.t)) (v1 : isok v0 = @true) => v1)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.mem_spec	100	0.563410	1	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.add_inf	100	0.427627	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : HdRel (@X.lt) v3 v1) (v5 : X.lt v3 v2), HdRel (@X.lt) v3 (add v2 v1)) ((fun (v1 v2 : @elt) (v3 : HdRel (@X.lt) v2 nil) (v4 : X.lt v2 v1) => HdRel_cons (@X.lt) v2 v1 nil v4 : HdRel (@X.lt) v2 (v1 :: nil)) : forall (v1 v2 : @elt) (v3 : HdRel (@X.lt) v2 nil) (v4 : X.lt v2 v1), HdRel (@X.lt) v2 (add v1 nil)) ((fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : HdRel (@X.lt) v4 v2) (v6 : X.lt v4 v3), HdRel (@X.lt) v4 (add v3 v2)) (v4 v5 : @elt) (v6 : HdRel (@X.lt) v5 (v1 :: v2)) (v7 : X.lt v5 v4) => let v8 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v9 : @comparison := X.compare v4 v1 in match v8 as v11 in (CompareSpec _ _ _ v10) return (HdRel (@X.lt) v5 match v10 as v12 in comparison return (list (@X.t)) with | Eq => v1 :: v2 | Lt => v4 :: v1 :: v2 | Gt => v1 :: add v4 v2 end) with | CompEq _ _ v10 => (fun v10 : X.eq v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2) := match v6 as v12 in (HdRel _ _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2)) with | HdRel_nil _ _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: v2)) v13) v11 | HdRel_cons _ _ v11 v12 v13 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : X.lt v5 v11) (v14 : v11 :: v12 = v1 :: v2) => (fun v15 : v11 :: v12 = v1 :: v2 => let v16 : v12 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v12 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v11 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v11 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v11 = v1 => let v19 : v11 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v12 = v2) (v22 : X.lt v5 v20), HdRel (@X.lt) v5 (v1 :: v2)) (fun v20 : v12 = v2 => let v21 : v12 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall v23 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: v2)) (fun v22 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 v2 v22 : HdRel (@X.lt) v5 (v1 :: v2)) v21) v19) v17) v16) v14 v13) v11 v12 v13 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v4 :: v1 :: v2) := match v6 as v12 in (HdRel _ _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v4 :: v1 :: v2)) with | HdRel_nil _ _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v4 :: v1 :: v2)) v13) v11 | HdRel_cons _ _ v11 v12 v13 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : X.lt v5 v11) (v14 : v11 :: v12 = v1 :: v2) => (fun v15 : v11 :: v12 = v1 :: v2 => let v16 : v12 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v12 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v11 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v11 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v11 = v1 => let v19 : v11 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v12 = v2) (v22 : X.lt v5 v20), HdRel (@X.lt) v5 (v4 :: v1 :: v2)) (fun v20 : v12 = v2 => let v21 : v12 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall v23 : X.lt v5 v1, HdRel (@X.lt) v5 (v4 :: v1 :: v2)) (fun v22 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v4 (v1 :: v2) v7 : HdRel (@X.lt) v5 (v4 :: v1 :: v2)) v21) v19) v17) v16) v14 v13) v11 v12 v13 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v1 v4 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: add v4 v2) := match v6 as v12 in (HdRel _ _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: add v4 v2)) with | HdRel_nil _ _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: add v4 v2)) v13) v11 | HdRel_cons _ _ v11 v12 v13 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : X.lt v5 v11) (v14 : v11 :: v12 = v1 :: v2) => (fun v15 : v11 :: v12 = v1 :: v2 => let v16 : v12 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v12 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v11 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v11 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v11 = v1 => let v19 : v11 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v12 = v2) (v22 : X.lt v5 v20), HdRel (@X.lt) v5 (v1 :: add v4 v2)) (fun v20 : v12 = v2 => let v21 : v12 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall v23 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: add v4 v2)) (fun v22 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 (add v4 v2) v22 : HdRel (@X.lt) v5 (v1 :: add v4 v2)) v21) v19) v17) v16) v14 v13) v11 v12 v13 end in v11 Logic.eq_refl) v10 end) : forall (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : HdRel (@X.lt) v4 v2) (v6 : X.lt v4 v3), HdRel (@X.lt) v4 (add v3 v2)) (v4 v5 : @elt) (v6 : HdRel (@X.lt) v5 (v1 :: v2)) (v7 : X.lt v5 v4), HdRel (@X.lt) v5 (add v4 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.add_ok	100	0.532345	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @t) (v1 : @X.t) => (fun v2 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v2) (Ok (add v1 v0)) (Ok (add v1 v0)) (reflexive_proper_proxy (@iff_Reflexive) (Ok (add v1 v0)))) (isok_iff v0) ((fun v2 : Sorted (@X.lt) (add v1 v0) <-> Ok (add v1 v0) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v0)) (Ok (add v1 v0)) (Sorted (@X.lt) (add v1 v0)) (symmetry v2)) (isok_iff (add v1 v0)) ((fun v2 : @t => list_ind (fun v3 : list (@elt) => forall (v4 : @X.t) (v5 : Sorted (@X.lt) v3), Sorted (@X.lt) (add v4 v3)) ((fun (v3 : @X.t) (v4 : Sorted (@X.lt) nil) => Sorted_cons v4 (HdRel_nil (@X.lt) v3) : Sorted (@X.lt) (v3 :: nil)) : forall (v3 : @X.t) (v4 : Sorted (@X.lt) nil), Sorted (@X.lt) (add v3 nil)) ((fun (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : @X.t) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (add v5 v4)) (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)) => let v8 : CompareSpec (X.eq v6 v3) (X.lt v6 v3) (X.lt v3 v6) (X.compare v6 v3) := X.compare_spec v6 v3 in let v9 : @comparison := X.compare v6 v3 in match v8 as v11 in (CompareSpec _ _ _ v10) return (Sorted (@X.lt) match v10 as v12 in comparison return (list (@X.t)) with | Eq => v3 :: v4 | Lt => v6 :: v3 :: v4 | Gt => v3 :: add v6 v4 end) with | CompEq _ _ v10 => (fun v10 : X.eq v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons v23 v24) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v6 :: v3 :: v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v6 :: v3 :: v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v6 :: v3 :: v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v6 :: v3 :: v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v6 :: v3 :: v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons (Sorted_cons v23 v24) (HdRel_cons (@X.lt) v6 v3 v4 v10)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v3 v6 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: add v6 v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: add v6 v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: add v6 v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: add v6 v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: add v6 v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons (v5 v6 v23) (add_inf v24 v10)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 end) : forall (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : @X.t) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (add v5 v4)) (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)), Sorted (@X.lt) (add v6 (v3 :: v4))) v2) v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.add_spec	100	1.642126	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : Ok v1), InA (@X.eq) v3 (add v2 v1) <-> X.eq v3 v2 \/ InA (@X.eq) v3 v1) ((fun (v1 v2 : @elt) (v3 : Ok nil) => conj (fun v4 : InA (@X.eq) v2 (v1 :: nil) => let v5 : forall v5 : v1 :: nil = v1 :: nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil := match v4 as v6 in (InA _ _ v5) return (forall v7 : v5 = v1 :: nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil) with | @InA_cons_hd _ _ _ v5 v6 v7 => (fun (v5 : @X.t) (v6 : list (@X.t)) (v7 : X.eq v2 v5) (v8 : v5 :: v6 = v1 :: nil) => (fun v9 : v5 :: v6 = v1 :: nil => let v10 : v6 = nil := f_equal (fun v10 : list (@X.t) => match v10 as v11 in (list _) return (list (@X.t)) with | nil => v6 | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => v12) v11 v12 end) v9 in (let v11 : v5 = v1 := f_equal (fun v11 : list (@X.t) => match v11 as v12 in (list _) return (@X.t) with | nil => v5 | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => v12) v12 v13 end) v9 in (fun v12 : v5 = v1 => let v13 : v5 = v1 := v12 in eq_ind_r (fun v14 : @X.t => forall (v15 : v6 = nil) (v16 : X.eq v2 v14), X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v14 : v6 = nil => let v15 : v6 = nil := v14 in eq_ind_r (fun v16 : list (@X.t) => forall v17 : X.eq v2 v1, X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v16 : X.eq v2 v1 => or_introl v16) v15) v13) v11) v10) v8 v7) v5 v6 v7 | @InA_cons_tl _ _ _ v5 v6 v7 => (fun (v5 : @X.t) (v6 : list (@X.t)) (v7 : InA (@X.eq) v2 v6) (v8 : v5 :: v6 = v1 :: nil) => (fun v9 : v5 :: v6 = v1 :: nil => let v10 : v6 = nil := f_equal (fun v10 : list (@X.t) => match v10 as v11 in (list _) return (list (@X.t)) with | nil => v6 | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => v12) v11 v12 end) v9 in (let v11 : v5 = v1 := f_equal (fun v11 : list (@X.t) => match v11 as v12 in (list _) return (@X.t) with | nil => v5 | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => v12) v12 v13 end) v9 in (fun v12 : v5 = v1 => let v13 : v5 = v1 := v12 in eq_ind_r (fun v14 : @X.t => forall (v15 : v6 = nil) (v16 : InA (@X.eq) v2 v6), X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v14 : v6 = nil => let v15 : v6 = nil := v14 in eq_ind_r (fun v16 : list (@X.t) => forall v17 : InA (@X.eq) v2 v16, X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v16 : InA (@X.eq) v2 nil => let v17 : forall v17 : nil = nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil := match v16 as v18 in (InA _ _ v17) return (forall v19 : v17 = nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil) with | @InA_cons_hd _ _ _ v17 v18 v19 => (fun (v17 : @X.t) (v18 : list (@X.t)) (v19 : X.eq v2 v17) (v20 : v17 :: v18 = nil) => (fun v21 : v17 :: v18 = nil => let v22 : @False := eq_ind (v17 :: v18) (fun v22 : list (@X.t) => match v22 as v23 in (list _) return Prop with | nil => @False | v23 :: v24 => (fun (v23 : @X.t) (v24 : list (@X.t)) => @True) v23 v24 end) (@I) nil v21 in False_ind (forall v23 : X.eq v2 v17, X.eq v2 v1 \/ InA (@X.eq) v2 nil) v22) v20 v19) v17 v18 v19 | @InA_cons_tl _ _ _ v17 v18 v19 => (fun (v17 : @X.t) (v18 : list (@X.t)) (v19 : InA (@X.eq) v2 v18) (v20 : v17 :: v18 = nil) => (fun v21 : v17 :: v18 = nil => let v22 : @False := eq_ind (v17 :: v18) (fun v22 : list (@X.t) => match v22 as v23 in (list _) return Prop with | nil => @False | v23 :: v24 => (fun (v23 : @X.t) (v24 : list (@X.t)) => @True) v23 v24 end) (@I) nil v21 in False_ind (forall v23 : InA (@X.eq) v2 v18, X.eq v2 v1 \/ InA (@X.eq) v2 nil) v22) v20 v19) v17 v18 v19 end in v17 Logic.eq_refl) v15) v13) v11) v10) v8 v7) v5 v6 v7 end in v5 Logic.eq_refl) (fun v4 : X.eq v2 v1 \/ InA (@X.eq) v2 nil => or_ind (fun v5 : X.eq v2 v1 => InA_cons_hd (eqA:=@X.eq) (x:=v2) (y:=v1) nil v5 : InA (@X.eq) v2 (v1 :: nil)) (fun v5 : InA (@X.eq) v2 nil => InA_cons_tl v1 v5 : InA (@X.eq) v2 (v1 :: nil)) v4)) : forall (v1 v2 : @elt) (v3 : Ok nil), InA (@X.eq) v2 (add v1 nil) <-> X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : Ok v2), InA (@X.eq) v4 (add v3 v2) <-> X.eq v4 v3 \/ InA (@X.eq) v4 v2) => (fun (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) => let v7 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v8 : @comparison := X.compare v4 v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (InA (@X.eq) v5 match v9 as v11 in comparison return (list (@X.t)) with | Eq => v1 :: v2 | Lt => v4 :: v1 :: v2 | Gt => v1 :: add v4 v2 end <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | CompEq _ _ v9 => (fun v9 : X.eq v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => subrelation_proper (PER_morphism (Equivalence_PER (@iff_equivalence))) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24)) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v1 => or_introl (OrderTac.not_neq_eq ((fun v26 : ~ X.eq v5 v4 => (fun v27 : ~ X.eq v1 v4 => (fun v28 : ~ X.eq v1 v1 => v28 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v27 v9)) (OrderTac.eq_neq (OrderTac.eq_sym v25) v26)) : ~ ~ X.eq v5 v4) : X.eq v5 v4)) (fun v25 : InA (@X.eq) v5 v2 => or_intror (or_intror v25)) v24) (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_introl (OrderTac.not_neq_eq ((fun v26 : ~ X.eq v5 v1 => (fun v27 : ~ X.eq v4 v1 => (fun v28 : ~ X.eq v1 v1 => v28 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v9) v27)) (OrderTac.eq_neq (OrderTac.eq_sym v25) v26)) : ~ ~ X.eq v5 v1) : X.eq v5 v1)) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_introl v26) (fun v26 : InA (@X.eq) v5 v2 => or_intror v26) v25) v24))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompLt _ _ v9 => (fun v9 : X.lt v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v5 (v4 :: v1 :: v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v24 (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (eq_proper_proxy (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)))) (InA_cons (@X.eq) v5 v4 (v1 :: v2)) ((fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => subrelation_proper (PER_morphism (Equivalence_PER (@iff_equivalence))) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24)) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_introl v25) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_intror (or_introl v26)) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24) (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_introl v25) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_intror (or_introl v26)) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24)))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompGt _ _ v9 => (fun v9 : X.lt v1 v4 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 (add v4 v2) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v5 (v1 :: add v4 v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 (add v4 v2)) v24 (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (eq_proper_proxy (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)))) (InA_cons (@X.eq) v5 v1 (add v4 v2)) ((fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24)) (InA_cons (@X.eq) v5 v1 v2) ((fun v24 : InA (@X.eq) v5 (add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 v2 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (X.eq v5 v1 \/ InA (@X.eq) v5 (add v4 v2)) (X.eq v5 v1 \/ X.eq v5 v4 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v1)) (InA (@X.eq) v5 (add v4 v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 v2) v24) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (eq_proper_proxy (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2))) (v3 v4 v5 ((fun v24 : Sorted (@X.lt) v2 <-> Ok v2 => iff_flip_impl_subrelation (Ok v2) (Sorted (@X.lt) v2) (symmetry v24)) (isok_iff v2) v22 : Ok v2)) (conj (fun v24 : X.eq v5 v1 \/ X.eq v5 v4 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v1 => or_intror (or_introl v25)) (fun v25 : X.eq v5 v4 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v4 => or_introl v26) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24) (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_intror (or_introl v25)) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_introl v26) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24))))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 end) : forall (v4 v5 : @elt) (v6 : Ok (v1 :: v2)), InA (@X.eq) v5 (add v4 (v1 :: v2)) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.remove_inf	100	0.804882	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : Ok v1) (v5 : HdRel (@X.lt) v3 v1), HdRel (@X.lt) v3 (remove v2 v1)) ((fun (v1 v2 : @elt) (v3 : Ok nil) (v4 : HdRel (@X.lt) v2 nil) => v4) : forall (v1 v2 : @elt) (v3 : Ok nil) (v4 : HdRel (@X.lt) v2 nil), HdRel (@X.lt) v2 (remove v1 nil)) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : Ok v2) (v6 : HdRel (@X.lt) v4 v2), HdRel (@X.lt) v4 (remove v3 v2)) => (fun (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) (v7 : HdRel (@X.lt) v5 (v1 :: v2)) => let v8 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v9 : @comparison := X.compare v4 v1 in match v8 as v11 in (CompareSpec _ _ _ v10) return (HdRel (@X.lt) v5 match v10 as v12 in comparison return (@t) with | Eq => v2 | Lt => v1 :: v2 | Gt => v1 :: remove v4 v2 end) with | CompEq _ _ v10 => (fun v10 : X.eq v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 v2 := match (fun v11 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v11)) (isok_iff (v1 :: v2)) v6 as v12 in (Sorted _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 v2) with | Sorted_nil _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 v2) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v1 :: v2) => (fun v16 : v11 :: v12 = v1 :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v1 => let v20 : v11 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v2) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), HdRel (@X.lt) v5 v2) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v1 v23), HdRel (@X.lt) v5 v2) (fun (v23 : Sorted (@X.lt) v2) (v24 : HdRel (@X.lt) v1 v2) => let v25 : forall v25 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 v2 := match v7 as v26 in (HdRel _ _ v25) return (forall v27 : v25 = v1 :: v2, HdRel (@X.lt) v5 v2) with | HdRel_nil _ _ => fun v25 : nil = v1 :: v2 => (fun v26 : nil = v1 :: v2 => let v27 : @False := eq_ind nil (fun v27 : list (@X.t) => match v27 as v28 in (list _) return Prop with | nil => @True | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => @False) v28 v29 end) (@I) (v1 :: v2) v26 in False_ind (HdRel (@X.lt) v5 v2) v27) v25 | HdRel_cons _ _ v25 v26 v27 => (fun (v25 : @X.t) (v26 : list (@X.t)) (v27 : X.lt v5 v25) (v28 : v25 :: v26 = v1 :: v2) => (fun v29 : v25 :: v26 = v1 :: v2 => let v30 : v26 = v2 := f_equal (fun v30 : list (@X.t) => match v30 as v31 in (list _) return (list (@X.t)) with | nil => v26 | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => v32) v31 v32 end) v29 in (let v31 : v25 = v1 := f_equal (fun v31 : list (@X.t) => match v31 as v32 in (list _) return (@X.t) with | nil => v25 | v32 :: v33 => (fun (v32 : @X.t) (v33 : list (@X.t)) => v32) v32 v33 end) v29 in (fun v32 : v25 = v1 => let v33 : v25 = v1 := v32 in eq_ind_r (fun v34 : @X.t => forall (v35 : v26 = v2) (v36 : X.lt v5 v34), HdRel (@X.lt) v5 v2) (fun v34 : v26 = v2 => let v35 : v26 = v2 := v34 in eq_ind_r (fun v36 : list (@X.t) => forall v37 : X.lt v5 v1, HdRel (@X.lt) v5 v2) (fun v36 : X.lt v5 v1 => Inf_lt v36 v24) v35) v33) v31) v30) v28 v27) v25 v26 v27 end in v25 Logic.eq_refl) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2) := match (fun v11 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v11)) (isok_iff (v1 :: v2)) v6 as v12 in (Sorted _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2)) with | Sorted_nil _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: v2)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v1 :: v2) => (fun v16 : v11 :: v12 = v1 :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v1 => let v20 : v11 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v2) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), HdRel (@X.lt) v5 (v1 :: v2)) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v1 v23), HdRel (@X.lt) v5 (v1 :: v2)) (fun (v23 : Sorted (@X.lt) v2) (v24 : HdRel (@X.lt) v1 v2) => let v25 : forall v25 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2) := match v7 as v26 in (HdRel _ _ v25) return (forall v27 : v25 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2)) with | HdRel_nil _ _ => fun v25 : nil = v1 :: v2 => (fun v26 : nil = v1 :: v2 => let v27 : @False := eq_ind nil (fun v27 : list (@X.t) => match v27 as v28 in (list _) return Prop with | nil => @True | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => @False) v28 v29 end) (@I) (v1 :: v2) v26 in False_ind (HdRel (@X.lt) v5 (v1 :: v2)) v27) v25 | HdRel_cons _ _ v25 v26 v27 => (fun (v25 : @X.t) (v26 : list (@X.t)) (v27 : X.lt v5 v25) (v28 : v25 :: v26 = v1 :: v2) => (fun v29 : v25 :: v26 = v1 :: v2 => let v30 : v26 = v2 := f_equal (fun v30 : list (@X.t) => match v30 as v31 in (list _) return (list (@X.t)) with | nil => v26 | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => v32) v31 v32 end) v29 in (let v31 : v25 = v1 := f_equal (fun v31 : list (@X.t) => match v31 as v32 in (list _) return (@X.t) with | nil => v25 | v32 :: v33 => (fun (v32 : @X.t) (v33 : list (@X.t)) => v32) v32 v33 end) v29 in (fun v32 : v25 = v1 => let v33 : v25 = v1 := v32 in eq_ind_r (fun v34 : @X.t => forall (v35 : v26 = v2) (v36 : X.lt v5 v34), HdRel (@X.lt) v5 (v1 :: v2)) (fun v34 : v26 = v2 => let v35 : v26 = v2 := v34 in eq_ind_r (fun v36 : list (@X.t) => forall v37 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: v2)) (fun v36 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 v2 v36) v35) v33) v31) v30) v28 v27) v25 v26 v27 end in v25 Logic.eq_refl) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v1 v4 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2) := match (fun v11 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v11)) (isok_iff (v1 :: v2)) v6 as v12 in (Sorted _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2)) with | Sorted_nil _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: remove v4 v2)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v1 :: v2) => (fun v16 : v11 :: v12 = v1 :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v1 => let v20 : v11 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v2) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v1 v23), HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun (v23 : Sorted (@X.lt) v2) (v24 : HdRel (@X.lt) v1 v2) => let v25 : forall v25 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2) := match v7 as v26 in (HdRel _ _ v25) return (forall v27 : v25 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2)) with | HdRel_nil _ _ => fun v25 : nil = v1 :: v2 => (fun v26 : nil = v1 :: v2 => let v27 : @False := eq_ind nil (fun v27 : list (@X.t) => match v27 as v28 in (list _) return Prop with | nil => @True | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => @False) v28 v29 end) (@I) (v1 :: v2) v26 in False_ind (HdRel (@X.lt) v5 (v1 :: remove v4 v2)) v27) v25 | HdRel_cons _ _ v25 v26 v27 => (fun (v25 : @X.t) (v26 : list (@X.t)) (v27 : X.lt v5 v25) (v28 : v25 :: v26 = v1 :: v2) => (fun v29 : v25 :: v26 = v1 :: v2 => let v30 : v26 = v2 := f_equal (fun v30 : list (@X.t) => match v30 as v31 in (list _) return (list (@X.t)) with | nil => v26 | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => v32) v31 v32 end) v29 in (let v31 : v25 = v1 := f_equal (fun v31 : list (@X.t) => match v31 as v32 in (list _) return (@X.t) with | nil => v25 | v32 :: v33 => (fun (v32 : @X.t) (v33 : list (@X.t)) => v32) v32 v33 end) v29 in (fun v32 : v25 = v1 => let v33 : v25 = v1 := v32 in eq_ind_r (fun v34 : @X.t => forall (v35 : v26 = v2) (v36 : X.lt v5 v34), HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun v34 : v26 = v2 => let v35 : v26 = v2 := v34 in eq_ind_r (fun v36 : list (@X.t) => forall v37 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun v36 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 (remove v4 v2) v36) v35) v33) v31) v30) v28 v27) v25 v26 v27 end in v25 Logic.eq_refl) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 end) : forall (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) (v7 : HdRel (@X.lt) v5 (v1 :: v2)), HdRel (@X.lt) v5 (remove v4 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.remove_ok	100	0.440130	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @t) (v1 : @X.t) => (fun v2 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v2) (Ok (remove v1 v0)) (Ok (remove v1 v0)) (reflexive_proper_proxy (@iff_Reflexive) (Ok (remove v1 v0)))) (isok_iff v0) ((fun v2 : Sorted (@X.lt) (remove v1 v0) <-> Ok (remove v1 v0) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v0)) (Ok (remove v1 v0)) (Sorted (@X.lt) (remove v1 v0)) (symmetry v2)) (isok_iff (remove v1 v0)) ((fun v2 : @t => list_ind (fun v3 : list (@elt) => forall (v4 : @X.t) (v5 : Sorted (@X.lt) v3), Sorted (@X.lt) (remove v4 v3)) ((fun (v3 : @X.t) (v4 : Sorted (@X.lt) nil) => v4) : forall (v3 : @X.t) (v4 : Sorted (@X.lt) nil), Sorted (@X.lt) (remove v3 nil)) (fun (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : @X.t) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (remove v5 v4)) => (fun (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)) => let v8 : CompareSpec (X.eq v6 v3) (X.lt v6 v3) (X.lt v3 v6) (X.compare v6 v3) := X.compare_spec v6 v3 in let v9 : @comparison := X.compare v6 v3 in match v8 as v11 in (CompareSpec _ _ _ v10) return (Sorted (@X.lt) match v10 as v12 in comparison return (@t) with | Eq => v4 | Lt => v3 :: v4 | Gt => v3 :: remove v6 v4 end) with | CompEq _ _ v10 => (fun v10 : X.eq v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) v4 := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) v4) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) v4) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) v4) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) v4) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => v23) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons v23 v24) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v3 v6 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: remove v6 v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: remove v6 v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: remove v6 v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: remove v6 v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: remove v6 v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons (v5 v6 v23) (remove_inf v6 ((fun v25 : Sorted (@X.lt) v4 <-> Ok v4 => iff_flip_impl_subrelation (Ok v4) (Sorted (@X.lt) v4) (symmetry v25)) (isok_iff v4) v23) v24)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 end) : forall (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)), Sorted (@X.lt) (remove v6 (v3 :: v4))) v2) v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.remove_spec	100	1.534179	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : Ok v1), InA (@X.eq) v3 (remove v2 v1) <-> InA (@X.eq) v3 v1 /\ ~ X.eq v3 v2) ((fun (v1 v2 : @elt) (v3 : Ok nil) => conj (fun v4 : InA (@X.eq) v2 nil => conj v4 ((fun v5 : X.eq v2 v1 => let v6 : forall v6 : nil = nil, @False := match v4 as v7 in (InA _ _ v6) return (forall v8 : v6 = nil, @False) with | @InA_cons_hd _ _ _ v6 v7 v8 => (fun (v6 : @X.t) (v7 : list (@X.t)) (v8 : X.eq v2 v6) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t) => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : X.eq v2 v6, @False) v11) v9 v8) v6 v7 v8 | @InA_cons_tl _ _ _ v6 v7 v8 => (fun (v6 : @X.t) (v7 : list (@X.t)) (v8 : InA (@X.eq) v2 v7) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t) => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : InA (@X.eq) v2 v7, @False) v11) v9 v8) v6 v7 v8 end in v6 Logic.eq_refl) : ~ X.eq v2 v1)) (fun v4 : InA (@X.eq) v2 nil /\ ~ X.eq v2 v1 => and_ind (fun (v5 : InA (@X.eq) v2 nil) (v6 : ~ X.eq v2 v1) => v5) v4)) : forall (v1 v2 : @elt) (v3 : Ok nil), InA (@X.eq) v2 (remove v1 nil) <-> InA (@X.eq) v2 nil /\ ~ X.eq v2 v1) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : Ok v2), InA (@X.eq) v4 (remove v3 v2) <-> InA (@X.eq) v4 v2 /\ ~ X.eq v4 v3) => (fun (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) => let v7 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v8 : @comparison := X.compare v4 v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (InA (@X.eq) v5 match v9 as v11 in comparison return (@t) with | Eq => v2 | Lt => v1 :: v2 | Gt => v1 :: remove v4 v2 end <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | CompEq _ _ v9 => (fun v9 : X.eq v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4 := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (~ X.eq v5 v4) (~ X.eq v5 v4) (reflexive_proper_proxy (@iff_Reflexive) (~ X.eq v5 v4)))) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : InA (@X.eq) v5 v2 => conj (or_intror v24) ((fun v25 : X.eq v5 v4 => (let v26 : X.lt v1 v5 := Sort_Inf_In v22 v23 v24 in (fun v27 : X.lt v1 v5 => False_ind (@False) ((fun v28 : X.lt v1 v4 => (fun v29 : X.lt v1 v1 => OrderTac.lt_irrefl v29) (OrderTac.lt_eq v28 v9)) (OrderTac.lt_eq v27 v25))) v26) : @False) : ~ X.eq v5 v4)) (fun v24 : (X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4 => and_ind (fun (v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2) (v26 : ~ X.eq v5 v4) => or_ind (fun v27 : X.eq v5 v1 => ListIn_In (l:=v2) (x:=v5) (False_ind (List.In v5 v2) ((fun v28 : ~ X.eq v1 v4 => (fun v29 : ~ X.eq v1 v1 => v29 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v28 v9)) (OrderTac.eq_neq (OrderTac.eq_sym v27) v26))) : InA (@X.eq) v5 v2) (fun v27 : InA (@X.eq) v5 v2 => v27) v25) v24))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompLt _ _ v9 => (fun v9 : X.lt v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4 := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => subrelation_proper (PER_morphism (Equivalence_PER (@iff_equivalence))) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (~ X.eq v5 v4) (~ X.eq v5 v4) (reflexive_proper_proxy (@iff_Reflexive) (~ X.eq v5 v4)))) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v1 => conj (or_introl v25) ((fun v26 : X.eq v5 v4 => diff_false_true (absurd_eq_true (@false) (diff_false_true (absurd_eq_true (@false) (False_ind (@False) ((fun v27 : X.eq v4 v1 => (fun v28 : X.lt v1 v1 => OrderTac.lt_irrefl v28) (OrderTac.eq_lt (OrderTac.eq_sym v27) v9)) (OrderTac.eq_trans (OrderTac.eq_sym v26) v25)))))) : @False) : ~ X.eq v5 v4)) (fun v25 : InA (@X.eq) v5 v2 => conj (or_intror v25) ((fun v26 : X.eq v5 v4 => (let v27 : X.lt v1 v5 := Sort_Inf_In v22 v23 v25 in (fun v28 : X.lt v1 v5 => False_ind (@False) ((fun v29 : X.lt v1 v4 => (fun v30 : X.lt v4 v4 => OrderTac.lt_irrefl v30) (OrderTac.lt_trans v9 v29)) (OrderTac.lt_eq v28 v26))) v27) : @False) : ~ X.eq v5 v4)) v24) (fun v24 : (X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4 => and_ind (fun (v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2) (v26 : ~ X.eq v5 v4) => or_ind (fun v27 : X.eq v5 v1 => or_introl v27) (fun v27 : InA (@X.eq) v5 v2 => or_intror v27) v25) v24))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompGt _ _ v9 => (fun v9 : X.lt v1 v4 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4 := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: remove v4 v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 (remove v4 v2) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v5 (v1 :: remove v4 v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 (remove v4 v2)) v24 (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (eq_proper_proxy (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4))) (InA_cons (@X.eq) v5 v1 (remove v4 v2)) ((fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (~ X.eq v5 v4) (~ X.eq v5 v4) (reflexive_proper_proxy (@iff_Reflexive) (~ X.eq v5 v4)))) (InA_cons (@X.eq) v5 v1 v2) ((fun v24 : InA (@X.eq) v5 (remove v4 v2) <-> InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (X.eq v5 v1 \/ InA (@X.eq) v5 (remove v4 v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v1)) (InA (@X.eq) v5 (remove v4 v2)) (InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4) v24) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (eq_proper_proxy ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4))) (v3 v4 v5 ((fun v24 : Sorted (@X.lt) v2 <-> Ok v2 => iff_flip_impl_subrelation (Ok v2) (Sorted (@X.lt) v2) (symmetry v24)) (isok_iff v2) v22 : Ok v2)) (conj (fun v24 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4 => or_ind (fun v25 : X.eq v5 v1 => conj (or_introl v25) ((fun v26 : X.eq v5 v4 => diff_false_true (absurd_eq_true (@false) (diff_false_true (absurd_eq_true (@false) (False_ind (@False) ((fun v27 : X.eq v4 v1 => (fun v28 : X.lt v1 v1 => OrderTac.lt_irrefl v28) (OrderTac.lt_eq v9 v27)) (OrderTac.eq_trans (OrderTac.eq_sym v26) v25)))))) : @False) : ~ X.eq v5 v4)) (fun v25 : InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4 => and_ind (fun (v26 : InA (@X.eq) v5 v2) (v27 : ~ X.eq v5 v4) => conj (or_intror v26) ((fun v28 : X.eq v5 v4 => let v29 : @False := v27 v28 in False_ind (@False) v29) : ~ X.eq v5 v4)) v25) v24) (fun v24 : (X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4 => and_ind (fun (v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2) (v26 : ~ X.eq v5 v4) => or_ind (fun v27 : X.eq v5 v1 => or_introl v27) (fun v27 : InA (@X.eq) v5 v2 => or_intror (conj v27 ((fun v28 : X.eq v5 v4 => let v29 : @False := v26 v28 in False_ind (@False) v29) : ~ X.eq v5 v4))) v25) v24))))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 end) : forall (v4 v5 : @elt) (v6 : Ok (v1 :: v2)), InA (@X.eq) v5 (remove v4 (v1 :: v2)) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.singleton_ok	100	0.062202	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @elt => ((fun v1 : Sorted (@X.lt) (v0 :: nil) <-> Ok (v0 :: nil) => iff_flip_impl_subrelation (Ok (v0 :: nil)) (Sorted (@X.lt) (v0 :: nil)) (symmetry v1)) (isok_iff (v0 :: nil)) (Sorted_cons (Sorted_nil (@X.lt)) (HdRel_nil (@X.lt) v0)) : Ok (v0 :: nil)) : Ok (singleton v0))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.singleton_spec	100	0.267593	1	1	0	synth with cache (only 1: refine (((fun v0 v1 : @elt => conj (fun v2 : InA (@X.eq) v1 (v0 :: nil) => let v3 : forall v3 : v0 :: nil = v0 :: nil, X.eq v1 v0 := match v2 as v4 in (InA _ _ v3) return (forall v5 : v3 = v0 :: nil, X.eq v1 v0) with | @InA_cons_hd _ _ _ v3 v4 v5 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : X.eq v1 v3) (v6 : v3 :: v4 = v0 :: nil) => (fun v7 : v3 :: v4 = v0 :: nil => let v8 : v4 = nil := f_equal (fun v8 : list (@X.t) => match v8 as v9 in (list _) return (list (@X.t)) with | nil => v4 | v9 :: v10 => (fun (v9 : @X.t) (v10 : list (@X.t)) => v10) v9 v10 end) v7 in (let v9 : v3 = v0 := f_equal (fun v9 : list (@X.t) => match v9 as v10 in (list _) return (@X.t) with | nil => v3 | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => v10) v10 v11 end) v7 in (fun v10 : v3 = v0 => let v11 : v3 = v0 := v10 in eq_ind_r (fun v12 : @X.t => forall (v13 : v4 = nil) (v14 : X.eq v1 v12), X.eq v1 v0) (fun v12 : v4 = nil => let v13 : v4 = nil := v12 in eq_ind_r (fun v14 : list (@X.t) => forall v15 : X.eq v1 v0, X.eq v1 v0) (fun v14 : X.eq v1 v0 => v14) v13) v11) v9) v8) v6 v5) v3 v4 v5 | @InA_cons_tl _ _ _ v3 v4 v5 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : InA (@X.eq) v1 v4) (v6 : v3 :: v4 = v0 :: nil) => (fun v7 : v3 :: v4 = v0 :: nil => let v8 : v4 = nil := f_equal (fun v8 : list (@X.t) => match v8 as v9 in (list _) return (list (@X.t)) with | nil => v4 | v9 :: v10 => (fun (v9 : @X.t) (v10 : list (@X.t)) => v10) v9 v10 end) v7 in (let v9 : v3 = v0 := f_equal (fun v9 : list (@X.t) => match v9 as v10 in (list _) return (@X.t) with | nil => v3 | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => v10) v10 v11 end) v7 in (fun v10 : v3 = v0 => let v11 : v3 = v0 := v10 in eq_ind_r (fun v12 : @X.t => forall (v13 : v4 = nil) (v14 : InA (@X.eq) v1 v4), X.eq v1 v0) (fun v12 : v4 = nil => let v13 : v4 = nil := v12 in eq_ind_r (fun v14 : list (@X.t) => forall v15 : InA (@X.eq) v1 v14, X.eq v1 v0) (fun v14 : InA (@X.eq) v1 nil => let v15 : forall v15 : nil = nil, X.eq v1 v0 := match v14 as v16 in (InA _ _ v15) return (forall v17 : v15 = nil, X.eq v1 v0) with | @InA_cons_hd _ _ _ v15 v16 v17 => (fun (v15 : @X.t) (v16 : list (@X.t)) (v17 : X.eq v1 v15) (v18 : v15 :: v16 = nil) => (fun v19 : v15 :: v16 = nil => let v20 : @False := eq_ind (v15 :: v16) (fun v20 : list (@X.t) => match v20 as v21 in (list _) return Prop with | nil => @False | v21 :: v22 => (fun (v21 : @X.t) (v22 : list (@X.t)) => @True) v21 v22 end) (@I) nil v19 in False_ind (forall v21 : X.eq v1 v15, X.eq v1 v0) v20) v18 v17) v15 v16 v17 | @InA_cons_tl _ _ _ v15 v16 v17 => (fun (v15 : @X.t) (v16 : list (@X.t)) (v17 : InA (@X.eq) v1 v16) (v18 : v15 :: v16 = nil) => (fun v19 : v15 :: v16 = nil => let v20 : @False := eq_ind (v15 :: v16) (fun v20 : list (@X.t) => match v20 as v21 in (list _) return Prop with | nil => @False | v21 :: v22 => (fun (v21 : @X.t) (v22 : list (@X.t)) => @True) v21 v22 end) (@I) nil v19 in False_ind (forall v21 : InA (@X.eq) v1 v16, X.eq v1 v0) v20) v18 v17) v15 v16 v17 end in v15 Logic.eq_refl) v13) v11) v9) v8) v6 v5) v3 v4 v5 end in v3 Logic.eq_refl) (fun v2 : X.eq v1 v0 => InA_cons_hd (eqA:=@X.eq) (x:=v1) (y:=v0) nil v2)) : forall v0 v1 : @elt, InA (@X.eq) v1 (v0 :: nil) <-> X.eq v1 v0) : forall v0 v1 : @elt, InA (@X.eq) v1 (singleton v0) <-> X.eq v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.union_inf	100	1.070211	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.union_ok	100	1.046194	1	2
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.union_spec	100	2.252558	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inter_inf	100	1.229755	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inter_ok	100	0.598334	1	2
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inter_spec	100	1.874969	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.diff_inf	100	1.261181	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.diff_ok	100	0.773274	1	2
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.diff_spec	100	1.790303	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.equal_spec	100	2.056566	1	1
