coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj1	100	0.026945	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@A) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v1) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj2	100	0.026089	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@B) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_refl	100	0.012714	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : v0 => v1) (fun v1 : v0 => v1))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_trans	100	0.031035	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v1 <-> v2, v0 <-> v2) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v1 <-> v2) => match v6 as v7 in (_ /\ _) return (v0 <-> v2) with | conj v7 v8 => (fun (v7 : forall v7 : v1, v2) (v8 : forall v8 : v2, v1) => conj (fun v9 : v0 => v7 (v4 v9)) (fun v9 : v2 => v5 (v4 (v5 (v8 v9))))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_sym	100	0.021160	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return (v1 <-> v0) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v4 v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_l	100	0.039424	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 /\ v1 <-> v0 /\ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 /\ v1 => match v6 as v7 in (_ /\ _) return (v0 /\ v2) with | conj v7 v8 => (fun (v7 : v0) (v8 : v1) => conj v7 (v4 v8)) v7 v8 end) (fun v6 : v0 /\ v2 => match v6 as v7 in (_ /\ _) return (v0 /\ v1) with | conj v7 v8 => (fun (v7 : v0) (v8 : v2) => conj v7 (v5 v8)) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_r	100	0.035756	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 /\ v0 <-> v2 /\ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 /\ v0 => match v6 as v7 in (_ /\ _) return (v2 /\ v0) with | conj v7 v8 => (fun (v7 : v1) (v8 : v0) => conj (v4 v7) v8) v7 v8 end) (fun v6 : v2 /\ v0 => match v6 as v7 in (_ /\ _) return (v1 /\ v0) with | conj v7 v8 => (fun (v7 : v2) (v8 : v0) => conj (v5 v7) v8) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_l	100	0.041540	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 \/ v1 <-> v0 \/ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 \/ v1 => match v6 as v7 in (_ \/ _) return (v0 \/ v2) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v1 => or_intror (v4 v7)) v7 end) (fun v6 : v0 \/ v2 => match v6 as v7 in (_ \/ _) return (v0 \/ v1) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v2 => or_intror (v5 v7)) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_r	100	0.043590	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 \/ v0 <-> v2 \/ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 \/ v0 => match v6 as v7 in (_ \/ _) return (v2 \/ v0) with | or_introl v7 => (fun v7 : v1 => or_introl (v4 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end) (fun v6 : v2 \/ v0 => match v6 as v7 in (_ \/ _) return (v1 \/ v0) with | or_introl v7 => (fun v7 : v2 => or_introl (v5 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_l	100	0.023490	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v0, v1) <-> (forall v5 : v0, v2)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v0, v1) (v7 : v0) => v4 (v6 v7)) (fun (v6 : forall v6 : v0, v2) (v7 : v0) => v5 (v6 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_r	100	0.023038	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v1, v0) <-> (forall v5 : v2, v0)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v1, v0) (v7 : v2) => v6 (v5 v7)) (fun (v6 : forall v6 : v2, v0) (v7 : v1) => v6 (v4 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.not_iff_compat	100	0.016032	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => imp_iff_compat_r (@False) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.neg_false	100	0.027933	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : forall v1 : v0, @False => conj v1 (fun v2 : @False => False_ind v0 v2)) (fun v1 : v0 <-> @False => match v1 as v2 in (_ /\ _) return (forall v3 : v0, @False) with | conj v2 v3 => (fun (v2 : forall v2 : v0, @False) (v3 : forall v3 : @False, v0) => v2) v2 v3 end) : ~ v0 <-> (v0 <-> @False))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_l	100	0.051407	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v0 /\ v1 <-> v0 /\ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 /\ v1, v0 /\ v2) (v7 : forall v7 : v0 /\ v2, v0 /\ v1) => conj (fun v8 : v1 => let v9 : forall v9 : v0 /\ v1, v2 := fun v9 : v0 /\ v1 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v0) (v11 : v2) => v11) v10 v11 end in v9 (conj (v3 v8) v8)) (fun v8 : v2 => let v9 : forall v9 : v0 /\ v2, v1 := fun v9 : v0 /\ v2 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v0) (v11 : v1) => v11) v10 v11 end in v9 (conj (v4 v8) v8))) v6 v7 end) (and_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_r	100	0.048466	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v1 /\ v0 <-> v2 /\ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 /\ v0, v2 /\ v0) (v7 : forall v7 : v2 /\ v0, v1 /\ v0) => conj (fun v8 : v1 => let v9 : forall v9 : v1 /\ v0, v2 := fun v9 : v1 /\ v0 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v2) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v3 v8))) (fun v8 : v2 => let v9 : forall v9 : v2 /\ v0, v1 := fun v9 : v2 /\ v0 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v1) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v4 v8)))) v6 v7 end) (and_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_comm	100	0.030719	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 /\ v1 => match v2 as v3 in (_ /\ _) return (v1 /\ v0) with | conj v3 v4 => (fun (v3 : v0) (v4 : v1) => conj v4 v3) v3 v4 end) (fun v2 : v1 /\ v0 => match v2 as v3 in (_ /\ _) return (v0 /\ v1) with | conj v3 v4 => (fun (v3 : v1) (v4 : v0) => conj v4 v3) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_assoc	100	0.050548	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 /\ v1) /\ v2 => match v3 as v4 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v4 v5 => (fun (v4 : v0 /\ v1) (v5 : v2) => match v4 as v6 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v6 v7 => (fun (v6 : v0) (v7 : v1) => conj v6 (conj v7 v5)) v6 v7 end) v4 v5 end) (fun v3 : v0 /\ v1 /\ v2 => match v3 as v4 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v4 v5 => (fun (v4 : v0) (v5 : v1 /\ v2) => match v5 as v6 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v6 v7 => (fun (v6 : v1) (v7 : v2) => conj (conj v4 v6) v7) v6 v7 end) v4 v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_l	100	0.057059	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v0 \/ v1 <-> v0 \/ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 \/ v1, v0 \/ v2) (v7 : forall v7 : v0 \/ v2, v0 \/ v1) => conj (fun v8 : v1 => let v9 : v0 \/ v2 := v6 (or_intror v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 | or_intror v10 => (fun v10 : v2 => v10) v10 end) (fun v8 : v2 => let v9 : v0 \/ v1 := v7 (or_intror v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 | or_intror v10 => (fun v10 : v1 => v10) v10 end)) v6 v7 end) (or_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_r	100	0.057101	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v1 \/ v0 <-> v2 \/ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 \/ v0, v2 \/ v0) (v7 : forall v7 : v2 \/ v0, v1 \/ v0) => conj (fun v8 : v1 => let v9 : v2 \/ v0 := v6 (or_introl v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v2 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 end) (fun v8 : v2 => let v9 : v1 \/ v0 := v7 (or_introl v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v1 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 end)) v6 v7 end) (or_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_comm	100	0.038711	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 \/ v1 => match v2 as v3 in (_ \/ _) return (v1 \/ v0) with | or_introl v3 => (fun v3 : v0 => or_intror v3) v3 | or_intror v3 => (fun v3 : v1 => or_introl v3) v3 end) (fun v2 : v1 \/ v0 => match v2 as v3 in (_ \/ _) return (v0 \/ v1) with | or_introl v3 => (fun v3 : v1 => or_intror v3) v3 | or_intror v3 => (fun v3 : v0 => or_introl v3) v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_assoc	100	0.060597	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 \/ v1) \/ v2 => match v3 as v4 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v4 => (fun v4 : v0 \/ v1 => match v4 as v5 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v5 => (fun v5 : v0 => or_introl v5) v5 | or_intror v5 => (fun v5 : v1 => or_intror (or_introl v5)) v5 end) v4 | or_intror v4 => (fun v4 : v2 => or_intror (or_intror v4)) v4 end) (fun v3 : v0 \/ v1 \/ v2 => match v3 as v4 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v4 => (fun v4 : v0 => or_introl (or_introl v4)) v4 | or_intror v4 => (fun v4 : v1 \/ v2 => match v4 as v5 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v5 => (fun v5 : v1 => or_introl (or_intror v5)) v5 | or_intror v5 => (fun v5 : v2 => or_intror v5) v5 end) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_and	100	0.022537	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v3 v4) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_to_and	100	0.038837	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 <-> v1 => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end) (fun v2 : (forall v2 : v0, v1) /\ (forall v2 : v1, v0) => match v2 as v3 in (_ /\ _) return (v0 <-> v1) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.inst	100	0.019513	1	1	0	synth with cache (only 1: refine ((fun (v0 : @A) (v1 : forall v1 : @A, P v1) => v1 v0) : forall (v0 : @A) (v1 : all (fun v1 : @A => P v1)), P v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.gen	100	0.018070	1	1	0	synth with cache (only 1: refine ((fun (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0) (v3 : @A) => v1 v3 v2) : forall (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0), all (@P))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.absurd	100	0.012812	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : Prop) (v2 : v0) (v3 : forall v3 : v0, @False) => let v4 : @False := v3 v2 in match v4 as v5 in False return v1 with end) : forall (v0 v1 : Prop) (v2 : v0) (v3 : ~ v0), v1)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_sym	100	0.021877	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (v1 = @x) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans	100	0.026844	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @y = @z) => match v1 as v3 in (_ = v2) return (@x = v2) with | eq_refl => v0 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans_r	100	0.029197	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @z = @y) => match v1 as v3 in (_ = v2) return (forall v4 : @x = v2, @x = @z) with | eq_refl => fun v2 : @x = @z => v2 end v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.f_equal	100	0.025438	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.not_eq_sym	100	0.029646	1	1	0	synth with cache (only 1: refine ((fun (v0 : @x <> @y) (v1 : @y = @x) => v0 (match v1 as v3 in (_ = v2) return (forall v4 : v2 <> @y, v2 = @y) with | eq_refl => fun v2 : @y <> @y => eq_refl end v0)) : forall v0 : @x <> @y, @y <> @x)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_sind_r	100	0.016616	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, SProp) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_sind (fun v6 : v0 => v2 v6) v3 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_ind_r	100	0.016683	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Prop) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_ind v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rec_r	100	0.015946	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Set) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rec v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rect_r	100	0.016447	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rect v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep.f_equal_dep	100	0.036283	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (rew [@B] v2 in f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep2.f_equal_dep2	100	0.066016	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v2 v6) (v9 : v2 v7) (v10 : v6 = v7) => match v10 as v12 in (_ = v11) return (forall (v13 : v2 v11) (v14 : rew [v2] v12 in v8 = v13), rew [v3] f_equal v4 v12 in v5 v6 v8 = v5 v11 v13) with | eq_refl => fun (v11 : v2 v6) (v12 : rew [v2] eq_refl in v8 = v11) => match v12 as v14 in (_ = v13) return (rew [v3] f_equal v4 eq_refl in v5 v6 v8 = v5 v6 v13) with | eq_refl => eq_refl end end v9)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_r	100	0.031425	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v3) => match v4 as v7 in (_ = v6) return (forall v8 : v1 v6, rew [v1] v7 in rew <- [v1] v7 in v8 = v8) with | eq_refl => fun v6 : v1 v2 => eq_refl end v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_l	100	0.030815	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v2) => match v4 as v7 in (_ = v6) return (rew <- [v1] v7 in rew [v1] v7 in v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal2	100	0.035995	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 : forall (v3 : v0) (v4 : v1), v2) (v4 v5 : v0) (v6 v7 : v1) (v8 : v4 = v5) => match v8 as v10 in (_ = v9) return (forall v11 : v6 = v7, v3 v4 v6 = v3 v9 v7) with | eq_refl => fun v9 : v6 = v7 => match v9 as v11 in (_ = v10) return (v3 v4 v6 = v3 v4 v10) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal3	100	0.051189	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : Type) (v4 : forall (v4 : v0) (v5 : v1) (v6 : v2), v3) (v5 v6 : v0) (v7 v8 : v1) (v9 v10 : v2) (v11 : v5 = v6) => match v11 as v13 in (_ = v12) return (forall (v14 : v7 = v8) (v15 : v9 = v10), v4 v5 v7 v9 = v4 v12 v8 v10) with | eq_refl => fun v12 : v7 = v8 => match v12 as v14 in (_ = v13) return (forall v15 : v9 = v10, v4 v5 v7 v9 = v4 v5 v13 v10) with | eq_refl => fun v13 : v9 = v10 => match v13 as v15 in (_ = v14) return (v4 v5 v7 v9 = v4 v5 v7 v14) with | eq_refl => eq_refl end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal4	100	0.065170	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 : Type) (v5 : forall (v5 : v0) (v6 : v1) (v7 : v2) (v8 : v3), v4) (v6 v7 : v0) (v8 v9 : v1) (v10 v11 : v2) (v12 v13 : v3) (v14 : v6 = v7) => match v14 as v16 in (_ = v15) return (forall (v17 : v8 = v9) (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v15 v9 v11 v13) with | eq_refl => fun v15 : v8 = v9 => match v15 as v17 in (_ = v16) return (forall (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v6 v16 v11 v13) with | eq_refl => fun v16 : v10 = v11 => match v16 as v18 in (_ = v17) return (forall v19 : v12 = v13, v5 v6 v8 v10 v12 = v5 v6 v8 v17 v13) with | eq_refl => fun v17 : v12 = v13 => match v17 as v19 in (_ = v18) return (v5 v6 v8 v10 v12 = v5 v6 v8 v10 v18) with | eq_refl => eq_refl end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal5	100	0.146432	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 v5 : Type) (v6 : forall (v6 : v0) (v7 : v1) (v8 : v2) (v9 : v3) (v10 : v4), v5) (v7 v8 : v0) (v9 v10 : v1) (v11 v12 : v2) (v13 v14 : v3) (v15 v16 : v4) (v17 : v7 = v8) => match v17 as v19 in (_ = v18) return (forall (v20 : v9 = v10) (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v18 v10 v12 v14 v16) with | eq_refl => fun v18 : v9 = v10 => match v18 as v20 in (_ = v19) return (forall (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v19 v12 v14 v16) with | eq_refl => fun v19 : v11 = v12 => match v19 as v21 in (_ = v20) return (forall (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v9 v20 v14 v16) with | eq_refl => fun v20 : v13 = v14 => match v20 as v22 in (_ = v21) return (forall v23 : v15 = v16, v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v21 v16) with | eq_refl => fun v21 : v15 = v16 => match v21 as v23 in (_ = v22) return (v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v13 v22) with | eq_refl => eq_refl end end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal_compose	100	1.893360	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : forall v6 : v1, v2) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v6 (f_equal v5 v9) = f_equal (fun v10 : v0 => v6 (v5 v10)) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_l	100	0.034417	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans eq_refl v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_r	100	0.072774	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 eq_refl = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_involutive	100	0.059533	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_sym (eq_sym v5) = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_l	100	0.050333	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans (eq_sym v5) v5 = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_r	100	1.872085	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 (eq_sym v5) = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_assoc	100	0.061147	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 v4 : v0) (v5 : v1 = v2) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (eq_trans v5 (eq_trans v6 v9) = eq_trans (eq_trans v5 v6) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_map	100	0.052113	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v1, Type) (v3 : forall v3 : v0, v1) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v2 (v3 v4), rew [fun v10 : v0 => v2 (v3 v10)] v8 in v9 = rew [v2] f_equal v3 v8 in v9) with | eq_refl => fun v7 : v2 (v3 v4) => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map	100	0.068273	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v1 v2) (v6 : v1 v3) (v7 : v1 v4) (v8 : v2 = v3) (v9 : v3 = v4) (v10 : rew [v1] v8 in v5 = v6) (v11 : rew [v1] v9 in v6 = v7) => match v9 as v13 in (_ = v12) return (forall (v14 : v1 v12) (v15 : rew [v1] v13 in v6 = v14), rew [v1] eq_trans v8 v13 in v5 = v14) with | eq_refl => fun (v12 : v1 v3) (v13 : rew [v1] eq_refl in v6 = v12) => eq_trans v10 v13 end v7 v11)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst	100	1.709671	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v1 v3), v2 v3) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v4, rew [v2] v8 in v3 v4 v9 = v3 v7 (rew [v1] v8 in v9)) with | eq_refl => fun v7 : v1 v4 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst_map	100	0.056881	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v6 = v7) => match v8 as v10 in (_ = v9) return (forall v11 : v2 v6, rew [v3] f_equal v4 v10 in v5 v6 v11 = v5 v9 (rew [v2] v10 in v11)) with | eq_refl => fun v9 : v2 v6 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_swap	100	0.040556	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall (v7 : v1 v2) (v8 : v1 v5) (v9 : rew [v1] v6 in v7 = v8), v7 = rew <- [v1] v6 in v8) with | eq_refl => fun (v5 v6 : v1 v2) (v7 : rew [v1] eq_refl in v5 = v6) => v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_compose	100	0.050503	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) (v6 : v3 = v4) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] v8 in rew [v1] v5 in v9 = rew [v1] eq_trans v5 v8 in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_l	100	1.678694	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v2 = v1 v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 v3)) (v2 v3)) (fun v4 : v1 v3 = v1 v3 => match v2 v3 as v6 in (_ = v5) return (v1 v3 = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : v3 = v1 v3 := v2 v3 in let v5 : v0 := v1 v3 in match v4 as v7 in (_ = v6) return (match v7 as v9 in (_ = v8) return (v6 = v1 v8) with | eq_refl => eq_trans (eq_sym v7) (v2 v3) end = v2 v6) with | eq_refl => let v6 : v3 = v1 v3 := v2 v3 in let v7 : v0 := v1 v3 in match v6 as v9 in (_ = v8) return (eq_trans (eq_sym eq_refl) v9 = v9) with | eq_refl => eq_refl end end) eq_refl (eq_trans_sym_inv_l (v2 v3)) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_r	100	1.890482	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v1 v2 = v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 (v1 (v1 v3)))) (v2 (v1 (v1 v3)))) (fun v4 : v1 (v1 v3) = v1 (v1 v3) => match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : forall v4 : v0, v4 = v1 v4 := fun v4 : v0 => eq_sym (v2 v4) in (let v5 : f_equal v1 (v4 (v1 v3)) = v4 (v1 (v1 v3)) := eq_id_comm_l v1 v4 (v1 v3) in let v6 : v1 (v1 v3) = v1 (v1 (v1 v3)) := v4 (v1 (v1 v3)) in match v5 as v8 in (_ = v7) return (match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans v7 (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => let v7 : f_equal v1 (v4 v3) = v4 (v1 v3) := eq_id_comm_l v1 v4 v3 in let v8 : v1 v3 = v1 (v1 v3) := v4 (v1 v3) in match v7 as v10 in (_ = v9) return (match v2 v3 as v12 in (_ = v11) return (v1 (v1 v3) = v1 v11) with | eq_refl => eq_trans (f_equal v1 v9) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => (let v9 : v1 v3 = v3 := v2 v3 in match v9 as v11 in (_ = v10) return (match v11 as v13 in (_ = v12) return (v1 (v1 v10) = v1 v12) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (eq_sym v11))) (v2 (v1 (v1 v3))) end = v2 (v1 v10)) with | eq_refl => eq_ind_r (fun v10 : v1 (v1 (v1 v3)) = v1 (v1 v3) => v10 = v2 (v1 (v1 v3))) eq_refl (eq_trans_refl_l (v2 (v1 (v1 v3)))) : eq_trans (f_equal v1 (f_equal v1 (eq_sym eq_refl))) (v2 (v1 (v1 v3))) = v2 (v1 (v1 v3)) end) : match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (v4 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3) end end) : match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => eq_trans (v4 (v1 (v1 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) eq_refl (eq_trans_sym_inv_l (v2 (v1 (v1 v3)))) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_refl_map_distr	100	0.026206	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : v0) (v3 : forall v3 : v0, v1) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map_distr	100	0.060422	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v5 (eq_trans v6 v9) = eq_trans (f_equal v5 v6) (f_equal v5 v9)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_map_distr	100	1.772872	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : forall v4 : v0, v1) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (eq_sym (f_equal v4 v7) = f_equal v4 (eq_sym v7)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_distr	100	0.067890	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) => match v4 as v6 in (_ = v5) return (forall v7 : v5 = v3, eq_sym (eq_trans v6 v7) = eq_trans (eq_sym v7) (eq_sym v6)) with | eq_refl => fun v5 : v1 = v3 => match v5 as v7 in (_ = v6) return (eq_sym (eq_trans eq_refl v7) = eq_trans (eq_sym v7) (eq_sym eq_refl)) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_rew_distr	100	0.084954	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (forall (v8 : v6 = v4) (v9 : v1 v2), rew [v1] eq_trans v7 v8 in v9 = rew [v1] v8 in rew [v1] v7 in v9) with | eq_refl => fun v6 : v2 = v4 => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] eq_trans eq_refl v8 in v9 = rew [v1] v8 in rew [v1] eq_refl in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_const	100	0.027784	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall v7 : v1, rew [fun v8 : v0 => v1] v6 in v7 = v7) with | eq_refl => fun v5 : v1 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.unique_existence	100	1.757750	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) => conj (fun v2 : (exists v2 : v0, v1 v2) /\ uniqueness v1 => match v2 as v3 in (_ /\ _) return (exists ! v4 : v0, v1 v4) with | conj v3 v4 => (fun (v3 : exists v3 : v0, v1 v3) (v4 : uniqueness v1) => match v3 as v5 in (ex _) return (exists ! v6 : v0, v1 v6) with | ex_intro _ v5 v6 => (fun (v5 : v0) (v6 : v1 v5) => ex_intro (unique (fun v7 : v0 => v1 v7)) v5 (conj v6 (fun (v7 : v0) (v8 : v1 v7) => v4 v5 v7 v6 v8) : unique (fun v7 : v0 => v1 v7) v5)) v5 v6 end) v3 v4 end) (fun v2 : exists ! v2 : v0, v1 v2 => match v2 as v3 in (ex _) return ((exists v4 : v0, v1 v4) /\ uniqueness v1) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return ((exists v6 : v0, v1 v6) /\ uniqueness v1) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) => conj (ex_intro (fun v7 : v0 => v1 v7) v3 v5) ((fun (v7 v8 : v0) (v9 : v1 v7) (v10 : v1 v8) => eq_trans (eq_sym (v6 v7 v9)) (v6 v8 v10)) : uniqueness v1)) v5 v6 end) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_unique_domain_coincide	100	0.074009	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists ! v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (forall v4 : forall v4 : v0, Prop, (forall (v5 : v0) (v6 : v1 v5), v4 v5) <-> (exists v5 : v0, v1 v5 /\ v4 v5)) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return (forall v6 : forall v6 : v0, Prop, (forall (v7 : v0) (v8 : v1 v7), v6 v7) <-> (exists v7 : v0, v1 v7 /\ v6 v7)) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) (v7 : forall v7 : v0, Prop) => conj (fun v8 : forall (v8 : v0) (v9 : v1 v8), v7 v8 => ex_intro (fun v9 : v0 => v1 v9 /\ v7 v9) v3 (conj v5 (v8 v3 v5))) (fun v8 : exists v8 : v0, v1 v8 /\ v7 v8 => match v8 as v9 in (ex _) return (forall (v10 : v0) (v11 : v1 v10), v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v0) (v10 : v1 v9 /\ v7 v9) => match v10 as v11 in (_ /\ _) return (forall (v12 : v0) (v13 : v1 v12), v7 v12) with | conj v11 v12 => (fun (v11 : v1 v9) (v12 : v7 v9) (v13 : v0) (v14 : v1 v13) => let v15 : v9 = v13 := eq_trans (eq_sym (v6 v9 v11)) (v6 v13 v14) in match v15 as v17 in (_ = v16) return (forall v18 : v1 v16, v7 v16) with | eq_refl => fun v16 : v1 v9 => v12 end v14) v11 v12 end) v9 v10 end)) v5 v6 end) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_coincide_unique_domain	100	1.667174	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : forall v2 : v0, Prop, (forall (v3 : v0) (v4 : v1 v3), v2 v3) <-> (exists v3 : v0, v1 v3 /\ v2 v3)) => let v3 : (forall v3 : forall (v3 : v0) (v4 : v1 v3), v1 v3, exists v4 : v0, v1 v4 /\ v1 v4) /\ (forall (v3 : exists v3 : v0, v1 v3 /\ v1 v3) (v4 : v0) (v5 : v1 v4), v1 v4) := v2 v1 in match v3 as v4 in (_ /\ _) return (exists ! v5 : v0, v1 v5) with | conj v4 v5 => (fun (v4 : forall v4 : forall (v4 : v0) (v5 : v1 v4), v1 v4, exists v5 : v0, v1 v5 /\ v1 v5) (v5 : forall (v5 : exists v5 : v0, v1 v5 /\ v1 v5) (v6 : v0) (v7 : v1 v6), v1 v6) => let v6 : exists v6 : v0, v1 v6 /\ v1 v6 := v4 (fun (v6 : v0) (v7 : v1 v6) => v7) in match v6 as v7 in (ex _) return (exists ! v8 : v0, v1 v8) with | ex_intro _ v7 v8 => (fun (v7 : v0) (v8 : v1 v7 /\ v1 v7) => match v8 as v9 in (_ /\ _) return (exists ! v10 : v0, v1 v10) with | conj v9 v10 => (fun v9 v10 : v1 v7 => ex_intro (unique (fun v11 : v0 => v1 v11)) v7 (conj v9 (let v11 : (forall v11 : forall (v11 : v0) (v12 : v1 v11), v7 = v11, exists v12 : v0, v1 v12 /\ v7 = v12) /\ (forall (v11 : exists v11 : v0, v1 v11 /\ v7 = v11) (v12 : v0) (v13 : v1 v12), v7 = v12) := v2 (fun v11 : v0 => v7 = v11) in match v11 as v12 in (_ /\ _) return (forall (v13 : v0) (v14 : v1 v13), v7 = v13) with | conj v12 v13 => (fun (v12 : forall v12 : forall (v12 : v0) (v13 : v1 v12), v7 = v12, exists v13 : v0, v1 v13 /\ v7 = v13) (v13 : forall (v13 : exists v13 : v0, v1 v13 /\ v7 = v13) (v14 : v0) (v15 : v1 v14), v7 = v14) => v13 (ex_intro (fun v14 : v0 => v1 v14 /\ v7 = v14) v7 (conj v9 eq_refl))) v12 v13 end))) v9 v10 end) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.exists_inhabited	100	0.020131	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (inhabited v0) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : v1 v3) => inhabits v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.inhabited_covariant	100	0.018186	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, v1) (v3 : inhabited v0) => match v3 as v4 in (inhabited _) return (inhabited v1) with | inhabits v4 => (fun v4 : v0 => inhabits (v2 v4)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_stepl	100	0.018941	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) (v5 : v1 = v3) => eq_ind v1 (fun v6 : v0 => v6 = v2) v4 v3 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_stepl	100	0.028232	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v0 <-> v2, v2 <-> v1) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v0 <-> v2) => match v6 as v7 in (_ /\ _) return (v2 <-> v1) with | conj v7 v8 => (fun (v7 : forall v7 : v0, v2) (v8 : forall v8 : v2, v0) => conj (fun v9 : v2 => v4 (v5 (v4 (v8 v9)))) (fun v9 : v1 => v7 (v5 v9))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.eq_ex_uncurried	100	1.802034	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 v3 : v0) (v4 : v1 v2) (v5 : v1 v3) (v6 : exists v6 : v2 = v3, rew [v1] v6 in v4 = v5) => match v6 as v7 in (ex _) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v5) with | ex_intro _ v7 v8 => (fun (v7 : v2 = v3) (v8 : rew [v1] v7 in v4 = v5) => match v8 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v9) with | eq_refl => match v7 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v9 (rew [v1] v10 in v4)) with | eq_refl => eq_refl end : ex_intro v1 v2 v4 = ex_intro v1 v3 (rew [v1] v7 in v4) end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.rew_ex	100	0.124219	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : exists v4 : v2 v1, v3 v1 v4) (v5 : v0) (v6 : v1 = v5) => match v6 as v8 in (_ = v7) return (rew [fun v9 : v0 => exists v10 : v2 v9, v3 v9 v10] v8 in v4 = match v4 as v9 in (ex _) return (exists v10 : v2 v7, v3 v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) => ex_intro (v3 v7) (rew [v2] v8 in v9) match v8 as v12 in (_ = v11) return (v3 v11 (rew [v2] v12 in v9)) with | eq_refl => v10 end) v9 v10 end) with | eq_refl => match v4 as v7 in (ex _) return (rew [fun v8 : v0 => exists v9 : v2 v8, v3 v8 v9] eq_refl in v7 = match v7 as v8 in (ex _) return (exists v9 : v2 v1, v3 v1 v9) with | ex_intro _ v8 v9 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) => ex_intro (v3 v1) (rew [v2] eq_refl in v8) v9) v8 v9 end) with | ex_intro _ v7 v8 => (fun (v7 : v2 v1) (v8 : v3 v1 v7) => eq_refl) v7 v8 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.eq_ex2_uncurried	100	1.836951	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : v0, Prop) (v3 v4 : v0) (v5 : v1 v3) (v6 : v1 v4) (v7 : v2 v3) (v8 : v2 v4) (v9 : exists2 v9 : v3 = v4, rew [v1] v9 in v5 = v6 & rew [v2] v9 in v7 = v8) => match v9 as v10 in (ex2 _ _) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v8) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v3 = v4) (v11 : rew [v1] v10 in v5 = v6) (v12 : rew [v2] v10 in v7 = v8) => match v12 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v13) with | eq_refl => match v11 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v13 (rew [v2] v10 in v7)) with | eq_refl => match v10 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v13 (rew [v1] v14 in v5) (rew [v2] v14 in v7)) with | eq_refl => eq_refl : ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v3 (rew [v1] eq_refl in v5) (rew [v2] eq_refl in v7) end end end) v10 v11 v12 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.rew_ex2	100	1.975874	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : forall (v4 : v0) (v5 : v2 v4), Prop) (v5 : exists2 v5 : v2 v1, v3 v1 v5 & v4 v1 v5) (v6 : v0) (v7 : v1 = v6) => match v7 as v9 in (_ = v8) return (rew [fun v10 : v0 => exists2 v11 : v2 v10, v3 v10 v11 & v4 v10 v11] v9 in v5 = match v5 as v10 in (ex2 _ _) return (exists2 v11 : v2 v8, v3 v8 v11 & v4 v8 v11) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v2 v1) (v11 : v3 v1 v10) (v12 : v4 v1 v10) => ex_intro2 (v3 v8) (v4 v8) (rew [v2] v9 in v10) match v9 as v14 in (_ = v13) return (v3 v13 (rew [v2] v14 in v10)) with | eq_refl => v11 end match v9 as v14 in (_ = v13) return (v4 v13 (rew [v2] v14 in v10)) with | eq_refl => v12 end) v10 v11 v12 end) with | eq_refl => match v5 as v8 in (ex2 _ _) return (rew [fun v9 : v0 => exists2 v10 : v2 v9, v3 v9 v10 & v4 v9 v10] eq_refl in v8 = match v8 as v9 in (ex2 _ _) return (exists2 v10 : v2 v1, v3 v1 v10 & v4 v1 v10) with | ex_intro2 _ _ v9 v10 v11 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) (v11 : v4 v1 v9) => ex_intro2 (v3 v1) (v4 v1) (rew [v2] eq_refl in v9) v10 v11) v9 v10 v11 end) with | ex_intro2 _ _ v8 v9 v10 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) (v10 : v4 v1 v8) => eq_refl) v8 v9 v10 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_succ_r'	100	0.610961	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => pow_succ_r v0 v1 (le_0_l v1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_0_l	100	0.029095	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : v0 ~= 0) => pow_0_l v0 ((fun v2 : v0 ~= 0 <-> 0 < v0 => iff_flip_impl_subrelation (0 < v0) (v0 ~= 0) (symmetry v2)) (neq_0_lt_0 v0) v1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_1_l	100	0.016044	1	1	0	synth with cache (only 1: refine (fun v0 : @t => pow_1_l v0 (le_0_l v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_add_r	100	0.024910	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @t => pow_add_r v0 v1 v2 (le_0_l v1) (le_0_l v2))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_mul_l	100	0.023843	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @t => pow_mul_l v0 v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_mul_r	100	0.022908	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @t => pow_mul_r v0 v1 v2 (le_0_l v1) (le_0_l v2))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_eq_0	100	1.758002	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : v1 ~= 0) (v3 : v0 ^ v1 == 0) => pow_eq_0 v0 v1 (le_0_l v1) v3)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_nonzero	100	0.024467	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : v0 ~= 0) => pow_nonzero v0 v1 v2 (le_0_l v1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_eq_0_iff	100	0.110695	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj ((fun v2 : v0 ^ v1 == 0 <-> v1 < 0 \/ 0 < v1 /\ v0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 ^ v1 == 0) (v1 < 0 \/ 0 < v1 /\ v0 == 0) v2 (v1 ~= 0 /\ v0 == 0) (v1 ~= 0 /\ v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v1 ~= 0 /\ v0 == 0))) (pow_eq_0_iff v0 v1) (fun v2 : v1 < 0 \/ 0 < v1 /\ v0 == 0 => match v2 as v3 in (_ \/ _) return (v1 ~= 0 /\ v0 == 0) with | or_introl v3 => (fun v3 : v1 < 0 => (fun v4 : 0 <= v1 => False_ind (v1 ~= 0 /\ v0 == 0) ((fun v5 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v5) (Private_OrderTac.Tac.le_lt_trans v4 v3))) (le_0_l v1)) v3 | or_intror v3 => (fun v3 : 0 < v1 /\ v0 == 0 => match v3 as v4 in (_ /\ _) return (v1 ~= 0 /\ v0 == 0) with | conj v4 v5 => (fun (v4 : 0 < v1) (v5 : v0 == 0) => conj ((fun v6 : v1 == 0 => False_ind (@False) ((fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_eq v4 v6))) : v1 ~= 0) (Private_OrderTac.Tac.not_neq_eq ((fun v6 : v0 ~= 0 => (fun v7 : 0 ~= 0 => v7 (Private_OrderTac.Tac.eq_refl 0)) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v5) v6)) : ~ v0 ~= 0))) v4 v5 end) v3 end)) (fun v2 : v1 ~= 0 /\ v0 == 0 => match v2 as v3 in (_ /\ _) return (v0 ^ v1 == 0) with | conj v3 v4 => (fun (v3 : v1 ~= 0) (v4 : v0 == 0) => (fun v5 : v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ v1) (0 ^ v1) (pow_wd v0 0 v5 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) 0 0 (eq_proper_proxy 0)) v4 (pow_0_l' v1 v3)) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_lt_mono_l	100	0.038117	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : v2 ~= 0) (v4 : v0 < v1) => pow_lt_mono_l v0 v1 v2 ((fun v5 : v2 ~= 0 <-> 0 < v2 => iff_flip_impl_subrelation (0 < v2) (v2 ~= 0) (symmetry v5)) (neq_0_lt_0 v2) v3) (conj (le_0_l v0) v4))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_le_mono_l	100	1.762429	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 <= v1) => pow_le_mono_l v0 v1 v2 (conj (le_0_l v0) v3))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_gt_1	100	0.052771	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 1 < v0) (v3 : v1 ~= 0) => let v4 : forall (v4 v5 : @t) (v6 : 1 < v4) (v7 : 0 < v5), 1 < v4 ^ v5 := fun (v4 v5 : @t) (v6 : 1 < v4) => match pow_gt_1 v4 v5 v6 as v7 in (_ /\ _) return (forall v8 : 0 < v5, 1 < v4 ^ v5) with | conj v7 v8 => (fun (v7 : forall v7 : 0 < v5, 1 < v4 ^ v5) (v8 : forall v8 : 1 < v4 ^ v5, 0 < v5) => v7) v7 v8 end in v4 v0 v1 v2 ((fun v5 : v1 ~= 0 <-> 0 < v1 => iff_flip_impl_subrelation (0 < v1) (v1 ~= 0) (symmetry v5)) (neq_0_lt_0 v1) v3))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_lt_mono_r	100	0.026601	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 1 < v0) (v4 : v1 < v2) => pow_lt_mono_r v0 v1 v2 v3 (le_0_l v2) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_le_mono_r	100	0.037041	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 ~= 0) (v4 : v1 <= v2) => pow_le_mono_r v0 v1 v2 ((fun v5 : v0 ~= 0 <-> 0 < v0 => iff_flip_impl_subrelation (0 < v0) (v0 ~= 0) (symmetry v5)) (neq_0_lt_0 v0) v3) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_le_mono	100	1.834660	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @t) (v4 : v0 ~= 0) (v5 : v0 <= v2) (v6 : v1 <= v3) => pow_le_mono v0 v1 v2 v3 ((fun v7 : v0 ~= 0 <-> 0 < v0 => subrelation_proper (@and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 < v0) (v0 ~= 0) (symmetry v7) (v0 <= v2) (v0 <= v2) (reflexive_proper_proxy (@iff_Reflexive) (v0 <= v2))) (neq_0_lt_0 v0) (conj v4 v5)) v6)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_inj_l	100	0.036789	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : v2 ~= 0) (v4 : v0 ^ v2 == v1 ^ v2) => pow_inj_l v0 v1 v2 (le_0_l v0) (le_0_l v1) ((fun v5 : v2 ~= 0 <-> 0 < v2 => iff_flip_impl_subrelation (0 < v2) (v2 ~= 0) (symmetry v5)) (neq_0_lt_0 v2) v3) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_inj_r	100	0.027601	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 1 < v0) (v4 : v0 ^ v1 == v0 ^ v2) => pow_inj_r v0 v1 v2 v3 (le_0_l v1) (le_0_l v2) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_lt_mono_l_iff	100	0.036328	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : v2 ~= 0) => pow_lt_mono_l_iff v0 v1 v2 (le_0_l v0) (le_0_l v1) ((fun v4 : v2 ~= 0 <-> 0 < v2 => iff_flip_impl_subrelation (0 < v2) (v2 ~= 0) (symmetry v4)) (neq_0_lt_0 v2) v3))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NPow.NPowProp.pow_le_mono_l_iff	100	0.036178	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : v2 ~= 0) => pow_le_mono_l_iff v0 v1 v2 (le_0_l v0) (le_0_l v1) ((fun v4 : v2 ~= 0 <-> 0 < v2 => iff_flip_impl_subrelation (0 < v2) (v2 ~= 0) (symmetry v4)) (neq_0_lt_0 v2) v3))).
tch Rle_dec v0 v1 as v4 in ({_} + {_}) return (match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end > v2) with | left v4 => and_ind (fun (v4 : v0 > v2) (v5 : v1 > v2) (v6 : v0 <= v1) => v4) v3 v4 | right v4 => and_ind (fun (v4 : v0 > v2) (v5 : v1 > v2) (v6 : ~ v0 <= v1) => v5) v3 v4 end : Rmin v0 v1 > v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_Rgt	100	0.043063	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => conj (Rmin_Rgt_l v0 v1 v2) (Rmin_Rgt_r v0 v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_l	100	0.046358	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => match Rle_dec v0 v1 as v2 in ({_} + {_}) return (match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 <= v1 => v0) v3 | right v3 => (fun v3 : ~ v0 <= v1 => v1) v3 end <= v0) with | left v2 => (fun v2 : v0 <= v1 => or_intror eq_refl) v2 | right v2 => (fun v2 : ~ v0 <= v1 => Rlt_le v1 v0 (Rnot_le_lt v0 v1 v2)) v2 end : Rmin v0 v1 <= v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_r	100	0.043971	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => match Rle_dec v0 v1 as v2 in ({_} + {_}) return (match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 <= v1 => v0) v3 | right v3 => (fun v3 : ~ v0 <= v1 => v1) v3 end <= v1) with | left v2 => (fun v2 : v0 <= v1 => v2) v2 | right v2 => (fun v2 : ~ v0 <= v1 => Req_le_sym v1 v1 eq_refl) v2 end : Rmin v0 v1 <= v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_left	100	0.080540	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : v0 <= v1) => let v3 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v3 as v4 in ({_} + {_}) return (match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end = v0) with | left v4 => (fun v4 : v0 <= v1 => or_ind (fun v5 : v0 < v1 => or_ind (fun v6 : v0 < v1 => eq_refl) (fun v6 : v0 = v1 => eq_refl) v4) (fun v5 : v0 = v1 => or_ind (fun v6 : v0 < v1 => eq_refl) (fun v6 : v0 = v1 => eq_refl) v4) v2 : v0 = v0) v4 | right v4 => (fun v4 : ~ v0 <= v1 => let v5 : v1 < v0 := Rnot_le_lt v0 v1 v4 in or_ind (fun v6 : v0 < v1 => Rle_antisym v1 v0 (Rge_le v0 v1 (Rle_ge v1 v0 (Rlt_le v1 v0 v5))) (Rge_le v1 v0 (Rle_ge v0 v1 (Rlt_le v0 v1 v6))) : v1 = v0) (fun v6 : v0 = v1 => eq_sym v6 : v1 = v0) v2 : v1 = v0) v4 end) : forall (v0 v1 : @R) (v2 : v0 <= v1), Rmin v0 v1 = v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_right	100	0.077700	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : v1 <= v0) => let v3 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v3 as v4 in ({_} + {_}) return (match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end = v1) with | left v4 => (fun v4 : v0 <= v1 => or_ind (fun v5 : v1 < v0 => or_ind (fun v6 : v0 < v1 => Rle_antisym v0 v1 (Rge_le v1 v0 (Rle_ge v0 v1 (Rlt_le v0 v1 v6))) (Rge_le v0 v1 (Rle_ge v1 v0 (Rlt_le v1 v0 v5))) : v0 = v1) (fun v6 : v0 = v1 => v6) v4) (fun v5 : v1 = v0 => or_ind (fun v6 : v0 < v1 => eq_sym v5 : v0 = v1) (fun v6 : v0 = v1 => v6) v4) v2 : v0 = v1) v4 | right v4 => (fun v4 : ~ v0 <= v1 => let v5 : v1 < v0 := Rnot_le_lt v0 v1 v4 in or_ind (fun v6 : v1 < v0 => eq_refl) (fun v6 : v1 = v0 => eq_refl) v2 : v1 = v1) v4 end) : forall (v0 v1 : @R) (v2 : v1 <= v0), Rmin v0 v1 = v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rle_min_compat_r	100	0.044002	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v1) => Rmin_case_strong v0 v2 (fun v4 : @R => v4 <= Rmin v1 v2) (fun v4 : v0 <= v2 => Rmin_case_strong v1 v2 (fun v5 : @R => v0 <= v5) (fun v5 : v1 <= v2 => v3) (fun v5 : v2 <= v1 => v4)) (fun v4 : v2 <= v0 => Rmin_case_strong v1 v2 (fun v5 : @R => v2 <= v5) (fun v5 : v1 <= v2 => Rle_trans v2 v0 v1 v4 v3) (fun v5 : v2 <= v1 => Rle_refl v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rle_min_compat_l	100	0.045360	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v1) => Rmin_case_strong v2 v0 (fun v4 : @R => v4 <= Rmin v2 v1) (fun v4 : v2 <= v0 => Rmin_case_strong v2 v1 (fun v5 : @R => v2 <= v5) (fun v5 : v2 <= v1 => Rle_refl v2) (fun v5 : v1 <= v2 => Rle_trans v2 v0 v1 v4 v3)) (fun v4 : v0 <= v2 => Rmin_case_strong v2 v1 (fun v5 : @R => v0 <= v5) (fun v5 : v2 <= v1 => v4) (fun v5 : v1 <= v2 => v3)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_comm	100	0.104602	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => match Rle_dec v0 v1 as v2 in ({_} + {_}) return (match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 <= v1 => v0) v3 | right v3 => (fun v3 : ~ v0 <= v1 => v1) v3 end = match Rle_dec v1 v0 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v1 <= v0 => v1) v3 | right v3 => (fun v3 : ~ v1 <= v0 => v0) v3 end) with | left v2 => match Rle_dec v1 v0 as v2 in ({_} + {_}) return (forall v3 : v0 <= v1, v0 = match v2 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 <= v0 => v1) v4 | right v4 => (fun v4 : ~ v1 <= v0 => v0) v4 end) with | left v2 => (fun (v2 : v1 <= v0) (v3 : v0 <= v1) => Rle_antisym v0 v1 v3 v2) v2 | right v2 => (fun (v2 : ~ v1 <= v0) (v3 : v0 <= v1) => eq_refl) v2 end v2 | right v2 => match Rle_dec v1 v0 as v2 in ({_} + {_}) return (forall v3 : ~ v0 <= v1, v1 = match v2 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 <= v0 => v1) v4 | right v4 => (fun v4 : ~ v1 <= v0 => v0) v4 end) with | left v2 => (fun (v2 : v1 <= v0) (v3 : ~ v0 <= v1) => eq_refl) v2 | right v2 => (fun (v2 : ~ v1 <= v0) (v3 : ~ v0 <= v1) => Rle_antisym v1 v0 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v3)) (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v2))) v2 end v2 end : Rmin v0 v1 = Rmin v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_stable_in_posreal	100	0.037035	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @posreal => Rmin_Rgt_r v0 v1 (IZR 0) (conj (cond_pos v0) (cond_pos v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_pos	100	0.069470	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : IZR 0 < v0) (v3 : IZR 0 < v1) => match Rle_dec v0 v1 as v4 in ({_} + {_}) return (IZR 0 < match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end) with | left v4 => (fun v4 : v0 <= v1 => v2) v4 | right v4 => (fun v4 : ~ v0 <= v1 => v3) v4 end : IZR 0 < Rmin v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_glb	100	0.074149	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v2 <= v0) (v4 : v2 <= v1) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (v2 <= match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v0) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v1) v6 end) with | left v5 => (fun v5 : v0 <= v1 => v3) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v4) v5 end : v2 <= Rmin v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_glb_lt	100	0.073192	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v2 < v0) (v4 : v2 < v1) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (v2 < match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v0) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v1) v6 end) with | left v5 => (fun v5 : v0 <= v1 => v3) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v4) v5 end : v2 < Rmin v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_case	100	0.053194	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, Type) (v3 : v2 v0) (v4 : v2 v1) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (v2 match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v1) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v0) v6 end) with | left v5 => (fun v5 : v0 <= v1 => v4) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v3) v5 end : v2 (Rmax v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_case_strong	100	0.060876	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, Type) (v3 : forall v3 : v1 <= v0, v2 v0) (v4 : forall v4 : v0 <= v1, v2 v1) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (v2 match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v1) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v0) v6 end) with | left v5 => v4 v5 | right v5 => (fun v5 : ~ v0 <= v1 => v3 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v5))) v5 end : v2 (Rmax v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_Rle	100	0.108530	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => conj (match Rle_dec v0 v1 as v3 in ({_} + {_}) return (forall v4 : v2 <= match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 <= v1 => v1) v4 | right v4 => (fun v4 : ~ v0 <= v1 => v0) v4 end, v2 <= v0 \/ v2 <= v1) with | left v3 => (fun (v3 : v0 <= v1) (v4 : v2 <= v1) => or_intror v4) v3 | right v3 => (fun (v3 : ~ v0 <= v1) (v4 : v2 <= v0) => or_introl v4) v3 end : forall v3 : v2 <= Rmax v0 v1, v2 <= v0 \/ v2 <= v1) (fun v3 : v2 <= v0 \/ v2 <= v1 => (let v4 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v4 as v5 in ({_} + {_}) return (v2 <= match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v1) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v0) v6 end) with | left v5 => (fun v5 : v0 <= v1 => or_ind (fun v6 : v2 <= v0 => Rle_trans v2 v0 v1 v6 v5) (fun v6 : v2 <= v1 => v6) v3) v5 | right v5 => (fun v5 : ~ v0 <= v1 => or_ind (fun v6 : v2 <= v0 => v6) (fun v6 : v2 <= v1 => (fun v7 : v1 < v0 => Rlt_le v2 v0 (Rle_lt_trans v2 v1 v0 v6 v7)) (Rnot_le_lt v0 v1 v5)) v3) v5 end) : v2 <= Rmax v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_comm	100	0.101435	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => match Rle_dec v0 v1 as v2 in ({_} + {_}) return (match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 <= v1 => v1) v3 | right v3 => (fun v3 : ~ v0 <= v1 => v0) v3 end = match Rle_dec v1 v0 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v1 <= v0 => v0) v3 | right v3 => (fun v3 : ~ v1 <= v0 => v1) v3 end) with | left v2 => match Rle_dec v1 v0 as v2 in ({_} + {_}) return (forall v3 : v0 <= v1, v1 = match v2 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 <= v0 => v0) v4 | right v4 => (fun v4 : ~ v1 <= v0 => v1) v4 end) with | left v2 => (fun (v2 : v1 <= v0) (v3 : v0 <= v1) => Rle_antisym v1 v0 v2 v3) v2 | right v2 => (fun (v2 : ~ v1 <= v0) (v3 : v0 <= v1) => eq_refl) v2 end v2 | right v2 => match Rle_dec v1 v0 as v2 in ({_} + {_}) return (forall v3 : ~ v0 <= v1, v0 = match v2 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 <= v0 => v0) v4 | right v4 => (fun v4 : ~ v1 <= v0 => v1) v4 end) with | left v2 => (fun (v2 : v1 <= v0) (v3 : ~ v0 <= v1) => eq_refl) v2 | right v2 => (fun (v2 : ~ v1 <= v0) (v3 : ~ v0 <= v1) => Rle_antisym v0 v1 (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v2)) (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v3))) v2 end v2 end : Rmax v0 v1 = Rmax v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_l	100	0.051002	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => match Rle_dec v0 v1 as v2 in ({_} + {_}) return (v0 <= match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 <= v1 => v1) v3 | right v3 => (fun v3 : ~ v0 <= v1 => v0) v3 end) with | left v2 => (fun v2 : v0 <= v1 => v2) v2 | right v2 => (fun v2 : ~ v0 <= v1 => Req_le_sym v0 v0 eq_refl) v2 end : v0 <= Rmax v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_r	100	0.053645	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => match Rle_dec v0 v1 as v2 in ({_} + {_}) return (v1 <= match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 <= v1 => v1) v3 | right v3 => (fun v3 : ~ v0 <= v1 => v0) v3 end) with | left v2 => (fun v2 : v0 <= v1 => or_intror eq_refl) v2 | right v2 => (fun v2 : ~ v0 <= v1 => Rlt_le v1 v0 (Rnot_le_lt v0 v1 v2)) v2 end : v1 <= Rmax v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_left	100	0.086155	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : v1 <= v0) => let v3 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v3 as v4 in ({_} + {_}) return (match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end = v0) with | left v4 => (fun v4 : v0 <= v1 => or_ind (fun v5 : v1 < v0 => or_ind (fun v6 : v0 < v1 => Rle_antisym v1 v0 (Rge_le v0 v1 (Rle_ge v1 v0 (Rlt_le v1 v0 v5))) (Rge_le v1 v0 (Rle_ge v0 v1 (Rlt_le v0 v1 v6))) : v1 = v0) (fun v6 : v0 = v1 => eq_sym v6 : v1 = v0) v4) (fun v5 : v1 = v0 => or_ind (fun v6 : v0 < v1 => v5) (fun v6 : v0 = v1 => v5) v4) v2 : v1 = v0) v4 | right v4 => (fun v4 : ~ v0 <= v1 => let v5 : v1 < v0 := Rnot_le_lt v0 v1 v4 in or_ind (fun v6 : v1 < v0 => eq_refl) (fun v6 : v1 = v0 => eq_refl) v2 : v0 = v0) v4 end) : forall (v0 v1 : @R) (v2 : v1 <= v0), Rmax v0 v1 = v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_right	100	0.079788	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : v0 <= v1) => let v3 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v3 as v4 in ({_} + {_}) return (match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end = v1) with | left v4 => (fun v4 : v0 <= v1 => or_ind (fun v5 : v0 < v1 => or_ind (fun v6 : v0 < v1 => eq_refl) (fun v6 : v0 = v1 => eq_refl) v4) (fun v5 : v0 = v1 => or_ind (fun v6 : v0 < v1 => eq_refl) (fun v6 : v0 = v1 => eq_refl) v4) v2 : v1 = v1) v4 | right v4 => (fun v4 : ~ v0 <= v1 => let v5 : v1 < v0 := Rnot_le_lt v0 v1 v4 in or_ind (fun v6 : v0 < v1 => Rle_antisym v0 v1 (Rge_le v1 v0 (Rle_ge v0 v1 (Rlt_le v0 v1 v6))) (Rge_le v0 v1 (Rle_ge v1 v0 (Rlt_le v1 v0 v5))) : v0 = v1) (fun v6 : v0 = v1 => v6) v2 : v0 = v1) v4 end) : forall (v0 v1 : @R) (v2 : v0 <= v1), Rmax v0 v1 = v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rle_max_compat_r	100	0.160584	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v1) => Rmax_case_strong v0 v2 (fun v4 : @R => v4 <= Rmax v1 v2) (fun v4 : v2 <= v0 => Rmax_case_strong v1 v2 (fun v5 : @R => v0 <= v5) (fun v5 : v2 <= v1 => v3) (fun v5 : v1 <= v2 => Rle_trans v0 v1 v2 v3 v5)) (fun v4 : v0 <= v2 => Rmax_case_strong v1 v2 (fun v5 : @R => v2 <= v5) (fun v5 : v2 <= v1 => v5) (fun v5 : v1 <= v2 => Rle_refl v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rle_max_compat_l	100	0.043335	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v1) => Rmax_case_strong v2 v0 (fun v4 : @R => v4 <= Rmax v2 v1) (fun v4 : v0 <= v2 => Rmax_case_strong v2 v1 (fun v5 : @R => v2 <= v5) (fun v5 : v1 <= v2 => Rle_refl v2) (fun v5 : v2 <= v1 => v5)) (fun v4 : v2 <= v0 => Rmax_case_strong v2 v1 (fun v5 : @R => v0 <= v5) (fun v5 : v1 <= v2 => Rle_trans v0 v1 v2 v3 v5) (fun v5 : v2 <= v1 => v3)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.RmaxRmult	100	0.221811	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : IZR 0 <= v2) => match Rle_dec v0 v1 as v4 in ({_} + {_}) return (match Rle_dec (v2 * v0) (v2 * v1) as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v2 * v0 <= v2 * v1 => v2 * v1) v5 | right v5 => (fun v5 : ~ v2 * v0 <= v2 * v1 => v2 * v0) v5 end = v2 * match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end) with | left v4 => match Rle_dec (v2 * v0) (v2 * v1) as v4 in ({_} + {_}) return (forall v5 : v0 <= v1, match v4 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v2 * v0 <= v2 * v1 => v2 * v1) v6 | right v6 => (fun v6 : ~ v2 * v0 <= v2 * v1 => v2 * v0) v6 end = v2 * v1) with | left v4 => (fun (v4 : v2 * v0 <= v2 * v1) (v5 : v0 <= v1) => eq_refl) v4 | right v4 => (fun (v4 : ~ v2 * v0 <= v2 * v1) (v5 : v0 <= v1) => match v3 as v6 in (_ \/ _) return (v2 * v0 = v2 * v1) with | or_introl v6 => (fun v6 : IZR 0 < v2 => match v4 (Rmult_le_compat_l v2 v0 v1 v3 v5) as v7 in False return (v2 * v0 = v2 * v1) with end) v6 | or_intror v6 => (fun v6 : IZR 0 = v2 => eq_ind (IZR 0) (fun v7 : @R => v7 * v0 = v7 * v1) (eq_ind_r (fun v7 : @R => v7 = IZR 0 * v1) (eq_ind_r (fun v7 : @R => IZR 0 = v7) eq_refl (Rmult_0_l v1)) (Rmult_0_l v0)) v2 v6) v6 end) v4 end v4 | right v4 => match Rle_dec (v2 * v0) (v2 * v1) as v4 in ({_} + {_}) return (forall v5 : ~ v0 <= v1, match v4 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v2 * v0 <= v2 * v1 => v2 * v1) v6 | right v6 => (fun v6 : ~ v2 * v0 <= v2 * v1 => v2 * v0) v6 end = v2 * v0) with | left v4 => (fun (v4 : v2 * v0 <= v2 * v1) (v5 : ~ v0 <= v1) => match v3 as v6 in (_ \/ _) return (v2 * v1 = v2 * v0) with | or_introl v6 => (fun v6 : IZR 0 < v2 => match v5 (Rmult_le_reg_l v2 v0 v1 v6 v4) as v7 in False return (v2 * v1 = v2 * v0) with end) v6 | or_intror v6 => (fun v6 : IZR 0 = v2 => eq_ind (IZR 0) (fun v7 : @R => v7 * v1 = v7 * v0) (eq_ind_r (fun v7 : @R => v7 = IZR 0 * v0) (eq_ind_r (fun v7 : @R => IZR 0 = v7) eq_refl (Rmult_0_l v0)) (Rmult_0_l v1)) v2 v6) v6 end) v4 | right v4 => (fun (v4 : ~ v2 * v0 <= v2 * v1) (v5 : ~ v0 <= v1) => eq_refl) v4 end v4 end : Rmax (v2 * v0) (v2 * v1) = v2 * Rmax v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_stable_in_negreal	100	0.053144	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @negreal => match Rle_dec v0 v1 as v2 in ({_} + {_}) return (match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 <= v1 => neg v1) v3 | right v3 => (fun v3 : ~ v0 <= v1 => neg v0) v3 end < IZR 0) with | left v2 => (fun v2 : v0 <= v1 => cond_neg v1) v2 | right v2 => (fun v2 : ~ v0 <= v1 => cond_neg v0) v2 end : Rmax v0 v1 < IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_lub	100	0.052137	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v2) (v4 : v1 <= v2) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v1) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v0) v6 end <= v2) with | left v5 => (fun v5 : v0 <= v1 => v4) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v3) v5 end : Rmax v0 v1 <= v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_lub_lt	100	0.054473	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 < v2) (v4 : v1 < v2) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v1) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v0) v6 end < v2) with | left v5 => (fun v5 : v0 <= v1 => v4) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v3) v5 end : Rmax v0 v1 < v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_Rlt	100	0.078015	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => conj (match Rle_dec v0 v1 as v3 in ({_} + {_}) return (forall v4 : match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 <= v1 => v1) v4 | right v4 => (fun v4 : ~ v0 <= v1 => v0) v4 end < v2, v0 < v2 /\ v1 < v2) with | left v3 => (fun (v3 : v0 <= v1) (v4 : v1 < v2) => conj (Rle_lt_trans v0 v1 v2 v3 v4) v4) v3 | right v3 => (fun (v3 : ~ v0 <= v1) (v4 : v0 < v2) => conj v4 (Rlt_trans v1 v0 v2 (Rnot_le_gt v0 v1 v3) v4)) v3 end : forall v3 : Rmax v0 v1 < v2, v0 < v2 /\ v1 < v2) (fun v3 : v0 < v2 /\ v1 < v2 => match v3 as v4 in (_ /\ _) return (Rmax v0 v1 < v2) with | conj v4 v5 => (fun (v4 : v0 < v2) (v5 : v1 < v2) => Rmax_lub_lt v0 v1 v2 v4 v5) v4 v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_neg	100	0.060107	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : v0 < IZR 0) (v3 : v1 < IZR 0) => match Rle_dec v0 v1 as v4 in ({_} + {_}) return (match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end < IZR 0) with | left v4 => (fun v4 : v0 <= v1 => v3) v4 | right v4 => (fun v4 : ~ v0 <= v1 => v2) v4 end : Rmax v0 v1 < IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rcase_abs	100	0.049260	1	1	0	synth with cache (only 1: refine (fun v0 : @R => (fun v1 : {IZR 0 <= v0} + {~ IZR 0 <= v0} => sumbool_rec (fun v2 : {IZR 0 <= v0} + {~ IZR 0 <= v0} => {v0 < IZR 0} + {v0 >= IZR 0}) (fun v2 : IZR 0 <= v0 => right (Rle_ge (IZR 0) v0 v2)) (fun v2 : ~ IZR 0 <= v0 => left (Rnot_le_lt (IZR 0) v0 v2 : v0 < IZR 0)) v1) (Rle_dec (IZR 0) v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_R0	100	0.052176	1	1	0	synth with cache (only 1: refine (match Rcase_abs (IZR 0) as v0 in ({_} + {_}) return (match v0 as v1 in ({_} + {_}) return (@R) with | left v1 => (fun v1 : IZR 0 < IZR 0 => - IZR 0) v1 | right v1 => (fun v1 : IZR 0 >= IZR 0 => IZR 0) v1 end = IZR 0) with | left v0 => (fun v0 : IZR 0 < IZR 0 => (fun v1 : ~ IZR 0 < IZR 0 => False_ind (- IZR 0 = IZR 0) (v1 v0)) (Rlt_irrefl (IZR 0))) v0 | right v0 => (fun v0 : IZR 0 >= IZR 0 => eq_refl) v0 end : Rabs (IZR 0) = IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_R1	100	0.072240	1	1	0	synth with cache (only 1: refine (match Rcase_abs (IZR 1) as v0 in ({_} + {_}) return (match v0 as v1 in ({_} + {_}) return (@R) with | left v1 => (fun v1 : IZR 1 < IZR 0 => - IZR 1) v1 | right v1 => (fun v1 : IZR 1 >= IZR 0 => IZR 1) v1 end = IZR 1) with | left v0 => (fun v0 : IZR 1 < IZR 0 => False_ind (- IZR 1 = IZR 1) (((fun v1 : IZR 1 < IZR 0 => R1_neq_R0 (Rle_antisym (IZR 1) (IZR 0) (Rlt_le (IZR 1) (IZR 0) v1) (IZR_le 0 1 (Zle_bool_imp_le 0 1 eq_refl)))) : ~ IZR 1 < IZR 0) v0)) v0 | right v0 => (fun v0 : IZR 1 >= IZR 0 => eq_refl) v0 end : Rabs (IZR 1) = IZR 1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_no_R0	100	0.058234	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : v0 <> IZR 0) => match Rcase_abs v0 as v2 in ({_} + {_}) return (match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 < IZR 0 => - v0) v3 | right v3 => (fun v3 : v0 >= IZR 0 => v0) v3 end <> IZR 0) with | left v2 => (fun v2 : v0 < IZR 0 => Ropp_neq_0_compat v0 v1) v2 | right v2 => (fun v2 : v0 >= IZR 0 => v1) v2 end : Rabs v0 <> IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_left	100	0.056198	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : v0 < IZR 0) => match Rcase_abs v0 as v2 in ({_} + {_}) return (match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 < IZR 0 => - v0) v3 | right v3 => (fun v3 : v0 >= IZR 0 => v0) v3 end = - v0) with | left v2 => (fun v2 : v0 < IZR 0 => eq_refl) v2 | right v2 => (fun v2 : v0 >= IZR 0 => False_ind (v0 = - v0) (Rlt_not_ge v0 (IZR 0) v1 v2)) v2 end : Rabs v0 = - v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_right	100	0.053600	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : v0 >= IZR 0) => (let v2 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v2 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 < IZR 0 => - v0) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v0) v4 end = v0) with | left v3 => (fun v3 : v0 < IZR 0 => False_ind (- v0 = v0) (Rlt_not_ge v0 (IZR 0) v3 v1)) v3 | right v3 => (fun v3 : v0 >= IZR 0 => eq_refl) v3 end) : Rabs v0 = v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_left1	100	0.056397	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : v0 <= IZR 0) => match v1 as v2 in (_ \/ _) return (Rabs v0 = - v0) with | or_introl v2 => (fun v2 : v0 < IZR 0 => Rabs_left v0 v2) v2 | or_intror v2 => (fun v2 : v0 = IZR 0 => eq_ind_r (fun v3 : @R => Rabs v3 = - v3) (eq_ind_r (fun v3 : @R => v3 = - IZR 0) (eq_sym (@Ropp_0)) (Rabs_right (IZR 0) (Rle_ge (IZR 0) (IZR 0) (IZR_le 0 0 (Zle_bool_imp_le 0 0 eq_refl)))) : Rabs (IZR 0) = - IZR 0) v2) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_pos	100	0.057498	1	1	0	synth with cache (only 1: refine (fun v0 : @R => (let v1 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v1 as v2 in ({_} + {_}) return (IZR 0 <= match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : v0 < IZR 0 => - v0) v3 | right v3 => (fun v3 : v0 >= IZR 0 => v0) v3 end) with | left v2 => (fun v2 : v0 < IZR 0 => (fun v3 : - v0 > - IZR 0 => let v4 : IZR 0 < - v0 := eq_ind (- IZR 0) (fun v4 : @R => v4 < - v0) v3 (IZR 0) (@Ropp_0) in or_introl v4) (Ropp_lt_gt_contravar v0 (IZR 0) v2)) v2 | right v2 => (fun v2 : v0 >= IZR 0 => Rge_le v0 (IZR 0) v2) v2 end) : IZR 0 <= Rabs v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rle_abs	100	0.055965	1	1	0	synth with cache (only 1: refine (fun v0 : @R => match Rcase_abs v0 as v1 in ({_} + {_}) return (v0 <= match v1 as v2 in ({_} + {_}) return (@R) with | left v2 => (fun v2 : v0 < IZR 0 => - v0) v2 | right v2 => (fun v2 : v0 >= IZR 0 => v0) v2 end) with | left v1 => (fun v1 : v0 < IZR 0 => Rminus_le v0 (- v0) (eq_ind (IZR 0 + IZR 0) (Rle (v0 - - v0)) (eq_ind_r (fun v2 : @R => v0 + v2 <= IZR 0 + IZR 0) (Rlt_le (v0 + v0) (IZR 0 + IZR 0) (Rplus_lt_compat v0 (IZR 0) v0 (IZR 0) v1 v1)) (Ropp_involutive v0) : v0 - - v0 <= IZR 0 + IZR 0) (IZR 0) (Rplus_0_r (IZR 0)))) v1 | right v1 => (fun v1 : v0 >= IZR 0 => Req_le_sym v0 v0 eq_refl) v1 end : v0 <= Rabs v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_le	100	0.080476	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => match Rcase_abs v0 as v2 in ({_} + {_}) return (forall v3 : - v1 <= v0 <= v1, match v2 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 < IZR 0 => - v0) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v0) v4 end <= v1) with | left v2 => (fun (v2 : v0 < IZR 0) (v3 : - v1 <= v0 <= v1) => match v3 as v4 in (_ /\ _) return (- v0 <= v1) with | conj v4 v5 => (fun (v4 : - v1 <= v0) (v5 : v0 <= v1) => Ropp_le_cancel (- v0) v1 (eq_ind_r (fun v6 : @R => - v1 <= v6) v4 (Ropp_involutive v0))) v4 v5 end) v2 | right v2 => (fun (v2 : v0 >= IZR 0) (v3 : - v1 <= v0 <= v1) => match v3 as v4 in (_ /\ _) return (v0 <= v1) with | conj v4 v5 => (fun (v4 : - v1 <= v0) (v5 : v0 <= v1) => v5) v4 v5 end) v2 end : forall v2 : - v1 <= v0 <= v1, Rabs v0 <= v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_pos_eq	100	0.058076	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : IZR 0 <= v0) => (let v2 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v2 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 < IZR 0 => - v0) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v0) v4 end = v0) with | left v3 => (fun v3 : v0 < IZR 0 => (fun v4 : ~ IZR 0 <= v0 => False_ind (- v0 = v0) (v4 v1)) (Rgt_not_le (IZR 0) v0 v3)) v3 | right v3 => (fun v3 : v0 >= IZR 0 => eq_refl) v3 end) : Rabs v0 = v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_Rabsolu	100	0.029665	1	1	0	synth with cache (only 1: refine (fun v0 : @R => Rabs_pos_eq (Rabs v0) (Rabs_pos v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_pos_lt	100	0.063464	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : v0 <> IZR 0) => let v2 : IZR 0 < Rabs v0 \/ IZR 0 = Rabs v0 := Rabs_pos v0 in match v2 as v3 in (_ \/ _) return (IZR 0 < Rabs v0) with | or_introl v3 => (fun v3 : IZR 0 < Rabs v0 => v3) v3 | or_intror v3 => (fun v3 : IZR 0 = Rabs v0 => let v4 : Rabs v0 <> IZR 0 := Rabs_no_R0 v0 v1 in let v5 : Rabs v0 = IZR 0 := eq_sym v3 in (fun v6 : Rabs v0 = IZR 0 => False_ind (IZR 0 < Rabs v0) (v4 v6)) v5) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_minus_sym	100	0.270157	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (let v2 : {v0 - v1 < IZR 0} + {v0 - v1 >= IZR 0} := Rcase_abs (v0 - v1) in match v2 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 - v1 < IZR 0 => - (v0 - v1)) v4 | right v4 => (fun v4 : v0 - v1 >= IZR 0 => v0 - v1) v4 end = match Rcase_abs (v1 - v0) as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 - v0 < IZR 0 => - (v1 - v0)) v4 | right v4 => (fun v4 : v1 - v0 >= IZR 0 => v1 - v0) v4 end) with | left v3 => (fun v3 : v0 - v1 < IZR 0 => let v4 : {v1 - v0 < IZR 0} + {v1 - v0 >= IZR 0} := Rcase_abs (v1 - v0) in match v4 as v5 in ({_} + {_}) return (- (v0 - v1) = match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 - v0 < IZR 0 => - (v1 - v0)) v6 | right v6 => (fun v6 : v1 - v0 >= IZR 0 => v1 - v0) v6 end) with | left v5 => (fun v5 : v1 - v0 < IZR 0 => let v6 : v0 < v1 := Rminus_lt v0 v1 v3 in let v7 : ~ v1 < v0 := Rlt_asym v0 v1 v6 in let v8 : v1 < v0 := Rminus_lt v1 v0 v5 in False_ind (- (v0 - v1) = - (v1 - v0)) (v7 v8)) v5 | right v5 => (fun v5 : v1 - v0 >= IZR 0 => eq_ind_r (fun v6 : @R => v6 = v1 - v0) eq_refl (Ropp_minus_distr v0 v1)) v5 end) v3 | right v3 => (fun v3 : v0 - v1 >= IZR 0 => let v4 : {v1 - v0 < IZR 0} + {v1 - v0 >= IZR 0} := Rcase_abs (v1 - v0) in match v4 as v5 in ({_} + {_}) return (v0 - v1 = match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 - v0 < IZR 0 => - (v1 - v0)) v6 | right v6 => (fun v6 : v1 - v0 >= IZR 0 => v1 - v0) v6 end) with | left v5 => (fun v5 : v1 - v0 < IZR 0 => eq_ind_r (fun v6 : @R => v0 - v1 = v6) eq_refl (Ropp_minus_distr v1 v0)) v5 | right v5 => (fun v5 : v1 - v0 >= IZR 0 => match v3 as v6 in (_ \/ _) return (v0 - v1 = v1 - v0) with | or_introl v6 => (fun v6 : v0 - v1 > IZR 0 => match v5 as v7 in (_ \/ _) return (v0 - v1 = v1 - v0) with | or_introl v7 => (fun v7 : v1 - v0 > IZR 0 => let v8 : - (v0 - v1) < IZR 0 := Ropp_lt_gt_0_contravar (v0 - v1) v6 in let v9 : v1 - v0 < IZR 0 := eq_ind (- (v0 - v1)) (fun v9 : @R => v9 < IZR 0) v8 (v1 - v0) (Ropp_minus_distr v0 v1) in let v10 : ~ v1 - v0 < IZR 0 := Rlt_asym (IZR 0) (v1 - v0) v7 in False_ind (v0 - v1 = v1 - v0) (v10 v9)) v7 | or_intror v7 => (fun v7 : v1 - v0 = IZR 0 => let v8 : v1 = v0 := Rminus_diag_uniq v1 v0 v7 in eq_ind_r (fun v9 : @R => forall v10 : v0 - v9 > IZR 0, v0 - v9 = v9 - v0) (fun v9 : v0 - v0 > IZR 0 => eq_refl) v8 v6) v7 end) v6 | or_intror v6 => (fun v6 : v0 - v1 = IZR 0 => match v5 as v7 in (_ \/ _) return (v0 - v1 = v1 - v0) with | or_introl v7 => (fun v7 : v1 - v0 > IZR 0 => let v8 : v0 = v1 := Rminus_diag_uniq v0 v1 v6 in eq_ind_r (fun v9 : @R => forall v10 : v1 - v9 > IZR 0, v9 - v1 = v1 - v9) (fun v9 : v1 - v1 > IZR 0 => eq_refl) v8 v7) v7 | or_intror v7 => (fun v7 : v1 - v0 = IZR 0 => let v8 : v1 = v0 := Rminus_diag_uniq v1 v0 v7 in eq_ind_r (fun v9 : @R => forall v10 : v0 - v9 = IZR 0, v0 - v9 = v9 - v0) (fun v9 : v0 - v0 = IZR 0 => eq_refl) v8 v6) v7 end) v6 end) v5 end) v3 end) : Rabs (v0 - v1) = Rabs (v1 - v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_mult	100	0.552665	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (let v2 : {v0 * v1 < IZR 0} + {v0 * v1 >= IZR 0} := Rcase_abs (v0 * v1) in match v2 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 * v1 < IZR 0 => - (v0 * v1)) v4 | right v4 => (fun v4 : v0 * v1 >= IZR 0 => v0 * v1) v4 end = match Rcase_abs v0 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 < IZR 0 => - v0) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v0) v4 end * match Rcase_abs v1 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 < IZR 0 => - v1) v4 | right v4 => (fun v4 : v1 >= IZR 0 => v1) v4 end) with | left v3 => (fun v3 : v0 * v1 < IZR 0 => let v4 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v4 as v5 in ({_} + {_}) return (- (v0 * v1) = match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 < IZR 0 => - v0) v6 | right v6 => (fun v6 : v0 >= IZR 0 => v0) v6 end * match Rcase_abs v1 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 < IZR 0 => - v1) v6 | right v6 => (fun v6 : v1 >= IZR 0 => v1) v6 end) with | left v5 => (fun v5 : v0 < IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (- (v0 * v1) = - v0 * match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => let v8 : v0 * v1 > v0 * IZR 0 := Rmult_lt_gt_compat_neg_l v0 v1 (IZR 0) v5 v7 in let v9 : ~ v0 * v1 < v0 * IZR 0 := Rlt_asym (v0 * IZR 0) (v0 * v1) v8 in let v10 : ~ v0 * v1 < IZR 0 := eq_ind (v0 * IZR 0) (fun v10 : @R => ~ v0 * v1 < v10) v9 (IZR 0) (Rmult_0_r v0) in False_ind (- (v0 * v1) = - v0 * - v1) (v10 v3)) v7 | right v7 => (fun v7 : v1 >= IZR 0 => eq_ind_r (fun v8 : @R => - (v0 * v1) = v8) eq_refl (Ropp_mult_distr_l_reverse v0 v1)) v7 end) v5 | right v5 => (fun v5 : v0 >= IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (- (v0 * v1) = v0 * match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => eq_ind_r (fun v8 : @R => - (v0 * v1) = v8) (eq_ind_r (fun v8 : @R => - (v0 * v1) = v8) (eq_ind_r (fun v8 : @R => - v8 = - (v1 * v0)) eq_refl (Rmult_comm v0 v1)) (Ropp_mult_distr_l_reverse v1 v0)) (Rmult_comm v0 (- v1))) v7 | right v7 => (fun v7 : v1 >= IZR 0 => match v5 as v8 in (_ \/ _) return (- (v0 * v1) = v0 * v1) with | or_introl v8 => (fun v8 : v0 > IZR 0 => match v7 as v9 in (_ \/ _) return (- (v0 * v1) = v0 * v1) with | or_introl v9 => (fun v9 : v1 > IZR 0 => let v10 : v0 * IZR 0 < v0 * v1 := Rmult_lt_compat_l v0 (IZR 0) v1 v8 v9 in let v11 : ~ v0 * v1 < v0 * IZR 0 := Rlt_asym (v0 * IZR 0) (v0 * v1) v10 in let v12 : ~ v0 * v1 < IZR 0 := eq_ind (v0 * IZR 0) (fun v12 : @R => ~ v0 * v1 < v12) v11 (IZR 0) (Rmult_0_r v0) in False_ind (- (v0 * v1) = v0 * v1) (v12 v3)) v9 | or_intror v9 => (fun v9 : v1 = IZR 0 => eq_ind_r (fun v10 : @R => forall v11 : v0 * v10 < IZR 0, - (v0 * v10) = v0 * v10) (fun v10 : v0 * IZR 0 < IZR 0 => let v11 : IZR 0 < IZR 0 := eq_ind (v0 * IZR 0) (fun v11 : @R => v11 < IZR 0) v10 (IZR 0) (Rmult_0_r v0) in False_ind (- (v0 * IZR 0) = v0 * IZR 0) (Rlt_irrefl (IZR 0) v11)) v9 v3) v9 end) v8 | or_intror v8 => (fun v8 : v0 = IZR 0 => eq_ind_r (fun v9 : @R => forall v10 : v9 * v1 < IZR 0, - (v9 * v1) = v9 * v1) (fun v9 : IZR 0 * v1 < IZR 0 => match v7 as v10 in (_ \/ _) return (- (IZR 0 * v1) = IZR 0 * v1) with | or_introl v10 => (fun v10 : v1 > IZR 0 => let v11 : IZR 0 < IZR 0 := eq_ind (IZR 0 * v1) (fun v11 : @R => v11 < IZR 0) v9 (IZR 0) (Rmult_0_l v1) in False_ind (- (IZR 0 * v1) = IZR 0 * v1) (Rlt_irrefl (IZR 0) v11)) v10 | or_intror v10 => (fun v10 : v1 = IZR 0 => eq_ind_r (fun v11 : @R => forall v12 : IZR 0 * v11 < IZR 0, - (IZR 0 * v11) = IZR 0 * v11) (fun v11 : IZR 0 * IZR 0 < IZR 0 => let v12 : IZR 0 < IZR 0 := eq_ind (IZR 0 * IZR 0) (fun v12 : @R => v12 < IZR 0) v11 (IZR 0) (Rmult_0_l (IZR 0)) in False_ind (- (IZR 0 * IZR 0) = IZR 0 * IZR 0) (Rlt_irrefl (IZR 0) v12)) v10 v9) v10 end) v8 v3) v8 end) v7 end) v5 end) v3 | right v3 => (fun v3 : v0 * v1 >= IZR 0 => let v4 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v4 as v5 in ({_} + {_}) return (v0 * v1 = match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 < IZR 0 => - v0) v6 | right v6 => (fun v6 : v0 >= IZR 0 => v0) v6 end * match Rcase_abs v1 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 < IZR 0 => - v1) v6 | right v6 => (fun v6 : v1 >= IZR 0 => v1) v6 end) with | left v5 => (fun v5 : v0 < IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (v0 * v1 = - v0 * match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => eq_ind_r (fun v8 : @R => v0 * v1 = v8) eq_refl (Rmult_opp_opp v0 v1)) v7 | right v7 => (fun v7 : v1 >= IZR 0 => match v3 as v8 in (_ \/ _) return (v0 * v1 = - v0 * v1) with | or_introl v8 => (fun v8 : v0 * v1 > IZR 0 => match v7 as v9 in (_ \/ _) return (v0 * v1 = - v0 * v1) with | or_introl v9 => (fun v9 : v1 > IZR 0 => let v10 : v0 * v1 < IZR 0 * v1 := Rmult_lt_compat_r v1 v0 (IZR 0) v9 v5 in let v11 : ~ IZR 0 * v1 < v0 * v1 := Rlt_asym (v0 * v1) (IZR 0 * v1) v10 in let v12 : ~ IZR 0 < v0 * v1 := eq_ind (IZR 0 * v1) (fun v12 : @R => ~ v12 < v0 * v1) v11 (IZR 0) (Rmult_0_l v1) in False_ind (v0 * v1 = - v0 * v1) (v12 v8)) v9 | or_intror v9 => (fun v9 : v1 = IZR 0 => let v10 : v0 * IZR 0 > IZR 0 := eq_ind v1 (fun v10 : @R => v0 * v10 > IZR 0) v8 (IZR 0) v9 in let v11 : IZR 0 > IZR 0 := eq_ind (v0 * IZR 0) (fun v11 : @R => v11 > IZR 0) v10 (IZR 0) (Rmult_0_r v0) in False_ind (v0 * v1 = - v0 * v1) (Rlt_irrefl (IZR 0) v11)) v9 end) v8 | or_intror v8 => (fun v8 : v0 * v1 = IZR 0 => eq_ind (- (v0 * v1)) (fun v9 : @R => v0 * v1 = v9) (eq_ind_r (fun v9 : @R => v9 = - v9) (eq_ind_r (fun v9 : @R => IZR 0 = v9) eq_refl (@Ropp_0)) v8) (- v0 * v1) (Ropp_mult_distr_l v0 v1)) v8 end) v7 end) v5 | right v5 => (fun v5 : v0 >= IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (v0 * v1 = v0 * match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => match v3 as v8 in (_ \/ _) return (v0 * v1 = v0 * - v1) with | or_introl v8 => (fun v8 : v0 * v1 > IZR 0 => match v5 as v9 in (_ \/ _) return (v0 * v1 = v0 * - v1) with | or_introl v9 => (fun v9 : v0 > IZR 0 => let v10 : v0 * v1 < v0 * IZR 0 := Rmult_lt_compat_l v0 v1 (IZR 0) v9 v7 in let v11 : ~ v0 * IZR 0 < v0 * v1 := Rlt_asym (v0 * v1) (v0 * IZR 0) v10 in let v12 : ~ IZR 0 < v0 * v1 := eq_ind (v0 * IZR 0) (fun v12 : @R => ~ v12 < v0 * v1) v11 (IZR 0) (Rmult_0_r v0) in False_ind (v0 * v1 = v0 * - v1) (v12 v8)) v9 | or_intror v9 => (fun v9 : v0 = IZR 0 => eq_ind_r (fun v10 : @R => v10 * v1 = v10 * - v1) (eq_ind_r (fun v10 : @R => v10 = IZR 0 * - v1) (eq_ind_r (fun v10 : @R => IZR 0 = v10) eq_refl (Rmult_0_l (- v1))) (Rmult_0_l v1)) v9) v9 end) v8 | or_intror v8 => (fun v8 : v0 * v1 = IZR 0 => eq_ind (- (v0 * v1)) (fun v9 : @R => v0 * v1 = v9) (eq_ind_r (fun v9 : @R => v9 = - v9) (eq_ind_r (fun v9 : @R => IZR 0 = v9) eq_refl (@Ropp_0)) v8) (v0 * - v1) (Ropp_mult_distr_r v0 v1)) v8 end) v7 | right v7 => (fun v7 : v1 >= IZR 0 => eq_refl) v7 end) v5 end) v3 end) : Rabs (v0 * v1) = Rabs v0 * Rabs v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_Rinv	100	0.233892	1	1	0	synth with cache (only 1: refine (fun v0 : @R => (let v1 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v1 as v2 in ({_} + {_}) return (forall v3 : v0 <> IZR 0, match Rcase_abs (/ v0) as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : / v0 < IZR 0 => - / v0) v4 | right v4 => (fun v4 : / v0 >= IZR 0 => / v0) v4 end = / match v2 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 < IZR 0 => - v0) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v0) v4 end) with | left v2 => (fun v2 : v0 < IZR 0 => let v3 : {/ v0 < IZR 0} + {/ v0 >= IZR 0} := Rcase_abs (/ v0) in match v3 as v4 in ({_} + {_}) return (forall v5 : v0 <> IZR 0, match v4 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : / v0 < IZR 0 => - / v0) v6 | right v6 => (fun v6 : / v0 >= IZR 0 => / v0) v6 end = / - v0) with | left v4 => (fun (v4 : / v0 < IZR 0) (v5 : v0 <> IZR 0) => Ropp_inv_permute v0 v5) v4 | right v4 => (fun (v4 : / v0 >= IZR 0) (v5 : v0 <> IZR 0) => eq_ind (- / v0) (fun v6 : @R => / v0 = v6) match v4 as v6 in (_ \/ _) return (/ v0 = - / v0) with | or_introl v6 => (fun v6 : / v0 > IZR 0 => let v7 : / v0 < IZR 0 := Rinv_lt_0_compat v0 v2 in let v8 : ~ IZR 0 < / v0 := Rlt_asym (/ v0) (IZR 0) v7 in False_ind (/ v0 = - / v0) (v8 v6)) v6 | or_intror v6 => (fun v6 : / v0 = IZR 0 => eq_ind_r (fun v7 : @R => v7 = - v7) (eq_ind_r (fun v7 : @R => IZR 0 = v7) eq_refl (@Ropp_0)) v6) v6 end (/ - v0) (Ropp_inv_permute v0 v5)) v4 end) v2 | right v2 => (fun v2 : v0 >= IZR 0 => let v3 : {/ v0 < IZR 0} + {/ v0 >= IZR 0} := Rcase_abs (/ v0) in match v3 as v4 in ({_} + {_}) return (forall v5 : v0 <> IZR 0, match v4 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : / v0 < IZR 0 => - / v0) v6 | right v6 => (fun v6 : / v0 >= IZR 0 => / v0) v6 end = / v0) with | left v4 => (fun (v4 : / v0 < IZR 0) (v5 : v0 <> IZR 0) => match v2 as v6 in (_ \/ _) return (- / v0 = / v0) with | or_introl v6 => (fun v6 : v0 > IZR 0 => let v7 : IZR 0 < / v0 := Rinv_0_lt_compat v0 v6 in let v8 : ~ / v0 < IZR 0 := Rlt_asym (IZR 0) (/ v0) v7 in False_ind (- / v0 = / v0) (v8 v4)) v6 | or_intror v6 => (fun v6 : v0 = IZR 0 => eq_ind_r (fun v7 : @R => forall (v8 : / v7 < IZR 0) (v9 : v7 <> IZR 0), - / v7 = / v7) (fun (v7 : / IZR 0 < IZR 0) (v8 : IZR 0 <> IZR 0) => False_ind (- / IZR 0 = / IZR 0) (v8 eq_refl)) v6 v4 v5) v6 end) v4 | right v4 => (fun (v4 : / v0 >= IZR 0) (v5 : v0 <> IZR 0) => eq_refl) v4 end) v2 end) : forall v1 : v0 <> IZR 0, Rabs (/ v0) = / Rabs v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_Ropp	100	0.170509	1	1	0	synth with cache (only 1: refine (fun v0 : @R => let v1 : IZR (-1) * v0 = - v0 := let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : list (@R) := (v0 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v2 v1 (Ring_polynom.PEmul (Ring_polynom.PEc (-1)%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (@I) (eq_refl : (let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (Ring_polynom.PEc (-1)%Z) (Ring_polynom.PEX (@Z) 1))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)))) = @true) in eq_ind (IZR (-1) * v0) (fun v2 : @R => Rabs v2 = Rabs v0) (eq_ind_r (fun v2 : @R => v2 = Rabs v0) (let v2 : IZR 1 = Rabs (IZR (-1)) := match Rcase_abs (IZR (-1)) as v2 in ({_} + {_}) return (IZR 1 = match v2 as v3 in ({_} + {_}) return (@R) with | left v3 => (fun v3 : IZR (-1) < IZR 0 => - IZR (-1)) v3 | right v3 => (fun v3 : IZR (-1) >= IZR 0 => IZR (-1)) v3 end) with | left v2 => (fun v2 : IZR (-1) < IZR 0 => let v3 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v4 : list (@R) := nil in RField_ring_lemma1 (@ring_subst_niter) v4 v3 (Ring_polynom.PEc 1%Z) (Ring_polynom.PEopp (Ring_polynom.PEc (-1)%Z)) (@I) (eq_refl : (let v5 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEc 1%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEopp (Ring_polynom.PEc (-1)%Z)))) = @true)) v2 | right v2 => eq_ind (- IZR 0) (fun v2 : @R => forall v3 : IZR (-1) >= v2, IZR 1 = IZR (-1)) (fun v2 : IZR (-1) >= - IZR 0 => let v3 : IZR 0 >= IPR 1 := Ropp_ge_cancel (IZR 0) (IPR 1) v2 in False_ind (IZR 1 = IZR (-1)) (Rge_not_lt (IZR 0) (IPR 1) v3 (@Rlt_0_1))) (IZR 0) (@Ropp_0) v2 end : IZR 1 = Rabs (IZR (-1)) in eq_ind (IZR 1) (fun v3 : @R => v3 * Rabs v0 = Rabs v0) (Rmult_1_l (Rabs v0)) (Rabs (IZR (-1))) v2) (Rabs_mult (IZR (-1)) v0)) (- v0) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_triang	100	0.614532	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (let v2 : {v0 + v1 < IZR 0} + {v0 + v1 >= IZR 0} := Rcase_abs (v0 + v1) in match v2 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 + v1 < IZR 0 => - (v0 + v1)) v4 | right v4 => (fun v4 : v0 + v1 >= IZR 0 => v0 + v1) v4 end <= match Rcase_abs v0 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 < IZR 0 => - v0) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v0) v4 end + match Rcase_abs v1 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 < IZR 0 => - v1) v4 | right v4 => (fun v4 : v1 >= IZR 0 => v1) v4 end) with | left v3 => (fun v3 : v0 + v1 < IZR 0 => let v4 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v4 as v5 in ({_} + {_}) return (- (v0 + v1) <= match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 < IZR 0 => - v0) v6 | right v6 => (fun v6 : v0 >= IZR 0 => v0) v6 end + match Rcase_abs v1 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 < IZR 0 => - v1) v6 | right v6 => (fun v6 : v1 >= IZR 0 => v1) v6 end) with | left v5 => (fun v5 : v0 < IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (- (v0 + v1) <= - v0 + match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => Req_le (- (v0 + v1)) (- v0 + - v1) (eq_ind_r (fun v8 : @R => v8 = - v0 + - v1) eq_refl (Ropp_plus_distr v0 v1))) v7 | right v7 => (fun v7 : v1 >= IZR 0 => eq_ind_r (fun v8 : @R => v8 <= - v0 + v1) (Rplus_le_compat_l (- v0) (- v1) v1 (or_ind (fun v8 : v1 > IZR 0 => or_introl ((fun v9 : - v1 + IZR 0 < - v1 + v1 => and_ind (fun (v10 : - v1 + IZR 0 = - v1) (v11 : IZR 0 + - v1 = - v1) => let v12 : - v1 < - v1 + v1 := eq_ind (- v1 + IZR 0) (fun v12 : @R => v12 < - v1 + v1) v9 (- v1) v10 in let v13 : - v1 < IZR 0 := eq_ind (- v1 + v1) (fun v13 : @R => - v1 < v13) v12 (IZR 0) (Rplus_opp_l v1) in Rlt_trans (- v1) (IZR 0) v1 v13 v8) (Rplus_ne (- v1))) (Rplus_lt_compat_l (- v1) (IZR 0) v1 v8))) (fun v8 : v1 = IZR 0 => or_intror (eq_ind_r (fun v9 : @R => - v9 = v9) (@Ropp_0) v8)) v7 : - v1 <= v1)) (Ropp_plus_distr v0 v1)) v7 end) v5 | right v5 => (fun v5 : v0 >= IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (- (v0 + v1) <= v0 + match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => eq_ind_r (fun v8 : @R => v8 <= v0 + - v1) (eq_ind_r (fun v8 : @R => v8 <= v0 + - v1) (eq_ind_r (fun v8 : @R => - v1 + - v0 <= v8) (Rplus_le_compat_l (- v1) (- v0) v0 (or_ind (fun v8 : v0 > IZR 0 => or_introl ((fun v9 : - v0 + IZR 0 < - v0 + v0 => and_ind (fun (v10 : - v0 + IZR 0 = - v0) (v11 : IZR 0 + - v0 = - v0) => let v12 : - v0 < - v0 + v0 := eq_ind (- v0 + IZR 0) (fun v12 : @R => v12 < - v0 + v0) v9 (- v0) v10 in let v13 : - v0 < IZR 0 := eq_ind (- v0 + v0) (fun v13 : @R => - v0 < v13) v12 (IZR 0) (Rplus_opp_l v0) in Rlt_trans (- v0) (IZR 0) v0 v13 v8) (Rplus_ne (- v0))) (Rplus_lt_compat_l (- v0) (IZR 0) v0 v8))) (fun v8 : v0 = IZR 0 => or_intror (eq_ind_r (fun v9 : @R => - v9 = v9) (@Ropp_0) v8)) v5 : - v0 <= v0)) (Rplus_comm v0 (- v1))) (Rplus_comm (- v0) (- v1))) (Ropp_plus_distr v0 v1)) v7 | right v7 => (fun v7 : v1 >= IZR 0 => False_ind (- (v0 + v1) <= v0 + v1) ((fun v8 : v0 + v1 >= v0 + IZR 0 => and_ind (fun (v9 : v0 + IZR 0 = v0) (v10 : IZR 0 + v0 = v0) => let v11 : v0 + v1 >= v0 := eq_ind (v0 + IZR 0) (fun v11 : @R => v0 + v1 >= v11) v8 v0 v9 in (fun v12 : v0 + v1 >= IZR 0 => or_ind (fun v13 : v0 + v1 > IZR 0 => (fun v14 : ~ IZR 0 < v0 + v1 => v14 v13) (Rlt_asym (v0 + v1) (IZR 0) v3)) (fun v13 : v0 + v1 = IZR 0 => False_ind (@False) (Rlt_dichotomy_converse (v0 + v1) (IZR 0) (or_introl v3) v13)) v12) (Rge_trans (v0 + v1) v0 (IZR 0) v11 v5)) (Rplus_ne v0)) (Rplus_ge_compat_l v0 v1 (IZR 0) v7))) v7 end) v5 end) v3 | right v3 => (fun v3 : v0 + v1 >= IZR 0 => let v4 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v4 as v5 in ({_} + {_}) return (v0 + v1 <= match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 < IZR 0 => - v0) v6 | right v6 => (fun v6 : v0 >= IZR 0 => v0) v6 end + match Rcase_abs v1 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 < IZR 0 => - v1) v6 | right v6 => (fun v6 : v1 >= IZR 0 => v1) v6 end) with | left v5 => (fun v5 : v0 < IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (v0 + v1 <= - v0 + match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => False_ind (v0 + v1 <= - v0 + - v1) ((fun v8 : v0 + v1 < v0 + IZR 0 => and_ind (fun (v9 : v0 + IZR 0 = v0) (v10 : IZR 0 + v0 = v0) => let v11 : v0 + v1 < v0 := eq_ind (v0 + IZR 0) (fun v11 : @R => v0 + v1 < v11) v8 v0 v9 in (fun v12 : v0 + v1 < IZR 0 => match v3 as v13 in (_ \/ _) return (@False) with | or_introl v13 => (fun v13 : v0 + v1 > IZR 0 => (fun v14 : v0 + v1 < v0 + v1 => Rlt_irrefl (v0 + v1) v14) (Rlt_trans (v0 + v1) (IZR 0) (v0 + v1) v12 v13)) v13 | or_intror v13 => (fun v13 : v0 + v1 = IZR 0 => let v14 : IZR 0 < IZR 0 := eq_ind (v0 + v1) (fun v14 : @R => v14 < IZR 0) v12 (IZR 0) v13 in Rlt_irrefl (IZR 0) v14) v13 end) (Rlt_trans (v0 + v1) v0 (IZR 0) v11 v5)) (Rplus_ne v0)) (Rplus_lt_compat_l v0 v1 (IZR 0) v7))) v7 | right v7 => (fun v7 : v1 >= IZR 0 => eq_ind_r (fun v8 : @R => v8 <= - v0 + v1) (eq_ind_r (fun v8 : @R => v1 + v0 <= v8) (Rplus_le_compat_l v1 v0 (- v0) (Rminus_le v0 (- v0) (eq_ind_r (fun v8 : @R => v0 + v8 <= IZR 0) ((fun v8 : v0 + v0 < v0 + IZR 0 => and_ind (fun (v9 : v0 + IZR 0 = v0) (v10 : IZR 0 + v0 = v0) => let v11 : v0 + v0 < v0 := eq_ind (v0 + IZR 0) (fun v11 : @R => v0 + v0 < v11) v8 v0 v9 in (fun v12 : v0 + v0 < IZR 0 => Rlt_le (v0 + v0) (IZR 0) v12) (Rlt_trans (v0 + v0) v0 (IZR 0) v11 v5)) (Rplus_ne v0)) (Rplus_lt_compat_l v0 v0 (IZR 0) v5)) (Ropp_involutive v0) : v0 - - v0 <= IZR 0))) (Rplus_comm (- v0) v1)) (Rplus_comm v0 v1)) v7 end) v5 | right v5 => (fun v5 : v0 >= IZR 0 => let v6 : {v1 < IZR 0} + {v1 >= IZR 0} := Rcase_abs v1 in match v6 as v7 in ({_} + {_}) return (v0 + v1 <= v0 + match v7 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v1 < IZR 0 => - v1) v8 | right v8 => (fun v8 : v1 >= IZR 0 => v1) v8 end) with | left v7 => (fun v7 : v1 < IZR 0 => Rplus_le_compat_l v0 v1 (- v1) (Rminus_le v1 (- v1) (eq_ind_r (fun v8 : @R => v1 + v8 <= IZR 0) ((fun v8 : v1 + v1 < v1 + IZR 0 => and_ind (fun (v9 : v1 + IZR 0 = v1) (v10 : IZR 0 + v1 = v1) => let v11 : v1 + v1 < v1 := eq_ind (v1 + IZR 0) (fun v11 : @R => v1 + v1 < v11) v8 v1 v9 in (fun v12 : v1 + v1 < IZR 0 => Rlt_le (v1 + v1) (IZR 0) v12) (Rlt_trans (v1 + v1) v1 (IZR 0) v11 v7)) (Rplus_ne v1)) (Rplus_lt_compat_l v1 v1 (IZR 0) v7)) (Ropp_involutive v1) : v1 - - v1 <= IZR 0))) v7 | right v7 => (fun v7 : v1 >= IZR 0 => or_intror eq_refl : v0 + v1 <= v0 + v1) v7 end) v5 end) v3 end) : Rabs (v0 + v1) <= Rabs v0 + Rabs v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_triang_inv	100	0.156788	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => Rplus_le_reg_l (Rabs v1) (Rabs v0 - Rabs v1) (Rabs (v0 - v1)) (eq_ind (Rabs v1 + Rabs v0 + - Rabs v1) (fun v2 : @R => v2 <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind_r (fun v2 : @R => v2 + - Rabs v1 <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind_r (fun v2 : @R => v2 <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind_r (fun v2 : @R => Rabs v0 + v2 <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind_r (fun v2 : @R => v2 <= Rabs v1 + Rabs (v0 + - v1)) (let v2 : Rabs (v0 + IZR 0) = Rabs v0 := eq_ind_r (fun v2 : @R => Rabs v2 = Rabs v0) eq_refl (proj1 (Rplus_ne v0)) in eq_ind (Rabs (v0 + IZR 0)) (fun v3 : @R => v3 <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind (v1 + - v1) (fun v3 : @R => Rabs (v0 + v3) <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind (v0 + v1 + - v1) (fun v3 : @R => Rabs v3 <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind_r (fun v3 : @R => Rabs (v3 + - v1) <= Rabs v1 + Rabs (v0 + - v1)) (eq_ind_r (fun v3 : @R => Rabs v3 <= Rabs v1 + Rabs (v0 + - v1)) (Rabs_triang v1 (v0 + - v1)) (Rplus_assoc v1 v0 (- v1))) (Rplus_comm v0 v1)) (v0 + (v1 + - v1)) (Rplus_assoc v0 v1 (- v1))) (IZR 0) (Rplus_opp_r v1)) (Rabs v0) v2) (proj1 (Rplus_ne (Rabs v0)))) (Rplus_opp_r (Rabs v1))) (Rplus_assoc (Rabs v0) (Rabs v1) (- Rabs v1))) (Rplus_comm (Rabs v1) (Rabs v0))) (Rabs v1 + (Rabs v0 + - Rabs v1)) (Rplus_assoc (Rabs v1) (Rabs v0) (- Rabs v1)) : Rabs v1 + (Rabs v0 - Rabs v1) <= Rabs v1 + Rabs (v0 - v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_triang_inv2	100	0.211367	1	1	0	synth with cache (only 1: refine (let v0 : forall (v0 v1 : @R) (v2 : Rabs v1 <= Rabs v0), Rabs (Rabs v0 - Rabs v1) <= Rabs (v0 - v1) := fun (v0 v1 : @R) (v2 : Rabs v1 <= Rabs v0) => let v3 : Rabs v0 - Rabs v1 = Rabs (Rabs v0 - Rabs v1) := eq_ind_r (fun v3 : @R => Rabs v0 - Rabs v1 = v3) eq_refl (Rabs_right (Rabs v0 - Rabs v1) (Rle_ge (IZR 0) (Rabs v0 - Rabs v1) (Rplus_le_reg_l (Rabs v1) (IZR 0) (Rabs v0 - Rabs v1) (eq_ind_r (fun v3 : @R => v3 <= Rabs v1 + (Rabs v0 - Rabs v1)) (let v3 : Rabs v0 = Rabs v1 + (Rabs v0 - Rabs v1) := let v3 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v4 : list (@R) := (Rabs v0 :: Rabs v1 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v4 v3 (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (@I) (eq_refl : (let v5 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))))) = @true) in eq_ind (Rabs v0) (fun v4 : @R => Rabs v1 <= v4) v2 (Rabs v1 + (Rabs v0 - Rabs v1)) v3) (Rplus_0_r (Rabs v1)))))) in eq_ind (Rabs v0 - Rabs v1) (fun v4 : @R => v4 <= Rabs (v0 - v1)) (Rabs_triang_inv v0 v1) (Rabs (Rabs v0 - Rabs v1)) v3 in (fun (v1 : forall (v1 v2 : @R) (v3 : Rabs v2 <= Rabs v1), Rabs (Rabs v1 - Rabs v2) <= Rabs (v1 - v2)) (v2 v3 : @R) => let v4 : Rabs v2 < Rabs v3 \/ Rabs v2 = Rabs v3 \/ Rabs v2 > Rabs v3 := Rtotal_order (Rabs v2) (Rabs v3) in match v4 as v5 in (_ \/ _) return (Rabs (Rabs v2 - Rabs v3) <= Rabs (v2 - v3)) with | or_introl v5 => (fun v5 : Rabs v2 < Rabs v3 => eq_ind (Rabs (- (Rabs v2 - Rabs v3))) (fun v6 : @R => v6 <= Rabs (v2 - v3)) (eq_ind (Rabs (- (v2 - v3))) (fun v6 : @R => Rabs (- (Rabs v2 - Rabs v3)) <= v6) (eq_ind_r (fun v6 : @R => Rabs v6 <= Rabs (- (v2 - v3))) (eq_ind_r (fun v6 : @R => Rabs (Rabs v3 - Rabs v2) <= Rabs v6) (v1 v3 v2 (or_introl v5)) (Ropp_minus_distr v2 v3)) (Ropp_minus_distr (Rabs v2) (Rabs v3))) (Rabs (v2 - v3)) (Rabs_Ropp (v2 - v3))) (Rabs (Rabs v2 - Rabs v3)) (Rabs_Ropp (Rabs v2 - Rabs v3))) v5 | or_intror v5 => (fun v5 : Rabs v2 = Rabs v3 \/ Rabs v2 > Rabs v3 => match v5 as v6 in (_ \/ _) return (Rabs (Rabs v2 - Rabs v3) <= Rabs (v2 - v3)) with | or_introl v6 => (fun v6 : Rabs v2 = Rabs v3 => eq_ind_r (fun v7 : @R => Rabs (v7 - Rabs v3) <= Rabs (v2 - v3)) (eq_ind_r (fun v7 : @R => Rabs v7 <= Rabs (v2 + - v3)) (eq_ind_r (fun v7 : @R => v7 <= Rabs (v2 + - v3)) (Rabs_pos (v2 + - v3)) (@Rabs_R0)) (Rplus_opp_r (Rabs v3)) : Rabs (Rabs v3 - Rabs v3) <= Rabs (v2 - v3)) v6) v6 | or_intror v6 => (fun v6 : Rabs v2 > Rabs v3 => v1 v2 v3 (or_introl v6)) v6 end) v5 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_def1	100	0.067331	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : v0 < v1) (v3 : - v1 < v0) => match Rcase_abs v0 as v4 in ({_} + {_}) return (match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 < IZR 0 => - v0) v5 | right v5 => (fun v5 : v0 >= IZR 0 => v0) v5 end < v1) with | left v4 => (fun v4 : v0 < IZR 0 => (eq_ind_r (fun v5 : @R => forall v6 : - v0 < v5, - v0 < v1) (fun v5 : - v0 < v1 => v5) (Ropp_involutive v1) : forall v5 : - - v1 > - v0, - v0 < v1) (Ropp_lt_gt_contravar (- v1) v0 v3)) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v2) v4 end) : forall (v0 v1 : @R) (v2 : v0 < v1) (v3 : - v1 < v0), Rabs v0 < v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_def2	100	0.104163	1	1	0	synth with cache (only 1: refine ((fun v0 : @R => let v1 : {v0 < IZR 0} + {v0 >= IZR 0} := Rcase_abs v0 in match v1 as v2 in ({_} + {_}) return (forall (v3 : @R) (v4 : match v2 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 < IZR 0 => - v0) v4 | right v4 => (fun v4 : v0 >= IZR 0 => v0) v4 end < v3), v0 < v3 /\ - v3 < v0) with | left v2 => (fun (v2 : v0 < IZR 0) (v3 : @R) (v4 : - v0 < v3) => ((fun v5 : IZR 0 < - v0 => (fun v6 : IZR 0 < v3 => conj (Rlt_trans v0 (IZR 0) v3 v2 v6) (eq_ind_r (fun v7 : @R => forall v8 : v7 > - v3, - v3 < v0) ((fun v7 : - v3 < v0 => v7) : forall v7 : v0 > - v3, - v3 < v0) (Ropp_involutive v0) (Ropp_lt_gt_contravar (- v0) v3 v4))) (Rlt_trans (IZR 0) (- v0) v3 v5 v4)) : forall v5 : - v0 > IZR 0, v0 < v3 /\ - v3 < v0) (Ropp_gt_lt_0_contravar v0 v2)) v2 | right v2 => (fun (v2 : v0 >= IZR 0) (v3 : @R) (v4 : v0 < v3) => (fun v5 : v3 > IZR 0 => (fun v6 : - v3 < IZR 0 => ((fun v7 : - v3 < v0 => conj v4 v7) : forall v7 : v0 > - v3, v0 < v3 /\ - v3 < v0) (Rge_gt_trans v0 (IZR 0) (- v3) v2 v6) : v0 < v3 /\ - v3 < v0) (Ropp_lt_gt_0_contravar v3 v5)) (Rgt_ge_trans v3 v0 (IZR 0) v4 v2)) v2 end) : forall (v0 v1 : @R) (v2 : Rabs v0 < v1), v0 < v1 /\ - v1 < v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.RmaxAbs	100	0.170205	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v1) (v4 : v1 <= v2) => match Rle_or_lt (IZR 0) v0 as v5 in (_ \/ _) return (Rabs v1 <= Rmax (Rabs v0) (Rabs v2)) with | or_introl v5 => (fun v5 : IZR 0 <= v0 => eq_ind_r (fun v6 : @R => v6 <= Rmax (Rabs v0) (Rabs v2)) (eq_ind_r (fun v6 : @R => v1 <= Rmax v6 (Rabs v2)) (eq_ind_r (fun v6 : @R => v1 <= Rmax v0 v6) (Rle_trans v1 v2 (Rmax v0 v2) v4 (Rmax_r v0 v2)) (Rabs_right v2 (Rge_trans v2 v0 (IZR 0) (Rge_trans v2 v1 v0 (Rle_ge v1 v2 v4) (Rle_ge v0 v1 v3)) (Rle_ge (IZR 0) v0 v5)))) (Rabs_right v0 (Rle_ge (IZR 0) v0 v5))) (Rabs_right v1 (Rge_trans v1 v0 (IZR 0) (Rle_ge v0 v1 v3) (Rle_ge (IZR 0) v0 v5)))) v5 | or_intror v5 => (fun v5 : v0 < IZR 0 => eq_ind_r (fun v6 : @R => Rabs v1 <= Rmax v6 (Rabs v2)) match Rle_or_lt (IZR 0) v1 as v6 in (_ \/ _) return (Rabs v1 <= Rmax (- v0) (Rabs v2)) with | or_introl v6 => (fun v6 : IZR 0 <= v1 => eq_ind_r (fun v7 : @R => v7 <= Rmax (- v0) (Rabs v2)) (eq_ind_r (fun v7 : @R => v1 <= Rmax (- v0) v7) (Rle_trans v1 v2 (Rmax (- v0) v2) v4 (Rmax_r (- v0) v2)) (Rabs_right v2 (Rge_trans v2 v1 (IZR 0) (Rle_ge v1 v2 v4) (Rle_ge (IZR 0) v1 v6)))) (Rabs_right v1 (Rle_ge (IZR 0) v1 v6))) v6 | or_intror v6 => (fun v6 : v1 < IZR 0 => eq_ind_r (fun v7 : @R => v7 <= Rmax (- v0) (Rabs v2)) match Rle_or_lt (IZR 0) v2 as v7 in (_ \/ _) return (- v1 <= Rmax (- v0) (Rabs v2)) with | or_introl v7 => (fun v7 : IZR 0 <= v2 => eq_ind_r (fun v8 : @R => - v1 <= Rmax (- v0) v8) (Rle_trans (- v1) (- v0) (Rmax (- v0) v2) (Ropp_le_contravar v1 v0 v3) (Rmax_l (- v0) v2)) (Rabs_right v2 (Rle_ge (IZR 0) v2 v7))) v7 | or_intror v7 => (fun v7 : v2 < IZR 0 => eq_ind_r (fun v8 : @R => - v1 <= Rmax (- v0) v8) (Rle_trans (- v1) (- v0) (Rmax (- v0) (- v2)) (Ropp_le_contravar v1 v0 v3) (Rmax_l (- v0) (- v2))) (Rabs_left v2 v7)) v7 end (Rabs_left v1 v6)) v6 end (Rabs_left v0 v5)) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rabs_Zabs	100	0.114803	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (Rabs (IZR v1) = IZR (BinIntDef.Z.abs v1)) with | 0%Z => @Rabs_R0 : Rabs (IZR 0) = IZR (BinIntDef.Z.abs 0) | Z.pos v1 => ((fun v1 : @positive => Rabs_pos_eq (IZR (Z.pos v1)) (IZR_le 0 (Z.pos v1) ((fun v2 : (0 ?= Z.pos v1)%Z = @Gt => let v3 : forall v3 : @Gt = @Gt, @False := match v2 as v4 in (_ = v3) return (forall v5 : v3 = @Gt, @False) with | eq_refl => fun v3 : (0 ?= Z.pos v1)%Z = @Gt => (fun v4 : (0 ?= Z.pos v1)%Z = @Gt => let v5 : @False := eq_ind (0 ?= Z.pos v1)%Z (fun v5 : @comparison => match v5 as v6 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v4 in False_ind (@False) v5) v3 end in v3 eq_refl) : (0 <= Z.pos v1)%Z))) : forall v1 : @positive, Rabs (IZR (Z.pos v1)) = IZR (BinIntDef.Z.abs (Z.pos v1))) v1 | Z.neg v1 => (((fun v1 : @positive => eq_ind_r (fun v2 : @R => v2 = IZR (Z.pos v1)) (Rabs_pos_eq (IZR (Z.pos v1)) (IZR_le 0 (Z.pos v1) ((fun v2 : (0 ?= Z.pos v1)%Z = @Gt => let v3 : forall v3 : @Gt = @Gt, @False := match v2 as v4 in (_ = v3) return (forall v5 : v3 = @Gt, @False) with | eq_refl => fun v3 : (0 ?= Z.pos v1)%Z = @Gt => (fun v4 : (0 ?= Z.pos v1)%Z = @Gt => let v5 : @False := eq_ind (0 ?= Z.pos v1)%Z (fun v5 : @comparison => match v5 as v6 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v4 in False_ind (@False) v5) v3 end in v3 eq_refl) : (0 <= Z.pos v1)%Z))) (Rabs_Ropp (IPR v1))) : forall v1 : @positive, Rabs (IZR (Z.neg v1)) = IZR (Z.pos v1)) : forall v1 : @positive, Rabs (IZR (Z.neg v1)) = IZR (BinIntDef.Z.abs (Z.neg v1))) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.abs_IZR	100	0.038567	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => eq_ind_r (fun v1 : @R => IZR (BinIntDef.Z.abs v0) = v1) eq_refl (Rabs_Zabs v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Ropp_Rmax	100	0.058715	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Ropp_Rmin	100	0.049599	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmax_assoc	100	0.538236	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => (let v3 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v3 as v4 in ({_} + {_}) return (match Rle_dec v0 match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v2 => v2) v5 | right v5 => (fun v5 : ~ v1 <= v2 => v1) v5 end as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v2 => v2) v5 | right v5 => (fun v5 : ~ v1 <= v2 => v1) v5 end => match v4 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 <= v2 => v2) v6 | right v6 => (fun v6 : ~ v1 <= v2 => v1) v6 end) v5 | right v5 => (fun v5 : ~ v0 <= match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v2 => v2) v5 | right v5 => (fun v5 : ~ v1 <= v2 => v1) v5 end => v0) v5 end = match Rle_dec match Rle_dec v0 v1 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end v2 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : match Rle_dec v0 v1 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end <= v2 => v2) v5 | right v5 => (fun v5 : ~ match Rle_dec v0 v1 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end <= v2 => match Rle_dec v0 v1 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v1) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v0) v6 end) v5 end) with | left v4 => (fun v4 : v1 <= v2 => let v5 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v5 as v6 in ({_} + {_}) return (match Rle_dec v0 v2 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v2 => v2) v7 | right v7 => (fun v7 : ~ v0 <= v2 => v0) v7 end = match Rle_dec match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v1) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v0) v7 end v2 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v1) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v0) v7 end <= v2 => v2) v7 | right v7 => (fun v7 : ~ match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v1) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v0) v7 end <= v2 => match v6 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v0 <= v1 => v1) v8 | right v8 => (fun v8 : ~ v0 <= v1 => v0) v8 end) v7 end) with | left v6 => (fun v6 : v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v2) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v0) v9 end = match Rle_dec v1 v2 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v1 <= v2 => v2) v9 | right v9 => (fun v9 : ~ v1 <= v2 => v1) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v2 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v2) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v1) v11 end) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => Rle_antisym v2 v1 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v10)) v4) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v2) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v1) v11 end) with | left v10 => (fun v10 : v1 <= v2 => match v8 (Rle_trans v0 v1 v2 v6 v10) as v11 in False return (v0 = v2) with end) v10 | right v10 => (fun v10 : ~ v1 <= v2 => match v8 (Rle_trans v0 v1 v2 v6 v4) as v11 in False return (v0 = v1) with end) v10 end) v8 end) v6 | right v6 => (fun v6 : ~ v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v2) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v0) v9 end = match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v2) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v0) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v2 = v2) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = v0) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 end) v6 end) v4 | right v4 => (fun v4 : ~ v1 <= v2 => let v5 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v5 as v6 in ({_} + {_}) return (match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v1) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v0) v7 end = match Rle_dec match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v1) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v0) v7 end v2 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v1) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v0) v7 end <= v2 => v2) v7 | right v7 => (fun v7 : ~ match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v1) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v0) v7 end <= v2 => match v6 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v0 <= v1 => v1) v8 | right v8 => (fun v8 : ~ v0 <= v1 => v0) v8 end) v7 end) with | left v6 => (fun v6 : v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (v1 = match Rle_dec v1 v2 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v1 <= v2 => v2) v9 | right v9 => (fun v9 : ~ v1 <= v2 => v1) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v1 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v2) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v1) v11 end) with | left v10 => (fun v10 : v1 <= v2 => Rle_antisym v1 v2 v10 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v4))) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v1 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v2) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v1) v11 end) with | left v10 => (fun v10 : v1 <= v2 => Rle_antisym v1 v2 v10 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v4))) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 end) v6 | right v6 => (fun v6 : ~ v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (v0 = match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v2) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v0) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = v2) with | left v10 => (fun v10 : v1 <= v2 => match v4 (Rle_trans v1 v2 v2 v10 (Req_le_sym v2 v2 eq_refl)) as v11 in False return (v0 = v2) with end) v10 | right v10 => (fun v10 : ~ v1 <= v2 => match v6 (Rle_trans v0 v2 v1 v8 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v10))) as v11 in False return (v0 = v2) with end) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = v0) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 end) v6 end) v4 end) : Rmax v0 (Rmax v1 v2) = Rmax (Rmax v0 v1) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rminmax	100	0.055796	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v2 as v3 in ({_} + {_}) return (Rmin v0 v1 <= Rmax v0 v1) with | left v3 => (fun v3 : v0 <= v1 => eq_ind_r (fun v4 : @R => v4 <= Rmax v0 v1) (eq_ind_r (fun v4 : @R => v0 <= v4) v3 (Rmax_right v0 v1 v3)) (Rmin_left v0 v1 v3)) v3 | right v3 => (fun v3 : ~ v0 <= v1 => eq_ind_r (fun v4 : @R => v4 <= Rmax v0 v1) (eq_ind_r (fun v4 : @R => v1 <= v4) (Rlt_le v1 v0 (Rnot_le_gt v0 v1 v3)) (Rmax_left v0 v1 (Rlt_le v1 v0 (Rnot_le_gt v0 v1 v3)))) (Rmin_right v0 v1 (Rlt_le v1 v0 (Rnot_le_gt v0 v1 v3)))) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Rbasic_fun.Rmin_assoc	100	0.547726	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => (let v3 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v3 as v4 in ({_} + {_}) return (match Rle_dec v0 match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v2 => v1) v5 | right v5 => (fun v5 : ~ v1 <= v2 => v2) v5 end as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v2 => v1) v5 | right v5 => (fun v5 : ~ v1 <= v2 => v2) v5 end => v0) v5 | right v5 => (fun v5 : ~ v0 <= match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v2 => v1) v5 | right v5 => (fun v5 : ~ v1 <= v2 => v2) v5 end => match v4 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v1 <= v2 => v1) v6 | right v6 => (fun v6 : ~ v1 <= v2 => v2) v6 end) v5 end = match Rle_dec match Rle_dec v0 v1 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end v2 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : match Rle_dec v0 v1 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end <= v2 => match Rle_dec v0 v1 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => v0) v6 | right v6 => (fun v6 : ~ v0 <= v1 => v1) v6 end) v5 | right v5 => (fun v5 : ~ match Rle_dec v0 v1 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end <= v2 => v2) v5 end) with | left v4 => (fun v4 : v1 <= v2 => let v5 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v5 as v6 in ({_} + {_}) return (match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v1) v7 end = match Rle_dec match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v1) v7 end v2 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v1) v7 end <= v2 => match v6 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v0 <= v1 => v0) v8 | right v8 => (fun v8 : ~ v0 <= v1 => v1) v8 end) v7 | right v7 => (fun v7 : ~ match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v1) v7 end <= v2 => v2) v7 end) with | left v6 => (fun v6 : v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (v0 = match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v0) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v2) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = v0) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = v2) with | left v10 => (fun v10 : v1 <= v2 => match v8 (Rle_trans v0 v1 v2 v6 v10) as v11 in False return (v0 = v2) with end) v10 | right v10 => (fun v10 : ~ v1 <= v2 => match v8 (Rle_trans v0 v1 v2 v6 v4) as v11 in False return (v0 = v2) with end) v10 end) v8 end) v6 | right v6 => (fun v6 : ~ v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (v1 = match Rle_dec v1 v2 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v1 <= v2 => v1) v9 | right v9 => (fun v9 : ~ v1 <= v2 => v2) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v1 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v1) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v2) v11 end) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => Rle_antisym v1 v2 v4 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v10))) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v1 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v1) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v2) v11 end) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => Rle_antisym v1 v2 v4 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v10))) v10 end) v8 end) v6 end) v4 | right v4 => (fun v4 : ~ v1 <= v2 => let v5 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v5 as v6 in ({_} + {_}) return (match Rle_dec v0 v2 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v2 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v2 => v2) v7 end = match Rle_dec match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v1) v7 end v2 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v1) v7 end <= v2 => match v6 as v8 in ({_} + {_}) return (@R) with | left v8 => (fun v8 : v0 <= v1 => v0) v8 | right v8 => (fun v8 : ~ v0 <= v1 => v1) v8 end) v7 | right v7 => (fun v7 : ~ match v6 as v7 in ({_} + {_}) return (@R) with | left v7 => (fun v7 : v0 <= v1 => v0) v7 | right v7 => (fun v7 : ~ v0 <= v1 => v1) v7 end <= v2 => v2) v7 end) with | left v6 => (fun v6 : v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v0) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v2) v9 end = match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v0) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v2) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = v0) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v2 = v2) with | left v10 => (fun v10 : v1 <= v2 => eq_refl) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 end) v6 | right v6 => (fun v6 : ~ v0 <= v1 => let v7 : {v0 <= v2} + {~ v0 <= v2} := Rle_dec v0 v2 in match v7 as v8 in ({_} + {_}) return (match v8 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v0 <= v2 => v0) v9 | right v9 => (fun v9 : ~ v0 <= v2 => v2) v9 end = match Rle_dec v1 v2 as v9 in ({_} + {_}) return (@R) with | left v9 => (fun v9 : v1 <= v2 => v1) v9 | right v9 => (fun v9 : ~ v1 <= v2 => v2) v9 end) with | left v8 => (fun v8 : v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v0 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v1) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v2) v11 end) with | left v10 => (fun v10 : v1 <= v2 => match v4 (Rle_trans v1 v2 v2 v10 (Req_le_sym v2 v2 eq_refl)) as v11 in False return (v0 = v1) with end) v10 | right v10 => (fun v10 : ~ v1 <= v2 => match v6 (Rle_trans v0 v2 v1 v8 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v10))) as v11 in False return (v0 = v2) with end) v10 end) v8 | right v8 => (fun v8 : ~ v0 <= v2 => let v9 : {v1 <= v2} + {~ v1 <= v2} := Rle_dec v1 v2 in match v9 as v10 in ({_} + {_}) return (v2 = match v10 as v11 in ({_} + {_}) return (@R) with | left v11 => (fun v11 : v1 <= v2 => v1) v11 | right v11 => (fun v11 : ~ v1 <= v2 => v2) v11 end) with | left v10 => (fun v10 : v1 <= v2 => Rle_antisym v2 v1 (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v4)) v10) v10 | right v10 => (fun v10 : ~ v1 <= v2 => eq_refl) v10 end) v8 end) v6 end) v4 end) : Rmin v0 (Rmin v1 v2) = Rmin (Rmin v0 v1) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.in_holed_interval_dec	100	0.573628	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @R) (v3 : forall v3 : @nat, @R) (v4 : @nat) => let v5 : {(v0 < v3 v4)%R} + {v0 = v3 v4} + {(v3 v4 < v0)%R} := total_order_T v0 (v3 v4) in match v5 as v6 in (_ + {_}) return ({in_holed_interval v0 v1 v2 v3 v4} + {~ in_holed_interval v0 v1 v2 v3 v4}) with | inleft v6 => (fun v6 : {(v0 < v3 v4)%R} + {v0 = v3 v4} => match v6 as v7 in ({_} + {_}) return ({in_holed_interval v0 v1 v2 v3 v4} + {~ in_holed_interval v0 v1 v2 v3 v4}) with | left v7 => (fun v7 : (v0 < v3 v4)%R => let v8 : {(v1 < v3 v4)%R} + {v1 = v3 v4} + {(v3 v4 < v1)%R} := total_order_T v1 (v3 v4) in match v8 as v9 in (_ + {_}) return ({in_holed_interval v0 v1 v2 v3 v4} + {~ in_holed_interval v0 v1 v2 v3 v4}) with | inleft v9 => (fun v9 : {(v1 < v3 v4)%R} + {v1 = v3 v4} => match v9 as v10 in ({_} + {_}) return ({in_holed_interval v0 v1 v2 v3 v4} + {~ in_holed_interval v0 v1 v2 v3 v4}) with | left v10 => (fun v10 : (v1 < v3 v4)%R => right ((fun v11 : in_holed_interval v0 v1 v2 v3 v4 => match v11 as v12 in (_ /\ _) return (@False) with | conj v12 v13 => (fun (v12 : (v0 < v3 v4)%R) (v13 : (v3 v4 < v1)%R /\ v3 v4 <> v2) => match v13 as v14 in (_ /\ _) return (@False) with | conj v14 v15 => (fun (v14 : (v3 v4 < v1)%R) (v15 : v3 v4 <> v2) => let v16 : ~ (v1 < v3 v4)%R := Rlt_asym (v3 v4) v1 v14 in False_ind (@False) (v16 v10)) v14 v15 end) v12 v13 end) : ~ in_holed_interval v0 v1 v2 v3 v4)) v10 | right v10 => (fun v10 : v1 = v3 v4 => eq_rec_r (fun v11 : @R => {in_holed_interval v0 v11 v2 v3 v4} + {~ in_holed_interval v0 v11 v2 v3 v4}) (right ((fun v11 : in_holed_interval v0 (v3 v4) v2 v3 v4 => match v11 as v12 in (_ /\ _) return (@False) with | conj v12 v13 => (fun (v12 : (v0 < v3 v4)%R) (v13 : (v3 v4 < v3 v4)%R /\ v3 v4 <> v2) => match v13 as v14 in (_ /\ _) return (@False) with | conj v14 v15 => (fun (v14 : (v3 v4 < v3 v4)%R) (v15 : v3 v4 <> v2) => let v16 : ~ (v3 v4 < v3 v4)%R := Rlt_asym (v3 v4) (v3 v4) v14 in False_ind (@False) (v16 v14)) v14 v15 end) v12 v13 end) : ~ in_holed_interval v0 (v3 v4) v2 v3 v4)) v10) v10 end) v9 | inright v9 => (fun v9 : (v3 v4 < v1)%R => let v10 : {v2 = v3 v4} + {v2 <> v3 v4} := Req_EM_T v2 (v3 v4) in match v10 as v11 in ({_} + {_}) return ({in_holed_interval v0 v1 v2 v3 v4} + {~ in_holed_interval v0 v1 v2 v3 v4}) with | left v11 => (fun v11 : v2 = v3 v4 => eq_rec_r (fun v12 : @R => {in_holed_interval v0 v1 v12 v3 v4} + {~ in_holed_interval v0 v1 v12 v3 v4}) (right ((fun v12 : in_holed_interval v0 v1 (v3 v4) v3 v4 => match v12 as v13 in (_ /\ _) return (@False) with | conj v13 v14 => (fun (v13 : (v0 < v3 v4)%R) (v14 : (v3 v4 < v1)%R /\ v3 v4 <> v3 v4) => match v14 as v15 in (_ /\ _) return (@False) with | conj v15 v16 => (fun (v15 : (v3 v4 < v1)%R) (v16 : v3 v4 <> v3 v4) => v16 eq_refl) v15 v16 end) v13 v14 end) : ~ in_holed_interval v0 v1 (v3 v4) v3 v4)) v11) v11 | right v11 => (fun v11 : v2 <> v3 v4 => left (conj v7 (conj v9 ((fun v12 : v3 v4 = v2 => eq_ind (v3 v4) (fun v13 : @R => forall v14 : v13 <> v3 v4, @False) (fun v13 : v3 v4 <> v3 v4 => v13 eq_refl) v2 v12 v11) : v3 v4 <> v2)))) v11 end) v9 end) v7 | right v7 => (fun v7 : v0 = v3 v4 => eq_rec_r (fun v8 : @R => {in_holed_interval v8 v1 v2 v3 v4} + {~ in_holed_interval v8 v1 v2 v3 v4}) (right ((fun v8 : in_holed_interval (v3 v4) v1 v2 v3 v4 => match v8 as v9 in (_ /\ _) return (@False) with | conj v9 v10 => (fun (v9 : (v3 v4 < v3 v4)%R) (v10 : (v3 v4 < v1)%R /\ v3 v4 <> v2) => let v11 : ~ (v3 v4 < v3 v4)%R := Rlt_asym (v3 v4) (v3 v4) v9 in False_ind (@False) (v11 v9)) v9 v10 end) : ~ in_holed_interval (v3 v4) v1 v2 v3 v4)) v7) v7 end) v6 | inright v6 => (fun v6 : (v3 v4 < v0)%R => right ((fun v7 : in_holed_interval v0 v1 v2 v3 v4 => match v7 as v8 in (_ /\ _) return (@False) with | conj v8 v9 => (fun (v8 : (v0 < v3 v4)%R) (v9 : (v3 v4 < v1)%R /\ v3 v4 <> v2) => let v10 : ~ (v3 v4 < v0)%R := Rlt_asym v0 (v3 v4) v8 in False_ind (@False) (v10 v6)) v8 v9 end) : ~ in_holed_interval v0 v1 v2 v3 v4)) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.middle_in_interval	100	0.430884	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : (v0 < v1)%R) => let v3 : INR 2 <> IZR 0 := not_0_INR 2 ((fun v3 : 2 = 0 => let v4 : forall v4 : 0 = 0, @False := match v3 as v5 in (_ = v4) return (forall v6 : v4 = 0, @False) with | eq_refl => fun v4 : 2 = 0 => (fun v5 : 2 = 0 => let v6 : @False := eq_ind 2 (fun v6 : @nat => match v6 as v7 in nat return Prop with | 0 => @False | S v7 => (fun v7 : @nat => @True) v7 end) (@I) 0 v5 in False_ind (@False) v6) v4 end in v4 eq_refl) : 2 <> 0) in let v4 : (IZR 0 < / INR 2)%R := Rinv_0_lt_compat (INR 2) (lt_0_INR 2 (le_n_S 0 1 (le_S 0 0 (le_n 0)))) in let v5 : forall v5 : @R, (v5 + v5)%R = (INR 2 * v5)%R := fun v5 : @R => eq_ind_r (fun v6 : @R => (v5 + v5)%R = (v6 * v5)%R) (eq_ind_r (fun v6 : @R => (v5 + v5)%R = v6) (eq_ind_r (fun v6 : @R => (v5 + v5)%R = (v6 + v6)%R) eq_refl (Rmult_1_l v5)) (Rmult_plus_distr_r (INR 1) (INR 1) v5)) (S_O_plus_INR 1) in conj (let v6 : (v0 + v0 < v0 + v1)%R := Rplus_lt_compat_l v0 v0 v1 v2 in let v7 : (INR 2 * v0 < v0 + v1)%R := eq_ind (v0 + v0)%R (fun v7 : @R => (v7 < v0 + v1)%R) v6 (INR 2 * v0)%R (v5 v0) in let v8 : (/ INR 2 * (INR 2 * v0) < / INR 2 * (v0 + v1))%R := Rmult_lt_compat_l (/ INR 2) (INR 2 * v0) (v0 + v1) v4 v7 in let v9 : (/ INR 2 * INR 2 * v0 < / INR 2 * (v0 + v1))%R := eq_ind_r (fun v9 : @R => (v9 < / INR 2 * (v0 + v1))%R) v8 (Rmult_assoc (/ INR 2) (INR 2) v0) in let v10 : (IZR 1 * v0 < / INR 2 * (v0 + v1))%R := eq_ind (/ INR 2 * INR 2)%R (fun v10 : @R => (v10 * v0 < / INR 2 * (v0 + v1))%R) v9 (IZR 1) (Rinv_l (INR 2) v3) in let v11 : (v0 < / (IZR 1 + IZR 1) * (v0 + v1))%R := eq_ind (IZR 1 * v0)%R (fun v11 : @R => (v11 < / (IZR 1 + IZR 1) * (v0 + v1))%R) v10 v0 (Rmult_1_l v0) in let v12 : (v0 < (v0 + v1) * / (IZR 1 + IZR 1))%R := eq_ind (/ (IZR 1 + IZR 1) * (v0 + v1))%R (fun v12 : @R => (v0 < v12)%R) v11 ((v0 + v1) * / (IZR 1 + IZR 1))%R (Rmult_comm (/ (IZR 1 + IZR 1)) (v0 + v1)) in v12) (let v6 : (v1 + v0 < v1 + v1)%R := Rplus_lt_compat_l v1 v0 v1 v2 in let v7 : (v0 + v1 < v1 + v1)%R := eq_ind (v1 + v0)%R (fun v7 : @R => (v7 < v1 + v1)%R) v6 (v0 + v1)%R (Rplus_comm v1 v0) in let v8 : (v0 + v1 < INR 2 * v1)%R := eq_ind (v1 + v1)%R (fun v8 : @R => (v0 + v1 < v8)%R) v7 (INR 2 * v1)%R (v5 v1) in let v9 : (/ INR 2 * (v0 + v1) < / INR 2 * (INR 2 * v1))%R := Rmult_lt_compat_l (/ INR 2) (v0 + v1) (INR 2 * v1) v4 v8 in let v10 : (/ INR 2 * (v0 + v1) < / INR 2 * INR 2 * v1)%R := eq_ind_r (fun v10 : @R => (/ INR 2 * (v0 + v1) < v10)%R) v9 (Rmult_assoc (/ INR 2) (INR 2) v1) in let v11 : (/ INR 2 * (v0 + v1) < IZR 1 * v1)%R := eq_ind (/ INR 2 * INR 2)%R (fun v11 : @R => (/ INR 2 * (v0 + v1) < v11 * v1)%R) v10 (IZR 1) (Rinv_l (INR 2) v3) in let v12 : (/ (IZR 1 + IZR 1) * (v0 + v1) < v1)%R := eq_ind (IZR 1 * v1)%R (fun v12 : @R => (/ (IZR 1 + IZR 1) * (v0 + v1) < v12)%R) v11 v1 (Rmult_1_l v1) in let v13 : ((v0 + v1) * / (IZR 1 + IZR 1) < v1)%R := eq_ind (/ (IZR 1 + IZR 1) * (v0 + v1))%R (fun v13 : @R => (v13 < v1)%R) v12 ((v0 + v1) * / (IZR 1 + IZR 1))%R (Rmult_comm (/ (IZR 1 + IZR 1)) (v0 + v1)) in v13))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.point_in_holed_interval_works	100	0.261818	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @R) (v3 : (v0 < v1)%R) => let v4 : @R := point_in_holed_interval v0 v1 v2 in let v5 : (v0 < (v0 + v1) / INR 2 < v1)%R := middle_in_interval v0 v1 v3 in match v5 as v6 in (_ /\ _) return ((v0 < v4)%R /\ (v4 < v1)%R /\ v4 <> v2) with | conj v6 v7 => (fun (v6 : (v0 < (v0 + v1) / INR 2)%R) (v7 : ((v0 + v1) / INR 2 < v1)%R) => let v8 : {v2 = ((v0 + v1) / INR 2)%R} + {v2 <> ((v0 + v1) / INR 2)%R} := Req_EM_T v2 ((v0 + v1) / INR 2) in match v8 as v9 in ({_} + {_}) return (let v10 : @R := match v9 as v10 in ({_} + {_}) return (@R) with | left v10 => (fun v10 : v2 = ((v0 + v1) / INR 2)%R => ((v0 + v2) / INR 2)%R) v10 | right v10 => (fun v10 : v2 <> ((v0 + v1) / INR 2)%R => ((v0 + v1) / INR 2)%R) v10 end in (v0 < v10)%R /\ (v10 < v1)%R /\ v10 <> v2) with | left v9 => (fun v9 : v2 = ((v0 + v1) / INR 2)%R => let v10 : @R := ((v0 + v2) / INR 2)%R in eq_ind_r (fun v11 : @R => let v12 : @R := ((v0 + v11) / INR 2)%R in (v0 < v12)%R /\ (v12 < v1)%R /\ v12 <> v11) (let v11 : @R := ((v0 + (v0 + v1) / INR 2) / INR 2)%R in let v12 : (v0 < (v0 + (v0 + v1) / INR 2) / INR 2 < (v0 + v1) / INR 2)%R := middle_in_interval v0 ((v0 + v1) / INR 2) v6 in match v12 as v13 in (_ /\ _) return ((v0 < v11)%R /\ (v11 < v1)%R /\ v11 <> ((v0 + v1) / INR 2)%R) with | conj v13 v14 => (fun (v13 : (v0 < (v0 + (v0 + v1) / INR 2) / INR 2)%R) (v14 : ((v0 + (v0 + v1) / INR 2) / INR 2 < (v0 + v1) / INR 2)%R) => conj v13 (conj (Rlt_trans v11 ((v0 + v1) / INR 2) v1 v14 v7) (Rlt_not_eq v11 ((v0 + v1) / INR 2) v14))) v13 v14 end) v9) v9 | right v9 => (fun v9 : v2 <> ((v0 + v1) / INR 2)%R => let v10 : @R := ((v0 + v1) / INR 2)%R in conj v6 (conj v7 ((fun v11 : v10 = v2 => eq_ind v10 (fun v12 : @R => forall v13 : v12 <> ((v0 + v1) / INR 2)%R, @False) (fun v12 : v10 <> ((v0 + v1) / INR 2)%R => False_ind (@False) (v12 eq_refl)) v2 v11 v9) : v10 <> v2))) v9 end) v6 v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.first_in_holed_interval	100	0.097232	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 v3 v4 : @R) (v5 : enumeration (@R) v0 v1) (v6 : (v2 < v3)%R) => epsilon_smallest (in_holed_interval v2 v3 v4 v0) (in_holed_interval_dec v2 v3 v4 v0) (ex_intro (fun v7 : @nat => in_holed_interval v2 v3 v4 v0 v7) (v1 (point_in_holed_interval v2 v3 v4)) match v5 as v7 in (_ /\ _) return (in_holed_interval v2 v3 v4 v0 (v1 (point_in_holed_interval v2 v3 v4))) with | conj v7 v8 => (fun (v7 : forall v7 : @R, v0 (v1 v7) = v7) (v8 : forall v8 : @nat, v1 (v0 v8) = v8) => eq_ind_r (fun v9 : @R => (v2 < v9)%R /\ (v9 < v3)%R /\ v9 <> v4) (point_in_holed_interval_works v2 v3 v4 v6) (v7 (point_in_holed_interval v2 v3 v4)) : in_holed_interval v2 v3 v4 v0 (v1 (point_in_holed_interval v2 v3 v4))) v7 v8 end))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.first_in_holed_interval_works	100	0.351832	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 v3 v4 : @R) (v5 : enumeration (@R) v0 v1) (v6 : (v2 < v3)%R) => let v7 : {v7 : @nat | in_holed_interval v2 v3 v4 v0 v7 /\ (forall (v8 : @nat) (v9 : v8 < v7), ~ in_holed_interval v2 v3 v4 v0 v8)} := first_in_holed_interval v0 v1 v2 v3 v4 v5 v6 in match v7 as v8 in (sig _) return match v8 as v9 in (sig _) return Prop with | exist _ v9 v10 => (fun (v9 : @nat) (v10 : in_holed_interval v2 v3 v4 v0 v9 /\ (forall (v10 : @nat) (v11 : v10 < v9), ~ in_holed_interval v2 v3 v4 v0 v10)) => forall (v11 : @R) (v12 : (v2 < v11)%R) (v13 : (v11 < v3)%R) (v14 : v11 <> v4) (v15 : v11 <> v0 v9), v9 < v1 v11) v9 v10 end with | exist _ v8 v9 => (fun (v8 : @nat) (v9 : in_holed_interval v2 v3 v4 v0 v8 /\ (forall (v9 : @nat) (v10 : v9 < v8), ~ in_holed_interval v2 v3 v4 v0 v9)) (v10 : @R) (v11 : (v2 < v10)%R) (v12 : (v10 < v3)%R) (v13 : v10 <> v4) (v14 : v10 <> v0 v8) => let v15 : @comparison := v8 ?= v1 v10 in let v16 : (v8 ?= v1 v10) = v15 := eq_refl in match v15 as v17 in comparison return (forall v18 : (v8 ?= v1 v10) = v17, v8 < v1 v10) with | Eq => fun v17 : (v8 ?= v1 v10) = @Eq => False_ind (v8 < v1 v10) (let v18 : forall (v18 v19 : @nat) (v20 : (v18 ?= v19) = @Eq), v18 = v19 := fun v18 v19 : @nat => match Nat.compare_eq_iff v18 v19 as v20 in (_ /\ _) return (forall v21 : (v18 ?= v19) = @Eq, v18 = v19) with | conj v20 v21 => (fun (v20 : forall v20 : (v18 ?= v19) = @Eq, v18 = v19) (v21 : forall v21 : v18 = v19, (v18 ?= v19) = @Eq) => v20) v20 v21 end in let v19 : v8 = v1 v10 := v18 v8 (v1 v10) v17 in let v20 : v10 <> v0 (v1 v10) := eq_ind v8 (fun v20 : @nat => v10 <> v0 v20) v14 (v1 v10) v19 in match v5 as v21 in (_ /\ _) return (@False) with | conj v21 v22 => (fun (v21 : forall v21 : @R, v0 (v1 v21) = v21) (v22 : forall v22 : @nat, v1 (v0 v22) = v22) => let v23 : v10 <> v10 := eq_ind (v0 (v1 v10)) (fun v23 : @R => v10 <> v23) v20 v10 (v21 v10) in v23 eq_refl) v21 v22 end) | Lt => fun v17 : (v8 ?= v1 v10) = @Lt => let v18 : forall (v18 v19 : @nat) (v20 : (v18 ?= v19) = @Lt), v18 < v19 := fun v18 v19 : @nat => match Nat.compare_lt_iff v18 v19 as v20 in (_ /\ _) return (forall v21 : (v18 ?= v19) = @Lt, v18 < v19) with | conj v20 v21 => (fun (v20 : forall v20 : (v18 ?= v19) = @Lt, v18 < v19) (v21 : forall v21 : v18 < v19, (v18 ?= v19) = @Lt) => v20) v20 v21 end in let v19 : v8 < v1 v10 := v18 v8 (v1 v10) v17 in v19 | Gt => fun v17 : (v8 ?= v1 v10) = @Gt => False_ind (v8 < v1 v10) (let v18 : forall (v18 v19 : @nat) (v20 : (v18 ?= v19) = @Gt), v19 < v18 := fun v18 v19 : @nat => match Nat.compare_gt_iff v18 v19 as v20 in (_ /\ _) return (forall v21 : (v18 ?= v19) = @Gt, v19 < v18) with | conj v20 v21 => (fun (v20 : forall v20 : (v18 ?= v19) = @Gt, v19 < v18) (v21 : forall v21 : v19 < v18, (v18 ?= v19) = @Gt) => v20) v20 v21 end in let v19 : v1 v10 < v8 := v18 v8 (v1 v10) v17 in match v9 as v20 in (_ /\ _) return (@False) with | conj v20 v21 => (fun (v20 : in_holed_interval v2 v3 v4 v0 v8) (v21 : forall (v21 : @nat) (v22 : v21 < v8), ~ in_holed_interval v2 v3 v4 v0 v21) => let v22 : ~ in_holed_interval v2 v3 v4 v0 (v1 v10) := v21 (v1 v10) v19 in let v23 : in_holed_interval v2 v3 v4 v0 (v1 v10) := match v5 as v23 in (_ /\ _) return (in_holed_interval v2 v3 v4 v0 (v1 v10)) with | conj v23 v24 => (fun (v23 : forall v23 : @R, v0 (v1 v23) = v23) (v24 : forall v24 : @nat, v1 (v0 v24) = v24) => conj (eq_ind_r (fun v25 : @R => (v2 < v25)%R) v11 (v23 v10)) (eq_ind_r (fun v25 : @R => (v25 < v3)%R /\ v25 <> v4) (conj v12 v13) (v23 v10))) v23 v24 end in False_ind (@False) (v22 v23)) v20 v21 end) end v16) v8 v9 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.split_couple_eq	100	0.147419	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @R) (v4 : (v0, v1) = (v2, v3)) => let v5 : v0 = v2 := f_equal (fun v5 : @R * @R => match v5 as v6 in (_ * _)%type return (@R) with | (v6, v7) => (fun v6 v7 : @R => v6) v6 v7 end) v4 in (let v6 : v1 = v3 := f_equal (fun v6 : @R * @R => match v6 as v7 in (_ * _)%type return (@R) with | (v7, v8) => (fun v7 v8 : @R => v8) v7 v8 end) v4 in (fun (v7 : v1 = v3) (v8 : v0 = v2) => conj (eq_ind_r (fun v9 : @R => forall v10 : (v0, v9) = (v2, v3), v0 = v2) (fun v9 : (v0, v3) = (v2, v3) => eq_ind_r (fun v10 : @R => forall v11 : (v10, v3) = (v2, v3), v10 = v2) (fun v10 : (v2, v3) = (v2, v3) => eq_refl) v8 v9) v7 v4) (eq_ind_r (fun v9 : @R => forall v10 : (v0, v9) = (v2, v3), v9 = v3) (fun v9 : (v0, v3) = (v2, v3) => eq_ind_r (fun v10 : @R => forall v11 : (v10, v3) = (v2, v3), v3 = v3) (fun v10 : (v2, v3) = (v2, v3) => eq_refl) v8 v9) v7 v4)) v6) v5)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.first_two_in_interval_works	100	1.181921	2	2
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.tearing_sequences	100	0.520879	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 : enumeration (@R) v0 v1) => nat_rec (fun v3 : @nat => {v4 : @R * @R | (fst v4 < snd v4)%R}) (exist (fun v3 : @R * @R => (fst v3 < snd v3)%R) (INR 0, INR 1) (@Rlt_0_1 : (fst (INR 0, INR 1) < snd (INR 0, INR 1))%R)) (fun (v3 : @nat) (v4 : {v4 : @R * @R | (fst v4 < snd v4)%R}) => match v4 as v5 in (sig _) return {v6 : @R * @R | (fst v6 < snd v6)%R} with | exist _ v5 v6 => (fun (v5 : @R * @R) (v6 : (fst v5 < snd v5)%R) => match v5 as v7 in (_ * _)%type return (forall v8 : (fst v7 < snd v7)%R, {v9 : @R * @R | (fst v9 < snd v9)%R}) with | (v7, v8) => (fun (v7 v8 : @R) (v9 : (fst (v7, v8) < snd (v7, v8))%R) => exist (fun v10 : @R * @R => (fst v10 < snd v10)%R) (first_two_in_interval v0 v1 v7 v8 v2 v9) (let v10 : match first_two_in_interval v0 v1 v7 v8 v2 v9 as v10 in (_ * _) return Prop with | (v10, v11) => (fun v10 v11 : @R => (v7 < v10)%R /\ (v10 < v8)%R /\ (v7 < v11)%R /\ (v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v12 : @R) (v13 : (v7 < v12)%R) (v14 : (v12 < v8)%R) (v15 : v12 <> v10) (v16 : v12 <> v11), v1 v10 < v1 v12)) v10 v11 end := first_two_in_interval_works v0 v1 v7 v8 v2 v9 in let v11 : @R * @R := first_two_in_interval v0 v1 v7 v8 v2 v9 in match v11 as v12 in (_ * _)%type return (forall v13 : match v12 as v13 in (_ * _) return Prop with | (v13, v14) => (fun v13 v14 : @R => (v7 < v13)%R /\ (v13 < v8)%R /\ (v7 < v14)%R /\ (v14 < v8)%R /\ (v13 < v14)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v13) (v19 : v15 <> v14), v1 v13 < v1 v15)) v13 v14 end, (fst v12 < snd v12)%R) with | (v12, v13) => (fun (v12 v13 : @R) (v14 : (v7 < v12)%R /\ (v12 < v8)%R /\ (v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v12) (v18 : v14 <> v13), v1 v12 < v1 v14)) => let v15 : (v12 < v8)%R /\ (v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v12) (v19 : v15 <> v13), v1 v12 < v1 v15) := match v14 as v15 in (_ /\ _) return ((v12 < v8)%R /\ (v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v7 < v16)%R) (v18 : (v16 < v8)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) with | conj v15 v16 => (fun (v15 : (v7 < v12)%R) (v16 : (v12 < v8)%R /\ (v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v7 < v16)%R) (v18 : (v16 < v8)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) => v16) v15 v16 end in let v16 : (v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v7 < v16)%R) (v18 : (v16 < v8)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16) := match v15 as v16 in (_ /\ _) return ((v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v17 : @R) (v18 : (v7 < v17)%R) (v19 : (v17 < v8)%R) (v20 : v17 <> v12) (v21 : v17 <> v13), v1 v12 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v12 < v8)%R) (v17 : (v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v17 : @R) (v18 : (v7 < v17)%R) (v19 : (v17 < v8)%R) (v20 : v17 <> v12) (v21 : v17 <> v13), v1 v12 < v1 v17)) => v17) v16 v17 end in let v17 : (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v17 : @R) (v18 : (v7 < v17)%R) (v19 : (v17 < v8)%R) (v20 : v17 <> v12) (v21 : v17 <> v13), v1 v12 < v1 v17) := match v16 as v17 in (_ /\ _) return ((v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v18 : @R) (v19 : (v7 < v18)%R) (v20 : (v18 < v8)%R) (v21 : v18 <> v12) (v22 : v18 <> v13), v1 v12 < v1 v18)) with | conj v17 v18 => (fun (v17 : (v7 < v13)%R) (v18 : (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v18 : @R) (v19 : (v7 < v18)%R) (v20 : (v18 < v8)%R) (v21 : v18 <> v12) (v22 : v18 <> v13), v1 v12 < v1 v18)) => v18) v17 v18 end in let v18 : (v12 < v13)%R /\ (forall (v18 : @R) (v19 : (v7 < v18)%R) (v20 : (v18 < v8)%R) (v21 : v18 <> v12) (v22 : v18 <> v13), v1 v12 < v1 v18) := match v17 as v18 in (_ /\ _) return ((v12 < v13)%R /\ (forall (v19 : @R) (v20 : (v7 < v19)%R) (v21 : (v19 < v8)%R) (v22 : v19 <> v12) (v23 : v19 <> v13), v1 v12 < v1 v19)) with | conj v18 v19 => (fun (v18 : (v13 < v8)%R) (v19 : (v12 < v13)%R /\ (forall (v19 : @R) (v20 : (v7 < v19)%R) (v21 : (v19 < v8)%R) (v22 : v19 <> v12) (v23 : v19 <> v13), v1 v12 < v1 v19)) => v19) v18 v19 end in let v19 : (v12 < v13)%R := match v18 as v19 in (_ /\ _) return (v12 < v13)%R with | conj v19 v20 => (fun (v19 : (v12 < v13)%R) (v20 : forall (v20 : @R) (v21 : (v7 < v20)%R) (v22 : (v20 < v8)%R) (v23 : v20 <> v12) (v24 : v20 <> v13), v1 v12 < v1 v20) => v19) v19 v20 end in v19) v12 v13 end v10)) v7 v8 end v6) v5 v6 end))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.tearing_sequences_projsig	100	0.734574	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 : enumeration (@R) v0 v1) (v3 : @nat) => (let v4 : {v4 : @R * @R | (fst v4 < snd v4)%R} := tearing_sequences v0 v1 v2 v3 in match v4 as v5 in (sig _) return match v5 as v6 in (sig _) return Prop with | exist _ v6 v7 => (fun (v6 : @R * @R) (v7 : (fst v6 < snd v6)%R) => proj1_sig match v5 as v8 in (sig _) return {v9 : @R * @R | (fst v9 < snd v9)%R} with | exist _ v8 v9 => (fun (v8 : @R * @R) (v9 : (fst v8 < snd v8)%R) => match v8 as v10 in (_ * _)%type return (forall v11 : (fst v10 < snd v10)%R, {v12 : @R * @R | (fst v12 < snd v12)%R}) with | (v10, v11) => (fun (v10 v11 : @R) (v12 : (v10 < v11)%R) => exist (fun v13 : @R * @R => (fst v13 < snd v13)%R) (first_two_in_interval v0 v1 v10 v11 v2 v12) (match first_two_in_interval v0 v1 v10 v11 v2 v12 as v13 in (_ * _)%type return (forall v14 : match v13 as v14 in (_ * _) return Prop with | (v14, v15) => (fun v14 v15 : @R => (v10 < v14)%R /\ (v14 < v11)%R /\ (v10 < v15)%R /\ (v15 < v11)%R /\ (v14 < v15)%R /\ (forall (v16 : @R) (v17 : (v10 < v16)%R) (v18 : (v16 < v11)%R) (v19 : v16 <> v14) (v20 : v16 <> v15), v1 v14 < v1 v16)) v14 v15 end, (fst v13 < snd v13)%R) with | (v13, v14) => (fun (v13 v14 : @R) (v15 : (v10 < v13)%R /\ (v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v15 : @R) (v16 : (v10 < v15)%R) (v17 : (v15 < v11)%R) (v18 : v15 <> v13) (v19 : v15 <> v14), v1 v13 < v1 v15)) => match match match match match v15 as v16 in (_ /\ _) return ((v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v10 < v13)%R) (v17 : (v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v13 < v11)%R) (v17 : (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v10 < v14)%R) (v17 : (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v14 < v11)%R) (v17 : (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return (v13 < v14)%R with | conj v16 v17 => (fun (v16 : (v13 < v14)%R) (v17 : forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17) => v16) v16 v17 end) v13 v14 end (first_two_in_interval_works v0 v1 v10 v11 v2 v12))) v10 v11 end v9) v8 v9 end = first_two_in_interval v0 v1 (fst v6) (snd v6) v2 v7) v6 v7 end with | exist _ v5 v6 => (fun (v5 : @R * @R) (v6 : (fst v5 < snd v5)%R) => match v5 as v7 in (_ * _)%type return (forall v8 : (fst v7 < snd v7)%R, proj1_sig (match v7 as v9 in (_ * _)%type return (forall v10 : (fst v9 < snd v9)%R, {v11 : @R * @R | (fst v11 < snd v11)%R}) with | (v9, v10) => (fun (v9 v10 : @R) (v11 : (v9 < v10)%R) => exist (fun v12 : @R * @R => (fst v12 < snd v12)%R) (first_two_in_interval v0 v1 v9 v10 v2 v11) (match first_two_in_interval v0 v1 v9 v10 v2 v11 as v12 in (_ * _)%type return (forall v13 : match v12 as v13 in (_ * _) return Prop with | (v13, v14) => (fun v13 v14 : @R => (v9 < v13)%R /\ (v13 < v10)%R /\ (v9 < v14)%R /\ (v14 < v10)%R /\ (v13 < v14)%R /\ (forall (v15 : @R) (v16 : (v9 < v15)%R) (v17 : (v15 < v10)%R) (v18 : v15 <> v13) (v19 : v15 <> v14), v1 v13 < v1 v15)) v13 v14 end, (fst v12 < snd v12)%R) with | (v12, v13) => (fun (v12 v13 : @R) (v14 : (v9 < v12)%R /\ (v12 < v10)%R /\ (v9 < v13)%R /\ (v13 < v10)%R /\ (v12 < v13)%R /\ (forall (v14 : @R) (v15 : (v9 < v14)%R) (v16 : (v14 < v10)%R) (v17 : v14 <> v12) (v18 : v14 <> v13), v1 v12 < v1 v14)) => match match match match match v14 as v15 in (_ /\ _) return ((v12 < v10)%R /\ (v9 < v13)%R /\ (v13 < v10)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) with | conj v15 v16 => (fun (v15 : (v9 < v12)%R) (v16 : (v12 < v10)%R /\ (v9 < v13)%R /\ (v13 < v10)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) => v16) v15 v16 end as v15 in (_ /\ _) return ((v9 < v13)%R /\ (v13 < v10)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) with | conj v15 v16 => (fun (v15 : (v12 < v10)%R) (v16 : (v9 < v13)%R /\ (v13 < v10)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) => v16) v15 v16 end as v15 in (_ /\ _) return ((v13 < v10)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) with | conj v15 v16 => (fun (v15 : (v9 < v13)%R) (v16 : (v13 < v10)%R /\ (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) => v16) v15 v16 end as v15 in (_ /\ _) return ((v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) with | conj v15 v16 => (fun (v15 : (v13 < v10)%R) (v16 : (v12 < v13)%R /\ (forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16)) => v16) v15 v16 end as v15 in (_ /\ _) return (v12 < v13)%R with | conj v15 v16 => (fun (v15 : (v12 < v13)%R) (v16 : forall (v16 : @R) (v17 : (v9 < v16)%R) (v18 : (v16 < v10)%R) (v19 : v16 <> v12) (v20 : v16 <> v13), v1 v12 < v1 v16) => v15) v15 v16 end) v12 v13 end (first_two_in_interval_works v0 v1 v9 v10 v2 v11))) v9 v10 end v8) = first_two_in_interval v0 v1 (fst v7) (snd v7) v2 v8) with | (v7, v8) => (fun (v7 v8 : @R) (v9 : (fst (v7, v8) < snd (v7, v8))%R) => eq_refl : proj1_sig (exist (fun v10 : @R * @R => (fst v10 < snd v10)%R) (first_two_in_interval v0 v1 v7 v8 v2 v9) (match first_two_in_interval v0 v1 v7 v8 v2 v9 as v10 in (_ * _)%type return (forall v11 : match v10 as v11 in (_ * _) return Prop with | (v11, v12) => (fun v11 v12 : @R => (v7 < v11)%R /\ (v11 < v8)%R /\ (v7 < v12)%R /\ (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v13 : @R) (v14 : (v7 < v13)%R) (v15 : (v13 < v8)%R) (v16 : v13 <> v11) (v17 : v13 <> v12), v1 v11 < v1 v13)) v11 v12 end, (fst v10 < snd v10)%R) with | (v10, v11) => (fun (v10 v11 : @R) (v12 : (v7 < v10)%R /\ (v10 < v8)%R /\ (v7 < v11)%R /\ (v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v12 : @R) (v13 : (v7 < v12)%R) (v14 : (v12 < v8)%R) (v15 : v12 <> v10) (v16 : v12 <> v11), v1 v10 < v1 v12)) => match match match match match v12 as v13 in (_ /\ _) return ((v10 < v8)%R /\ (v7 < v11)%R /\ (v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) with | conj v13 v14 => (fun (v13 : (v7 < v10)%R) (v14 : (v10 < v8)%R /\ (v7 < v11)%R /\ (v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) => v14) v13 v14 end as v13 in (_ /\ _) return ((v7 < v11)%R /\ (v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) with | conj v13 v14 => (fun (v13 : (v10 < v8)%R) (v14 : (v7 < v11)%R /\ (v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) => v14) v13 v14 end as v13 in (_ /\ _) return ((v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) with | conj v13 v14 => (fun (v13 : (v7 < v11)%R) (v14 : (v11 < v8)%R /\ (v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) => v14) v13 v14 end as v13 in (_ /\ _) return ((v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) with | conj v13 v14 => (fun (v13 : (v11 < v8)%R) (v14 : (v10 < v11)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14)) => v14) v13 v14 end as v13 in (_ /\ _) return (v10 < v11)%R with | conj v13 v14 => (fun (v13 : (v10 < v11)%R) (v14 : forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v10) (v18 : v14 <> v11), v1 v10 < v1 v14) => v13) v13 v14 end) v10 v11 end (first_two_in_interval_works v0 v1 v7 v8 v2 v9))) = first_two_in_interval v0 v1 (fst (v7, v8)) (snd (v7, v8)) v2 v9) v7 v8 end v6) v5 v6 end) : match tearing_sequences v0 v1 v2 v3 as v4 in (sig _) return Prop with | exist _ v4 v5 => (fun (v4 : @R * @R) (v5 : (fst v4 < snd v4)%R) => proj1_sig (tearing_sequences v0 v1 v2 (S v3)) = first_two_in_interval v0 v1 (fst v4) (snd v4) v2 v5) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.tearing_sequences_inc_dec	100	1.507557	2	2
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.split_lt_succ	100	0.242056	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall (v3 : @nat) (v4 : v3 < S v2), v3 < v2 \/ v3 = v2) (fun (v2 : @nat) (v3 : v2 < 1) => match v2 as v4 in nat return (forall v5 : v4 < 1, v4 < 0 \/ v4 = 0) with | 0 => fun v4 : 0 < 1 => or_intror eq_refl | S v4 => (fun (v4 : @nat) (v5 : S v4 < 1) => False_ind (S v4 < 0 \/ S v4 = 0) (let v6 : forall v6 : 1 = 1, @False := match v5 as v7 in (_ <= v6) return (forall v8 : v6 = 1, @False) with | le_n _ => fun v6 : S (S v4) = 1 => (fun v7 : S (S v4) = 1 => let v8 : @False := eq_ind (S (S v4)) (fun v8 : @nat => match v8 as v9 in nat return Prop with | 0 => @False | S v9 => (fun v9 : @nat => match v9 as v10 in nat return Prop with | 0 => @False | S v10 => (fun v10 : @nat => @True) v10 end) v9 end) (@I) 1 v7 in False_ind (@False) v8) v6 | le_S _ v6 v7 => (fun (v6 : @nat) (v7 : S (S v4) <= v6) (v8 : S v6 = 1) => (fun v9 : S v6 = 1 => let v10 : v6 = 0 := f_equal (fun v10 : @nat => match v10 as v11 in nat return (@nat) with | 0 => v6 | S v11 => (fun v11 : @nat => v11) v11 end) v9 in (fun v11 : v6 = 0 => let v12 : v6 = 0 := v11 in eq_ind_r (fun v13 : @nat => forall v14 : S (S v4) <= v13, @False) (fun v13 : S (S v4) <= 0 => let v14 : forall v14 : 0 = 0, @False := match v13 as v15 in (_ <= v14) return (forall v16 : v14 = 0, @False) with | le_n _ => fun v14 : S (S v4) = 0 => (fun v15 : S (S v4) = 0 => let v16 : @False := eq_ind (S (S v4)) (fun v16 : @nat => match v16 as v17 in nat return Prop with | 0 => @False | S v17 => (fun v17 : @nat => @True) v17 end) (@I) 0 v15 in False_ind (@False) v16) v14 | le_S _ v14 v15 => (fun (v14 : @nat) (v15 : S (S v4) <= v14) (v16 : S v14 = 0) => (fun v17 : S v14 = 0 => let v18 : @False := eq_ind (S v14) (fun v18 : @nat => match v18 as v19 in nat return Prop with | 0 => @False | S v19 => (fun v19 : @nat => @True) v19 end) (@I) 0 v17 in False_ind (forall v19 : S (S v4) <= v14, @False) v18) v16 v15) v14 v15 end in v14 eq_refl) v12) v10) v8 v7) v6 v7 end in v6 eq_refl)) v4 end v3) (fun (v2 : @nat) (v3 : forall (v3 : @nat) (v4 : v3 < S v2), v3 < v2 \/ v3 = v2) (v4 : @nat) (v5 : v4 < S (S v2)) => match v4 as v6 in nat return (forall v7 : v6 < S (S v2), v6 < S v2 \/ v6 = S v2) with | 0 => fun v6 : 0 < S (S v2) => or_introl (le_n_S 0 v2 (Nat.le_0_l v2) : 0 < S v2) | S v6 => (fun (v6 : @nat) (v7 : S v6 < S (S v2)) => let v8 : v6 < Init.Nat.pred (S (S v2)) := lt_pred v6 (S (S v2)) v7 in let v9 : v6 < v2 \/ v6 = v2 := v3 v6 v8 in match v9 as v10 in (_ \/ _) return (S v6 < S v2 \/ S v6 = S v2) with | or_introl v10 => (fun v10 : v6 < v2 => or_introl (lt_n_S v6 v2 v10)) v10 | or_intror v10 => (fun v10 : v6 = v2 => eq_ind_r (fun v11 : @nat => forall v12 : v11 < S v2, S v11 < S v2 \/ S v11 = S v2) (fun v11 : v2 < S v2 => or_intror eq_refl) v10 v8) v10 end) v6 end v5) v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.increase_seq_transit	100	0.119850	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @nat, (v0 v1 < v0 (S v1))%R) (v2 v3 : @nat) (v4 : v2 < v3) => nat_ind (fun v5 : @nat => forall v6 : v2 < v5, (v0 v2 < v0 v5)%R) (fun v5 : v2 < 0 => let v6 : forall v6 : 0 = 0, (v0 v2 < v0 0%nat)%R := match v5 as v7 in (_ <= v6) return (forall v8 : v6 = 0, (v0 v2 < v0 0%nat)%R) with | le_n _ => fun v6 : S v2 = 0 => (fun v7 : S v2 = 0 => let v8 : @False := eq_ind (S v2) (fun v8 : @nat => match v8 as v9 in nat return Prop with | 0 => @False | S v9 => (fun v9 : @nat => @True) v9 end) (@I) 0 v7 in False_ind (v0 v2 < v0 0%nat)%R v8) v6 | le_S _ v6 v7 => (fun (v6 : @nat) (v7 : S v2 <= v6) (v8 : S v6 = 0) => (fun v9 : S v6 = 0 => let v10 : @False := eq_ind (S v6) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v9 in False_ind (forall v11 : S v2 <= v6, (v0 v2 < v0 0%nat)%R) v10) v8 v7) v6 v7 end in v6 eq_refl) (fun (v5 : @nat) (v6 : forall v6 : v2 < v5, (v0 v2 < v0 v5)%R) (v7 : v2 < S v5) => let v8 : v2 < v5 \/ v2 = v5 := split_lt_succ v2 v5 v7 in match v8 as v9 in (_ \/ _) return (v0 v2 < v0 (S v5))%R with | or_introl v9 => (fun v9 : v2 < v5 => Rlt_trans (v0 v2) (v0 v5) (v0 (S v5)) (v6 v9) (v1 v5)) v9 | or_intror v9 => (fun v9 : v2 = v5 => eq_ind_r (fun v10 : @nat => forall (v11 : v10 < S v5) (v12 : forall v12 : v10 < v5, (v0 v10 < v0 v5)%R), (v0 v10 < v0 (S v5))%R) (fun (v10 : v5 < S v5) (v11 : forall v11 : v5 < v5, (v0 v5 < v0 v5)%R) => v1 v5) v9 v7 v6) v9 end) v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.decrease_seq_transit	100	0.109758	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @nat, (v0 (S v1) < v0 v1)%R) (v2 v3 : @nat) (v4 : v2 < v3) => nat_ind (fun v5 : @nat => forall v6 : v2 < v5, (v0 v5 < v0 v2)%R) (fun v5 : v2 < 0 => let v6 : forall v6 : 0 = 0, (v0 0%nat < v0 v2)%R := match v5 as v7 in (_ <= v6) return (forall v8 : v6 = 0, (v0 0%nat < v0 v2)%R) with | le_n _ => fun v6 : S v2 = 0 => (fun v7 : S v2 = 0 => let v8 : @False := eq_ind (S v2) (fun v8 : @nat => match v8 as v9 in nat return Prop with | 0 => @False | S v9 => (fun v9 : @nat => @True) v9 end) (@I) 0 v7 in False_ind (v0 0%nat < v0 v2)%R v8) v6 | le_S _ v6 v7 => (fun (v6 : @nat) (v7 : S v2 <= v6) (v8 : S v6 = 0) => (fun v9 : S v6 = 0 => let v10 : @False := eq_ind (S v6) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v9 in False_ind (forall v11 : S v2 <= v6, (v0 0%nat < v0 v2)%R) v10) v8 v7) v6 v7 end in v6 eq_refl) (fun (v5 : @nat) (v6 : forall v6 : v2 < v5, (v0 v5 < v0 v2)%R) (v7 : v2 < S v5) => let v8 : v2 < v5 \/ v2 = v5 := split_lt_succ v2 v5 v7 in match v8 as v9 in (_ \/ _) return (v0 (S v5) < v0 v2)%R with | or_introl v9 => (fun v9 : v2 < v5 => Rlt_trans (v0 (S v5)) (v0 v5) (v0 v2) (v1 v5) (v6 v9)) v9 | or_intror v9 => (fun v9 : v2 = v5 => eq_ind_r (fun v10 : @nat => forall (v11 : v10 < S v5) (v12 : forall v12 : v10 < v5, (v0 v5 < v0 v10)%R), (v0 (S v5) < v0 v10)%R) (fun (v10 : v5 < S v5) (v11 : forall v11 : v5 < v5, (v0 v5 < v0 v5)%R) => v1 v5) v9 v7 v6) v9 end) v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.tearing_sequences_ordered_forall	100	1.663698	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 : enumeration (@R) v0 v1) (v3 v4 : @nat) => let v5 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v3) in let v6 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v4) in let v7 : {v7 : @R * @R | (fst v7 < snd v7)%R} := tearing_sequences v0 v1 v2 v3 in let v8 : tearing_sequences v0 v1 v2 v3 = v7 := eq_refl in match v7 as v9 in (sig _) return (forall v10 : tearing_sequences v0 v1 v2 v3 = v9, let v11 : @R * @R := proj1_sig v9 in (fst v11 < snd v6)%R) with | exist _ v9 v10 => (fun (v9 : @R * @R) (v10 : (fst v9 < snd v9)%R) (v11 : tearing_sequences v0 v1 v2 v3 = exist (fun v11 : @R * @R => (fst v11 < snd v11)%R) v9 v10) => let v12 : @R * @R := proj1_sig (exist (fun v12 : @R * @R => (fst v12 < snd v12)%R) v9 v10) in let v13 : {v13 : @R * @R | (fst v13 < snd v13)%R} := tearing_sequences v0 v1 v2 v4 in let v14 : tearing_sequences v0 v1 v2 v4 = v13 := eq_refl in match v13 as v15 in (sig _) return (forall v16 : tearing_sequences v0 v1 v2 v4 = v15, let v17 : @R * @R := proj1_sig v15 in (fst v12 < snd v17)%R) with | exist _ v15 v16 => (fun (v15 : @R * @R) (v16 : (fst v15 < snd v15)%R) (v17 : tearing_sequences v0 v1 v2 v4 = exist (fun v17 : @R * @R => (fst v17 < snd v17)%R) v15 v16) => let v18 : @R * @R := proj1_sig (exist (fun v18 : @R * @R => (fst v18 < snd v18)%R) v15 v16) in let v19 : @comparison := v3 ?= v4 in let v20 : (v3 ?= v4) = v19 := eq_refl in match v19 as v21 in comparison return (forall v22 : (v3 ?= v4) = v21, (fst v12 < snd v18)%R) with | Eq => fun v21 : (v3 ?= v4) = @Eq => let v22 : forall (v22 v23 : @nat) (v24 : (v22 ?= v23) = @Eq), v22 = v23 := fun v22 v23 : @nat => match Nat.compare_eq_iff v22 v23 as v24 in (_ /\ _) return (forall v25 : (v22 ?= v23) = @Eq, v22 = v23) with | conj v24 v25 => (fun (v24 : forall v24 : (v22 ?= v23) = @Eq, v22 = v23) (v25 : forall v25 : v22 = v23, (v22 ?= v23) = @Eq) => v24) v24 v25 end in let v23 : v3 = v4 := v22 v3 v4 v21 in eq_ind_r (fun v24 : @nat => forall v25 : tearing_sequences v0 v1 v2 v24 = exist (fun v25 : @R * @R => (fst v25 < snd v25)%R) v9 v10, (fst v12 < snd v18)%R) (fun v24 : tearing_sequences v0 v1 v2 v4 = exist (fun v24 : @R * @R => (fst v24 < snd v24)%R) v9 v10 => let v25 : exist (fun v25 : @R * @R => (fst v25 < snd v25)%R) v15 v16 = exist (fun v25 : @R * @R => (fst v25 < snd v25)%R) v9 v10 := eq_ind (tearing_sequences v0 v1 v2 v4) (fun v25 : {v25 : @R * @R | (fst v25 < snd v25)%R} => v25 = exist (fun v26 : @R * @R => (fst v26 < snd v26)%R) v9 v10) v24 (exist (fun v25 : @R * @R => (fst v25 < snd v25)%R) v15 v16) v17 in let v26 : forall v26 : exist (fun v26 : @R * @R => (fst v26 < snd v26)%R) v9 v10 = exist (fun v26 : @R * @R => (fst v26 < snd v26)%R) v9 v10, (fst v12 < snd v18)%R := match v25 as v27 in (_ = v26) return (forall v28 : v26 = exist (fun v28 : @R * @R => (fst v28 < snd v28)%R) v9 v10, (fst v12 < snd v18)%R) with | eq_refl => fun v26 : exist (fun v26 : @R * @R => (fst v26 < snd v26)%R) v15 v16 = exist (fun v26 : @R * @R => (fst v26 < snd v26)%R) v9 v10 => (fun v27 : exist (fun v27 : @R * @R => (fst v27 < snd v27)%R) v15 v16 = exist (fun v27 : @R * @R => (fst v27 < snd v27)%R) v9 v10 => let v28 : v15 = v9 := f_equal (fun v28 : {v28 : @R * @R | (fst v28 < snd v28)%R} => match v28 as v29 in (sig _) return (@R * @R) with | exist _ v29 v30 => (fun (v29 : @R * @R) (v30 : (fst v29 < snd v29)%R) => v29) v29 v30 end) v27 in (fun v29 : v15 = v9 => let v30 : v15 = v9 := v29 in eq_ind_r (fun v31 : @R * @R => (fst v12 < snd v18)%R) (eq_ind_r (fun v31 : @R * @R => forall (v32 : (fst v31 < snd v31)%R) (v33 : exist (fun v33 : @R * @R => (fst v33 < snd v33)%R) v31 v32 = exist (fun v33 : @R * @R => (fst v33 < snd v33)%R) v9 v10) (v34 : tearing_sequences v0 v1 v2 v4 = exist (fun v34 : @R * @R => (fst v34 < snd v34)%R) v31 v32), let v35 : @R * @R := v31 in (fst v12 < snd v35)%R) (fun (v31 : (fst v9 < snd v9)%R) (v32 : exist (fun v32 : @R * @R => (fst v32 < snd v32)%R) v9 v31 = exist (fun v32 : @R * @R => (fst v32 < snd v32)%R) v9 v10) (v33 : tearing_sequences v0 v1 v2 v4 = exist (fun v33 : @R * @R => (fst v33 < snd v33)%R) v9 v31) => let v34 : @R * @R := v9 in v31) v29 v16 v25 v17) v30) v28) v26 end in v26 eq_refl) v23 v11 | Lt => fun v21 : (v3 ?= v4) = @Lt => let v22 : forall (v22 v23 : @nat) (v24 : (v22 ?= v23) = @Lt), v22 < v23 := fun v22 v23 : @nat => match Nat.compare_lt_iff v22 v23 as v24 in (_ /\ _) return (forall v25 : (v22 ?= v23) = @Lt, v22 < v23) with | conj v24 v25 => (fun (v24 : forall v24 : (v22 ?= v23) = @Lt, v22 < v23) (v25 : forall v25 : v22 < v23, (v22 ?= v23) = @Lt) => v24) v24 v25 end in let v23 : v3 < v4 := v22 v3 v4 v21 in Rlt_trans (fst v12) (fst v18) (snd v18) (let v24 : forall v24 : @nat, @R := fun v24 : @nat => fst (proj1_sig (tearing_sequences v0 v1 v2 v24)) in let v25 : v24 = (fun v25 : @nat => fst (proj1_sig (tearing_sequences v0 v1 v2 v25))) := eq_refl in let v26 : forall (v26 : forall v26 : @nat, (v24 v26 < v24 (S v26))%R) (v27 v28 : @nat) (v29 : v27 < v28), (v24 v27 < v24 v28)%R := increase_seq_transit v24 in let v27 : forall v27 : @nat, (v24 v27 < v24 (S v27))%R := fun v27 : @nat => eq_ind_r (fun v28 : forall v28 : @nat, @R => (v28 v27 < v28 (S v27))%R) (let v28 : let v28 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v27) in let v29 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 (S v27)) in (fst v28 < fst v29)%R /\ (snd v29 < snd v28)%R := tearing_sequences_inc_dec v0 v1 v2 v27 in let v29 : {v29 : @R * @R | (fst v29 < snd v29)%R} := tearing_sequences v0 v1 v2 (S v27) in match v29 as v30 in (sig _) return (forall v31 : let v31 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v27) in let v32 : @R * @R := proj1_sig v30 in (fst v31 < fst v32)%R /\ (snd v32 < snd v31)%R, (fst (proj1_sig (tearing_sequences v0 v1 v2 v27)) < fst (proj1_sig v30))%R) with | exist _ v30 v31 => (fun (v30 : @R * @R) (v31 : (fst v30 < snd v30)%R) (v32 : let v32 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v27) in let v33 : @R * @R := proj1_sig (exist (fun v33 : @R * @R => (fst v33 < snd v33)%R) v30 v31) in (fst v32 < fst v33)%R /\ (snd v33 < snd v32)%R) => (let v33 : {v33 : @R * @R | (fst v33 < snd v33)%R} := tearing_sequences v0 v1 v2 v27 in match v33 as v34 in (sig _) return (forall v35 : let v35 : @R * @R := proj1_sig v34 in let v36 : @R * @R := proj1_sig (exist (fun v36 : @R * @R => (fst v36 < snd v36)%R) v30 v31) in (fst v35 < fst v36)%R /\ (snd v36 < snd v35)%R, (fst (proj1_sig v34) < fst v30)%R) with | exist _ v34 v35 => (fun (v34 : @R * @R) (v35 : (fst v34 < snd v34)%R) (v36 : let v36 : @R * @R := proj1_sig (exist (fun v36 : @R * @R => (fst v36 < snd v36)%R) v34 v35) in let v37 : @R * @R := proj1_sig (exist (fun v37 : @R * @R => (fst v37 < snd v37)%R) v30 v31) in (fst v36 < fst v37)%R /\ (snd v37 < snd v36)%R) => let v37 : (fst (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v34 v35)) < fst (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v30 v31)))%R := match v36 as v37 in (_ /\ _) return (fst (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v34 v35)) < fst (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v30 v31)))%R with | conj v37 v38 => (fun (v37 : (fst (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v34 v35)) < fst (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v30 v31)))%R) (v38 : (snd (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v30 v31)) < snd (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v34 v35)))%R) => v37) v37 v38 end in v37) v34 v35 end v32) : (fst (proj1_sig (tearing_sequences v0 v1 v2 v27)) < fst (proj1_sig (exist (fun v33 : @R * @R => fst v33 < snd v33) v30 v31)))%R) v30 v31 end v28) v25 in let v28 : forall (v28 v29 : @nat) (v30 : v28 < v29), (v24 v28 < v24 v29)%R := v26 v27 in let v29 : forall (v29 v30 : @nat) (v31 : v29 < v30), (fst (proj1_sig (tearing_sequences v0 v1 v2 v29)) < fst (proj1_sig (tearing_sequences v0 v1 v2 v30)))%R := eq_ind v24 (fun v29 : forall v29 : @nat, @R => forall (v30 v31 : @nat) (v32 : v30 < v31), (v29 v30 < v29 v31)%R) v28 (fun v29 : @nat => fst (proj1_sig (tearing_sequences v0 v1 v2 v29))) v25 in let v30 : (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < fst (proj1_sig (tearing_sequences v0 v1 v2 v4)))%R := v29 v3 v4 v23 in let v31 : (fst (proj1_sig (exist (fun v31 : @R * @R => fst v31 < snd v31) v9 v10)) < fst (proj1_sig (tearing_sequences v0 v1 v2 v4)))%R := eq_ind (tearing_sequences v0 v1 v2 v3) (fun v31 : {v31 : @R * @R | (fst v31 < snd v31)%R} => (fst (proj1_sig v31) < fst (proj1_sig (tearing_sequences v0 v1 v2 v4)))%R) v30 (exist (fun v31 : @R * @R => (fst v31 < snd v31)%R) v9 v10) v11 in let v32 : (fst (proj1_sig (exist (fun v32 : @R * @R => fst v32 < snd v32) v9 v10)) < fst (proj1_sig (exist (fun v32 : @R * @R => fst v32 < snd v32) v15 v16)))%R := eq_ind (tearing_sequences v0 v1 v2 v4) (fun v32 : {v32 : @R * @R | (fst v32 < snd v32)%R} => (fst (proj1_sig (exist (fun v33 : @R * @R => fst v33 < snd v33) v9 v10)) < fst (proj1_sig v32))%R) v31 (exist (fun v32 : @R * @R => (fst v32 < snd v32)%R) v15 v16) v17 in v32) v16 | Gt => fun v21 : (v3 ?= v4) = @Gt => let v22 : forall (v22 v23 : @nat) (v24 : (v22 ?= v23) = @Gt), v23 < v22 := fun v22 v23 : @nat => match Nat.compare_gt_iff v22 v23 as v24 in (_ /\ _) return (forall v25 : (v22 ?= v23) = @Gt, v23 < v22) with | conj v24 v25 => (fun (v24 : forall v24 : (v22 ?= v23) = @Gt, v23 < v22) (v25 : forall v25 : v23 < v22, (v22 ?= v23) = @Gt) => v24) v24 v25 end in let v23 : v4 < v3 := v22 v3 v4 v21 in Rlt_trans (fst v12) (snd v12) (snd v18) v10 (let v24 : forall v24 : @nat, @R := fun v24 : @nat => snd (proj1_sig (tearing_sequences v0 v1 v2 v24)) in let v25 : v24 = (fun v25 : @nat => snd (proj1_sig (tearing_sequences v0 v1 v2 v25))) := eq_refl in let v26 : forall (v26 : forall v26 : @nat, (v24 (S v26) < v24 v26)%R) (v27 v28 : @nat) (v29 : v27 < v28), (v24 v28 < v24 v27)%R := decrease_seq_transit v24 in let v27 : forall v27 : @nat, (v24 (S v27) < v24 v27)%R := fun v27 : @nat => eq_ind_r (fun v28 : forall v28 : @nat, @R => (v28 (S v27) < v28 v27)%R) (let v28 : let v28 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v27) in let v29 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 (S v27)) in (fst v28 < fst v29)%R /\ (snd v29 < snd v28)%R := tearing_sequences_inc_dec v0 v1 v2 v27 in let v29 : {v29 : @R * @R | (fst v29 < snd v29)%R} := tearing_sequences v0 v1 v2 (S v27) in match v29 as v30 in (sig _) return (forall v31 : let v31 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v27) in let v32 : @R * @R := proj1_sig v30 in (fst v31 < fst v32)%R /\ (snd v32 < snd v31)%R, (snd (proj1_sig v30) < snd (proj1_sig (tearing_sequences v0 v1 v2 v27)))%R) with | exist _ v30 v31 => (fun (v30 : @R * @R) (v31 : (fst v30 < snd v30)%R) (v32 : let v32 : @R * @R := proj1_sig (tearing_sequences v0 v1 v2 v27) in let v33 : @R * @R := proj1_sig (exist (fun v33 : @R * @R => (fst v33 < snd v33)%R) v30 v31) in (fst v32 < fst v33)%R /\ (snd v33 < snd v32)%R) => (let v33 : {v33 : @R * @R | (fst v33 < snd v33)%R} := tearing_sequences v0 v1 v2 v27 in match v33 as v34 in (sig _) return (forall v35 : let v35 : @R * @R := proj1_sig v34 in let v36 : @R * @R := proj1_sig (exist (fun v36 : @R * @R => (fst v36 < snd v36)%R) v30 v31) in (fst v35 < fst v36)%R /\ (snd v36 < snd v35)%R, (snd v30 < snd (proj1_sig v34))%R) with | exist _ v34 v35 => (fun (v34 : @R * @R) (v35 : (fst v34 < snd v34)%R) (v36 : let v36 : @R * @R := proj1_sig (exist (fun v36 : @R * @R => (fst v36 < snd v36)%R) v34 v35) in let v37 : @R * @R := proj1_sig (exist (fun v37 : @R * @R => (fst v37 < snd v37)%R) v30 v31) in (fst v36 < fst v37)%R /\ (snd v37 < snd v36)%R) => let v37 : (snd (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v30 v31)) < snd (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v34 v35)))%R := match v36 as v37 in (_ /\ _) return (snd (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v30 v31)) < snd (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v34 v35)))%R with | conj v37 v38 => (fun (v37 : (fst (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v34 v35)) < fst (proj1_sig (exist (fun v37 : @R * @R => fst v37 < snd v37) v30 v31)))%R) (v38 : (snd (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v30 v31)) < snd (proj1_sig (exist (fun v38 : @R * @R => fst v38 < snd v38) v34 v35)))%R) => v38) v37 v38 end in v37) v34 v35 end v32) : (snd (proj1_sig (exist (fun v33 : @R * @R => fst v33 < snd v33) v30 v31)) < snd (proj1_sig (tearing_sequences v0 v1 v2 v27)))%R) v30 v31 end v28) v25 in let v28 : forall (v28 v29 : @nat) (v30 : v28 < v29), (v24 v29 < v24 v28)%R := v26 v27 in let v29 : forall (v29 v30 : @nat) (v31 : v29 < v30), (snd (proj1_sig (tearing_sequences v0 v1 v2 v30)) < snd (proj1_sig (tearing_sequences v0 v1 v2 v29)))%R := eq_ind v24 (fun v29 : forall v29 : @nat, @R => forall (v30 v31 : @nat) (v32 : v30 < v31), (v29 v31 < v29 v30)%R) v28 (fun v29 : @nat => snd (proj1_sig (tearing_sequences v0 v1 v2 v29))) v25 in let v30 : (snd (proj1_sig (tearing_sequences v0 v1 v2 v3)) < snd (proj1_sig (tearing_sequences v0 v1 v2 v4)))%R := v29 v4 v3 v23 in let v31 : (snd (proj1_sig (exist (fun v31 : @R * @R => fst v31 < snd v31) v9 v10)) < snd (proj1_sig (tearing_sequences v0 v1 v2 v4)))%R := eq_ind (tearing_sequences v0 v1 v2 v3) (fun v31 : {v31 : @R * @R | (fst v31 < snd v31)%R} => (snd (proj1_sig v31) < snd (proj1_sig (tearing_sequences v0 v1 v2 v4)))%R) v30 (exist (fun v31 : @R * @R => (fst v31 < snd v31)%R) v9 v10) v11 in let v32 : (snd (proj1_sig (exist (fun v32 : @R * @R => fst v32 < snd v32) v9 v10)) < snd (proj1_sig (exist (fun v32 : @R * @R => fst v32 < snd v32) v15 v16)))%R := eq_ind (tearing_sequences v0 v1 v2 v4) (fun v32 : {v32 : @R * @R | (fst v32 < snd v32)%R} => (snd (proj1_sig (exist (fun v33 : @R * @R => fst v33 < snd v33) v9 v10)) < snd (proj1_sig v32))%R) v31 (exist (fun v32 : @R * @R => (fst v32 < snd v32)%R) v15 v16) v17 in v32) end v20) v15 v16 end v14) v9 v10 end v8)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.torn_number	100	0.108952	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 : enumeration (@R) v0 v1) => let v3 : bound (tearing_elem_fst v0 v1 v2) := ex_intro (fun v3 : @R => is_upper_bound (tearing_elem_fst v0 v1 v2) v3) (INR 1) ((fun (v3 : @R) (v4 : tearing_elem_fst v0 v1 v2 v3) => match v4 as v5 in (ex _) return (v3 <= INR 1)%R with | ex_intro _ v5 v6 => (fun (v5 : @nat) (v6 : v3 = fst (proj1_sig (tearing_sequences v0 v1 v2 v5))) => eq_ind_r (fun v7 : @R => (v7 <= INR 1)%R) (or_introl (tearing_sequences_ordered_forall v0 v1 v2 v5 0)) v6) v5 v6 end) : is_upper_bound (tearing_elem_fst v0 v1 v2) (INR 1)) in completeness (tearing_elem_fst v0 v1 v2) v3 (ex_intro (fun v4 : @R => tearing_elem_fst v0 v1 v2 v4) (INR 0) (ex_intro (fun v4 : @nat => INR 0 = fst (proj1_sig (tearing_sequences v0 v1 v2 v4))) 0 eq_refl)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.torn_number_above_first_sequence	100	0.359909	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 : enumeration (@R) v0 v1) (v3 : @nat) => let v4 : {v4 : @R | is_lub (tearing_elem_fst v0 v1 v2) v4} := torn_number v0 v1 v2 in match v4 as v5 in (sig _) return (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < proj1_sig v5)%R with | exist _ v5 v6 => (fun (v5 : @R) (v6 : is_lub (tearing_elem_fst v0 v1 v2) v5) => (let v7 : {(fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < v5)%R} + {(v5 <= fst (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R} := Rlt_le_dec (fst (proj1_sig (tearing_sequences v0 v1 v2 v3))) v5 in match v7 as v8 in ({_} + {_}) return (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < v5)%R with | left v8 => (fun v8 : (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < v5)%R => v8) v8 | right v8 => (fun v8 : (v5 <= fst (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R => False_ind (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < v5)%R match v6 as v9 in (_ /\ _) return (@False) with | conj v9 v10 => (fun (v9 : is_upper_bound (tearing_elem_fst v0 v1 v2) v5) (v10 : forall (v10 : @R) (v11 : is_upper_bound (tearing_elem_fst v0 v1 v2) v10), (v5 <= v10)%R) => let v11 : (v5 < fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3))))%R := Rle_lt_trans v5 (fst (proj1_sig (tearing_sequences v0 v1 v2 v3))) (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) v8 (let v11 : forall (v11 : forall v11 : @nat, @R) (v12 : forall v12 : @R, @nat) (v13 : enumeration (@R) v11 v12) (v14 : @nat), (fst (proj1_sig (tearing_sequences v11 v12 v13 v14)) < fst (proj1_sig (tearing_sequences v11 v12 v13 (S v14))))%R := fun (v11 : forall v11 : @nat, @R) (v12 : forall v12 : @R, @nat) (v13 : enumeration (@R) v11 v12) (v14 : @nat) => match tearing_sequences_inc_dec v11 v12 v13 v14 as v15 in (_ /\ _) return (fst (proj1_sig (tearing_sequences v11 v12 v13 v14)) < fst (proj1_sig (tearing_sequences v11 v12 v13 (S v14))))%R with | conj v15 v16 => (fun (v15 : (fst (proj1_sig (tearing_sequences v11 v12 v13 v14)) < fst (proj1_sig (tearing_sequences v11 v12 v13 (S v14))))%R) (v16 : (snd (proj1_sig (tearing_sequences v11 v12 v13 (S v14))) < snd (proj1_sig (tearing_sequences v11 v12 v13 v14)))%R) => v15) v15 v16 end in v11 v0 v1 v2 v3) in let v12 : forall v12 : tearing_elem_fst v0 v1 v2 (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))), (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) <= v5)%R := v9 (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) in let v13 : tearing_elem_fst v0 v1 v2 (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) := ex_intro (fun v13 : @nat => fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) = fst (proj1_sig (tearing_sequences v0 v1 v2 v13))) (S v3) eq_refl in let v14 : (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) <= v5)%R := v12 v13 in let v15 : (v5 < v5)%R := Rlt_le_trans v5 (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) v5 v11 v14 in let v16 : @False := Rlt_irrefl v5 v15 in False_ind (@False) v16) v9 v10 end) v8 end) : (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < proj1_sig (exist (fun v7 : @R => is_lub (tearing_elem_fst v0 v1 v2) v7) v5 v6))%R) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.torn_number_below_second_sequence	100	0.530112	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 : enumeration (@R) v0 v1) (v3 : @nat) => let v4 : {v4 : @R | is_lub (tearing_elem_fst v0 v1 v2) v4} := torn_number v0 v1 v2 in match v4 as v5 in (sig _) return (proj1_sig v5 < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R with | exist _ v5 v6 => (fun (v5 : @R) (v6 : is_lub (tearing_elem_fst v0 v1 v2) v5) => (let v7 : {(v5 < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R} + {(snd (proj1_sig (tearing_sequences v0 v1 v2 v3)) <= v5)%R} := Rlt_le_dec v5 (snd (proj1_sig (tearing_sequences v0 v1 v2 v3))) in match v7 as v8 in ({_} + {_}) return (v5 < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R with | left v8 => (fun v8 : (v5 < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R => v8) v8 | right v8 => (fun v8 : (snd (proj1_sig (tearing_sequences v0 v1 v2 v3)) <= v5)%R => False_ind (v5 < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R (let v9 : (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) < v5)%R := Rlt_le_trans (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) (snd (proj1_sig (tearing_sequences v0 v1 v2 v3))) v5 (let v9 : (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R := match tearing_sequences_inc_dec v0 v1 v2 v3 as v9 in (_ /\ _) return (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R with | conj v9 v10 => (fun (v9 : (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3))))%R) (v10 : (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R) => v10) v9 v10 end in v9) v8 in let v10 : is_upper_bound (tearing_elem_fst v0 v1 v2) (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) := (fun (v10 : @R) (v11 : tearing_elem_fst v0 v1 v2 v10) => match v11 as v12 in (ex _) return (v10 <= snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))))%R with | ex_intro _ v12 v13 => (fun (v12 : @nat) (v13 : v10 = fst (proj1_sig (tearing_sequences v0 v1 v2 v12))) => eq_ind_r (fun v14 : @R => (v14 <= snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))))%R) (or_introl (tearing_sequences_ordered_forall v0 v1 v2 v12 (S v3))) v13) v12 v13 end) : is_upper_bound (tearing_elem_fst v0 v1 v2) (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) in match v6 as v11 in (_ /\ _) return (@False) with | conj v11 v12 => (fun (v11 : is_upper_bound (tearing_elem_fst v0 v1 v2) v5) (v12 : forall (v12 : @R) (v13 : is_upper_bound (tearing_elem_fst v0 v1 v2) v12), (v5 <= v12)%R) => let v13 : (v5 <= snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))))%R := v12 (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) v10 in let v14 : (v5 < v5)%R := Rle_lt_trans v5 (snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) v5 v13 v9 in let v15 : @False := Rlt_irrefl v5 v14 in False_ind (@False) v15) v11 v12 end)) v8 end) : (proj1_sig (exist (fun v7 : @R => is_lub (tearing_elem_fst v0 v1 v2) v7) v5 v6) < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.limit_index_above_all_indices	100	1.725241	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @R, @nat) (v2 : enumeration (@R) v0 v1) (v3 : @nat) => (let v4 : {v4 : @R * @R | (fst v4 < snd v4)%R} := tearing_sequences v0 v1 v2 v3 in let v5 : tearing_sequences v0 v1 v2 v3 = v4 := eq_refl in match v4 as v6 in (sig _) return (forall v7 : tearing_sequences v0 v1 v2 v3 = v6, v1 (fst (proj1_sig match v6 as v8 in (sig _) return {v9 : @R * @R | (fst v9 < snd v9)%R} with | exist _ v8 v9 => (fun (v8 : @R * @R) (v9 : (fst v8 < snd v8)%R) => match v8 as v10 in (_ * _)%type return (forall v11 : (fst v10 < snd v10)%R, {v12 : @R * @R | (fst v12 < snd v12)%R}) with | (v10, v11) => (fun (v10 v11 : @R) (v12 : (v10 < v11)%R) => exist (fun v13 : @R * @R => (fst v13 < snd v13)%R) (first_two_in_interval v0 v1 v10 v11 v2 v12) (match first_two_in_interval v0 v1 v10 v11 v2 v12 as v13 in (_ * _)%type return (forall v14 : match v13 as v14 in (_ * _) return Prop with | (v14, v15) => (fun v14 v15 : @R => (v10 < v14)%R /\ (v14 < v11)%R /\ (v10 < v15)%R /\ (v15 < v11)%R /\ (v14 < v15)%R /\ (forall (v16 : @R) (v17 : (v10 < v16)%R) (v18 : (v16 < v11)%R) (v19 : v16 <> v14) (v20 : v16 <> v15), v1 v14 < v1 v16)) v14 v15 end, (fst v13 < snd v13)%R) with | (v13, v14) => (fun (v13 v14 : @R) (v15 : (v10 < v13)%R /\ (v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v15 : @R) (v16 : (v10 < v15)%R) (v17 : (v15 < v11)%R) (v18 : v15 <> v13) (v19 : v15 <> v14), v1 v13 < v1 v15)) => match match match match match v15 as v16 in (_ /\ _) return ((v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v10 < v13)%R) (v17 : (v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v13 < v11)%R) (v17 : (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v10 < v14)%R) (v17 : (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v14 < v11)%R) (v17 : (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return (v13 < v14)%R with | conj v16 v17 => (fun (v16 : (v13 < v14)%R) (v17 : forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17) => v16) v16 v17 end) v13 v14 end (first_two_in_interval_works v0 v1 v10 v11 v2 v12))) v10 v11 end v9) v8 v9 end)) < v1 (proj1_sig (torn_number v0 v1 v2))) with | exist _ v6 v7 => (fun v6 : @R * @R => match v6 as v7 in (_ * _)%type return (forall (v8 : (fst v7 < snd v7)%R) (v9 : tearing_sequences v0 v1 v2 v3 = exist (fun v9 : @R * @R => (fst v9 < snd v9)%R) v7 v8), v1 (fst (proj1_sig (match v7 as v10 in (_ * _)%type return (forall v11 : (fst v10 < snd v10)%R, {v12 : @R * @R | (fst v12 < snd v12)%R}) with | (v10, v11) => (fun (v10 v11 : @R) (v12 : (v10 < v11)%R) => exist (fun v13 : @R * @R => (fst v13 < snd v13)%R) (first_two_in_interval v0 v1 v10 v11 v2 v12) (match first_two_in_interval v0 v1 v10 v11 v2 v12 as v13 in (_ * _)%type return (forall v14 : match v13 as v14 in (_ * _) return Prop with | (v14, v15) => (fun v14 v15 : @R => (v10 < v14)%R /\ (v14 < v11)%R /\ (v10 < v15)%R /\ (v15 < v11)%R /\ (v14 < v15)%R /\ (forall (v16 : @R) (v17 : (v10 < v16)%R) (v18 : (v16 < v11)%R) (v19 : v16 <> v14) (v20 : v16 <> v15), v1 v14 < v1 v16)) v14 v15 end, (fst v13 < snd v13)%R) with | (v13, v14) => (fun (v13 v14 : @R) (v15 : (v10 < v13)%R /\ (v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v15 : @R) (v16 : (v10 < v15)%R) (v17 : (v15 < v11)%R) (v18 : v15 <> v13) (v19 : v15 <> v14), v1 v13 < v1 v15)) => match match match match match v15 as v16 in (_ /\ _) return ((v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v10 < v13)%R) (v17 : (v13 < v11)%R /\ (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v13 < v11)%R) (v17 : (v10 < v14)%R /\ (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v10 < v14)%R) (v17 : (v14 < v11)%R /\ (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return ((v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) with | conj v16 v17 => (fun (v16 : (v14 < v11)%R) (v17 : (v13 < v14)%R /\ (forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17)) => v17) v16 v17 end as v16 in (_ /\ _) return (v13 < v14)%R with | conj v16 v17 => (fun (v16 : (v13 < v14)%R) (v17 : forall (v17 : @R) (v18 : (v10 < v17)%R) (v19 : (v17 < v11)%R) (v20 : v17 <> v13) (v21 : v17 <> v14), v1 v13 < v1 v17) => v16) v16 v17 end) v13 v14 end (first_two_in_interval_works v0 v1 v10 v11 v2 v12))) v10 v11 end v8))) < v1 (proj1_sig (torn_number v0 v1 v2))) with | (v7, v8) => (fun (v7 v8 : @R) (v9 : (fst (v7, v8) < snd (v7, v8))%R) (v10 : tearing_sequences v0 v1 v2 v3 = exist (fun v10 : @R * @R => (fst v10 < snd v10)%R) (v7, v8) v9) => (let v11 : match first_two_in_interval v0 v1 v7 v8 v2 v9 as v11 in (_ * _) return Prop with | (v11, v12) => (fun v11 v12 : @R => (v7 < v11)%R /\ (v11 < v8)%R /\ (v7 < v12)%R /\ (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v13 : @R) (v14 : (v7 < v13)%R) (v15 : (v13 < v8)%R) (v16 : v13 <> v11) (v17 : v13 <> v12), v1 v11 < v1 v13)) v11 v12 end := first_two_in_interval_works v0 v1 v7 v8 v2 v9 in let v12 : @R * @R := first_two_in_interval v0 v1 v7 v8 v2 v9 in let v13 : first_two_in_interval v0 v1 v7 v8 v2 v9 = v12 := eq_refl in match v12 as v14 in (_ * _)%type return (forall (v15 : first_two_in_interval v0 v1 v7 v8 v2 v9 = v14) (v16 : match v14 as v16 in (_ * _) return Prop with | (v16, v17) => (fun v16 v17 : @R => (v7 < v16)%R /\ (v16 < v8)%R /\ (v7 < v17)%R /\ (v17 < v8)%R /\ (v16 < v17)%R /\ (forall (v18 : @R) (v19 : (v7 < v18)%R) (v20 : (v18 < v8)%R) (v21 : v18 <> v16) (v22 : v18 <> v17), v1 v16 < v1 v18)) v16 v17 end), v1 (fst v14) < v1 (proj1_sig (torn_number v0 v1 v2))) with | (v14, v15) => (fun (v14 v15 : @R) (v16 : first_two_in_interval v0 v1 v7 v8 v2 v9 = (v14, v15)) (v17 : (v7 < v14)%R /\ (v14 < v8)%R /\ (v7 < v15)%R /\ (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v17 : @R) (v18 : (v7 < v17)%R) (v19 : (v17 < v8)%R) (v20 : v17 <> v14) (v21 : v17 <> v15), v1 v14 < v1 v17)) => (let v18 : proj1_sig (tearing_sequences v0 v1 v2 (S v3)) = (v14, v15) := eq_ind_r (fun v18 : {v18 : @R * @R | (fst v18 < snd v18)%R} => proj1_sig match v18 as v19 in (sig _) return {v20 : @R * @R | (fst v20 < snd v20)%R} with | exist _ v19 v20 => (fun (v19 : @R * @R) (v20 : (fst v19 < snd v19)%R) => match v19 as v21 in (_ * _)%type return (forall v22 : (fst v21 < snd v21)%R, {v23 : @R * @R | (fst v23 < snd v23)%R}) with | (v21, v22) => (fun (v21 v22 : @R) (v23 : (v21 < v22)%R) => exist (fun v24 : @R * @R => (fst v24 < snd v24)%R) (first_two_in_interval v0 v1 v21 v22 v2 v23) (match first_two_in_interval v0 v1 v21 v22 v2 v23 as v24 in (_ * _)%type return (forall v25 : match v24 as v25 in (_ * _) return Prop with | (v25, v26) => (fun v25 v26 : @R => (v21 < v25)%R /\ (v25 < v22)%R /\ (v21 < v26)%R /\ (v26 < v22)%R /\ (v25 < v26)%R /\ (forall (v27 : @R) (v28 : (v21 < v27)%R) (v29 : (v27 < v22)%R) (v30 : v27 <> v25) (v31 : v27 <> v26), v1 v25 < v1 v27)) v25 v26 end, (fst v24 < snd v24)%R) with | (v24, v25) => (fun (v24 v25 : @R) (v26 : (v21 < v24)%R /\ (v24 < v22)%R /\ (v21 < v25)%R /\ (v25 < v22)%R /\ (v24 < v25)%R /\ (forall (v26 : @R) (v27 : (v21 < v26)%R) (v28 : (v26 < v22)%R) (v29 : v26 <> v24) (v30 : v26 <> v25), v1 v24 < v1 v26)) => match match match match match v26 as v27 in (_ /\ _) return ((v24 < v22)%R /\ (v21 < v25)%R /\ (v25 < v22)%R /\ (v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) with | conj v27 v28 => (fun (v27 : (v21 < v24)%R) (v28 : (v24 < v22)%R /\ (v21 < v25)%R /\ (v25 < v22)%R /\ (v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) => v28) v27 v28 end as v27 in (_ /\ _) return ((v21 < v25)%R /\ (v25 < v22)%R /\ (v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) with | conj v27 v28 => (fun (v27 : (v24 < v22)%R) (v28 : (v21 < v25)%R /\ (v25 < v22)%R /\ (v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) => v28) v27 v28 end as v27 in (_ /\ _) return ((v25 < v22)%R /\ (v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) with | conj v27 v28 => (fun (v27 : (v21 < v25)%R) (v28 : (v25 < v22)%R /\ (v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) => v28) v27 v28 end as v27 in (_ /\ _) return ((v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) with | conj v27 v28 => (fun (v27 : (v25 < v22)%R) (v28 : (v24 < v25)%R /\ (forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28)) => v28) v27 v28 end as v27 in (_ /\ _) return (v24 < v25)%R with | conj v27 v28 => (fun (v27 : (v24 < v25)%R) (v28 : forall (v28 : @R) (v29 : (v21 < v28)%R) (v30 : (v28 < v22)%R) (v31 : v28 <> v24) (v32 : v28 <> v25), v1 v24 < v1 v28) => v27) v27 v28 end) v24 v25 end (first_two_in_interval_works v0 v1 v21 v22 v2 v23))) v21 v22 end v20) v19 v20 end = (v14, v15)) v16 v10 : proj1_sig (tearing_sequences v0 v1 v2 (S v3)) = (v14, v15) in let v19 : (v14 < v8)%R /\ (v7 < v15)%R /\ (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v19 : @R) (v20 : (v7 < v19)%R) (v21 : (v19 < v8)%R) (v22 : v19 <> v14) (v23 : v19 <> v15), v1 v14 < v1 v19) := match v17 as v19 in (_ /\ _) return ((v14 < v8)%R /\ (v7 < v15)%R /\ (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v20 : @R) (v21 : (v7 < v20)%R) (v22 : (v20 < v8)%R) (v23 : v20 <> v14) (v24 : v20 <> v15), v1 v14 < v1 v20)) with | conj v19 v20 => (fun (v19 : (v7 < v14)%R) (v20 : (v14 < v8)%R /\ (v7 < v15)%R /\ (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v20 : @R) (v21 : (v7 < v20)%R) (v22 : (v20 < v8)%R) (v23 : v20 <> v14) (v24 : v20 <> v15), v1 v14 < v1 v20)) => v20) v19 v20 end in let v20 : (v7 < v15)%R /\ (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v20 : @R) (v21 : (v7 < v20)%R) (v22 : (v20 < v8)%R) (v23 : v20 <> v14) (v24 : v20 <> v15), v1 v14 < v1 v20) := match v19 as v20 in (_ /\ _) return ((v7 < v15)%R /\ (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v21 : @R) (v22 : (v7 < v21)%R) (v23 : (v21 < v8)%R) (v24 : v21 <> v14) (v25 : v21 <> v15), v1 v14 < v1 v21)) with | conj v20 v21 => (fun (v20 : (v14 < v8)%R) (v21 : (v7 < v15)%R /\ (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v21 : @R) (v22 : (v7 < v21)%R) (v23 : (v21 < v8)%R) (v24 : v21 <> v14) (v25 : v21 <> v15), v1 v14 < v1 v21)) => v21) v20 v21 end in let v21 : (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v21 : @R) (v22 : (v7 < v21)%R) (v23 : (v21 < v8)%R) (v24 : v21 <> v14) (v25 : v21 <> v15), v1 v14 < v1 v21) := match v20 as v21 in (_ /\ _) return ((v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v22 : @R) (v23 : (v7 < v22)%R) (v24 : (v22 < v8)%R) (v25 : v22 <> v14) (v26 : v22 <> v15), v1 v14 < v1 v22)) with | conj v21 v22 => (fun (v21 : (v7 < v15)%R) (v22 : (v15 < v8)%R /\ (v14 < v15)%R /\ (forall (v22 : @R) (v23 : (v7 < v22)%R) (v24 : (v22 < v8)%R) (v25 : v22 <> v14) (v26 : v22 <> v15), v1 v14 < v1 v22)) => v22) v21 v22 end in let v22 : (v14 < v15)%R /\ (forall (v22 : @R) (v23 : (v7 < v22)%R) (v24 : (v22 < v8)%R) (v25 : v22 <> v14) (v26 : v22 <> v15), v1 v14 < v1 v22) := match v21 as v22 in (_ /\ _) return ((v14 < v15)%R /\ (forall (v23 : @R) (v24 : (v7 < v23)%R) (v25 : (v23 < v8)%R) (v26 : v23 <> v14) (v27 : v23 <> v15), v1 v14 < v1 v23)) with | conj v22 v23 => (fun (v22 : (v15 < v8)%R) (v23 : (v14 < v15)%R /\ (forall (v23 : @R) (v24 : (v7 < v23)%R) (v25 : (v23 < v8)%R) (v26 : v23 <> v14) (v27 : v23 <> v15), v1 v14 < v1 v23)) => v23) v22 v23 end in let v23 : forall (v23 : @R) (v24 : (v7 < v23)%R) (v25 : (v23 < v8)%R) (v26 : v23 <> v14) (v27 : v23 <> v15), v1 v14 < v1 v23 := match v22 as v23 in (_ /\ _) return (forall (v24 : @R) (v25 : (v7 < v24)%R) (v26 : (v24 < v8)%R) (v27 : v24 <> v14) (v28 : v24 <> v15), v1 v14 < v1 v24) with | conj v23 v24 => (fun (v23 : (v14 < v15)%R) (v24 : forall (v24 : @R) (v25 : (v7 < v24)%R) (v26 : (v24 < v8)%R) (v27 : v24 <> v14) (v28 : v24 <> v15), v1 v14 < v1 v24) => v24) v23 v24 end in v23 (proj1_sig (torn_number v0 v1 v2)) (let v24 : (fst (proj1_sig (tearing_sequences v0 v1 v2 v3)) < proj1_sig (torn_number v0 v1 v2))%R := torn_number_above_first_sequence v0 v1 v2 v3 in let v25 : (fst (proj1_sig (exist (fun v25 : @R * @R => fst v25 < snd v25) (v7, v8) v9)) < proj1_sig (torn_number v0 v1 v2))%R := eq_ind (tearing_sequences v0 v1 v2 v3) (fun v25 : {v25 : @R * @R | (fst v25 < snd v25)%R} => (fst (proj1_sig v25) < proj1_sig (torn_number v0 v1 v2))%R) v24 (exist (fun v25 : @R * @R => (fst v25 < snd v25)%R) (v7, v8) v9) v10 in v25) (let v24 : (proj1_sig (torn_number v0 v1 v2) < snd (proj1_sig (tearing_sequences v0 v1 v2 v3)))%R := torn_number_below_second_sequence v0 v1 v2 v3 in let v25 : (proj1_sig (torn_number v0 v1 v2) < snd (proj1_sig (exist (fun v25 : @R * @R => fst v25 < snd v25) (v7, v8) v9)))%R := eq_ind (tearing_sequences v0 v1 v2 v3) (fun v25 : {v25 : @R * @R | (fst v25 < snd v25)%R} => (proj1_sig (torn_number v0 v1 v2) < snd (proj1_sig v25))%R) v24 (exist (fun v25 : @R * @R => (fst v25 < snd v25)%R) (v7, v8) v9) v10 in v25) (let v24 : (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) < proj1_sig (torn_number v0 v1 v2))%R := torn_number_above_first_sequence v0 v1 v2 (S v3) in let v25 : (fst (v14, v15) < proj1_sig (torn_number v0 v1 v2))%R := eq_ind (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) (fun v25 : @R * @R => (fst v25 < proj1_sig (torn_number v0 v1 v2))%R) v24 (v14, v15) v18 in (fun v26 : proj1_sig (torn_number v0 v1 v2) = v14 => eq_ind (proj1_sig (torn_number v0 v1 v2)) (fun v27 : @R => forall (v28 : first_two_in_interval v0 v1 v7 v8 v2 v9 = (v27, v15)) (v29 : (v7 < v27)%R /\ (v27 < v8)%R /\ (v7 < v15)%R /\ (v15 < v8)%R /\ (v27 < v15)%R /\ (forall (v29 : @R) (v30 : (v7 < v29)%R) (v31 : (v29 < v8)%R) (v32 : v29 <> v27) (v33 : v29 <> v15), v1 v27 < v1 v29)) (v30 : proj1_sig (tearing_sequences v0 v1 v2 (S v3)) = (v27, v15)) (v31 : (v27 < proj1_sig (torn_number v0 v1 v2))%R), @False) (fun (v27 : first_two_in_interval v0 v1 v7 v8 v2 v9 = (proj1_sig (torn_number v0 v1 v2), v15)) (v28 : (v7 < proj1_sig (torn_number v0 v1 v2))%R /\ (proj1_sig (torn_number v0 v1 v2) < v8)%R /\ (v7 < v15)%R /\ (v15 < v8)%R /\ (proj1_sig (torn_number v0 v1 v2) < v15)%R /\ (forall (v28 : @R) (v29 : (v7 < v28)%R) (v30 : (v28 < v8)%R) (v31 : v28 <> proj1_sig (torn_number v0 v1 v2)) (v32 : v28 <> v15), v1 (proj1_sig (torn_number v0 v1 v2)) < v1 v28)) (v29 : proj1_sig (tearing_sequences v0 v1 v2 (S v3)) = (proj1_sig (torn_number v0 v1 v2), v15)) (v30 : (proj1_sig (torn_number v0 v1 v2) < proj1_sig (torn_number v0 v1 v2))%R) => let v31 : @False := Rlt_irrefl (proj1_sig (torn_number v0 v1 v2)) v30 in False_ind (@False) v31) v14 v26 v16 v17 v18 v25) : proj1_sig (torn_number v0 v1 v2) <> v14) (let v24 : (proj1_sig (torn_number v0 v1 v2) < snd (proj1_sig (tearing_sequences v0 v1 v2 (S v3))))%R := torn_number_below_second_sequence v0 v1 v2 (S v3) in let v25 : (proj1_sig (torn_number v0 v1 v2) < snd (v14, v15))%R := eq_ind (proj1_sig (tearing_sequences v0 v1 v2 (S v3))) (fun v25 : @R * @R => (proj1_sig (torn_number v0 v1 v2) < snd v25)%R) v24 (v14, v15) v18 in (fun v26 : proj1_sig (torn_number v0 v1 v2) = v15 => eq_ind (proj1_sig (torn_number v0 v1 v2)) (fun v27 : @R => forall (v28 : first_two_in_interval v0 v1 v7 v8 v2 v9 = (v14, v27)) (v29 : (v7 < v14)%R /\ (v14 < v8)%R /\ (v7 < v27)%R /\ (v27 < v8)%R /\ (v14 < v27)%R /\ (forall (v29 : @R) (v30 : (v7 < v29)%R) (v31 : (v29 < v8)%R) (v32 : v29 <> v14) (v33 : v29 <> v27), v1 v14 < v1 v29)) (v30 : proj1_sig (tearing_sequences v0 v1 v2 (S v3)) = (v14, v27)) (v31 : (proj1_sig (torn_number v0 v1 v2) < v27)%R), @False) (fun (v27 : first_two_in_interval v0 v1 v7 v8 v2 v9 = (v14, proj1_sig (torn_number v0 v1 v2))) (v28 : (v7 < v14)%R /\ (v14 < v8)%R /\ (v7 < proj1_sig (torn_number v0 v1 v2))%R /\ (proj1_sig (torn_number v0 v1 v2) < v8)%R /\ (v14 < proj1_sig (torn_number v0 v1 v2))%R /\ (forall (v28 : @R) (v29 : (v7 < v28)%R) (v30 : (v28 < v8)%R) (v31 : v28 <> v14) (v32 : v28 <> proj1_sig (torn_number v0 v1 v2)), v1 v14 < v1 v28)) (v29 : proj1_sig (tearing_sequences v0 v1 v2 (S v3)) = (v14, proj1_sig (torn_number v0 v1 v2))) (v30 : (proj1_sig (torn_number v0 v1 v2) < proj1_sig (torn_number v0 v1 v2))%R) => let v31 : @False := Rlt_irrefl (proj1_sig (torn_number v0 v1 v2)) v30 in False_ind (@False) v31) v15 v26 v16 v17 v18 v25) : proj1_sig (torn_number v0 v1 v2) <> v15)) : v1 (fst (v14, v15)) < v1 (proj1_sig (torn_number v0 v1 v2))) v14 v15 end v13 v11) : v1 (fst (proj1_sig (exist (fun v11 : @R * @R => (fst v11 < snd v11)%R) (first_two_in_interval v0 v1 v7 v8 v2 v9) (match first_two_in_interval v0 v1 v7 v8 v2 v9 as v11 in (_ * _)%type return (forall v12 : match v11 as v12 in (_ * _) return Prop with | (v12, v13) => (fun v12 v13 : @R => (v7 < v12)%R /\ (v12 < v8)%R /\ (v7 < v13)%R /\ (v13 < v8)%R /\ (v12 < v13)%R /\ (forall (v14 : @R) (v15 : (v7 < v14)%R) (v16 : (v14 < v8)%R) (v17 : v14 <> v12) (v18 : v14 <> v13), v1 v12 < v1 v14)) v12 v13 end, (fst v11 < snd v11)%R) with | (v11, v12) => (fun (v11 v12 : @R) (v13 : (v7 < v11)%R /\ (v11 < v8)%R /\ (v7 < v12)%R /\ (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v13 : @R) (v14 : (v7 < v13)%R) (v15 : (v13 < v8)%R) (v16 : v13 <> v11) (v17 : v13 <> v12), v1 v11 < v1 v13)) => match match match match match v13 as v14 in (_ /\ _) return ((v11 < v8)%R /\ (v7 < v12)%R /\ (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) with | conj v14 v15 => (fun (v14 : (v7 < v11)%R) (v15 : (v11 < v8)%R /\ (v7 < v12)%R /\ (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) => v15) v14 v15 end as v14 in (_ /\ _) return ((v7 < v12)%R /\ (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) with | conj v14 v15 => (fun (v14 : (v11 < v8)%R) (v15 : (v7 < v12)%R /\ (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) => v15) v14 v15 end as v14 in (_ /\ _) return ((v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) with | conj v14 v15 => (fun (v14 : (v7 < v12)%R) (v15 : (v12 < v8)%R /\ (v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) => v15) v14 v15 end as v14 in (_ /\ _) return ((v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) with | conj v14 v15 => (fun (v14 : (v12 < v8)%R) (v15 : (v11 < v12)%R /\ (forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15)) => v15) v14 v15 end as v14 in (_ /\ _) return (v11 < v12)%R with | conj v14 v15 => (fun (v14 : (v11 < v12)%R) (v15 : forall (v15 : @R) (v16 : (v7 < v15)%R) (v17 : (v15 < v8)%R) (v18 : v15 <> v11) (v19 : v15 <> v12), v1 v11 < v1 v15) => v14) v14 v15 end) v11 v12 end (first_two_in_interval_works v0 v1 v7 v8 v2 v9))))) < v1 (proj1_sig (torn_number v0 v1 v2))) v7 v8 end) v6 v7 end v5) : v1 (fst (proj1_sig (tearing_sequences v0 v1 v2 (S v3)))) < v1 (proj1_sig (torn_number v0 v1 v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.first_indices_increasing	100	2.303121	2	2
coq-tactician-stdlib.8.11.dev	Coq.Reals.Runcountable.R_uncountable	100	0.561716	1	1	0	synth with cache (only 1: refine (fun v0 : forall v0 : @nat, @R => (fun v1 : Bijective v0 => match v1 as v2 in (ex _) return (@False) with | ex_intro _ v2 v3 => (fun (v2 : forall v2 : @R, @nat) (v3 : (forall v3 : @nat, v2 (v0 v3) = v3) /\ (forall v3 : @R, v0 (v2 v3) = v3)) => match v3 as v4 in (_ /\ _) return (@False) with | conj v4 v5 => (fun (v4 : forall v4 : @nat, v2 (v0 v4) = v4) (v5 : forall v5 : @R, v0 (v2 v5) = v5) => let v6 : (forall v6 : @R, v0 (v2 v6) = v6) /\ (forall v6 : @nat, v2 (v0 v6) = v6) := conj v5 v4 in let v7 : forall v7 : @nat, v7 + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1))) <= v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S v7)))) := fun v7 : @nat => nat_ind (fun v8 : @nat => v8 + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1))) <= v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S v8))))) (Nat.le_refl (v2 (fst (first_two_in_interval v0 v2 (IZR 0) (IZR 1) v6 (@Rlt_0_1)))) : 0 + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1))) <= v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1)))) (fun (v8 : @nat) (v9 : v8 + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1))) <= v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S v8))))) => Nat.le_trans (S v8 + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1)))) (S (v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S v8)))))) (v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S (S v8)))))) (le_n_S (v8 + v2 (fst (first_two_in_interval v0 v2 (IZR 0) (IZR 1) v6 (@Rlt_0_1)))) (v2 (fst (proj1_sig match tearing_sequences v0 v2 v6 v8 as v10 in (sig _) return {v11 : @R * @R | (fst v11 < snd v11)%R} with | exist _ v10 v11 => (fun (v10 : @R * @R) (v11 : (fst v10 < snd v10)%R) => match v10 as v12 in (_ * _)%type return (forall v13 : (fst v12 < snd v12)%R, {v14 : @R * @R | (fst v14 < snd v14)%R}) with | (v12, v13) => (fun (v12 v13 : @R) (v14 : (v12 < v13)%R) => exist (fun v15 : @R * @R => (fst v15 < snd v15)%R) (first_two_in_interval v0 v2 v12 v13 v6 v14) (match first_two_in_interval v0 v2 v12 v13 v6 v14 as v15 in (_ * _)%type return (forall v16 : match v15 as v16 in (_ * _) return Prop with | (v16, v17) => (fun v16 v17 : @R => (v12 < v16)%R /\ (v16 < v13)%R /\ (v12 < v17)%R /\ (v17 < v13)%R /\ (v16 < v17)%R /\ (forall (v18 : @R) (v19 : (v12 < v18)%R) (v20 : (v18 < v13)%R) (v21 : v18 <> v16) (v22 : v18 <> v17), v2 v16 < v2 v18)) v16 v17 end, (fst v15 < snd v15)%R) with | (v15, v16) => (fun (v15 v16 : @R) (v17 : (v12 < v15)%R /\ (v15 < v13)%R /\ (v12 < v16)%R /\ (v16 < v13)%R /\ (v15 < v16)%R /\ (forall (v17 : @R) (v18 : (v12 < v17)%R) (v19 : (v17 < v13)%R) (v20 : v17 <> v15) (v21 : v17 <> v16), v2 v15 < v2 v17)) => match match match match match v17 as v18 in (_ /\ _) return ((v15 < v13)%R /\ (v12 < v16)%R /\ (v16 < v13)%R /\ (v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) with | conj v18 v19 => (fun (v18 : (v12 < v15)%R) (v19 : (v15 < v13)%R /\ (v12 < v16)%R /\ (v16 < v13)%R /\ (v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) => v19) v18 v19 end as v18 in (_ /\ _) return ((v12 < v16)%R /\ (v16 < v13)%R /\ (v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) with | conj v18 v19 => (fun (v18 : (v15 < v13)%R) (v19 : (v12 < v16)%R /\ (v16 < v13)%R /\ (v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) => v19) v18 v19 end as v18 in (_ /\ _) return ((v16 < v13)%R /\ (v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) with | conj v18 v19 => (fun (v18 : (v12 < v16)%R) (v19 : (v16 < v13)%R /\ (v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) => v19) v18 v19 end as v18 in (_ /\ _) return ((v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) with | conj v18 v19 => (fun (v18 : (v16 < v13)%R) (v19 : (v15 < v16)%R /\ (forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19)) => v19) v18 v19 end as v18 in (_ /\ _) return (v15 < v16)%R with | conj v18 v19 => (fun (v18 : (v15 < v16)%R) (v19 : forall (v19 : @R) (v20 : (v12 < v19)%R) (v21 : (v19 < v13)%R) (v22 : v19 <> v15) (v23 : v19 <> v16), v2 v15 < v2 v19) => v18) v18 v19 end) v15 v16 end (first_two_in_interval_works v0 v2 v12 v13 v6 v14))) v12 v13 end v11) v10 v11 end))) v9 : S v8 + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1))) <= S (v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S v8)))))) (first_indices_increasing v0 v2 v6 (S v8) ((fun v10 : S v8 = 0 => let v11 : @False := eq_ind (S v8) (fun v11 : @nat => match v11 as v12 in nat return Prop with | 0 => @False | S v12 => (fun v12 : @nat => @True) v12 end) (@I) 0 v10 in False_ind (@False) v11) : S v8 <> 0))) v7 in let v8 : v2 (proj1_sig (torn_number v0 v2 v6)) + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1))) < v2 (proj1_sig (torn_number v0 v2 v6)) := let v8 : v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S (v2 (proj1_sig (torn_number v0 v2 v6))))))) < v2 (proj1_sig (torn_number v0 v2 v6)) := limit_index_above_all_indices v0 v2 v6 (v2 (proj1_sig (torn_number v0 v2 v6))) in let v9 : v2 (proj1_sig (torn_number v0 v2 v6)) + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1))) <= v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S (v2 (proj1_sig (torn_number v0 v2 v6))))))) := v7 (v2 (proj1_sig (torn_number v0 v2 v6))) in Nat.le_lt_trans (v2 (proj1_sig (torn_number v0 v2 v6)) + v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1)))) (v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 (S (v2 (proj1_sig (torn_number v0 v2 v6)))))))) (v2 (proj1_sig (torn_number v0 v2 v6))) v9 v8 in let v9 : forall v9 v10 : @nat, ~ v9 + v10 < v9 := fun v9 : @nat => nat_ind (fun v10 : @nat => forall v11 : @nat, ~ v10 + v11 < v10) (fun v10 : @nat => (fun v11 : 0 + v10 < 0 => let v12 : forall v12 : 0 = 0, @False := match v11 as v13 in (_ <= v12) return (forall v14 : v12 = 0, @False) with | le_n _ => fun v12 : S (0 + v10) = 0 => (fun v13 : S (0 + v10) = 0 => let v14 : @False := eq_ind (S (0 + v10)) (fun v14 : @nat => match v14 as v15 in nat return Prop with | 0 => @False | S v15 => (fun v15 : @nat => @True) v15 end) (@I) 0 v13 in False_ind (@False) v14) v12 | le_S _ v12 v13 => (fun (v12 : @nat) (v13 : S (0 + v10) <= v12) (v14 : S v12 = 0) => (fun v15 : S v12 = 0 => let v16 : @False := eq_ind (S v12) (fun v16 : @nat => match v16 as v17 in nat return Prop with | 0 => @False | S v17 => (fun v17 : @nat => @True) v17 end) (@I) 0 v15 in False_ind (forall v17 : S (0 + v10) <= v12, @False) v16) v14 v13) v12 v13 end in v12 eq_refl) : ~ 0 + v10 < 0) (fun (v10 : @nat) (v11 : forall v11 : @nat, ~ v10 + v11 < v10) (v12 : @nat) => (fun v13 : S v10 + v12 < S v10 => let v14 : v10 + v12 < Init.Nat.pred (S v10) := lt_pred (v10 + v12) (S v10) v13 in let v15 : @False := v11 v12 v14 in False_ind (@False) v15) : ~ S v10 + v12 < S v10) v9 in let v10 : @False := v9 (v2 (proj1_sig (torn_number v0 v2 v6))) (v2 (fst (proj1_sig (tearing_sequences v0 v2 v6 1)))) v8 in False_ind (@False) v10) v4 v5 end) v2 v3 end) : ~ Bijective v0)).
coq-tactician-stdlib.8.11.dev	Coq.Floats.FloatLemmas.shift_value	100	0.043447	1	1	0	synth with cache (only 1: refine eq_refl).
coq-tactician-stdlib.8.11.dev	Coq.Floats.FloatLemmas.frexp_spec	100	0.170804	1	1	0	synth with cache (only 1: refine (fun v0 : @float => (match frshiftexp v0 as v1 in (_ * _)%type return (forall v2 : frshiftexp v0 = v1, match match v1 as v3 in (_ * _)%type return (@float * @Z) with | (v3, v4) => (fun (v3 : @float) (v4 : @int) => (v3, ( (v4)%int63 - @shift)%Z)) v3 v4 end as v3 in (_ * _) return Prop with | (v3, v4) => (fun (v3 : @float) (v4 : @Z) => (Prim2SF v3, v4) = SFfrexp (@prec) (@emax) (Prim2SF v0)) v3 v4 end) with | (v1, v2) => (fun (v1 : @float) (v2 : @int) (v3 : frshiftexp v0 = (v1, v2)) => let v4 : match frshiftexp v0 as v4 in (_ * _) return Prop with | (v4, v5) => (fun (v4 : @float) (v5 : @int) => (Prim2SF v4, ( (v5)%int63 - @shift)%Z) = SFfrexp (@prec) (@emax) (Prim2SF v0)) v4 v5 end := frshiftexp_spec v0 in let v5 : (Prim2SF v1, ( (v2)%int63 - @shift)%Z) = SFfrexp (@prec) (@emax) (Prim2SF v0) := eq_ind (frshiftexp v0) (fun v5 : @float * @int => match v5 as v6 in (_ * _)%type return Prop with | (v6, v7) => (fun (v6 : @float) (v7 : @int) => (Prim2SF v6, ( (v7)%int63 - @shift)%Z) = SFfrexp (@prec) (@emax) (Prim2SF v0)) v6 v7 end) v4 (v1, v2) v3 in v5) v1 v2 end : forall v1 : frshiftexp v0 = frshiftexp v0, match match frshiftexp v0 as v2 in (_ * _)%type return (@float * @Z) with | (v2, v3) => (fun (v2 : @float) (v3 : @int) => (v2, ( (v3)%int63 - @shift)%Z)) v2 v3 end as v2 in (_ * _) return Prop with | (v2, v3) => (fun (v2 : @float) (v3 : @Z) => (Prim2SF v2, v3) = SFfrexp (@prec) (@emax) (Prim2SF v0)) v2 v3 end) eq_refl : match frexp v0 as v1 in (_ * _) return Prop with | (v1, v2) => (fun (v1 : @float) (v2 : @Z) => (Prim2SF v1, v2) = SFfrexp (@prec) (@emax) (Prim2SF v0)) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Floats.FloatLemmas.ldexp_spec	100	33.112568	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.E1_cvg	100	0.093455	1	1	0	synth with cache (only 1: refine (fun v0 : @R => (match exist_exp v0 as v1 in (sig _) return (Un_cv (E1 v0) (proj1_sig v1)) with | exist _ v1 v2 => (fun v1 : @R => ((((fun v2 : forall (v2 : @R) (v3 : v2 > IZR 0), exists v4 : @nat, forall (v5 : @nat) (v6 : (v5 >= v4)%nat), R_dist (sum_f_R0 (fun v7 : @nat => / INR (fact v7) * v0 ^ v7) v5) v1 < v2 => v2) : forall (v2 : forall (v2 : @R) (v3 : v2 > IZR 0), exists v4 : @nat, forall (v5 : @nat) (v6 : (v5 >= v4)%nat), R_dist (sum_f_R0 (fun v7 : @nat => / INR (fact v7) * v0 ^ v7) v5) v1 < v2) (v3 : @R) (v4 : v3 > IZR 0), exists v5 : @nat, forall (v6 : @nat) (v7 : (v6 >= v5)%nat), R_dist (E1 v0 v6) (proj1_sig (exist (fun v8 : @R => forall (v9 : @R) (v10 : v9 > IZR 0), exists v11 : @nat, forall (v12 : @nat) (v13 : (v12 >= v11)%nat), R_dist (sum_f_R0 (fun v14 : @nat => / INR (fact v14) * v0 ^ v14) v12) v8 < v9) v1 v2)) < v3) : forall (v2 : infinite_sum (fun v2 : @nat => / INR (fact v2) * v0 ^ v2) v1) (v3 : @R) (v4 : v3 > IZR 0), exists v5 : @nat, forall (v6 : @nat) (v7 : (v6 >= v5)%nat), R_dist (E1 v0 v6) (proj1_sig (exist (fun v8 : @R => infinite_sum (fun v9 : @nat => / INR (fact v9) * v0 ^ v9) v8) v1 v2)) < v3) : forall v2 : infinite_sum (fun v2 : @nat => / INR (fact v2) * v0 ^ v2) v1, Un_cv (E1 v0) (proj1_sig (exist (fun v3 : @R => infinite_sum (fun v4 : @nat => / INR (fact v4) * v0 ^ v4) v3) v1 v2))) : forall v2 : exp_in v0 v1, Un_cv (E1 v0) (proj1_sig (exist (fun v3 : @R => exp_in v0 v3) v1 v2))) v1 v2 end : Un_cv (E1 v0) (proj1_sig (exist_exp v0))) : Un_cv (E1 v0) (exp v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.exp_form	100	0.558505	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : @nat) (v3 : (0 < v2)%nat) => eq_ind_r (fun v4 : @R => v4 - Reste_E v0 v1 v2 = sum_f_R0 (fun v5 : @nat => / INR (fact v5) * (v0 + v1) ^ v5) v2) ((eq_ind_r (fun v4 : @R => v4 = sum_f_R0 (fun v5 : @nat => / INR (fact v5) * (v0 + v1) ^ v5) v2) (eq_ind_r (fun v4 : @R => sum_f_R0 (fun v5 : @nat => sum_f_R0 (fun v6 : @nat => / INR (fact v6) * v0 ^ v6 * (/ INR (fact (v5 - v6)) * v1 ^ (v5 - v6))) v5) v2 + v4 = sum_f_R0 (fun v5 : @nat => / INR (fact v5) * (v0 + v1) ^ v5) v2) (eq_ind_r (fun v4 : @R => v4 = sum_f_R0 (fun v5 : @nat => / INR (fact v5) * (v0 + v1) ^ v5) v2) (sum_eq (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact v5) * v0 ^ v5 * (/ INR (fact (v4 - v5)) * v1 ^ (v4 - v5))) v4) (fun v4 : @nat => / INR (fact v4) * (v0 + v1) ^ v4) v2 (fun (v4 : @nat) (v5 : (v4 <= v2)%nat) => eq_ind_r (fun v6 : @R => sum_f_R0 (fun v7 : @nat => / INR (fact v7) * v0 ^ v7 * (/ INR (fact (v4 - v7)) * v1 ^ (v4 - v7))) v4 = / INR (fact v4) * v6) (eq_ind_r (fun v6 : @R => sum_f_R0 (fun v7 : @nat => / INR (fact v7) * v0 ^ v7 * (/ INR (fact (v4 - v7)) * v1 ^ (v4 - v7))) v4 = v6) (sum_eq (fun v6 : @nat => / INR (fact v6) * v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) (fun v6 : @nat => C v4 v6 * v0 ^ v6 * v1 ^ (v4 - v6) * / INR (fact v4)) v4 (fun (v6 : @nat) (v7 : (v6 <= v4)%nat) => (eq_ind_r (fun v8 : @R => v8 = INR (fact v4) * / (INR (fact v6) * INR (fact (v4 - v6))) * v0 ^ v6 * v1 ^ (v4 - v6) * / INR (fact v4)) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = v8) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = v8) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = v8) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = v8) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = v8) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = / (INR (fact v6) * INR (fact (v4 - v6))) * v8) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = / (INR (fact v6) * INR (fact (v4 - v6))) * (v0 ^ v6 * v8)) (eq_ind (IZR 1) (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = / (INR (fact v6) * INR (fact (v4 - v6))) * (v0 ^ v6 * (v1 ^ (v4 - v6) * v8))) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = / (INR (fact v6) * INR (fact (v4 - v6))) * (v0 ^ v6 * v8)) (eq_ind_r (fun v8 : @R => / INR (fact v6) * (v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) = v8 * (v0 ^ v6 * v1 ^ (v4 - v6))) (let v8 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v9 : list (@R) := (/ INR (fact v6) :: v0 ^ v6 :: / INR (fact (v4 - v6)) :: v1 ^ (v4 - v6) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v9 v8 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4)))) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 4))) (@I) (eq_refl : (let v10 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v8 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 4))))) = @true)) (Rinv_mult_distr (INR (fact v6)) (INR (fact (v4 - v6))) (INR_fact_neq_0 v6) (INR_fact_neq_0 (v4 - v6)))) (Rmult_1_r (v1 ^ (v4 - v6)))) (/ INR (fact v4) * INR (fact v4)) (Rinv_l_sym (INR (fact v4)) (INR_fact_neq_0 v4))) (Rmult_assoc (v1 ^ (v4 - v6)) (/ INR (fact v4)) (INR (fact v4)))) (Rmult_assoc (v0 ^ v6) (v1 ^ (v4 - v6) * / INR (fact v4)) (INR (fact v4)))) (Rmult_assoc (/ (INR (fact v6) * INR (fact (v4 - v6)))) (v0 ^ v6 * (v1 ^ (v4 - v6) * / INR (fact v4))) (INR (fact v4)))) (Rmult_comm (INR (fact v4)) (/ (INR (fact v6) * INR (fact (v4 - v6))) * (v0 ^ v6 * (v1 ^ (v4 - v6) * / INR (fact v4)))))) (Rmult_assoc (INR (fact v4)) (/ (INR (fact v6) * INR (fact (v4 - v6)))) (v0 ^ v6 * (v1 ^ (v4 - v6) * / INR (fact v4))))) (Rmult_assoc (INR (fact v4) * / (INR (fact v6) * INR (fact (v4 - v6)))) (v0 ^ v6) (v1 ^ (v4 - v6) * / INR (fact v4)))) (Rmult_assoc (INR (fact v4) * / (INR (fact v6) * INR (fact (v4 - v6))) * v0 ^ v6) (v1 ^ (v4 - v6)) (/ INR (fact v4)))) (Rmult_assoc (/ INR (fact v6)) (v0 ^ v6) (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6))) : / INR (fact v6) * v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6)) = INR (fact v4) / (INR (fact v6) * INR (fact (v4 - v6))) * v0 ^ v6 * v1 ^ (v4 - v6) * / INR (fact v4)) : / INR (fact v6) * v0 ^ v6 * (/ INR (fact (v4 - v6)) * v1 ^ (v4 - v6)) = C v4 v6 * v0 ^ v6 * v1 ^ (v4 - v6) * / INR (fact v4))) (scal_sum (fun v6 : @nat => C v4 v6 * v0 ^ v6 * v1 ^ (v4 - v6)) v4 (/ INR (fact v4)))) (binomial v0 v1 v4))) (Rplus_0_r (sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact v5) * v0 ^ v5 * (/ INR (fact (v4 - v5)) * v1 ^ (v4 - v5))) v4) v2))) (Rplus_opp_r (sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact (S (v5 + v4))) * v0 ^ S (v5 + v4) * (/ INR (fact (v2 - v5)) * v1 ^ (v2 - v5))) (Init.Nat.pred (v2 - v4))) (Init.Nat.pred v2)))) (Rplus_assoc (sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact v5) * v0 ^ v5 * (/ INR (fact (v4 - v5)) * v1 ^ (v4 - v5))) v4) v2) (sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact (S (v5 + v4))) * v0 ^ S (v5 + v4) * (/ INR (fact (v2 - v5)) * v1 ^ (v2 - v5))) (Init.Nat.pred (v2 - v4))) (Init.Nat.pred v2)) (- sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact (S (v5 + v4))) * v0 ^ S (v5 + v4) * (/ INR (fact (v2 - v5)) * v1 ^ (v2 - v5))) (Init.Nat.pred (v2 - v4))) (Init.Nat.pred v2))) : sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact v5) * v0 ^ v5 * (/ INR (fact (v4 - v5)) * v1 ^ (v4 - v5))) v4) v2 + sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact (S (v5 + v4))) * v0 ^ S (v5 + v4) * (/ INR (fact (v2 - v5)) * v1 ^ (v2 - v5))) (Init.Nat.pred (v2 - v4))) (Init.Nat.pred v2) - sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact (S (v5 + v4))) * v0 ^ S (v5 + v4) * (/ INR (fact (v2 - v5)) * v1 ^ (v2 - v5))) (Init.Nat.pred (v2 - v4))) (Init.Nat.pred v2) = sum_f_R0 (fun v4 : @nat => / INR (fact v4) * (v0 + v1) ^ v4) v2) : sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact v5) * v0 ^ v5 * (/ INR (fact (v4 - v5)) * v1 ^ (v4 - v5))) v4) v2 + sum_f_R0 (fun v4 : @nat => sum_f_R0 (fun v5 : @nat => / INR (fact (S (v5 + v4))) * v0 ^ S (v5 + v4) * (/ INR (fact (v2 - v5)) * v1 ^ (v2 - v5))) (Init.Nat.pred (v2 - v4))) (Init.Nat.pred v2) - Reste_E v0 v1 v2 = sum_f_R0 (fun v4 : @nat => / INR (fact v4) * (v0 + v1) ^ v4) v2) (cauchy_finite (fun v4 : @nat => / INR (fact v4) * v0 ^ v4) (fun v4 : @nat => / INR (fact v4) * v1 ^ v4) v2 v3) : E1 v0 v2 * E1 v1 v2 - Reste_E v0 v1 v2 = E1 (v0 + v1) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.div2_double	100	0.058636	1	1	0	synth with cache (only 1: refine (fun v0 : @nat => nat_ind (fun v1 : @nat => Init.Nat.div2 (2 * v1) = v1) eq_refl (fun (v1 : @nat) (v2 : Init.Nat.div2 (2 * v1) = v1) => eq_ind_r (fun v3 : @nat => Init.Nat.div2 (S v3) = S v1) ((let v3 : Init.Nat.div2 (v1 + (v1 + 0)) = v1 := v2 in (fun v4 : Init.Nat.div2 (v1 + (v1 + 0)) = v1 => eq_trans (f_equal (fun v5 : forall v5 : @nat, @nat => v5 (Init.Nat.div2 (v1 + (v1 + 0)))) eq_refl) (f_equal (@S) v4)) v3) : Init.Nat.div2 (S (S (v1 + (v1 + 0)))) = S v1) (Nat.add_succ_r v1 (v1 + 0)) : Init.Nat.div2 (2 * S v1) = S v1) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.div2_S_double	100	0.056017	1	1	0	synth with cache (only 1: refine (fun v0 : @nat => nat_ind (fun v1 : @nat => Init.Nat.div2 (S (2 * v1)) = v1) eq_refl (fun (v1 : @nat) (v2 : Init.Nat.div2 (S (2 * v1)) = v1) => (let v3 : Init.Nat.div2 (v1 + S (v1 + 0)) = v1 := eq_ind_r (fun v3 : @nat => Init.Nat.div2 v3 = v1) v2 (Nat.add_succ_r v1 (v1 + 0)) in (fun v4 : Init.Nat.div2 (v1 + S (v1 + 0)) = v1 => eq_trans (f_equal (fun v5 : forall v5 : @nat, @nat => v5 (Init.Nat.div2 (v1 + S (v1 + 0)))) eq_refl) (f_equal (@S) v4)) v3) : Init.Nat.div2 (S (2 * S v1)) = S v1) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.div2_not_R0	100	0.172196	1	1	0	synth with cache (only 1: refine (fun (v0 : @nat) (v1 : (1 < v0)%nat) => nat_ind (fun v2 : @nat => forall v3 : (1 < v2)%nat, (0 < Init.Nat.div2 v2)%nat) (fun v2 : (1 < 0)%nat => False_ind (0 < Init.Nat.div2 0)%nat (Nat.nlt_0_r 1 v2)) (fun (v2 : @nat) (v3 : forall v3 : (1 < v2)%nat, (0 < Init.Nat.div2 v2)%nat) (v4 : (1 < S v2)%nat) => let v5 : (1 < v2)%nat \/ v2 = 1%nat := let v5 : forall v5 : S v2 = S v2, (1 < v2)%nat \/ v2 = 1%nat := match v4 as v6 in (_ <= v5)%nat return (forall v7 : v5 = S v2, (1 < v2)%nat \/ v2 = 1%nat) with | le_n _ => fun v5 : 2%nat = S v2 => (fun v6 : 2%nat = S v2 => let v7 : 1%nat = v2 := f_equal (fun v7 : @nat => match v7 as v8 in nat return (@nat) with | 0%nat => 1%nat | S v8 => (fun v8 : @nat => v8) v8 end) v6 in (fun v8 : 1%nat = v2 => let v9 : 1%nat = v2 := v8 in eq_ind 1%nat (fun v10 : @nat => (1 < v10)%nat \/ v10 = 1%nat) (or_intror eq_refl) v2 v9) v7) v5 | le_S _ v5 v6 => (fun (v5 : @nat) (v6 : (2 <= v5)%nat) (v7 : S v5 = S v2) => (fun v8 : S v5 = S v2 => let v9 : v5 = v2 := f_equal (fun v9 : @nat => match v9 as v10 in nat return (@nat) with | 0%nat => v5 | S v10 => (fun v10 : @nat => v10) v10 end) v8 in (fun v10 : v5 = v2 => let v11 : v5 = v2 := v10 in eq_ind_r (fun v12 : @nat => forall v13 : (2 <= v12)%nat, (1 < v2)%nat \/ v2 = 1%nat) (fun v12 : (2 <= v2)%nat => or_introl (Nat.lt_le_trans 1 2 v2 (Nat.lt_succ_diag_r 1) v12)) v11) v9) v7 v6) v5 v6 end in v5 eq_refl in (fun v6 : (1 < v2)%nat \/ v2 = 1%nat => or_ind (fun v7 : (1 < v2)%nat => let v8 : {even v2} + {odd v2} := even_odd_dec v2 in match v8 as v9 in ({_} + {_}) return (0 < Init.Nat.div2 (S v2))%nat with | left v9 => (fun v9 : even v2 => eq_ind (Init.Nat.div2 v2) (fun v10 : @nat => (0 < v10)%nat) (v3 v7) (Init.Nat.div2 (S v2)) (even_div2 v2 v9)) v9 | right v9 => (fun v9 : odd v2 => eq_ind (S (Init.Nat.div2 v2)) (fun v10 : @nat => (0 < v10)%nat) (Nat.lt_0_succ (Init.Nat.div2 v2)) (Init.Nat.div2 (S v2)) (odd_div2 v2 v9)) v9 end) (fun v7 : v2 = 1%nat => eq_ind_r (fun v8 : @nat => (0 < Init.Nat.div2 (S v8))%nat) (Nat.lt_0_succ 0 : (0 < Init.Nat.div2 2)%nat) v7) v6) v5) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.Reste_E_maj	100	3.668225	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.maj_Reste_cv_R0	100	3.283168	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.Reste_E_cv	100	0.094267	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : Un_cv (maj_Reste_E v0 v1) (IZR 0) := maj_Reste_cv_R0 v0 v1 in (fun (v3 : @R) (v4 : v3 > IZR 0) => ex_ind (fun (v5 : @nat) (v6 : forall (v6 : @nat) (v7 : (v6 >= v5)%nat), R_dist (maj_Reste_E v0 v1 v6) (IZR 0) < v3) => ex_intro (fun v7 : @nat => forall (v8 : @nat) (v9 : (v8 >= v7)%nat), R_dist (Reste_E v0 v1 v8) (IZR 0) < v3) (Init.Nat.max v5 1) (fun (v7 : @nat) (v8 : (v7 >= Init.Nat.max v5 1)%nat) => eq_ind_r (fun v9 : @R => Rabs v9 < v3) (Rle_lt_trans (Rabs (Reste_E v0 v1 v7)) (maj_Reste_E v0 v1 v7) v3 (Reste_E_maj v0 v1 v7 (Nat.lt_le_trans 0 1 v7 (Nat.lt_0_succ 0) (Nat.le_trans 1 (Init.Nat.max v5 1) v7 (le_max_r v5 1) v8))) (let v9 : R_dist (maj_Reste_E v0 v1 v7) (IZR 0) = maj_Reste_E v0 v1 v7 := eq_ind_r (fun v9 : @R => Rabs v9 = maj_Reste_E v0 v1 v7) (Rabs_right (maj_Reste_E v0 v1 v7) (Rle_ge (IZR 0) (maj_Reste_E v0 v1 v7) (Rle_trans (IZR 0) (Rabs (Reste_E v0 v1 v7)) (maj_Reste_E v0 v1 v7) (Rabs_pos (Reste_E v0 v1 v7)) (Reste_E_maj v0 v1 v7 (Nat.lt_le_trans 0 1 v7 (Nat.lt_0_succ 0) (Nat.le_trans 1 (Init.Nat.max v5 1) v7 (le_max_r v5 1) v8)))))) (Rminus_0_r (maj_Reste_E v0 v1 v7)) : R_dist (maj_Reste_E v0 v1 v7) (IZR 0) = maj_Reste_E v0 v1 v7 in eq_ind (R_dist (maj_Reste_E v0 v1 v7) (IZR 0)) (fun v10 : @R => v10 < v3) (v6 v7 (Nat.le_trans v5 (Init.Nat.max v5 1) v7 (le_max_l v5 1) v8 : (v7 >= v5)%nat)) (maj_Reste_E v0 v1 v7) v9)) (Rminus_0_r (Reste_E v0 v1 v7)) : R_dist (Reste_E v0 v1 v7) (IZR 0) < v3)) (v2 v3 v4)) : Un_cv (Reste_E v0 v1) (IZR 0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.exp_plus	100	0.152375	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : Un_cv (E1 v0) (exp v0) := E1_cvg v0 in let v3 : Un_cv (E1 v1) (exp v1) := E1_cvg v1 in let v4 : Un_cv (E1 (v0 + v1)) (exp (v0 + v1)) := E1_cvg (v0 + v1) in UL_sequence (E1 (v0 + v1)) (exp (v0 + v1)) (exp v0 * exp v1) v4 (let v5 : Un_cv (fun v5 : @nat => E1 v0 v5 * E1 v1 v5) (exp v0 * exp v1) := CV_mult (E1 v0) (E1 v1) (exp v0) (exp v1) v2 v3 in let v6 : Un_cv (fun v6 : @nat => (fun v7 : @nat => E1 v0 v7 * E1 v1 v7) v6 - Reste_E v0 v1 v6) (exp v0 * exp v1 - IZR 0) := CV_minus (fun v6 : @nat => E1 v0 v6 * E1 v1 v6) (Reste_E v0 v1) (exp v0 * exp v1) (IZR 0) v5 (Reste_E_cv v0 v1) in (fun (v7 : @R) (v8 : v7 > IZR 0) => ex_ind (fun (v9 : @nat) (v10 : forall (v10 : @nat) (v11 : (v10 >= v9)%nat), R_dist (E1 v0 v10 * E1 v1 v10 - Reste_E v0 v1 v10) (exp v0 * exp v1 - IZR 0) < v7) => ex_intro (fun v11 : @nat => forall (v12 : @nat) (v13 : (v12 >= v11)%nat), R_dist (E1 (v0 + v1) v12) (exp v0 * exp v1) < v7) (S v9) (fun (v11 : @nat) (v12 : (v11 >= S v9)%nat) => eq_ind (E1 v0 v11 * E1 v1 v11 - Reste_E v0 v1 v11) (fun v13 : @R => R_dist v13 (exp v0 * exp v1) < v7) (let v13 : forall (v13 : @nat) (v14 : (v13 >= v9)%nat), R_dist (E1 v0 v13 * E1 v1 v13 - Reste_E v0 v1 v13) (exp v0 * exp v1) < v7 := eq_ind (exp v0 * exp v1 - IZR 0) (fun v13 : @R => forall (v14 : @nat) (v15 : (v14 >= v9)%nat), R_dist (E1 v0 v14 * E1 v1 v14 - Reste_E v0 v1 v14) v13 < v7) v10 (exp v0 * exp v1) (Rminus_0_r (exp v0 * exp v1)) in v13 v11 (Nat.le_trans v9 (S v9) v11 (Nat.le_succ_diag_r v9) v12 : (v11 >= v9)%nat)) (E1 (v0 + v1) v11) (exp_form v0 v1 v11 (Nat.lt_le_trans 0 (S v9) v11 (Nat.lt_0_succ v9) v12)))) (v6 v7 v8)) : Un_cv (E1 (v0 + v1)) (exp v0 * exp v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.exp_pos_pos	100	0.159919	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : IZR 0 < v0) => let v2 : forall v2 : @nat, @R := fun v2 : @nat => / INR (fact v2) * v0 ^ v2 in let v3 : Un_cv (fun v3 : @nat => sum_f_R0 v2 v3) (exp v0) := (match exist_exp v0 as v3 in (sig _) return (Un_cv (fun v4 : @nat => sum_f_R0 v2 v4) (proj1_sig v3)) with | exist _ v3 v4 => (fun v3 : @R => (((fun v4 : forall (v4 : @R) (v5 : v4 > IZR 0), exists v6 : @nat, forall (v7 : @nat) (v8 : (v7 >= v6)%nat), R_dist (sum_f_R0 (fun v9 : @nat => / INR (fact v9) * v0 ^ v9) v7) v3 < v4 => v4) : forall v4 : forall (v4 : @R) (v5 : v4 > IZR 0), exists v6 : @nat, forall (v7 : @nat) (v8 : (v7 >= v6)%nat), R_dist (sum_f_R0 (fun v9 : @nat => / INR (fact v9) * v0 ^ v9) v7) v3 < v4, Un_cv (fun v5 : @nat => sum_f_R0 v2 v5) (proj1_sig (exist (fun v5 : @R => forall (v6 : @R) (v7 : v6 > IZR 0), exists v8 : @nat, forall (v9 : @nat) (v10 : (v9 >= v8)%nat), R_dist (sum_f_R0 (fun v11 : @nat => / INR (fact v11) * v0 ^ v11) v9) v5 < v6) v3 v4))) : forall v4 : infinite_sum (fun v4 : @nat => / INR (fact v4) * v0 ^ v4) v3, Un_cv (fun v5 : @nat => sum_f_R0 v2 v5) (proj1_sig (exist (fun v5 : @R => infinite_sum (fun v6 : @nat => / INR (fact v6) * v0 ^ v6) v5) v3 v4))) : forall v4 : exp_in v0 v3, Un_cv (fun v5 : @nat => sum_f_R0 v2 v5) (proj1_sig (exist (fun v5 : @R => exp_in v0 v5) v3 v4))) v3 v4 end : Un_cv (fun v3 : @nat => sum_f_R0 v2 v3) (proj1_sig (exist_exp v0))) : Un_cv (fun v3 : @nat => sum_f_R0 v2 v3) (exp v0) in (fun v4 : Un_cv (fun v4 : @nat => sum_f_R0 v2 v4) (exp v0) => Rlt_le_trans (IZR 0) (sum_f_R0 v2 0) (exp v0) ((eq_ind_r (fun v5 : @R => IZR 0 < v5 * IZR 1) (eq_ind_r (fun v5 : @R => IZR 0 < v5) (@Rlt_0_1) (Rmult_1_r (IZR 1))) (@Rinv_1) : IZR 0 < sum_f_R0 (fun v5 : @nat => / INR (fact v5) * v0 ^ v5) 0) : IZR 0 < sum_f_R0 v2 0) (sum_incr v2 0 (exp v0) v4 (fun v5 : @nat => or_introl (Rmult_lt_0_compat (/ INR (fact v5)) (v0 ^ v5) (Rinv_0_lt_compat (INR (fact v5)) (INR_fact_lt_0 v5)) (pow_lt v0 v5 v1)) : IZR 0 <= v2 v5))) v3)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.exp_pos	100	0.190750	1	1	0	synth with cache (only 1: refine (fun v0 : @R => let v1 : {IZR 0 < v0} + {IZR 0 = v0} + {v0 < IZR 0} := total_order_T (IZR 0) v0 in match v1 as v2 in (_ + {_}) return (IZR 0 < exp v0) with | inleft v2 => (fun v2 : {IZR 0 < v0} + {IZR 0 = v0} => match v2 as v3 in ({_} + {_}) return (IZR 0 < exp v0) with | left v3 => (fun v3 : IZR 0 < v0 => exp_pos_pos v0 v3) v3 | right v3 => (fun v3 : IZR 0 = v0 => eq_ind (IZR 0) (fun v4 : @R => IZR 0 < exp v4) (eq_ind_r (fun v4 : @R => IZR 0 < v4) (@Rlt_0_1) (@exp_0)) v0 v3) v3 end) v2 | inright v2 => (fun v2 : v0 < IZR 0 => let v3 : IZR 1 / exp (- v0) = exp v0 := let v3 : exp (- v0) <> IZR 0 := let v3 : exp (v0 + - v0) = exp v0 * exp (- v0) := exp_plus v0 (- v0) in let v4 : exp (IZR 0) = exp v0 * exp (- v0) := eq_ind (v0 + - v0) (fun v4 : @R => exp v4 = exp v0 * exp (- v0)) v3 (IZR 0) (Rplus_opp_r v0) in let v5 : IZR 1 = exp v0 * exp (- v0) := eq_ind (exp (IZR 0)) (fun v5 : @R => v5 = exp v0 * exp (- v0)) v4 (IZR 1) (@exp_0) in (fun v6 : exp (- v0) = IZR 0 => let v7 : IZR 1 = exp v0 * IZR 0 := eq_ind (exp (- v0)) (fun v7 : @R => IZR 1 = exp v0 * v7) v5 (IZR 0) v6 in let v8 : IZR 1 = IZR 0 := eq_ind (exp v0 * IZR 0) (fun v8 : @R => IZR 1 = v8) v7 (IZR 0) (Rmult_0_r (exp v0)) in False_ind (@False) (R1_neq_R0 v8)) : exp (- v0) <> IZR 0 in (fun v4 : exp (- v0) <> IZR 0 => Rmult_eq_reg_l (exp (- v0)) (IZR 1 * / exp (- v0)) (exp v0) (eq_ind_r (fun v5 : @R => exp (- v0) * v5 = exp (- v0) * exp v0) (eq_ind (IZR 1) (fun v5 : @R => v5 = exp (- v0) * exp v0) (eq_ind (exp (- v0 + v0)) (fun v5 : @R => IZR 1 = v5) (eq_ind_r (fun v5 : @R => IZR 1 = exp v5) (eq_ind_r (fun v5 : @R => IZR 1 = v5) eq_refl (@exp_0)) (Rplus_opp_l v0)) (exp (- v0) * exp v0) (exp_plus (- v0) v0)) (exp (- v0) * / exp (- v0)) (Rinv_r_sym (exp (- v0)) v4)) (Rmult_1_l (/ exp (- v0)))) v4 : IZR 1 / exp (- v0) = exp v0) v3 in eq_ind (IZR 1 / exp (- v0)) (fun v4 : @R => IZR 0 < v4) (Rmult_lt_0_compat (IZR 1) (/ exp (- v0)) (@Rlt_0_1) (Rinv_0_lt_compat (exp (- v0)) (exp_pos_pos (- v0) (Ropp_0_gt_lt_contravar v0 v2))) : IZR 0 < IZR 1 / exp (- v0)) (exp v0) v3) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.derivable_pt_lim_exp_0	100	1.649262	1	1	0	synth with cache (only 1: refine ((fun (v0 : @R) (v1 : IZR 0 < v0) => let v2 : forall (v2 : @nat) (v3 : @R), @R := fun (v2 : @nat) (v3 : @R) => v3 ^ v2 / INR (fact (S v2)) in let v3 : CVN_R v2 := let v3 : Un_cv (fun v3 : @nat => Rabs (/ INR (fact (S v3)) * / / INR (fact v3))) (IZR 0) := @Alembert_exp in (fun v4 : @posreal => existT (fun v5 : forall v5 : @nat, @R => {v6 : @R | Un_cv (fun v7 : @nat => sum_f_R0 (fun v8 : @nat => Rabs (v5 v8)) v7) v6 /\ (forall (v7 : @nat) (v8 : @R) (v9 : Boule (IZR 0) v4 v8), Rabs (v2 v7 v8) <= v5 v7)}) (fun v5 : @nat => v4 ^ v5 / INR (fact (S v5))) (let v5 : {v5 : @R | Un_cv (fun v6 : @nat => sum_f_R0 (fun v7 : @nat => Rabs (v4 ^ v7 / INR (fact (S v7)))) v6) v5} := let v5 : (v4 : @R) <> IZR 0 := let v5 : IZR 0 < v4 := cond_pos v4 in (fun v6 : v4 = IZR 0 => let v7 : IZR 0 < IZR 0 := eq_ind v4 (fun v7 : @R => IZR 0 < v7) v5 (IZR 0) v6 in False_ind (@False) (Rlt_irrefl (IZR 0) v7)) : (v4 : @R) <> IZR 0 in (fun v6 : (v4 : @R) <> IZR 0 => Alembert_C2 (fun v7 : @nat => Rabs (v4 ^ v7 / INR (fact (S v7)))) (fun v7 : @nat => Rabs_no_R0 (v4 ^ v7 / INR (fact (S v7))) (Rmult_integral_contrapositive_currified (v4 ^ v7) (/ INR (fact (S v7))) (pow_nonzero v4 v7 v6) (Rinv_neq_0_compat (INR (fact (S v7))) (INR_fact_neq_0 (S v7))) : v4 ^ v7 / INR (fact (S v7)) <> IZR 0)) ((fun (v7 : @R) (v8 : v7 > IZR 0) => let v9 : IZR 0 < v7 / v4 := Rmult_lt_0_compat v7 (/ v4) v8 (Rinv_0_lt_compat v4 (cond_pos v4)) : IZR 0 < v7 / v4 in (fun v10 : IZR 0 < v7 / v4 => ex_ind (fun (v11 : @nat) (v12 : forall (v12 : @nat) (v13 : (v12 >= v11)%nat), R_dist (Rabs (/ INR (fact (S v12)) * / / INR (fact v12))) (IZR 0) < v7 / v4) => ex_intro (fun v13 : @nat => forall (v14 : @nat) (v15 : (v14 >= v13)%nat), R_dist (Rabs (Rabs (v4 ^ S v14 / INR (fact (S (S v14)))) / Rabs (v4 ^ v14 / INR (fact (S v14))))) (IZR 0) < v7) v11 (fun (v13 : @nat) (v14 : (v13 >= v11)%nat) => let v15 : (S v13 >= v11)%nat := Nat.le_trans v11 v13 (S v13) v14 (Nat.le_succ_diag_r v13) : (S v13 >= v11)%nat in (fun v16 : (S v13 >= v11)%nat => let v17 : R_dist (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))) (IZR 0) < v7 / v4 := v12 (S v13) v16 in let v18 : Rabs (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))) < v7 / v4 := eq_ind (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))) - IZR 0) (fun v18 : @R => Rabs v18 < v7 / v4) v17 (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))) (Rminus_0_r (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))))) in let v19 : Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))) < v7 / v4 := eq_ind (Rabs (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))))) (fun v19 : @R => v19 < v7 / v4) v18 (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))) (Rabs_Rabsolu (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))) in eq_ind_r (fun v20 : @R => Rabs v20 < v7) (eq_ind_r (fun v20 : @R => v20 < v7) (let v20 : v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = Rabs (v4 ^ S v13 / INR (fact (S (S v13)))) / Rabs (v4 ^ v13 / INR (fact (S v13))) := eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = v20 * / Rabs (v4 ^ v13 * / INR (fact (S v13)))) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = Rabs (v4 ^ S v13) * Rabs (/ INR (fact (S (S v13)))) * / v20) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = Rabs (v4 ^ S v13) * v20 * / (Rabs (v4 ^ v13) * Rabs (/ INR (fact (S v13))))) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = Rabs (v4 ^ S v13) * / Rabs (INR (fact (S (S v13)))) * / (Rabs (v4 ^ v13) * v20)) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = Rabs (v4 ^ S v13) * / Rabs (INR (fact (S (S v13)))) * v20) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = v20 * / Rabs (INR (fact (S (S v13)))) * (/ Rabs (v4 ^ v13) * / / Rabs (INR (fact (S v13))))) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = v4 ^ S v13 * / v20 * (/ Rabs (v4 ^ v13) * / / Rabs (INR (fact (S v13))))) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = v4 ^ S v13 * / INR (fact (S (S v13))) * (/ v20 * / / Rabs (INR (fact (S v13))))) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = v4 ^ S v13 * / INR (fact (S (S v13))) * (/ v4 ^ v13 * / / v20)) (eq_ind_r (fun v20 : @R => v4 * / INR (fact (S (S v13))) * v20 = v4 ^ S v13 * / INR (fact (S (S v13))) * (/ v4 ^ v13 * v20)) (eq_ind_r (fun v20 : @R => v20 * INR (fact (S v13)) = v4 ^ S v13 * / INR (fact (S (S v13))) * (/ v4 ^ v13 * INR (fact (S v13)))) (eq_ind_r (fun v20 : @R => / INR (fact (S (S v13))) * v4 * INR (fact (S v13)) = v20 * (/ v4 ^ v13 * INR (fact (S v13)))) (eq_ind_r (fun v20 : @R => v20 = / INR (fact (S (S v13))) * v4 ^ S v13 * (/ v4 ^ v13 * INR (fact (S v13)))) (eq_ind_r (fun v20 : @R => / INR (fact (S (S v13))) * (v4 * INR (fact (S v13))) = v20) (Rmult_eq_compat_l (/ INR (fact (S (S v13)))) (v4 * INR (fact (S v13))) (v4 ^ S v13 * (/ v4 ^ v13 * INR (fact (S v13)))) (eq_ind_r (fun v20 : @R => v20 = v4 ^ S v13 * (/ v4 ^ v13 * INR (fact (S v13)))) (eq_ind (v4 ^ S v13 * / v4 ^ v13 * INR (fact (S v13))) (fun v20 : @R => INR (fact (S v13)) * v4 = v20) (eq_ind (INR (fact (S v13)) * (v4 ^ S v13 * / v4 ^ v13)) (fun v20 : @R => INR (fact (S v13)) * v4 = v20) (Rmult_eq_compat_l (INR (fact (S v13))) v4 (v4 ^ S v13 * / v4 ^ v13) (eq_ind_r (fun v20 : @R => v4 = v20) (eq_ind (IZR 1) (fun v20 : @R => v4 = v4 * v20) (let v20 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v21 : list (@R) := (v4 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v21 v20 (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)) (@I) (eq_refl : (let v22 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v20 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v22 (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v22 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) = @true)) (v4 ^ v13 * / v4 ^ v13) (Rinv_r_sym (v4 ^ v13) (pow_nonzero v4 v13 v6))) (Rmult_assoc v4 (v4 ^ v13) (/ v4 ^ v13)) : v4 = v4 ^ S v13 * / v4 ^ v13)) (v4 ^ S v13 * / v4 ^ v13 * INR (fact (S v13))) (Rmult_comm (INR (fact (S v13))) (v4 ^ S v13 * / v4 ^ v13))) (v4 ^ S v13 * (/ v4 ^ v13 * INR (fact (S v13)))) (Rmult_assoc (v4 ^ S v13) (/ v4 ^ v13) (INR (fact (S v13))))) (Rmult_comm v4 (INR (fact (S v13)))))) (Rmult_assoc (/ INR (fact (S (S v13)))) (v4 ^ S v13) (/ v4 ^ v13 * INR (fact (S v13))))) (Rmult_assoc (/ INR (fact (S (S v13)))) v4 (INR (fact (S v13))))) (Rmult_comm (v4 ^ S v13) (/ INR (fact (S (S v13)))))) (Rmult_comm v4 (/ INR (fact (S (S v13)))))) (Rinv_involutive (INR (fact (S v13))) (INR_fact_neq_0 (S v13)))) (Rabs_right (INR (fact (S v13))) (Rle_ge (IZR 0) (INR (fact (S v13))) (or_introl (INR_fact_lt_0 (S v13)))))) (Rabs_right (v4 ^ v13) (Rle_ge (IZR 0) (v4 ^ v13) (or_introl (pow_lt v4 v13 (cond_pos v4)))))) (Rabs_right (INR (fact (S (S v13)))) (Rle_ge (IZR 0) (INR (fact (S (S v13)))) (or_introl (INR_fact_lt_0 (S (S v13))))))) (Rabs_right (v4 ^ S v13) (Rle_ge (IZR 0) (v4 ^ S v13) (or_introl (pow_lt v4 (S v13) (cond_pos v4)))))) (Rinv_mult_distr (Rabs (v4 ^ v13)) (/ Rabs (INR (fact (S v13)))) (Rabs_no_R0 (v4 ^ v13) (pow_nonzero v4 v13 v6)) (Rinv_neq_0_compat (Rabs (INR (fact (S v13)))) (Rabs_no_R0 (INR (fact (S v13))) (INR_fact_neq_0 (S v13)))))) (Rabs_Rinv (INR (fact (S v13))) (INR_fact_neq_0 (S v13)))) (Rabs_Rinv (INR (fact (S (S v13)))) (INR_fact_neq_0 (S (S v13))))) (Rabs_mult (v4 ^ v13) (/ INR (fact (S v13))))) (Rabs_mult (v4 ^ S v13) (/ INR (fact (S (S v13))))) : v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13)) = Rabs (v4 ^ S v13 / INR (fact (S (S v13)))) / Rabs (v4 ^ v13 / INR (fact (S v13))) in eq_ind (v4 * / INR (fact (S (S v13))) * / / INR (fact (S v13))) (fun v21 : @R => Rabs v21 < v7) (eq_ind_r (fun v21 : @R => Rabs v21 < v7) (eq_ind_r (fun v21 : @R => v21 < v7) (eq_ind_r (fun v21 : @R => v21 * Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))) < v7) (Rmult_lt_reg_l (/ v4) (v4 * Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))) v7 (Rinv_0_lt_compat v4 (cond_pos v4)) (eq_ind (/ v4 * v4 * Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))) (fun v21 : @R => v21 < / v4 * v7) (eq_ind (IZR 1) (fun v21 : @R => v21 * Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))) < / v4 * v7) (eq_ind_r (fun v21 : @R => v21 < / v4 * v7) (eq_ind (v7 * / v4) (fun v21 : @R => Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))) < v21) v19 (/ v4 * v7) (Rmult_comm v7 (/ v4))) (Rmult_1_l (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13)))))) (/ v4 * v4) (Rinv_l_sym v4 v6)) (/ v4 * (v4 * Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))))) (Rmult_assoc (/ v4) v4 (Rabs (/ INR (fact (S (S v13))) * / / INR (fact (S v13))))))) (Rabs_right v4 (Rle_ge (IZR 0) v4 (or_introl (cond_pos v4))))) (Rabs_mult v4 (/ INR (fact (S (S v13))) * / / INR (fact (S v13))))) (Rmult_assoc v4 (/ INR (fact (S (S v13)))) (/ / INR (fact (S v13))))) (Rabs (v4 ^ S v13 / INR (fact (S (S v13)))) / Rabs (v4 ^ v13 / INR (fact (S v13)))) v20) (Rabs_Rabsolu (Rabs (v4 ^ S v13 / INR (fact (S (S v13)))) / Rabs (v4 ^ v13 / INR (fact (S v13)))))) (Rminus_0_r (Rabs (Rabs (v4 ^ S v13 / INR (fact (S (S v13)))) / Rabs (v4 ^ v13 / INR (fact (S v13)))))) : R_dist (Rabs (Rabs (v4 ^ S v13 / INR (fact (S (S v13)))) / Rabs (v4 ^ v13 / INR (fact (S v13))))) (IZR 0) < v7) v15)) (v3 (v7 / v4) v10)) v9) : Un_cv (fun v7 : @nat => Rabs (Rabs (v4 ^ S v7 / INR (fact (S (S v7)))) / Rabs (v4 ^ v7 / INR (fact (S v7))))) (IZR 0))) v5 in (fun v6 : {v6 : @R | Un_cv (fun v7 : @nat => sum_f_R0 (fun v8 : @nat => Rabs (v4 ^ v8 / INR (fact (S v8)))) v7) v6} => match v6 as v7 in (sig _) return {v8 : @R | Un_cv (fun v9 : @nat => sum_f_R0 (fun v10 : @nat => Rabs (v4 ^ v10 / INR (fact (S v10)))) v9) v8 /\ (forall (v9 : @nat) (v10 : @R) (v11 : Boule (IZR 0) v4 v10), Rabs (v2 v9 v10) <= v4 ^ v9 / INR (fact (S v9)))} with | exist _ v7 v8 => (fun (v7 : @R) (v8 : Un_cv (fun v8 : @nat => sum_f_R0 (fun v9 : @nat => Rabs (v4 ^ v9 / INR (fact (S v9)))) v8) v7) => exist (fun v9 : @R => Un_cv (fun v10 : @nat => sum_f_R0 (fun v11 : @nat => Rabs (v4 ^ v11 / INR (fact (S v11)))) v10) v9 /\ (forall (v10 : @nat) (v11 : @R) (v12 : Boule (IZR 0) v4 v11), Rabs (v2 v10 v11) <= v4 ^ v10 / INR (fact (S v10)))) v7 (conj v8 ((fun (v9 : @nat) (v10 : @R) (v11 : Rabs (v10 - IZR 0) < v4) => let v12 : Rabs v10 < v4 := eq_ind (v10 - IZR 0) (fun v12 : @R => Rabs v12 < v4) v11 v10 (Rminus_0_r v10) in (eq_ind_r (fun v13 : @R => v13 <= v4 ^ v9 * / INR (fact (S v9))) (let v13 : IZR 0 < INR (fact (S v9)) := INR_fact_lt_0 (S v9) in (fun v14 : IZR 0 < INR (fact (S v9)) => eq_ind_r (fun v15 : @R => Rabs (v10 ^ v9) * v15 <= v4 ^ v9 * / INR (fact (S v9))) (eq_ind (/ INR (fact (S v9)) * Rabs (v10 ^ v9)) (fun v15 : @R => v15 <= v4 ^ v9 * / INR (fact (S v9))) (eq_ind (/ INR (fact (S v9)) * v4 ^ v9) (fun v15 : @R => / INR (fact (S v9)) * Rabs (v10 ^ v9) <= v15) (Rmult_le_compat_l (/ INR (fact (S v9))) (Rabs (v10 ^ v9)) (v4 ^ v9) (or_introl (Rinv_0_lt_compat (INR (fact (S v9))) v14)) (eq_ind (Rabs v10 ^ v9) (fun v15 : @R => v15 <= v4 ^ v9) (pow_maj_Rabs v4 (Rabs v10) v9 (eq_ind_r (fun v15 : @R => v15 <= v4) (or_introl v12) (Rabs_Rabsolu v10))) (Rabs (v10 ^ v9)) (RPow_abs v10 v9))) (v4 ^ v9 * / INR (fact (S v9))) (Rmult_comm (/ INR (fact (S v9))) (v4 ^ v9))) (Rabs (v10 ^ v9) * / INR (fact (S v9))) (Rmult_comm (/ INR (fact (S v9))) (Rabs (v10 ^ v9)))) (Rabs_right (/ INR (fact (S v9))) (Rle_ge (IZR 0) (/ INR (fact (S v9))) (or_introl (Rinv_0_lt_compat (INR (fact (S v9))) v14))))) v13) (Rabs_mult (v10 ^ v9) (/ INR (fact (S v9)))) : Rabs (v10 ^ v9 / INR (fact (S v9))) <= v4 ^ v9 / INR (fact (S v9))) : Rabs (v2 v9 v10) <= v4 ^ v9 / INR (fact (S v9))) : forall (v9 : @nat) (v10 : @R) (v11 : Boule (IZR 0) v4 v10), Rabs (v2 v9 v10) <= v4 ^ v9 / INR (fact (S v9))))) v7 v8 end) v5) : CVN_r v2 v4) : CVN_R v2 in (fun v4 : CVN_R v2 => let v5 : forall v5 : @R, {v6 : @R | Un_cv (fun v7 : @nat => SP v2 v7 v5) v6} := CVN_R_CVS v2 v4 in (fun v6 : forall v6 : @R, {v7 : @R | Un_cv (fun v8 : @nat => SP v2 v8 v6) v7} => let v7 : forall v7 : @nat, continuity (v2 v7) := fun v7 : @nat => (let v8 : (pow_fct v7 / fct_cte (INR (fact (S v7))))%F = (fun v8 : @R => v8 ^ v7 / INR (fact (S v7))) := eq_refl in eq_ind (pow_fct v7 / fct_cte (INR (fact (S v7))))%F (fun v9 : forall v9 : @R, @R => continuity v9) (continuity_div (pow_fct v7) (fct_cte (INR (fact (S v7)))) (derivable_continuous (pow_fct v7) (derivable_pow v7)) (derivable_continuous (fct_cte (INR (fact (S v7)))) (derivable_const (INR (fact (S v7))))) (fun v9 : @R => INR_fact_neq_0 (S v7) : fct_cte (INR (fact (S v7))) v9 <> IZR 0)) (fun v9 : @R => v9 ^ v7 / INR (fact (S v7))) v8) : continuity (v2 v7) in (fun v8 : forall v8 : @nat, continuity (v2 v8) => let v9 : continuity (SFL v2 v6) := SFL_continuity v2 v6 v4 v8 in (fun v10 : continuity (SFL v2 v6) => let v11 : continuity_pt (SFL v2 v6) (IZR 0) := v10 (IZR 0) in ex_ind (fun (v12 : @R) (v13 : v12 > IZR 0 /\ (forall (v13 : @R) (v14 : D_x (@no_cond) (IZR 0) v13 /\ Rabs (v13 - IZR 0) < v12), Rabs (SFL v2 v6 v13 - SFL v2 v6 (IZR 0)) < v0)) => and_ind (fun (v14 : v12 > IZR 0) (v15 : forall (v15 : @R) (v16 : D_x (@no_cond) (IZR 0) v15 /\ Rabs (v15 - IZR 0) < v12), Rabs (SFL v2 v6 v15 - SFL v2 v6 (IZR 0)) < v0) => ex_intro (fun v16 : @posreal => forall (v17 : @R) (v18 : v17 <> IZR 0) (v19 : Rabs v17 < v16), Rabs ((exp (IZR 0 + v17) - exp (IZR 0)) / v17 - IZR 1) < v0) {| pos := v12; cond_pos := v14 |} (fun (v16 : @R) (v17 : v16 <> IZR 0) (v18 : Rabs v16 < {| pos := v12; cond_pos := v14 |}) => eq_ind_r (fun v19 : @R => Rabs ((exp v19 - exp (IZR 0)) / v16 - IZR 1) < v0) (eq_ind_r (fun v19 : @R => Rabs ((exp v16 - v19) / v16 - IZR 1) < v0) (let v19 : SFL v2 v6 v16 = (exp v16 - IZR 1) / v16 := ((let v19 : {v19 : @R | Un_cv (fun v20 : @nat => SP v2 v20 v16) v19} := v6 v16 in match v19 as v20 in (sig _) return (match v20 as v21 in (sig _) return (@R) with | exist _ v21 v22 => (fun (v21 : @R) (v22 : Un_cv (fun v22 : @nat => SP v2 v22 v16) v21) => v21) v21 v22 end = (proj1_sig (exist_exp v16) - IZR 1) / v16) with | exist _ v20 v21 => (fun (v20 : @R) (v21 : Un_cv (fun v21 : @nat => SP v2 v21 v16) v20) => let v22 : {v22 : @R | exp_in v16 v22} := exist_exp v16 in match v22 as v23 in (sig _) return (v20 = (proj1_sig v23 - IZR 1) / v16) with | exist _ v23 v24 => (fun (v23 : @R) (v24 : exp_in v16 v23) => UL_sequence (fun v25 : @nat => SP v2 v25 v16) v20 ((v23 - IZR 1) / v16) v21 ((fun (v25 : @R) (v26 : v25 > IZR 0) => let v27 : IZR 0 < v25 * Rabs v16 := Rmult_lt_0_compat v25 (Rabs v16) v26 (Rabs_pos_lt v16 v17) in (fun v28 : IZR 0 < v25 * Rabs v16 => ex_ind (fun (v29 : @nat) (v30 : forall (v30 : @nat) (v31 : (v30 >= v29)%nat), R_dist (sum_f_R0 (fun v32 : @nat => / INR (fact v32) * v16 ^ v32) v30) v23 < v25 * Rabs v16) => ex_intro (fun v31 : @nat => forall (v32 : @nat) (v33 : (v32 >= v31)%nat), R_dist (SP v2 v32 v16) ((v23 - IZR 1) / v16) < v25) v29 (fun (v31 : @nat) (v32 : (v31 >= v29)%nat) => Rmult_lt_reg_l (Rabs v16) (Rabs (SP v2 v31 v16 - (v23 - IZR 1) / v16)) v25 (Rabs_pos_lt v16 v17) (eq_ind (Rabs (v16 * (SP v2 v31 v16 - (v23 - IZR 1) / v16))) (fun v33 : @R => v33 < Rabs v16 * v25) (eq_ind_r (fun v33 : @R => Rabs v33 < Rabs v16 * v25) (let v33 : v23 - IZR 1 = v16 * ((v23 - IZR 1) / v16) := eq_ind (v16 * (v23 - IZR 1) * / v16) (fun v33 : @R => v23 - IZR 1 = v33) (eq_sym (Rinv_r_simpl_m v16 (v23 - IZR 1) v17)) (v16 * ((v23 - IZR 1) * / v16)) (Rmult_assoc v16 (v23 - IZR 1) (/ v16)) : v23 - IZR 1 = v16 * ((v23 - IZR 1) / v16) in eq_ind (v23 - IZR 1) (fun v34 : @R => Rabs (v16 * SP v2 v31 v16 - v34) < Rabs v16 * v25) (let v34 : sum_f_R0 (fun v34 : @nat => / INR (fact v34) * v16 ^ v34) (S v31) - v23 = v16 * SP v2 v31 v16 - (v23 - IZR 1) := eq_ind_r (fun v34 : @R => v34 - v23 = v16 * SP v2 v31 v16 - (v23 - IZR 1)) (let v34 : IZR 1 = / INR (fact 0) * v16 ^ 0 := eq_ind_r (fun v34 : @R => IZR 1 = v34 * IZR 1) (eq_ind_r (fun v34 : @R => IZR 1 = v34) eq_refl (Rmult_1_r (IZR 1))) (@Rinv_1) : IZR 1 = / INR (fact 0) * v16 ^ 0 in eq_ind (IZR 1) (fun v35 : @R => v35 + sum_f_R0 (fun v36 : @nat => / INR (fact (S v36)) * v16 ^ S v36) (Init.Nat.pred (S v31)) - v23 = v16 * SP v2 v31 v16 - (v23 - IZR 1)) (eq_ind_r (fun v35 : @R => IZR 1 + sum_f_R0 (fun v36 : @nat => / INR (fact (S v36)) * v16 ^ S v36) (Init.Nat.pred (S v31)) + - v23 = v16 * SP v2 v31 v16 + v35) (eq_ind_r (fun v35 : @R => IZR 1 + sum_f_R0 (fun v36 : @nat => / INR (fact (S v36)) * v16 ^ S v36) (Init.Nat.pred (S v31)) + - v23 = v16 * SP v2 v31 v16 + (- v23 + v35)) (eq_ind (- v23 + (IZR 1 + sum_f_R0 (fun v35 : @nat => / INR (fact (S v35)) * v16 ^ S v35) (Init.Nat.pred (S v31)))) (fun v35 : @R => v35 = v16 * SP v2 v31 v16 + (- v23 + IZR 1)) (eq_ind (- v23 + IZR 1 + v16 * SP v2 v31 v16) (fun v35 : @R => - v23 + (IZR 1 + sum_f_R0 (fun v36 : @nat => / INR (fact (S v36)) * v16 ^ S v36) (Init.Nat.pred (S v31))) = v35) (eq_ind_r (fun v35 : @R => - v23 + (IZR 1 + sum_f_R0 (fun v36 : @nat => / INR (fact (S v36)) * v16 ^ S v36) (Init.Nat.pred (S v31))) = v35) (Rplus_eq_compat_l (- v23) (IZR 1 + sum_f_R0 (fun v35 : @nat => / INR (fact (S v35)) * v16 ^ S v35) (Init.Nat.pred (S v31))) (IZR 1 + v16 * SP v2 v31 v16) (Rplus_eq_compat_l (IZR 1) (sum_f_R0 (fun v35 : @nat => / INR (fact (S v35)) * v16 ^ S v35) (Init.Nat.pred (S v31))) (v16 * SP v2 v31 v16) (let v35 : v31 = Init.Nat.pred (S v31) := eq_refl in eq_ind v31 (fun v36 : @nat => sum_f_R0 (fun v37 : @nat => / INR (fact (S v37)) * v16 ^ S v37) v36 = v16 * SP v2 v31 v16) (eq_ind_r (fun v36 : @R => sum_f_R0 (fun v37 : @nat => / INR (fact (S v37)) * v16 ^ S v37) v31 = v36) (sum_eq (fun v36 : @nat => / INR (fact (S v36)) * v16 ^ S v36) (fun v36 : @nat => v2 v36 v16 * v16) v31 (fun (v36 : @nat) (v37 : (v36 <= v31)%nat) => (let v38 : v16 * v16 ^ v36 = v16 ^ S v36 := (let v38 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v39 : list (@R) := (v16 :: v16 ^ v36 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v39 v38 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (@I) (eq_refl : (let v40 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v38 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v40 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v40 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)))) = @true)) : v16 * v16 ^ v36 = v16 ^ S v36 in eq_ind (v16 * v16 ^ v36) (fun v39 : @R => / INR (fact (S v36)) * v39 = v16 ^ v36 / INR (fact (S v36)) * v16) ((let v39 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v40 : list (@R) := (/ INR (fact (S v36)) :: v16 :: v16 ^ v36 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v40 v39 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (@I) (eq_refl : (let v41 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v39 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v41 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v41 (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)))) = @true)) : / INR (fact (S v36)) * (v16 * v16 ^ v36) = v16 ^ v36 / INR (fact (S v36)) * v16) (v16 ^ S v36) v38) : / INR (fact (S v36)) * v16 ^ S v36 = v2 v36 v16 * v16)) (scal_sum (fun v36 : @nat => v2 v36 v16) v31 v16) : sum_f_R0 (fun v36 : @nat => / INR (fact (S v36)) * v16 ^ S v36) v31 = v16 * SP v2 v31 v16) (Init.Nat.pred (S v31)) v35))) (Rplus_assoc (- v23) (IZR 1) (v16 * SP v2 v31 v16))) (v16 * SP v2 v31 v16 + (- v23 + IZR 1)) (Rplus_comm (- v23 + IZR 1) (v16 * SP v2 v31 v16))) (IZR 1 + sum_f_R0 (fun v35 : @nat => / INR (fact (S v35)) * v16 ^ S v35) (Init.Nat.pred (S v31)) + - v23) (Rplus_comm (- v23) (IZR 1 + sum_f_R0 (fun v35 : @nat => / INR (fact (S v35)) * v16 ^ S v35) (Init.Nat.pred (S v31))))) (Ropp_involutive (IZR 1))) (Ropp_plus_distr v23 (- IZR 1)) : IZR 1 + sum_f_R0 (fun v35 : @nat => / INR (fact (S v35)) * v16 ^ S v35) (Init.Nat.pred (S v31)) - v23 = v16 * SP v2 v31 v16 - (v23 - IZR 1)) (/ INR (fact 0) * v16 ^ 0) v34) (decomp_sum (fun v34 : @nat => / INR (fact v34) * v16 ^ v34) (S v31) (Nat.lt_0_succ v31)) in eq_ind (sum_f_R0 (fun v35 : @nat => / INR (fact v35) * v16 ^ v35) (S v31) - v23) (fun v35 : @R => Rabs v35 < Rabs v16 * v25) (eq_ind_r (fun v35 : @R => Rabs (sum_f_R0 (fun v36 : @nat => / INR (fact v36) * v16 ^ v36) (S v31) - v23) < v35) (v30 (S v31) (Nat.le_trans v29 (S v29) (S v31) (Nat.le_succ_diag_r v29) (le_n_S v29 v31 v32) : (S v31 >= v29)%nat)) (Rmult_comm (Rabs v16) v25)) (v16 * SP v2 v31 v16 - (v23 - IZR 1)) v34) (v16 * ((v23 - IZR 1) / v16)) v33) (Rmult_minus_distr_l v16 (SP v2 v31 v16) ((v23 - IZR 1) / v16))) (Rabs v16 * Rabs (SP v2 v31 v16 - (v23 - IZR 1) / v16)) (Rabs_mult v16 (SP v2 v31 v16 - (v23 - IZR 1) / v16))) : R_dist (SP v2 v31 v16) ((v23 - IZR 1) / v16) < v25)) (v24 (v25 * Rabs v16) v28)) v27) : Un_cv (fun v25 : @nat => SP v2 v25 v16) ((v23 - IZR 1) / v16)) : v20 = (proj1_sig (exist (fun v25 : @R => exp_in v16 v25) v23 v24) - IZR 1) / v16) v23 v24 end) v20 v21 end) : match v6 v16 as v19 in (sig _) return (@R) with | exist _ v19 v20 => (fun (v19 : @R) (v20 : Un_cv (fun v20 : @nat => SP v2 v20 v16) v19) => v19) v19 v20 end = (exp v16 - IZR 1) / v16) : SFL v2 v6 v16 = (exp v16 - IZR 1) / v16 in eq_ind (SFL v2 v6 v16) (fun v20 : @R => Rabs (v20 - IZR 1) < v0) (let v20 : SFL v2 v6 (IZR 0) = IZR 1 := (let v20 : {v20 : @R | Un_cv (fun v21 : @nat => SP v2 v21 (IZR 0)) v20} := v6 (IZR 0) in match v20 as v21 in (sig _) return (match v21 as v22 in (sig _) return (@R) with | exist _ v22 v23 => (fun (v22 : @R) (v23 : Un_cv (fun v23 : @nat => SP v2 v23 (IZR 0)) v22) => v22) v22 v23 end = IZR 1) with | exist _ v21 v22 => (fun (v21 : @R) (v22 : Un_cv (fun v22 : @nat => SP v2 v22 (IZR 0)) v21) => UL_sequence (fun v23 : @nat => SP v2 v23 (IZR 0)) v21 (IZR 1) v22 (((fun (v23 : @R) (v24 : v23 > IZR 0) => ex_intro (fun v25 : @nat => forall (v26 : @nat) (v27 : (v26 >= v25)%nat), R_dist (sum_f_R0 (fun v28 : @nat => v2 v28 (IZR 0)) v26) (IZR 1) < v23) 1%nat (fun (v25 : @nat) (v26 : (v25 >= 1)%nat) => eq_ind_r (fun v27 : @R => Rabs (v27 - IZR 1) < v23) (eq_ind_r (fun v27 : @R => Rabs (v27 - IZR 1) < v23) (let v27 : IZR 1 = v2 0%nat (IZR 0) := ((eq_ind_r (fun v27 : @R => IZR 1 = IZR 1 * v27) (eq_ind_r (fun v27 : @R => IZR 1 = v27) eq_refl (Rmult_1_r (IZR 1))) (@Rinv_1) : IZR 1 = IZR 1 / IZR 1) : IZR 1 = IZR 0 ^ 0 / INR (fact 1)) : IZR 1 = v2 0%nat (IZR 0) in eq_ind (IZR 1) (fun v28 : @R => Rabs (sum_f_R0 (fun v29 : @nat => v2 (S v29) (IZR 0)) (Init.Nat.pred v25) + v28 - IZR 1) < v23) (eq_ind_r (fun v28 : @R => Rabs v28 < v23) (eq_ind_r (fun v28 : @R => Rabs (sum_f_R0 (fun v29 : @nat => v2 (S v29) (IZR 0)) (Init.Nat.pred v25) + v28) < v23) (eq_ind_r (fun v28 : @R => Rabs v28 < v23) (let v28 : IZR 0 = sum_f_R0 (fun v28 : @nat => v2 (S v28) (IZR 0)) (Init.Nat.pred v25) := eq_sym (sum_eq_R0 (fun v28 : @nat => v2 (S v28) (IZR 0)) (Init.Nat.pred v25) (fun (v28 : @nat) (v29 : (v28 <= Init.Nat.pred v25)%nat) => ((eq_ind_r (fun v30 : @R => v30 * / INR (fact v28 + v28 * fact v28 + (fact v28 + v28 * fact v28 + v28 * (fact v28 + v28 * fact v28))) = IZR 0) (eq_ind_r (fun v30 : @R => v30 = IZR 0) eq_refl (Rmult_0_l (/ INR (fact v28 + v28 * fact v28 + (fact v28 + v28 * fact v28 + v28 * (fact v28 + v28 * fact v28)))))) (Rmult_0_l (IZR 0 ^ v28)) : IZR 0 * IZR 0 ^ v28 / INR (fact v28 + v28 * fact v28 + (fact v28 + v28 * fact v28 + v28 * (fact v28 + v28 * fact v28))) = IZR 0) : IZR 0 ^ S v28 / INR (fact (S (S v28))) = IZR 0) : v2 (S v28) (IZR 0) = IZR 0)) in eq_ind (IZR 0) (fun v29 : @R => Rabs v29 < v23) (eq_ind_r (fun v29 : @R => v29 < v23) v24 (@Rabs_R0)) (sum_f_R0 (fun v29 : @nat => v2 (S v29) (IZR 0)) (Init.Nat.pred v25)) v28) (Rplus_0_r (sum_f_R0 (fun v28 : @nat => v2 (S v28) (IZR 0)) (Init.Nat.pred v25)))) (Rplus_opp_r (IZR 1))) (Rplus_assoc (sum_f_R0 (fun v28 : @nat => v2 (S v28) (IZR 0)) (Init.Nat.pred v25)) (IZR 1) (- IZR 1)) : Rabs (sum_f_R0 (fun v28 : @nat => v2 (S v28) (IZR 0)) (Init.Nat.pred v25) + IZR 1 - IZR 1) < v23) (v2 0%nat (IZR 0)) v27) (Rplus_comm (v2 0%nat (IZR 0)) (sum_f_R0 (fun v27 : @nat => v2 (S v27) (IZR 0)) (Init.Nat.pred v25)))) (decomp_sum (fun v27 : @nat => v2 v27 (IZR 0)) v25 (Nat.lt_le_trans 0 1 v25 (Nat.lt_succ_diag_r 0) v26)) : R_dist (sum_f_R0 (fun v27 : @nat => v2 v27 (IZR 0)) v25) (IZR 1) < v23)) : forall (v23 : @R) (v24 : v23 > IZR 0), exists v25 : @nat, forall (v26 : @nat) (v27 : (v26 >= v25)%nat), R_dist (SP v2 v26 (IZR 0)) (IZR 1) < v23) : Un_cv (fun v23 : @nat => SP v2 v23 (IZR 0)) (IZR 1))) v21 v22 end) : SFL v2 v6 (IZR 0) = IZR 1 in eq_ind (SFL v2 v6 (IZR 0)) (fun v21 : @R => Rabs (SFL v2 v6 v16 - v21) < v0) (v15 v16 (conj ((conj (@I) (not_eq_sym v17) : no_cond v16 /\ IZR 0 <> v16) : D_x (@no_cond) (IZR 0) v16) (eq_ind_r (fun v21 : @R => Rabs v21 < v12) v18 (Rminus_0_r v16)))) (IZR 1) v20) ((exp v16 - IZR 1) / v16) v19) (@exp_0)) (Rplus_0_l v16))) v13) (v11 v0 v1)) v9) v7) v5) v3) : derivable_pt_lim (@exp) (IZR 0) (IZR 1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Exp_prop.derivable_pt_lim_exp	100	0.282693	1	1	0	synth with cache (only 1: refine (fun v0 : @R => let v1 : derivable_pt_lim (@exp) (IZR 0) (IZR 1) := @derivable_pt_lim_exp_0 in (fun (v2 : @R) (v3 : IZR 0 < v2) => let v4 : IZR 0 < v2 / exp v0 := Rmult_lt_0_compat v2 (/ exp v0) v3 (Rinv_0_lt_compat (exp v0) (exp_pos v0)) : IZR 0 < v2 / exp v0 in (fun v5 : IZR 0 < v2 / exp v0 => ex_ind (fun (v6 : @posreal) (v7 : forall (v7 : @R) (v8 : v7 <> IZR 0) (v9 : Rabs v7 < v6), Rabs ((exp (IZR 0 + v7) - exp (IZR 0)) / v7 - IZR 1) < v2 / exp v0) => ex_intro (fun v8 : @posreal => forall (v9 : @R) (v10 : v9 <> IZR 0) (v11 : Rabs v9 < v8), Rabs ((exp (v0 + v9) - exp v0) / v9 - exp v0) < v2) v6 (fun (v8 : @R) (v9 : v8 <> IZR 0) (v10 : Rabs v8 < v6) => let v11 : Rabs ((exp (IZR 0 + v8) - exp (IZR 0)) / v8 - IZR 1) < v2 / exp v0 := v7 v8 v9 v10 in let v12 : Rabs ((exp v8 - exp (IZR 0)) / v8 - IZR 1) < v2 / exp v0 := eq_ind (IZR 0 + v8) (fun v12 : @R => Rabs ((exp v12 - exp (IZR 0)) / v8 - IZR 1) < v2 / exp v0) v11 v8 (Rplus_0_l v8) in let v13 : Rabs ((exp v8 - IZR 1) / v8 - IZR 1) < v2 / exp v0 := eq_ind (exp (IZR 0)) (fun v13 : @R => Rabs ((exp v8 - v13) / v8 - IZR 1) < v2 / exp v0) v12 (IZR 1) (@exp_0) in let v14 : exp v0 * ((exp v8 - IZR 1) / v8 - IZR 1) = (exp (v0 + v8) - exp v0) / v8 - exp v0 := eq_ind_r (fun v14 : @R => v14 = (exp (v0 + v8) - exp v0) / v8 - exp v0) (eq_ind_r (fun v14 : @R => exp v0 * ((exp v8 - IZR 1) / v8) - v14 = (exp (v0 + v8) - exp v0) / v8 - exp v0) (eq_ind (exp v0 * (exp v8 - IZR 1) * / v8) (fun v14 : @R => v14 - exp v0 = (exp (v0 + v8) - exp v0) * / v8 - exp v0) (eq_ind_r (fun v14 : @R => v14 * / v8 - exp v0 = (exp (v0 + v8) - exp v0) * / v8 - exp v0) (eq_ind_r (fun v14 : @R => (exp v0 * exp v8 - v14) * / v8 - exp v0 = (exp (v0 + v8) - exp v0) * / v8 - exp v0) (eq_ind_r (fun v14 : @R => (exp v0 * exp v8 - exp v0) * / v8 - exp v0 = (v14 - exp v0) * / v8 - exp v0) eq_refl (exp_plus v0 v8)) (Rmult_1_r (exp v0))) (Rmult_minus_distr_l (exp v0) (exp v8) (IZR 1))) (exp v0 * ((exp v8 - IZR 1) * / v8)) (Rmult_assoc (exp v0) (exp v8 - IZR 1) (/ v8)) : exp v0 * ((exp v8 - IZR 1) / v8) - exp v0 = (exp (v0 + v8) - exp v0) / v8 - exp v0) (Rmult_1_r (exp v0))) (Rmult_minus_distr_l (exp v0) ((exp v8 - IZR 1) / v8) (IZR 1)) in eq_ind (exp v0 * ((exp v8 - IZR 1) / v8 - IZR 1)) (fun v15 : @R => Rabs v15 < v2) (eq_ind_r (fun v15 : @R => v15 < v2) (eq_ind_r (fun v15 : @R => v15 * Rabs ((exp v8 - IZR 1) / v8 - IZR 1) < v2) (Rmult_lt_reg_l (/ exp v0) (exp v0 * Rabs ((exp v8 - IZR 1) / v8 - IZR 1)) v2 (Rinv_0_lt_compat (exp v0) (exp_pos v0)) (eq_ind (/ exp v0 * exp v0 * Rabs ((exp v8 - IZR 1) / v8 - IZR 1)) (fun v15 : @R => v15 < / exp v0 * v2) (eq_ind (IZR 1) (fun v15 : @R => v15 * Rabs ((exp v8 - IZR 1) / v8 - IZR 1) < / exp v0 * v2) (eq_ind_r (fun v15 : @R => v15 < / exp v0 * v2) (eq_ind (v2 * / exp v0) (fun v15 : @R => Rabs ((exp v8 - IZR 1) / v8 - IZR 1) < v15) v13 (/ exp v0 * v2) (Rmult_comm v2 (/ exp v0))) (Rmult_1_l (Rabs ((exp v8 - IZR 1) / v8 - IZR 1)))) (/ exp v0 * exp v0) (Rinv_l_sym (exp v0) (let v15 : IZR 0 < exp v0 := exp_pos v0 in (fun v16 : exp v0 = IZR 0 => let v17 : IZR 0 < IZR 0 := eq_ind (exp v0) (fun v17 : @R => IZR 0 < v17) v15 (IZR 0) v16 in False_ind (@False) (Rlt_irrefl (IZR 0) v17)) : exp v0 <> IZR 0))) (/ exp v0 * (exp v0 * Rabs ((exp v8 - IZR 1) / v8 - IZR 1))) (Rmult_assoc (/ exp v0) (exp v0) (Rabs ((exp v8 - IZR 1) / v8 - IZR 1))))) (Rabs_right (exp v0) (Rle_ge (IZR 0) (exp v0) (or_introl (exp_pos v0))))) (Rabs_mult (exp v0) ((exp v8 - IZR 1) / v8 - IZR 1))) ((exp (v0 + v8) - exp v0) / v8 - exp v0) v14)) (v1 (v2 / exp v0) v5)) v4) : derivable_pt_lim (@exp) v0 (exp v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.IZN_var	100	0.038990	1	1	0	synth with cache (only 1: refine (fun (v0 : @Z) (v1 : (0 <= v0)%Z) => exist (fun v2 : @nat => v0 = BinIntDef.Z.of_nat v2) (BinIntDef.Z.to_nat v0) (eq_sym (Z2Nat.id v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.Nzorn	100	0.929461	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P1	100	0.081024	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => (let v3 : (fun v3 : @Rlist => is_subdivision v2 v0 v1 v3) (projT1 (pre v2)) := projT2 (pre v2) in match v3 as v4 in (sigT _) return (adapted_couple v2 v0 v1 (subdivision v2) match v4 as v5 in (sigT _) return (@Rlist) with | existT _ v5 v6 => (fun (v5 : @Rlist) (v6 : adapted_couple v2 v0 v1 (projT1 (pre v2)) v5) => v5) v5 v6 end) with | existT _ v4 v5 => (fun (v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 (projT1 (pre v2)) v4) => v5) v4 v5 end) : adapted_couple v2 v0 v1 (subdivision v2) (subdivision_val v2))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P2	100	0.562987	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v5) (pos_Rl v3 (S v5))) (pos_Rl v4 v5))) => let v6 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v6) (pos_Rl v3 (S v6))) (pos_Rl v4 v6)) := v5 in (fun v7 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7)) => and_ind (fun (v8 : ordered_Rlist v3) (v9 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v9) (pos_Rl v3 (S v9))) (pos_Rl v4 v9))) => and_ind (fun (v10 : pos_Rl v3 0 = Rmin v0 v1) (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v11) (pos_Rl v3 (S v11))) (pos_Rl v4 v11))) => and_ind (fun (v12 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v13 : Rlength v3 = S (Rlength v4) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v13) (pos_Rl v3 (S v13))) (pos_Rl v4 v13))) => and_ind (fun (v14 : Rlength v3 = S (Rlength v4)) (v15 : forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v4 v15)) => conj v8 (conj (eq_ind_r (fun v16 : @R => v16 = Rmin v1 v0) (match Rle_dec v0 v1 as v16 in ({_} + {_}) return (match v16 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v0 <= v1 => v0) v17 | right v17 => (fun v17 : ~ v0 <= v1 => v1) v17 end = match Rle_dec v1 v0 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v1 <= v0 => v1) v17 | right v17 => (fun v17 : ~ v1 <= v0 => v0) v17 end) with | left v16 => (fun v16 : v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v0 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v1) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v0) v18 end) with | left v17 => (fun v17 : v1 <= v0 => Rle_antisym v0 v1 v16 v17) v17 | right v17 => (fun v17 : ~ v1 <= v0 => eq_refl) v17 end) v16 | right v16 => (fun v16 : ~ v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v1 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v1) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v0) v18 end) with | left v17 => (fun v17 : v1 <= v0 => eq_refl) v17 | right v17 => (fun v17 : ~ v1 <= v0 => Rle_antisym v1 v0 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v16)) (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v17))) v17 end) v16 end : Rmin v0 v1 = Rmin v1 v0) v10) (conj (eq_ind_r (fun v16 : @R => v16 = Rmax v1 v0) (match Rle_dec v0 v1 as v16 in ({_} + {_}) return (match v16 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v0 <= v1 => v1) v17 | right v17 => (fun v17 : ~ v0 <= v1 => v0) v17 end = match Rle_dec v1 v0 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v1 <= v0 => v0) v17 | right v17 => (fun v17 : ~ v1 <= v0 => v1) v17 end) with | left v16 => (fun v16 : v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v1 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v0) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v1) v18 end) with | left v17 => (fun v17 : v1 <= v0 => Rle_antisym v1 v0 v17 v16) v17 | right v17 => (fun v17 : ~ v1 <= v0 => eq_refl) v17 end) v16 | right v16 => (fun v16 : ~ v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v0 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v0) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v1) v18 end) with | left v17 => (fun v17 : v1 <= v0 => eq_refl) v17 | right v17 => (fun v17 : ~ v1 <= v0 => Rle_antisym v0 v1 (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v17)) (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v16))) v17 end) v16 end : Rmax v0 v1 = Rmax v1 v0) v12) (conj v14 v15)))) v13) v11) v9) v7) v6) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4), adapted_couple v2 v1 v0 v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P3	100	0.322791	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v1) => conj ((fun (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat) => let v6 : forall v6 : 1%nat = 1%nat, pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4) := match v5 as v7 in (_ <= v6)%nat return (forall v8 : v6 = 1%nat, pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) with | le_n _ => fun v6 : S v4 = 1%nat => (fun v7 : S v4 = 1%nat => let v8 : v4 = 0%nat := f_equal (fun v8 : @nat => match v8 as v9 in nat return (@nat) with | 0%nat => v4 | S v9 => (fun v9 : @nat => v9) v9 end) v7 in (fun v9 : v4 = 0%nat => let v10 : v4 = 0%nat := v9 in eq_ind_r (fun v11 : @nat => pos_Rl (cons v0 (cons v1 (@nil))) v11 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v11)) (v3 : pos_Rl (cons v0 (cons v1 (@nil))) 0 <= pos_Rl (cons v0 (cons v1 (@nil))) 1) v10) v8) v6 | le_S _ v6 v7 => (fun (v6 : @nat) (v7 : (S v4 <= v6)%nat) (v8 : S v6 = 1%nat) => (fun v9 : S v6 = 1%nat => let v10 : v6 = 0%nat := f_equal (fun v10 : @nat => match v10 as v11 in nat return (@nat) with | 0%nat => v6 | S v11 => (fun v11 : @nat => v11) v11 end) v9 in (fun v11 : v6 = 0%nat => let v12 : v6 = 0%nat := v11 in eq_ind_r (fun v13 : @nat => forall v14 : (S v4 <= v13)%nat, pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) (fun v13 : (S v4 <= 0)%nat => False_ind (pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) (Nat.nle_succ_0 v4 v13)) v12) v10) v8 v7) v6 v7 end in v6 eq_refl) : ordered_Rlist (cons v0 (cons v1 (@nil)))) (conj ((decide_left (Rle_dec v0 v1) v3 (fun v4 : {v0 <= v1} + {~ v0 <= v1} => v0 = match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end) (fun v4 : v0 <= v1 => eq_refl) : v0 = Rmin v0 v1) : pos_Rl (cons v0 (cons v1 (@nil))) 0 = Rmin v0 v1) (conj ((decide_left (Rle_dec v0 v1) v3 (fun v4 : {v0 <= v1} + {~ v0 <= v1} => v1 = match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end) (fun v4 : v0 <= v1 => eq_refl) : v1 = Rmax v0 v1) : pos_Rl (cons v0 (cons v1 (@nil))) (Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil))))) = Rmax v0 v1) (conj eq_refl (((fun (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat) (v6 : @R) (v7 : pos_Rl (cons v0 (cons v1 (@nil))) v4 < v6 < pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) => let v8 : forall v8 : 1%nat = 1%nat, fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4 := match v5 as v9 in (_ <= v8)%nat return (forall v10 : v8 = 1%nat, fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) with | le_n _ => fun v8 : S v4 = 1%nat => (fun v9 : S v4 = 1%nat => let v10 : v4 = 0%nat := f_equal (fun v10 : @nat => match v10 as v11 in nat return (@nat) with | 0%nat => v4 | S v11 => (fun v11 : @nat => v11) v11 end) v9 in (fun v11 : v4 = 0%nat => let v12 : v4 = 0%nat := v11 in eq_ind_r (fun v13 : @nat => fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v13) eq_refl v12) v10) v8 | le_S _ v8 v9 => (fun (v8 : @nat) (v9 : (S v4 <= v8)%nat) (v10 : S v8 = 1%nat) => (fun v11 : S v8 = 1%nat => let v12 : v8 = 0%nat := f_equal (fun v12 : @nat => match v12 as v13 in nat return (@nat) with | 0%nat => v8 | S v13 => (fun v13 : @nat => v13) v13 end) v11 in (fun v13 : v8 = 0%nat => let v14 : v8 = 0%nat := v13 in eq_ind_r (fun v15 : @nat => forall v16 : (S v4 <= v15)%nat, fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) (fun v15 : (S v4 <= 0)%nat => False_ind (fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) (Nat.nle_succ_0 v4 v15)) v14) v12) v10 v9) v8 v9 end in v8 eq_refl) : forall (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat) (v6 : @R) (v7 : open_interval (pos_Rl (cons v0 (cons v1 (@nil))) v4) (pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) v6), fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) : forall (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat), constant_D_eq (fct_cte v2) (open_interval (pos_Rl (cons v0 (cons v1 (@nil))) v4) (pos_Rl (cons v0 (cons v1 (@nil))) (S v4))) (pos_Rl (cons v2 (@nil)) v4))))) : adapted_couple (fct_cte v2) v0 v1 (cons v0 (cons v1 (@nil))) (cons v2 (@nil)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P4	100	0.074620	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => (let v3 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v3 as v4 in ({_} + {_}) return {v5 : @Rlist & is_subdivision (fct_cte v2) v0 v1 v5} with | left v4 => (fun v4 : v0 <= v1 => existT (fun v5 : @Rlist => is_subdivision (fct_cte v2) v0 v1 v5) (cons v0 (cons v1 (@nil))) (existT (fun v5 : @Rlist => adapted_couple (fct_cte v2) v0 v1 (cons v0 (cons v1 (@nil))) v5) (cons v2 (@nil)) (StepFun_P3 v2 v4) : is_subdivision (fct_cte v2) v0 v1 (cons v0 (cons v1 (@nil))))) v4 | right v4 => (fun v4 : ~ v0 <= v1 => existT (fun v5 : @Rlist => is_subdivision (fct_cte v2) v0 v1 v5) (cons v1 (cons v0 (@nil))) (existT (fun v5 : @Rlist => adapted_couple (fct_cte v2) v0 v1 (cons v1 (cons v0 (@nil))) v5) (cons v2 (@nil)) (StepFun_P2 (StepFun_P3 v2 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v4)))) : is_subdivision (fct_cte v2) v0 v1 (cons v1 (cons v0 (@nil))))) v4 end) : IsStepFun (fct_cte v2) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P5	100	0.224022	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : @Rlist) (v4 : is_subdivision v2 v0 v1 v3) => match v4 as v5 in (sigT _) return (is_subdivision v2 v1 v0 v3) with | existT _ v5 v6 => (fun (v5 : @Rlist) (v6 : adapted_couple v2 v0 v1 v3 v5) => match v6 as v7 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v7 v8 => (fun (v7 : ordered_Rlist v3) (v8 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v5 v8))) => match v8 as v9 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v9 v10 => (fun (v9 : pos_Rl v3 0 = Rmin v0 v1) (v10 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v10) (pos_Rl v3 (S v10))) (pos_Rl v5 v10))) => match v10 as v11 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v11 v12 => (fun (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v12 : Rlength v3 = S (Rlength v5) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v12) (pos_Rl v3 (S v12))) (pos_Rl v5 v12))) => match v12 as v13 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v13 v14 => (fun (v13 : Rlength v3 = S (Rlength v5)) (v14 : forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v14) (pos_Rl v3 (S v14))) (pos_Rl v5 v14)) => existT (fun v15 : @Rlist => adapted_couple v2 v1 v0 v3 v15) v5 (conj v7 (conj (eq_ind_r (fun v15 : @R => v15 = Rmin v1 v0) (Rmin_comm v0 v1) v9) (conj (eq_ind_r (fun v15 : @R => v15 = Rmax v1 v0) (Rmax_comm v0 v1) v11) (conj v13 v14))))) v13 v14 end) v11 v12 end) v9 v10 end) v7 v8 end) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P6	100	0.051861	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : {v3 : @Rlist & is_subdivision v0 v1 v2 v3}) => sigT_rect (fun v4 : {v4 : @Rlist & is_subdivision v0 v1 v2 v4} => {v5 : @Rlist & is_subdivision v0 v2 v1 v5}) (fun (v4 : @Rlist) (v5 : is_subdivision v0 v1 v2 v4) => existT (fun v6 : @Rlist => is_subdivision v0 v2 v1 v6) v4 (StepFun_P5 v5)) v3) : forall (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : IsStepFun v0 v1 v2), IsStepFun v0 v2 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P7	100	0.615445	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 v3 v4 : @R) (v5 : forall v5 : @R, @R) (v6 v7 : @Rlist) (v8 : v0 <= v1) (v9 : ordered_Rlist (cons v2 (cons v3 v6)) /\ pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v9) (pos_Rl (cons v2 (cons v3 v6)) (S v9))) (pos_Rl (cons v4 v7) v9))) => let v10 : ordered_Rlist (cons v2 (cons v3 v6)) /\ pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v10) (pos_Rl (cons v2 (cons v3 v6)) (S v10))) (pos_Rl (cons v4 v7) v10)) := v9 in (fun v11 : ordered_Rlist (cons v2 (cons v3 v6)) /\ pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v11) (pos_Rl (cons v2 (cons v3 v6)) (S v11))) (pos_Rl (cons v4 v7) v11)) => and_ind (fun (v12 : ordered_Rlist (cons v2 (cons v3 v6))) (v13 : pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v13) (pos_Rl (cons v2 (cons v3 v6)) (S v13))) (pos_Rl (cons v4 v7) v13))) => and_ind (fun (v14 : pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1) (v15 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v15) (pos_Rl (cons v2 (cons v3 v6)) (S v15))) (pos_Rl (cons v4 v7) v15))) => and_ind (fun (v16 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1) (v17 : Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v17) (pos_Rl (cons v2 (cons v3 v6)) (S v17))) (pos_Rl (cons v4 v7) v17))) => and_ind (fun (v18 : Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7))) (v19 : forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v19) (pos_Rl (cons v2 (cons v3 v6)) (S v19))) (pos_Rl (cons v4 v7) v19)) => let v20 : Rmax v0 v1 = v1 := decide_left (Rle_dec v0 v1) v8 (fun v20 : {v0 <= v1} + {~ v0 <= v1} => match v20 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v0 <= v1 => v1) v21 | right v21 => (fun v21 : ~ v0 <= v1 => v0) v21 end = v1) (fun v20 : v0 <= v1 => eq_refl) : Rmax v0 v1 = v1 in let v21 : v3 <= v1 := let v21 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v1 := eq_ind (Rmax v0 v1) (fun v21 : @R => pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v21) v16 v1 v20 in eq_ind (pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))) (fun v22 : @R => v3 <= v22) (RList_P7 (cons v2 (cons v3 v6)) v3 v12 (or_intror (or_introl eq_refl) : In v3 (cons v2 (cons v3 v6)))) v1 v21 in conj (RList_P4 (cons v3 v6) v2 v12) (conj (let v22 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v1 := eq_ind (Rmax v0 v1) (fun v22 : @R => pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v22) v16 v1 v20 in decide_left (Rle_dec v3 v1) v21 (fun v23 : {v3 <= v1} + {~ v3 <= v1} => pos_Rl (cons v3 v6) 0 = match v23 as v24 in ({_} + {_}) return (@R) with | left v24 => (fun v24 : v3 <= v1 => v3) v24 | right v24 => (fun v24 : ~ v3 <= v1 => v1) v24 end) (fun v23 : v3 <= v1 => eq_refl) : pos_Rl (cons v3 v6) 0 = Rmin v3 v1) (conj (decide_left (Rle_dec v3 v1) v21 (fun v22 : {v3 <= v1} + {~ v3 <= v1} => pos_Rl (cons v3 v6) (Init.Nat.pred (Rlength (cons v3 v6))) = match v22 as v23 in ({_} + {_}) return (@R) with | left v23 => (fun v23 : v3 <= v1 => v1) v23 | right v23 => (fun v23 : ~ v3 <= v1 => v3) v23 end) (fun v22 : v3 <= v1 => let v23 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v1 := eq_ind (Rmax v0 v1) (fun v23 : @R => pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v23) v16 v1 v20 in eq_ind (pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))) (fun v24 : @R => pos_Rl (cons v3 v6) (Init.Nat.pred (Rlength (cons v3 v6))) = v24) eq_refl v1 v23) : pos_Rl (cons v3 v6) (Init.Nat.pred (Rlength (cons v3 v6))) = Rmax v3 v1) (conj (INR_eq (S (Rlength v6)) (S (Rlength v7)) (Rplus_eq_reg_l (IZR 1) (INR (S (Rlength v6))) (INR (S (Rlength v7))) (eq_ind_r (fun v22 : @R => v22 = IZR 1 + INR (S (Rlength v7))) (eq_ind_r (fun v22 : @R => INR (S (Rlength v6)) + IZR 1 = v22) (eq_ind (INR (S (S (Rlength v6)))) (fun v22 : @R => v22 = INR (S (Rlength v7)) + IZR 1) (eq_ind (INR (S (S (Rlength v7)))) (fun v22 : @R => INR (S (S (Rlength v6))) = v22) (eq_ind_r (fun v22 : @nat => INR v22 = INR (S (S (Rlength v7)))) eq_refl v18) (INR (S (Rlength v7)) + IZR 1) (S_INR (S (Rlength v7)))) (INR (S (Rlength v6)) + IZR 1) (S_INR (S (Rlength v6)))) (Rplus_comm (IZR 1) (INR (S (Rlength v7))))) (Rplus_comm (IZR 1) (INR (S (Rlength v6)))))) : Rlength (cons v3 v6) = S (Rlength v7)) (fun (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (cons v3 v6)))%nat) => ((fun (v24 : @R) (v25 : pos_Rl (cons v3 v6) v22 < v24 < pos_Rl (cons v3 v6) (S v22)) => let v26 : (S v22 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat := lt_n_S v22 (Rlength v6) v23 : (S v22 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat in let v27 : forall (v27 : @R) (v28 : pos_Rl (cons v2 (cons v3 v6)) (S v22) < v27 < pos_Rl (cons v2 (cons v3 v6)) (S (S v22))), v5 v27 = pos_Rl (cons v4 v7) (S v22) := v19 (S v22) v26 in v27 v24 v25) : forall (v24 : @R) (v25 : open_interval (pos_Rl (cons v3 v6) v22) (pos_Rl (cons v3 v6) (S v22)) v24), v5 v24 = pos_Rl v7 v22) : constant_D_eq v5 (open_interval (pos_Rl (cons v3 v6) v22) (pos_Rl (cons v3 v6) (S v22))) (pos_Rl v7 v22)))))) v17) v15) v13) v11) v10) : forall (v0 v1 v2 v3 v4 : @R) (v5 : forall v5 : @R, @R) (v6 v7 : @Rlist) (v8 : v0 <= v1) (v9 : adapted_couple v5 v0 v1 (cons v2 (cons v3 v6)) (cons v4 v7)), adapted_couple v5 v3 v1 (cons v3 v6) v7)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P8	100	0.790238	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : @Rlist) => Rlist_ind (fun v2 : @Rlist => forall (v3 : @Rlist) (v4 v5 : @R) (v6 : adapted_couple v0 v4 v5 v2 v3) (v7 : v4 = v5), Int_SF v3 v2 = IZR 0) (fun (v2 : @Rlist) (v3 v4 : @R) (v5 : adapted_couple v0 v3 v4 (@nil) v2) (v6 : v3 = v4) => Rlist_ind (fun v7 : @Rlist => forall v8 : adapted_couple v0 v3 v4 (@nil) v7, Int_SF v7 (@nil) = IZR 0) (fun v7 : adapted_couple v0 v3 v4 (@nil) (@nil) => eq_refl) (fun (v7 : @R) (v8 : @Rlist) (v9 : forall v9 : adapted_couple v0 v3 v4 (@nil) v8, Int_SF v8 (@nil) = IZR 0) (v10 : adapted_couple v0 v3 v4 (@nil) (cons v7 v8)) => eq_refl) v2 v5) (fun (v2 : @R) (v3 : @Rlist) => Rlist_ind (fun v4 : @Rlist => forall (v5 : forall (v5 : @Rlist) (v6 v7 : @R) (v8 : adapted_couple v0 v6 v7 v4 v5) (v9 : v6 = v7), Int_SF v5 v4 = IZR 0) (v6 : @Rlist) (v7 v8 : @R) (v9 : adapted_couple v0 v7 v8 (cons v2 v4) v6) (v10 : v7 = v8), Int_SF v6 (cons v2 v4) = IZR 0) (fun (v4 : forall (v4 : @Rlist) (v5 v6 : @R) (v7 : adapted_couple v0 v5 v6 (@nil) v4) (v8 : v5 = v6), Int_SF v4 (@nil) = IZR 0) (v5 : @Rlist) (v6 v7 : @R) (v8 : adapted_couple v0 v6 v7 (cons v2 (@nil)) v5) (v9 : v6 = v7) => Rlist_ind (fun v10 : @Rlist => forall v11 : adapted_couple v0 v6 v7 (cons v2 (@nil)) v10, Int_SF v10 (cons v2 (@nil)) = IZR 0) (fun v10 : adapted_couple v0 v6 v7 (cons v2 (@nil)) (@nil) => eq_refl) (fun (v10 : @R) (v11 : @Rlist) (v12 : forall v12 : adapted_couple v0 v6 v7 (cons v2 (@nil)) v11, Int_SF v11 (cons v2 (@nil)) = IZR 0) (v13 : adapted_couple v0 v6 v7 (cons v2 (@nil)) (cons v10 v11)) => let v14 : ordered_Rlist (cons v2 (@nil)) /\ pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7 /\ pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v14) (pos_Rl (cons v2 (@nil)) (S v14))) (pos_Rl (cons v10 v11) v14)) := v13 in (fun v15 : ordered_Rlist (cons v2 (@nil)) /\ pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7 /\ pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v15) (pos_Rl (cons v2 (@nil)) (S v15))) (pos_Rl (cons v10 v11) v15)) => and_ind (fun (v16 : ordered_Rlist (cons v2 (@nil))) (v17 : pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7 /\ pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v17) (pos_Rl (cons v2 (@nil)) (S v17))) (pos_Rl (cons v10 v11) v17))) => and_ind (fun (v18 : pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7) (v19 : pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v19) (pos_Rl (cons v2 (@nil)) (S v19))) (pos_Rl (cons v10 v11) v19))) => and_ind (fun (v20 : pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7) (v21 : Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v21) (pos_Rl (cons v2 (@nil)) (S v21))) (pos_Rl (cons v10 v11) v21))) => and_ind (fun (v22 : Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11))) (v23 : forall (v23 : @nat) (v24 : (v23 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v23) (pos_Rl (cons v2 (@nil)) (S v23))) (pos_Rl (cons v10 v11) v23)) => let v24 : @False := eq_ind 1%nat (fun v24 : @nat => match v24 as v25 in nat return Prop with | 0%nat => @False | S v25 => (fun v25 : @nat => match v25 as v26 in nat return Prop with | 0%nat => @True | S v26 => (fun v26 : @nat => @False) v26 end) v25 end) (@I) (S (S (Rlength v11))) v22 in False_ind (Int_SF (cons v10 v11) (cons v2 (@nil)) = IZR 0) v24) v21) v19) v17) v15) v14) v5 v8) (fun (v4 : @R) (v5 : @Rlist) (v6 : forall (v6 : forall (v6 : @Rlist) (v7 v8 : @R) (v9 : adapted_couple v0 v7 v8 v5 v6) (v10 : v7 = v8), Int_SF v6 v5 = IZR 0) (v7 : @Rlist) (v8 v9 : @R) (v10 : adapted_couple v0 v8 v9 (cons v2 v5) v7) (v11 : v8 = v9), Int_SF v7 (cons v2 v5) = IZR 0) (v7 : forall (v7 : @Rlist) (v8 v9 : @R) (v10 : adapted_couple v0 v8 v9 (cons v4 v5) v7) (v11 : v8 = v9), Int_SF v7 (cons v4 v5) = IZR 0) (v8 : @Rlist) (v9 v10 : @R) (v11 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) v8) (v12 : v9 = v10) => Rlist_ind (fun v13 : @Rlist => forall v14 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) v13, Int_SF v13 (cons v2 (cons v4 v5)) = IZR 0) (fun v13 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) (@nil) => eq_refl) (fun (v13 : @R) (v14 : @Rlist) (v15 : forall v15 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) v14, Int_SF v14 (cons v2 (cons v4 v5)) = IZR 0) (v16 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) (cons v13 v14)) => (let v17 : v2 = v4 := let v17 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v17) (pos_Rl (cons v2 (cons v4 v5)) (S v17))) (pos_Rl (cons v13 v14) v17)) := v16 in (fun v18 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v18 : @nat) (v19 : (v18 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v18) (pos_Rl (cons v2 (cons v4 v5)) (S v18))) (pos_Rl (cons v13 v14) v18)) => and_ind (fun (v19 : ordered_Rlist (cons v2 (cons v4 v5))) (v20 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v20 : @nat) (v21 : (v20 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v20) (pos_Rl (cons v2 (cons v4 v5)) (S v20))) (pos_Rl (cons v13 v14) v20))) => and_ind (fun (v21 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10) (v22 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v22) (pos_Rl (cons v2 (cons v4 v5)) (S v22))) (pos_Rl (cons v13 v14) v22))) => and_ind (fun (v23 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10) (v24 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v24) (pos_Rl (cons v2 (cons v4 v5)) (S v24))) (pos_Rl (cons v13 v14) v24))) => and_ind (fun (v25 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14))) (v26 : forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v26) (pos_Rl (cons v2 (cons v4 v5)) (S v26))) (pos_Rl (cons v13 v14) v26)) => Rle_antisym v2 v4 (v19 0%nat (Nat.lt_0_succ (Rlength v5) : (0 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat)) (let v27 : v2 = Rmin v10 v10 := eq_ind v9 (fun v27 : @R => v2 = Rmin v27 v10) v21 v10 v12 in eq_ind_r (fun v28 : @R => v4 <= v28) (let v28 : Rmax v9 v10 = Rmin v10 v10 := (match Rle_dec v10 v10 as v28 in ({_} + {_}) return (match Rle_dec v9 v10 as v29 in ({_} + {_}) return (@R) with | left v29 => (fun v29 : v9 <= v10 => v10) v29 | right v29 => (fun v29 : ~ v9 <= v10 => v9) v29 end = match v28 as v29 in ({_} + {_}) return (@R) with | left v29 => (fun v29 : v10 <= v10 => v10) v29 | right v29 => (fun v29 : ~ v10 <= v10 => v10) v29 end) with | left v28 => match Rle_dec v9 v10 as v28 in ({_} + {_}) return (forall v29 : v10 <= v10, match v28 as v30 in ({_} + {_}) return (@R) with | left v30 => (fun v30 : v9 <= v10 => v10) v30 | right v30 => (fun v30 : ~ v9 <= v10 => v9) v30 end = v10) with | left v28 => (fun (v28 : v9 <= v10) (v29 : v10 <= v10) => eq_refl) v28 | right v28 => (fun (v28 : ~ v9 <= v10) (v29 : v10 <= v10) => v12) v28 end v28 | right v28 => match Rle_dec v9 v10 as v28 in ({_} + {_}) return (forall v29 : ~ v10 <= v10, match v28 as v30 in ({_} + {_}) return (@R) with | left v30 => (fun v30 : v9 <= v10 => v10) v30 | right v30 => (fun v30 : ~ v9 <= v10 => v9) v30 end = v10) with | left v28 => (fun (v28 : v9 <= v10) (v29 : ~ v10 <= v10) => eq_refl) v28 | right v28 => (fun (v28 : ~ v9 <= v10) (v29 : ~ v10 <= v10) => v12) v28 end v28 end : Rmax v9 v10 = match Rle_dec v10 v10 as v28 in ({_} + {_}) return (@R) with | left v28 => (fun v28 : v10 <= v10 => v10) v28 | right v28 => (fun v28 : ~ v10 <= v10 => v10) v28 end) : Rmax v9 v10 = Rmin v10 v10 in eq_ind (Rmax v9 v10) (fun v29 : @R => v4 <= v29) (eq_ind (pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))) (fun v29 : @R => v4 <= v29) (RList_P7 (cons v2 (cons v4 v5)) v4 v19 (or_intror (or_introl eq_refl) : In v4 (cons v2 (cons v4 v5)))) (Rmax v9 v10) v23) (Rmin v10 v10) v28) v27)) v24) v22) v20) v18) v17 in (fun v18 : v2 = v4 => eq_ind_r (fun v19 : @R => v13 * (v4 - v19) + Int_SF v14 (cons v4 v5) = IZR 0) (eq_ind_r (fun v19 : @R => v13 * (v4 - v4) + v19 = IZR 0) (let v19 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v20 : list (@R) := (v13 :: v4 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v20 v19 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEc 0%Z) (@I) (eq_refl : (let v21 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v19 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEc 0%Z))) = @true)) (v7 v14 v2 v10 (eq_ind_r (fun v19 : @R => adapted_couple v0 v19 v10 (cons v4 v5) v14) (StepFun_P7 (or_intror v12) v16) v18) (let v19 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v19) (pos_Rl (cons v2 (cons v4 v5)) (S v19))) (pos_Rl (cons v13 v14) v19)) := v16 in (fun v20 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v20 : @nat) (v21 : (v20 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v20) (pos_Rl (cons v2 (cons v4 v5)) (S v20))) (pos_Rl (cons v13 v14) v20)) => and_ind (fun (v21 : ordered_Rlist (cons v2 (cons v4 v5))) (v22 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v22) (pos_Rl (cons v2 (cons v4 v5)) (S v22))) (pos_Rl (cons v13 v14) v22))) => and_ind (fun (v23 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10) (v24 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v24) (pos_Rl (cons v2 (cons v4 v5)) (S v24))) (pos_Rl (cons v13 v14) v24))) => and_ind (fun (v25 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10) (v26 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v26) (pos_Rl (cons v2 (cons v4 v5)) (S v26))) (pos_Rl (cons v13 v14) v26))) => and_ind (fun (v27 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14))) (v28 : forall (v28 : @nat) (v29 : (v28 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v28) (pos_Rl (cons v2 (cons v4 v5)) (S v28))) (pos_Rl (cons v13 v14) v28)) => eq_ind_r (fun v29 : @R => v29 = v10) (match Rle_dec v9 v10 as v29 in ({_} + {_}) return (match v29 as v30 in ({_} + {_}) return (@R) with | left v30 => (fun v30 : v9 <= v10 => v9) v30 | right v30 => (fun v30 : ~ v9 <= v10 => v10) v30 end = v10) with | left v29 => (fun v29 : v9 <= v10 => v12) v29 | right v29 => (fun v29 : ~ v9 <= v10 => eq_refl) v29 end : Rmin v9 v10 = v10) v23) v26) v24) v22) v20) v19))) v18) v17) : Int_SF (cons v13 v14) (cons v2 (cons v4 v5)) = IZR 0) v8 v11) v3) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P9	100	0.527046	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4) (v6 : v0 <> v1) => let v7 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7)) := v5 in (fun v8 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v4 v8)) => and_ind (fun (v9 : ordered_Rlist v3) (v10 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v10) (pos_Rl v3 (S v10))) (pos_Rl v4 v10))) => and_ind (fun (v11 : pos_Rl v3 0 = Rmin v0 v1) (v12 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v12) (pos_Rl v3 (S v12))) (pos_Rl v4 v12))) => and_ind (fun (v13 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v14 : Rlength v3 = S (Rlength v4) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v14) (pos_Rl v3 (S v14))) (pos_Rl v4 v14))) => and_ind (fun (v15 : Rlength v3 = S (Rlength v4)) (v16 : forall (v16 : @nat) (v17 : (v16 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v16) (pos_Rl v3 (S v16))) (pos_Rl v4 v16)) => Rlist_ind (fun v17 : @Rlist => forall (v18 : ordered_Rlist v17) (v19 : pos_Rl v17 0 = Rmin v0 v1) (v20 : pos_Rl v17 (Init.Nat.pred (Rlength v17)) = Rmax v0 v1) (v21 : Rlength v17 = S (Rlength v4)) (v22 : forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength v17))%nat), constant_D_eq v2 (open_interval (pos_Rl v17 v22) (pos_Rl v17 (S v22))) (pos_Rl v4 v22)), (2 <= Rlength v17)%nat) (fun (v17 : ordered_Rlist (@nil)) (v18 : pos_Rl (@nil) 0 = Rmin v0 v1) (v19 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v0 v1) (v20 : Rlength (@nil) = S (Rlength v4)) (v21 : forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v2 (open_interval (pos_Rl (@nil) v21) (pos_Rl (@nil) (S v21))) (pos_Rl v4 v21)) => let v22 : @False := eq_ind 0%nat (fun v22 : @nat => match v22 as v23 in nat return Prop with | 0%nat => @True | S v23 => (fun v23 : @nat => @False) v23 end) (@I) (S (Rlength v4)) v20 in False_ind (2 <= Rlength (@nil))%nat v22) (fun (v17 : @R) (v18 : @Rlist) (v19 : forall (v19 : ordered_Rlist v18) (v20 : pos_Rl v18 0 = Rmin v0 v1) (v21 : pos_Rl v18 (Init.Nat.pred (Rlength v18)) = Rmax v0 v1) (v22 : Rlength v18 = S (Rlength v4)) (v23 : forall (v23 : @nat) (v24 : (v23 < Init.Nat.pred (Rlength v18))%nat), constant_D_eq v2 (open_interval (pos_Rl v18 v23) (pos_Rl v18 (S v23))) (pos_Rl v4 v23)), (2 <= Rlength v18)%nat) (v20 : ordered_Rlist (cons v17 v18)) (v21 : pos_Rl (cons v17 v18) 0 = Rmin v0 v1) (v22 : pos_Rl (cons v17 v18) (Init.Nat.pred (Rlength (cons v17 v18))) = Rmax v0 v1) (v23 : Rlength (cons v17 v18) = S (Rlength v4)) (v24 : forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v17 v18)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 v18) v24) (pos_Rl (cons v17 v18) (S v24))) (pos_Rl v4 v24)) => Rlist_ind (fun v25 : @Rlist => forall (v26 : ordered_Rlist (cons v17 v25)) (v27 : pos_Rl (cons v17 v25) 0 = Rmin v0 v1) (v28 : pos_Rl (cons v17 v25) (Init.Nat.pred (Rlength (cons v17 v25))) = Rmax v0 v1) (v29 : Rlength (cons v17 v25) = S (Rlength v4)) (v30 : forall (v30 : @nat) (v31 : (v30 < Init.Nat.pred (Rlength (cons v17 v25)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 v25) v30) (pos_Rl (cons v17 v25) (S v30))) (pos_Rl v4 v30)) (v31 : forall (v31 : ordered_Rlist v25) (v32 : pos_Rl v25 0 = Rmin v0 v1) (v33 : pos_Rl v25 (Init.Nat.pred (Rlength v25)) = Rmax v0 v1) (v34 : Rlength v25 = S (Rlength v4)) (v35 : forall (v35 : @nat) (v36 : (v35 < Init.Nat.pred (Rlength v25))%nat), constant_D_eq v2 (open_interval (pos_Rl v25 v35) (pos_Rl v25 (S v35))) (pos_Rl v4 v35)), (2 <= Rlength v25)%nat), (2 <= Rlength (cons v17 v25))%nat) (fun (v25 : ordered_Rlist (cons v17 (@nil))) (v26 : pos_Rl (cons v17 (@nil)) 0 = Rmin v0 v1) (v27 : pos_Rl (cons v17 (@nil)) (Init.Nat.pred (Rlength (cons v17 (@nil)))) = Rmax v0 v1) (v28 : Rlength (cons v17 (@nil)) = S (Rlength v4)) (v29 : forall (v29 : @nat) (v30 : (v29 < Init.Nat.pred (Rlength (cons v17 (@nil))))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 (@nil)) v29) (pos_Rl (cons v17 (@nil)) (S v29))) (pos_Rl v4 v29)) (v30 : forall (v30 : ordered_Rlist (@nil)) (v31 : pos_Rl (@nil) 0 = Rmin v0 v1) (v32 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v0 v1) (v33 : Rlength (@nil) = S (Rlength v4)) (v34 : forall (v34 : @nat) (v35 : (v34 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v2 (open_interval (pos_Rl (@nil) v34) (pos_Rl (@nil) (S v34))) (pos_Rl v4 v34)), (2 <= Rlength (@nil))%nat) => ((match Rle_dec v0 v1 as v31 in ({_} + {_}) return (forall (v32 : v17 = match v31 as v32 in ({_} + {_}) return (@R) with | left v32 => (fun v32 : v0 <= v1 => v1) v32 | right v32 => (fun v32 : ~ v0 <= v1 => v0) v32 end) (v33 : v17 = match v31 as v33 in ({_} + {_}) return (@R) with | left v33 => (fun v33 : v0 <= v1 => v0) v33 | right v33 => (fun v33 : ~ v0 <= v1 => v1) v33 end), (2 <= Rlength (cons v17 (@nil)))%nat) with | left v31 => (fun (v31 : v0 <= v1) (v32 : v17 = v1) (v33 : v17 = v0) => False_ind (2 <= Rlength (cons v17 (@nil)))%nat (v6 (eq_ind v17 (fun v34 : @R => v0 = v34) (eq_ind v17 (fun v34 : @R => v34 = v17) eq_refl v0 v33) v1 v32))) v31 | right v31 => (fun (v31 : ~ v0 <= v1) (v32 : v17 = v0) (v33 : v17 = v1) => False_ind (2 <= Rlength (cons v17 (@nil)))%nat (v6 (eq_ind v17 (fun v34 : @R => v34 = v1) (eq_ind v17 (fun v34 : @R => v17 = v34) eq_refl v1 v33) v0 v32))) v31 end : forall (v31 : v17 = Rmax v0 v1) (v32 : v17 = match Rle_dec v0 v1 as v32 in ({_} + {_}) return (@R) with | left v32 => (fun v32 : v0 <= v1 => v0) v32 | right v32 => (fun v32 : ~ v0 <= v1 => v1) v32 end), (2 <= Rlength (cons v17 (@nil)))%nat) : forall (v31 : v17 = Rmax v0 v1) (v32 : v17 = Rmin v0 v1), (2 <= Rlength (cons v17 (@nil)))%nat) v27 v26) (fun (v25 : @R) (v26 : @Rlist) (v27 : forall (v27 : ordered_Rlist (cons v17 v26)) (v28 : pos_Rl (cons v17 v26) 0 = Rmin v0 v1) (v29 : pos_Rl (cons v17 v26) (Init.Nat.pred (Rlength (cons v17 v26))) = Rmax v0 v1) (v30 : Rlength (cons v17 v26) = S (Rlength v4)) (v31 : forall (v31 : @nat) (v32 : (v31 < Init.Nat.pred (Rlength (cons v17 v26)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 v26) v31) (pos_Rl (cons v17 v26) (S v31))) (pos_Rl v4 v31)) (v32 : forall (v32 : ordered_Rlist v26) (v33 : pos_Rl v26 0 = Rmin v0 v1) (v34 : pos_Rl v26 (Init.Nat.pred (Rlength v26)) = Rmax v0 v1) (v35 : Rlength v26 = S (Rlength v4)) (v36 : forall (v36 : @nat) (v37 : (v36 < Init.Nat.pred (Rlength v26))%nat), constant_D_eq v2 (open_interval (pos_Rl v26 v36) (pos_Rl v26 (S v36))) (pos_Rl v4 v36)), (2 <= Rlength v26)%nat), (2 <= Rlength (cons v17 v26))%nat) (v28 : ordered_Rlist (cons v17 (cons v25 v26))) (v29 : pos_Rl (cons v17 (cons v25 v26)) 0 = Rmin v0 v1) (v30 : pos_Rl (cons v17 (cons v25 v26)) (Init.Nat.pred (Rlength (cons v17 (cons v25 v26)))) = Rmax v0 v1) (v31 : Rlength (cons v17 (cons v25 v26)) = S (Rlength v4)) (v32 : forall (v32 : @nat) (v33 : (v32 < Init.Nat.pred (Rlength (cons v17 (cons v25 v26))))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 (cons v25 v26)) v32) (pos_Rl (cons v17 (cons v25 v26)) (S v32))) (pos_Rl v4 v32)) (v33 : forall (v33 : ordered_Rlist (cons v25 v26)) (v34 : pos_Rl (cons v25 v26) 0 = Rmin v0 v1) (v35 : pos_Rl (cons v25 v26) (Init.Nat.pred (Rlength (cons v25 v26))) = Rmax v0 v1) (v36 : Rlength (cons v25 v26) = S (Rlength v4)) (v37 : forall (v37 : @nat) (v38 : (v37 < Init.Nat.pred (Rlength (cons v25 v26)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v25 v26) v37) (pos_Rl (cons v25 v26) (S v37))) (pos_Rl v4 v37)), (2 <= Rlength (cons v25 v26))%nat) => le_n_S 1 (S (Rlength v26)) (le_n_S 0 (Rlength v26) (Nat.le_0_l (Rlength v26))) : (2 <= Rlength (cons v17 (cons v25 v26)))%nat) v18 v20 v21 v22 v23 v24 v19) v3 v9 v11 v13 v15 v16) v14) v12) v10) v8) v7)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P10	100	5.108106	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P11	100	1.456774	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P12	100	0.671921	1	1	0	synth with cache (only 1: refine (((fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : (ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v5) (pos_Rl v3 (S v5))) (pos_Rl v4 v5))) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v5 <> pos_Rl v4 (S v5) \/ v2 (pos_Rl v3 (S v5)) <> pos_Rl v4 v5) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v5 <> pos_Rl v3 (S v5))) => let v6 : (ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v6) (pos_Rl v3 (S v6))) (pos_Rl v4 v6))) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v6 <> pos_Rl v4 (S v6) \/ v2 (pos_Rl v3 (S v6)) <> pos_Rl v4 v6) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v6 <> pos_Rl v3 (S v6)) := v5 in (fun v7 : (ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7))) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v7 <> pos_Rl v4 (S v7) \/ v2 (pos_Rl v3 (S v7)) <> pos_Rl v4 v7) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v7 <> pos_Rl v3 (S v7)) => and_ind (fun (v8 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v4 v8))) (v9 : (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v9 <> pos_Rl v4 (S v9) \/ v2 (pos_Rl v3 (S v9)) <> pos_Rl v4 v9) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v9 <> pos_Rl v3 (S v9))) => and_ind (fun (v10 : ordered_Rlist v3) (v11 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v11) (pos_Rl v3 (S v11))) (pos_Rl v4 v11))) => and_ind (fun (v12 : pos_Rl v3 0 = Rmin v0 v1) (v13 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v13) (pos_Rl v3 (S v13))) (pos_Rl v4 v13))) => and_ind (fun (v14 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v15 : Rlength v3 = S (Rlength v4) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v4 v15))) => and_ind (fun (v16 : Rlength v3 = S (Rlength v4)) (v17 : forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v17) (pos_Rl v3 (S v17))) (pos_Rl v4 v17)) => and_ind (fun (v18 : forall (v18 : @nat) (v19 : (v18 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v18 <> pos_Rl v4 (S v18) \/ v2 (pos_Rl v3 (S v18)) <> pos_Rl v4 v18) (v19 : forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v19 <> pos_Rl v3 (S v19)) => conj (conj v10 (conj (eq_ind_r (fun v20 : @R => v20 = Rmin v1 v0) (match Rle_dec v0 v1 as v20 in ({_} + {_}) return (match v20 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v0 <= v1 => v0) v21 | right v21 => (fun v21 : ~ v0 <= v1 => v1) v21 end = match Rle_dec v1 v0 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v1 <= v0 => v1) v21 | right v21 => (fun v21 : ~ v1 <= v0 => v0) v21 end) with | left v20 => (fun v20 : v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v0 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v1) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v0) v22 end) with | left v21 => (fun v21 : v1 <= v0 => Rle_antisym v0 v1 v20 v21) v21 | right v21 => (fun v21 : ~ v1 <= v0 => eq_refl) v21 end) v20 | right v20 => (fun v20 : ~ v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v1 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v1) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v0) v22 end) with | left v21 => (fun v21 : v1 <= v0 => eq_refl) v21 | right v21 => (fun v21 : ~ v1 <= v0 => Rle_antisym v1 v0 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v20)) (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v21))) v21 end) v20 end : Rmin v0 v1 = Rmin v1 v0) v12) (conj (eq_ind_r (fun v20 : @R => v20 = Rmax v1 v0) (match Rle_dec v0 v1 as v20 in ({_} + {_}) return (match v20 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v0 <= v1 => v1) v21 | right v21 => (fun v21 : ~ v0 <= v1 => v0) v21 end = match Rle_dec v1 v0 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v1 <= v0 => v0) v21 | right v21 => (fun v21 : ~ v1 <= v0 => v1) v21 end) with | left v20 => (fun v20 : v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v1 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v0) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v1) v22 end) with | left v21 => (fun v21 : v1 <= v0 => Rle_antisym v1 v0 v21 v20) v21 | right v21 => (fun v21 : ~ v1 <= v0 => eq_refl) v21 end) v20 | right v20 => (fun v20 : ~ v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v0 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v0) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v1) v22 end) with | left v21 => (fun v21 : v1 <= v0 => eq_refl) v21 | right v21 => (fun v21 : ~ v1 <= v0 => Rle_antisym v0 v1 (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v21)) (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v20))) v21 end) v20 end : Rmax v0 v1 = Rmax v1 v0) v14) (conj v16 v17)))) (conj v18 v19)) v9) v15) v13) v11) v8) v7) v6) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4 /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v5 <> pos_Rl v4 (S v5) \/ v2 (pos_Rl v3 (S v5)) <> pos_Rl v4 v5) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v5 <> pos_Rl v3 (S v5))), adapted_couple v2 v1 v0 v3 v4 /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v6 <> pos_Rl v4 (S v6) \/ v2 (pos_Rl v3 (S v6)) <> pos_Rl v4 v6) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v6 <> pos_Rl v3 (S v6))) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple_opt v2 v0 v1 v3 v4), adapted_couple_opt v2 v1 v0 v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P13	100	0.121337	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 v5 v6 v7 : @R) (v8 v9 v10 v11 : @Rlist) (v12 : forall v12 : @R, @R) (v13 : v0 <> v1) (v14 : adapted_couple v12 v0 v1 (cons v2 (cons v3 v8)) (cons v4 v9)) (v15 : adapted_couple_opt v12 v0 v1 (cons v5 (cons v6 v10)) (cons v7 v11)) => let v16 : {v0 < v1} + {v0 = v1} + {v1 < v0} := total_order_T v0 v1 in match v16 as v17 in (_ + {_}) return (v3 <= v6) with | inleft v17 => (fun v17 : {v0 < v1} + {v0 = v1} => match v17 as v18 in ({_} + {_}) return (v3 <= v6) with | left v18 => (fun v18 : v0 < v1 => StepFun_P11 v18 v14 v15) v18 | right v18 => (fun v18 : v0 = v1 => False_ind (v3 <= v6) (v13 v18)) v18 end) v17 | inright v17 => (fun v17 : v1 < v0 => StepFun_P11 v17 (StepFun_P2 v14) (StepFun_P12 v15)) v17 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P14	100	3.845387	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P15	100	0.098098	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 v4 : @Rlist) (v5 v6 : @R) (v7 : adapted_couple v0 v5 v6 v1 v3) (v8 : adapted_couple_opt v0 v5 v6 v2 v4) => let v9 : {v5 <= v6} + {~ v5 <= v6} := Rle_dec v5 v6 in match v9 as v10 in ({_} + {_}) return (Int_SF v3 v1 = Int_SF v4 v2) with | left v10 => (fun v10 : v5 <= v6 => StepFun_P14 v10 v7 v8) v10 | right v10 => (fun v10 : ~ v5 <= v6 => let v11 : v6 <= v5 := Rlt_le v6 v5 (Rnot_le_lt v5 v6 v10) in StepFun_P14 v11 (StepFun_P2 v7) (StepFun_P12 v8)) v10 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P16	100	0.088391	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 : @Rlist) (v3 v4 : @R) (v5 : adapted_couple v0 v3 v4 v1 v2) => let v6 : {v3 <= v4} + {~ v3 <= v4} := Rle_dec v3 v4 in match v6 as v7 in ({_} + {_}) return (exists v8 v9 : @Rlist, adapted_couple_opt v0 v3 v4 v8 v9) with | left v7 => (fun v7 : v3 <= v4 => StepFun_P10 v7 v5) v7 | right v7 => (fun v7 : ~ v3 <= v4 => let v8 : v4 <= v3 := Rlt_le v4 v3 (Rnot_le_lt v3 v4 v7) in let v9 : exists v9 v10 : @Rlist, adapted_couple_opt v0 v4 v3 v9 v10 := StepFun_P10 v8 (StepFun_P2 v5) in ex_ind (fun (v10 : @Rlist) (v11 : exists v11 : @Rlist, adapted_couple_opt v0 v4 v3 v10 v11) => match v11 as v12 in (ex _) return (exists v13 v14 : @Rlist, adapted_couple_opt v0 v3 v4 v13 v14) with | ex_intro _ v12 v13 => (fun (v12 : @Rlist) (v13 : adapted_couple_opt v0 v4 v3 v10 v12) => ex_intro (fun v14 : @Rlist => exists v15 : @Rlist, adapted_couple_opt v0 v3 v4 v14 v15) v10 (ex_intro (fun v14 : @Rlist => adapted_couple_opt v0 v3 v4 v10 v14) v12 (StepFun_P12 v13))) v12 v13 end) v9) v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P17	100	0.078082	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 v4 : @Rlist) (v5 v6 : @R) (v7 : adapted_couple v0 v5 v6 v1 v3) (v8 : adapted_couple v0 v5 v6 v2 v4) => ex_ind (fun (v9 : @Rlist) (v10 : exists v10 : @Rlist, adapted_couple_opt v0 v5 v6 v9 v10) => match v10 as v11 in (ex _) return (Int_SF v3 v1 = Int_SF v4 v2) with | ex_intro _ v11 v12 => (fun (v11 : @Rlist) (v12 : adapted_couple_opt v0 v5 v6 v9 v11) => eq_ind_r (fun v13 : @R => v13 = Int_SF v4 v2) (eq_ind_r (fun v13 : @R => Int_SF v11 v9 = v13) eq_refl (StepFun_P15 v8 v12)) (StepFun_P15 v7 v12)) v11 v12 end) (StepFun_P16 v7))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P18	100	0.241047	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => match Rle_dec v0 v1 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 <= v1 => Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4 | right v4 => (fun v4 : ~ v0 <= v1 => - Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4 end = v2 * (v1 - v0)) with | left v3 => (fun v3 : v0 <= v1 => let v4 : Int_SF (cons v2 (@nil)) (cons v0 (cons v1 (@nil))) = Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) := StepFun_P17 (StepFun_P3 v2 v3) (StepFun_P1 {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) in eq_ind (Int_SF (cons v2 (@nil)) (cons v0 (cons v1 (@nil)))) (fun v5 : @R => v5 = v2 * (v1 - v0)) ((let v5 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v6 : list (@R) := (v2 :: v1 :: v0 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v6 v5 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (@I) (eq_refl : (let v7 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v5 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))))) = @true)) : Int_SF (cons v2 (@nil)) (cons v0 (cons v1 (@nil))) = v2 * (v1 - v0)) (Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4) v3 | right v3 => (fun v3 : ~ v0 <= v1 => let v4 : Int_SF (cons v2 (@nil)) (cons v1 (cons v0 (@nil))) = Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) := StepFun_P17 (StepFun_P2 (StepFun_P3 v2 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v3)))) (StepFun_P1 {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) in eq_ind (Int_SF (cons v2 (@nil)) (cons v1 (cons v0 (@nil)))) (fun v5 : @R => - v5 = v2 * (v1 - v0)) ((let v5 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v6 : list (@R) := (v2 :: v0 :: v1 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v6 v5 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 2))) (@I) (eq_refl : (let v7 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v5 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 2))))) = @true)) : - Int_SF (cons v2 (@nil)) (cons v1 (cons v0 (@nil))) = v2 * (v1 - v0)) (Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4) v3 end : RiemannInt_SF {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |} = v2 * (v1 - v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P19	100	0.336220	1	1	0	synth with cache (only 1: refine (fun (v0 : @Rlist) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 : @R) => Rlist_ind (fun v4 : @Rlist => Int_SF (FF v4 (fun v5 : @R => v1 v5 + v3 * v2 v5)) v4 = Int_SF (FF v4 v1) v4 + v3 * Int_SF (FF v4 v2) v4) ((let v4 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v5 : list (@R) := (v3 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v5 v4 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))) (@I) (eq_refl : (let v6 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))))) = @true)) : Int_SF (FF (@nil) (fun v4 : @R => v1 v4 + v3 * v2 v4)) (@nil) = Int_SF (FF (@nil) v1) (@nil) + v3 * Int_SF (FF (@nil) v2) (@nil)) (fun (v4 : @R) (v5 : @Rlist) (v6 : Int_SF (FF v5 (fun v6 : @R => v1 v6 + v3 * v2 v6)) v5 = Int_SF (FF v5 v1) v5 + v3 * Int_SF (FF v5 v2) v5) => Rlist_ind (fun v7 : @Rlist => forall v8 : Int_SF (FF v7 (fun v8 : @R => v1 v8 + v3 * v2 v8)) v7 = Int_SF (FF v7 v1) v7 + v3 * Int_SF (FF v7 v2) v7, Int_SF (FF (cons v4 v7) (fun v9 : @R => v1 v9 + v3 * v2 v9)) (cons v4 v7) = Int_SF (FF (cons v4 v7) v1) (cons v4 v7) + v3 * Int_SF (FF (cons v4 v7) v2) (cons v4 v7)) (fun v7 : Int_SF (FF (@nil) (fun v7 : @R => v1 v7 + v3 * v2 v7)) (@nil) = Int_SF (FF (@nil) v1) (@nil) + v3 * Int_SF (FF (@nil) v2) (@nil) => (let v8 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v9 : list (@R) := (v3 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v9 v8 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))) (@I) (eq_refl : (let v10 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v8 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))))) = @true)) : Int_SF (FF (cons v4 (@nil)) (fun v8 : @R => v1 v8 + v3 * v2 v8)) (cons v4 (@nil)) = Int_SF (FF (cons v4 (@nil)) v1) (cons v4 (@nil)) + v3 * Int_SF (FF (cons v4 (@nil)) v2) (cons v4 (@nil))) (fun (v7 : @R) (v8 : @Rlist) (v9 : forall v9 : Int_SF (FF v8 (fun v9 : @R => v1 v9 + v3 * v2 v9)) v8 = Int_SF (FF v8 v1) v8 + v3 * Int_SF (FF v8 v2) v8, Int_SF (FF (cons v4 v8) (fun v10 : @R => v1 v10 + v3 * v2 v10)) (cons v4 v8) = Int_SF (FF (cons v4 v8) v1) (cons v4 v8) + v3 * Int_SF (FF (cons v4 v8) v2) (cons v4 v8)) (v10 : Int_SF (FF (cons v7 v8) (fun v10 : @R => v1 v10 + v3 * v2 v10)) (cons v7 v8) = Int_SF (FF (cons v7 v8) v1) (cons v7 v8) + v3 * Int_SF (FF (cons v7 v8) v2) (cons v7 v8)) => eq_ind_r (fun v11 : @R => (v1 ((v4 + v7) / IZR 2) + v3 * v2 ((v4 + v7) / IZR 2)) * (v7 - v4) + v11 = v1 ((v4 + v7) / IZR 2) * (v7 - v4) + Int_SF (app_Rlist (mid_Rlist v8 v7) v1) (cons v7 v8) + v3 * (v2 ((v4 + v7) / IZR 2) * (v7 - v4) + Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8))) (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v12 : list (@R) := (v1 ((v4 + v7) / IZR 2) :: v3 :: v2 ((v4 + v7) / IZR 2) :: v7 :: v4 :: Int_SF (app_Rlist (mid_Rlist v8 v7) v1) (cons v7 v8) :: Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v12 v11 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 7)))) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 7)))) (@I) (eq_refl : (let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 7))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 7)))))) = @true)) v10 : Int_SF (FF (cons v4 (cons v7 v8)) (fun v11 : @R => v1 v11 + v3 * v2 v11)) (cons v4 (cons v7 v8)) = Int_SF (FF (cons v4 (cons v7 v8)) v1) (cons v4 (cons v7 v8)) + v3 * Int_SF (FF (cons v4 (cons v7 v8)) v2) (cons v4 (cons v7 v8))) v5 v6) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P20	100	0.063842	1	1	0	synth with cache (only 1: refine (fun (v0 : @Rlist) (v1 : forall v1 : @R, @R) (v2 : (0 < Rlength v0)%nat) => Rlist_ind (fun v3 : @Rlist => forall v4 : (0 < Rlength v3)%nat, Rlength v3 = S (Rlength (FF v3 v1))) (fun v3 : (0 < Rlength (@nil))%nat => False_ind (Rlength (@nil) = S (Rlength (FF (@nil) v1))) (Nat.lt_irrefl 0 v3)) (fun (v3 : @R) (v4 : @Rlist) (v5 : forall v5 : (0 < Rlength v4)%nat, Rlength v4 = S (Rlength (FF v4 v1))) (v6 : (0 < Rlength (cons v3 v4))%nat) => eq_ind_r (fun v7 : @nat => S (Rlength v4) = S v7) (eq_ind_r (fun v7 : @nat => S (Rlength v4) = S v7) eq_refl (RList_P14 v4 v3)) (RList_P18 (mid_Rlist v4 v3) v1) : Rlength (cons v3 v4) = S (Rlength (FF (cons v3 v4) v1))) v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P21	100	0.714581	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : @Rlist) (v4 : is_subdivision v2 v0 v1 v3) => match v4 as v5 in (sigT _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | existT _ v5 v6 => (fun (v5 : @Rlist) (v6 : adapted_couple v2 v0 v1 v3 v5) => match v6 as v7 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v7 v8 => (fun (v7 : ordered_Rlist v3) (v8 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v5 v8))) => match v8 as v9 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v9 v10 => (fun (v9 : pos_Rl v3 0 = Rmin v0 v1) (v10 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v10) (pos_Rl v3 (S v10))) (pos_Rl v5 v10))) => match v10 as v11 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v11 v12 => (fun (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v12 : Rlength v3 = S (Rlength v5) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v12) (pos_Rl v3 (S v12))) (pos_Rl v5 v12))) => match v12 as v13 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v13 v14 => (fun (v13 : Rlength v3 = S (Rlength v5)) (v14 : forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v14) (pos_Rl v3 (S v14))) (pos_Rl v5 v14)) => conj v7 (conj v9 (conj v11 (conj (StepFun_P20 v3 v2 (eq_ind_r (fun v15 : @nat => (0 < v15)%nat) (Nat.lt_0_succ (Rlength v5)) v13)) (fun (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat) => let v17 : constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v5 v15) := v14 v15 v16 in ((fun (v18 : @R) (v19 : pos_Rl v3 v15 < v18 < pos_Rl v3 (S v15)) => Rlist_ind (fun v20 : @Rlist => forall (v21 : ordered_Rlist v20) (v22 : pos_Rl v20 0 = Rmin v0 v1) (v23 : pos_Rl v20 (Init.Nat.pred (Rlength v20)) = Rmax v0 v1) (v24 : Rlength v20 = S (Rlength v5)) (v25 : forall (v25 : @nat) (v26 : (v25 < Init.Nat.pred (Rlength v20))%nat), constant_D_eq v2 (open_interval (pos_Rl v20 v25) (pos_Rl v20 (S v25))) (pos_Rl v5 v25)) (v26 : (v15 < Init.Nat.pred (Rlength v20))%nat) (v27 : forall (v27 : @R) (v28 : pos_Rl v20 v15 < v27 < pos_Rl v20 (S v15)), v2 v27 = pos_Rl v5 v15) (v28 : pos_Rl v20 v15 < v18 < pos_Rl v20 (S v15)), v2 v18 = pos_Rl (FF v20 v2) v15) (fun (v20 : ordered_Rlist (@nil)) (v21 : pos_Rl (@nil) 0 = Rmin v0 v1) (v22 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v0 v1) (v23 : Rlength (@nil) = S (Rlength v5)) (v24 : forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v2 (open_interval (pos_Rl (@nil) v24) (pos_Rl (@nil) (S v24))) (pos_Rl v5 v24)) (v25 : (v15 < Init.Nat.pred (Rlength (@nil)))%nat) (v26 : forall (v26 : @R) (v27 : pos_Rl (@nil) v15 < v26 < pos_Rl (@nil) (S v15)), v2 v26 = pos_Rl v5 v15) (v27 : pos_Rl (@nil) v15 < v18 < pos_Rl (@nil) (S v15)) => let v28 : @False := eq_ind (Rlength (@nil)) (fun v28 : @nat => match v28 as v29 in nat return Prop with | 0%nat => @True | S v29 => (fun v29 : @nat => @False) v29 end) (@I) (S (Rlength v5)) v23 in False_ind (v2 v18 = pos_Rl (FF (@nil) v2) v15) v28) (fun (v20 : @R) (v21 : @Rlist) (v22 : forall (v22 : ordered_Rlist v21) (v23 : pos_Rl v21 0 = Rmin v0 v1) (v24 : pos_Rl v21 (Init.Nat.pred (Rlength v21)) = Rmax v0 v1) (v25 : Rlength v21 = S (Rlength v5)) (v26 : forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength v21))%nat), constant_D_eq v2 (open_interval (pos_Rl v21 v26) (pos_Rl v21 (S v26))) (pos_Rl v5 v26)) (v27 : (v15 < Init.Nat.pred (Rlength v21))%nat) (v28 : forall (v28 : @R) (v29 : pos_Rl v21 v15 < v28 < pos_Rl v21 (S v15)), v2 v28 = pos_Rl v5 v15) (v29 : pos_Rl v21 v15 < v18 < pos_Rl v21 (S v15)), v2 v18 = pos_Rl (FF v21 v2) v15) (v23 : ordered_Rlist (cons v20 v21)) (v24 : pos_Rl (cons v20 v21) 0 = Rmin v0 v1) (v25 : pos_Rl (cons v20 v21) (Init.Nat.pred (Rlength (cons v20 v21))) = Rmax v0 v1) (v26 : Rlength (cons v20 v21) = S (Rlength v5)) (v27 : forall (v27 : @nat) (v28 : (v27 < Init.Nat.pred (Rlength (cons v20 v21)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v20 v21) v27) (pos_Rl (cons v20 v21) (S v27))) (pos_Rl v5 v27)) (v28 : (v15 < Init.Nat.pred (Rlength (cons v20 v21)))%nat) (v29 : forall (v29 : @R) (v30 : pos_Rl (cons v20 v21) v15 < v29 < pos_Rl (cons v20 v21) (S v15)), v2 v29 = pos_Rl v5 v15) (v30 : pos_Rl (cons v20 v21) v15 < v18 < pos_Rl (cons v20 v21) (S v15)) => eq_ind_r (fun v31 : @R => v2 v18 = v31) (eq_ind_r (fun v31 : @R => v2 v18 = v2 v31) (eq_ind_r (fun v31 : @R => v31 = v2 ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2)) (eq_ind_r (fun v31 : @R => pos_Rl v5 v15 = v31) eq_refl (v29 ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) (conj (Rmult_lt_reg_l (IZR 2) (pos_Rl (cons v20 v21) v15) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < IZR 2 * v31) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < v31) (eq_ind (IZR 1) (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < v31 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (eq_ind_r (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < v31) (eq_ind_r (fun v31 : @R => v31 < pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) (Rplus_lt_compat_l (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) (S v15)) (and_ind (fun (v31 : pos_Rl (cons v20 v21) v15 < v18) (v32 : v18 < pos_Rl (cons v20 v21) (S v15)) => Rlt_trans (pos_Rl (cons v20 v21) v15) v18 (pos_Rl (cons v20 v21) (S v15)) v31 v32) v30)) (double (pos_Rl (cons v20 v21) v15))) (Rmult_1_l (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v31 : 2%Z = 0%Z => let v32 : @False := eq_ind 2%Z (fun v32 : @Z => match v32 as v33 in Z return Prop with | 0%Z => @False | Z.pos v33 => (fun v33 : @positive => @True) v33 | Z.neg v33 => (fun v33 : @positive => @False) v33 end) (@I) 0%Z v31 in False_ind (@False) v32) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) : IZR 2 * pos_Rl (cons v20 v21) v15 < IZR 2 * ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2))) (Rmult_lt_reg_l (IZR 2) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) (pos_Rl (cons v20 v21) (S v15)) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => IZR 2 * v31 < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => v31 < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind (IZR 1) (fun v31 : @R => v31 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind_r (fun v31 : @R => v31 < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind_r (fun v31 : @R => pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15) < v31) (eq_ind_r (fun v31 : @R => v31 < pos_Rl (cons v20 v21) (S v15) + pos_Rl (cons v20 v21) (S v15)) (Rplus_lt_compat_l (pos_Rl (cons v20 v21) (S v15)) (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) (S v15)) (and_ind (fun (v31 : pos_Rl (cons v20 v21) v15 < v18) (v32 : v18 < pos_Rl (cons v20 v21) (S v15)) => Rlt_trans (pos_Rl (cons v20 v21) v15) v18 (pos_Rl (cons v20 v21) (S v15)) v31 v32) v30)) (Rplus_comm (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) (S v15)))) (double (pos_Rl (cons v20 v21) (S v15)))) (Rmult_1_l (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v31 : 2%Z = 0%Z => let v32 : @False := eq_ind 2%Z (fun v32 : @Z => match v32 as v33 in Z return Prop with | 0%Z => @False | Z.pos v33 => (fun v33 : @positive => @True) v33 | Z.neg v33 => (fun v33 : @positive => @False) v33 end) (@I) 0%Z v31 in False_ind (@False) v32) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) : IZR 2 * ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) < IZR 2 * pos_Rl (cons v20 v21) (S v15)))))) (v29 v18 v30)) (RList_P13 (cons v20 v21) v15 v20 v28) : v2 v18 = v2 (pos_Rl (mid_Rlist v21 v20) v15)) (RList_P12 (mid_Rlist v21 v20) v15 v2 (eq_ind_r (fun v31 : @nat => (v15 < v31)%nat) v28 (RList_P14 v21 v20))) : v2 v18 = pos_Rl (FF (cons v20 v21) v2) v15) v3 v7 v9 v11 v13 v14 v16 v17 v19) : forall (v18 : @R) (v19 : open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15)) v18), v2 v18 = pos_Rl (FF v3 v2) v15) : constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl (FF v3 v2) v15)))))) v13 v14 end) v11 v12 end) v9 v10 end) v7 v8 end) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P22	100	2.552007	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P23	100	0.069406	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 : @Rlist) (v6 : is_subdivision v2 v0 v1 v4) (v7 : is_subdivision v3 v0 v1 v5) => match Rle_dec v0 v1 as v8 in ({_} + {_}) return (is_subdivision v2 v0 v1 (cons_ORlist v4 v5)) with | left v8 => (fun v8 : v0 <= v1 => StepFun_P22 v8 v6 v7) v8 | right v8 => (fun v8 : ~ v0 <= v1 => StepFun_P5 (StepFun_P22 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v8)) (StepFun_P5 v6) (StepFun_P5 v7))) v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P24	100	2.629085	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P25	100	0.069903	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 : @Rlist) (v6 : is_subdivision v2 v0 v1 v4) (v7 : is_subdivision v3 v0 v1 v5) => match Rle_dec v0 v1 as v8 in ({_} + {_}) return (is_subdivision v3 v0 v1 (cons_ORlist v4 v5)) with | left v8 => (fun v8 : v0 <= v1 => StepFun_P24 v8 v6 v7) v8 | right v8 => (fun v8 : ~ v0 <= v1 => StepFun_P5 (StepFun_P24 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v8)) (StepFun_P5 v6) (StepFun_P5 v7))) v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P26	100	1.020311	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : forall v3 : @R, @R) (v4 : forall v4 : @R, @R) (v5 : @Rlist) (v6 : is_subdivision v3 v0 v1 v5) => match v6 as v7 in (sigT _) return (forall v8 : is_subdivision v4 v0 v1 v5, is_subdivision (fun v9 : @R => v3 v9 + v2 * v4 v9) v0 v1 v5) with | existT _ v7 v8 => (fun (v7 : @Rlist) (v8 : adapted_couple v3 v0 v1 v5 v7) => match v8 as v9 in (_ /\ _) return (forall v10 : is_subdivision v4 v0 v1 v5, is_subdivision (fun v11 : @R => v3 v11 + v2 * v4 v11) v0 v1 v5) with | conj v9 v10 => (fun (v9 : ordered_Rlist v5) (v10 : pos_Rl v5 0 = Rmin v0 v1 /\ pos_Rl v5 (Init.Nat.pred (Rlength v5)) = Rmax v0 v1 /\ Rlength v5 = S (Rlength v7) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v3 (open_interval (pos_Rl v5 v10) (pos_Rl v5 (S v10))) (pos_Rl v7 v10))) => match v10 as v11 in (_ /\ _) return (forall v12 : is_subdivision v4 v0 v1 v5, is_subdivision (fun v13 : @R => v3 v13 + v2 * v4 v13) v0 v1 v5) with | conj v11 v12 => (fun (v11 : pos_Rl v5 0 = Rmin v0 v1) (v12 : pos_Rl v5 (Init.Nat.pred (Rlength v5)) = Rmax v0 v1 /\ Rlength v5 = S (Rlength v7) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v3 (open_interval (pos_Rl v5 v12) (pos_Rl v5 (S v12))) (pos_Rl v7 v12))) => match v12 as v13 in (_ /\ _) return (forall v14 : is_subdivision v4 v0 v1 v5, is_subdivision (fun v15 : @R => v3 v15 + v2 * v4 v15) v0 v1 v5) with | conj v13 v14 => (fun (v13 : pos_Rl v5 (Init.Nat.pred (Rlength v5)) = Rmax v0 v1) (v14 : Rlength v5 = S (Rlength v7) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v3 (open_interval (pos_Rl v5 v14) (pos_Rl v5 (S v14))) (pos_Rl v7 v14))) => match v14 as v15 in (_ /\ _) return (forall v16 : is_subdivision v4 v0 v1 v5, is_subdivision (fun v17 : @R => v3 v17 + v2 * v4 v17) v0 v1 v5) with | conj v15 v16 => (fun (v15 : Rlength v5 = S (Rlength v7)) (v16 : forall (v16 : @nat) (v17 : (v16 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v3 (open_interval (pos_Rl v5 v16) (pos_Rl v5 (S v16))) (pos_Rl v7 v16)) (v17 : is_subdivision v4 v0 v1 v5) => match v17 as v18 in (sigT _) return (is_subdivision (fun v19 : @R => v3 v19 + v2 * v4 v19) v0 v1 v5) with | existT _ v18 v19 => (fun (v18 : @Rlist) (v19 : adapted_couple v4 v0 v1 v5 v18) => match v19 as v20 in (_ /\ _) return (is_subdivision (fun v21 : @R => v3 v21 + v2 * v4 v21) v0 v1 v5) with | conj v20 v21 => (fun (v20 : ordered_Rlist v5) (v21 : pos_Rl v5 0 = Rmin v0 v1 /\ pos_Rl v5 (Init.Nat.pred (Rlength v5)) = Rmax v0 v1 /\ Rlength v5 = S (Rlength v18) /\ (forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v4 (open_interval (pos_Rl v5 v21) (pos_Rl v5 (S v21))) (pos_Rl v18 v21))) => match v21 as v22 in (_ /\ _) return (is_subdivision (fun v23 : @R => v3 v23 + v2 * v4 v23) v0 v1 v5) with | conj v22 v23 => (fun (v22 : pos_Rl v5 0 = Rmin v0 v1) (v23 : pos_Rl v5 (Init.Nat.pred (Rlength v5)) = Rmax v0 v1 /\ Rlength v5 = S (Rlength v18) /\ (forall (v23 : @nat) (v24 : (v23 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v4 (open_interval (pos_Rl v5 v23) (pos_Rl v5 (S v23))) (pos_Rl v18 v23))) => match v23 as v24 in (_ /\ _) return (is_subdivision (fun v25 : @R => v3 v25 + v2 * v4 v25) v0 v1 v5) with | conj v24 v25 => (fun (v24 : pos_Rl v5 (Init.Nat.pred (Rlength v5)) = Rmax v0 v1) (v25 : Rlength v5 = S (Rlength v18) /\ (forall (v25 : @nat) (v26 : (v25 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v4 (open_interval (pos_Rl v5 v25) (pos_Rl v5 (S v25))) (pos_Rl v18 v25))) => match v25 as v26 in (_ /\ _) return (is_subdivision (fun v27 : @R => v3 v27 + v2 * v4 v27) v0 v1 v5) with | conj v26 v27 => (fun (v26 : Rlength v5 = S (Rlength v18)) (v27 : forall (v27 : @nat) (v28 : (v27 < Init.Nat.pred (Rlength v5))%nat), constant_D_eq v4 (open_interval (pos_Rl v5 v27) (pos_Rl v5 (S v27))) (pos_Rl v18 v27)) => existT (fun v28 : @Rlist => adapted_couple (fun v29 : @R => v3 v29 + v2 * v4 v29) v0 v1 v5 v28) (FF v5 (fun v28 : @R => v3 v28 + v2 * v4 v28)) (conj v9 (conj v11 (conj v13 (conj (StepFun_P20 v5 (fun v28 : @R => v3 v28 + v2 * v4 v28) (eq_ind_r (fun v28 : @nat => (0 < v28)%nat) (gt_le_S 0 (S (Rlength v7)) ((lt_le_S 0 (S (Rlength v7)) (Nat.lt_0_succ (Rlength v7)) : (0 < S (Rlength v7))%nat) : (S (Rlength v7) > 0)%nat) : (0 < S (Rlength v7))%nat) v15)) (fun (v28 : @nat) (v29 : (v28 < Init.Nat.pred (Rlength v5))%nat) => (fun (v30 : @R) (v31 : open_interval (pos_Rl v5 v28) (pos_Rl v5 (S v28)) v30) => eq_ind_r (fun v32 : @R => v3 v30 + v2 * v32 = pos_Rl (FF v5 (fun v33 : @R => v3 v33 + v2 * v4 v33)) v28) (eq_ind_r (fun v32 : @R => v32 + v2 * pos_Rl v18 v28 = pos_Rl (FF v5 (fun v33 : @R => v3 v33 + v2 * v4 v33)) v28) (let v32 : v5 <> @nil := (fun v32 : v5 = @nil => let v33 : (v28 < Init.Nat.pred (Rlength (@nil)))%nat := eq_ind v5 (fun v33 : @Rlist => (v28 < Init.Nat.pred (Rlength v33))%nat) v29 (@nil) v32 in False_ind (@False) (Nat.nlt_0_r v28 v33)) : v5 <> @nil in let v33 : exists (v33 : @R) (v34 : @Rlist), v5 = cons v33 v34 := RList_P19 v5 v32 in match v33 as v34 in (ex _) return (pos_Rl v7 v28 + v2 * pos_Rl v18 v28 = pos_Rl (FF v5 (fun v35 : @R => v3 v35 + v2 * v4 v35)) v28) with | ex_intro _ v34 v35 => (fun (v34 : @R) (v35 : exists v35 : @Rlist, v5 = cons v34 v35) => match v35 as v36 in (ex _) return (pos_Rl v7 v28 + v2 * pos_Rl v18 v28 = pos_Rl (FF v5 (fun v37 : @R => v3 v37 + v2 * v4 v37)) v28) with | ex_intro _ v36 v37 => (fun (v36 : @Rlist) (v37 : v5 = cons v34 v36) => eq_ind_r (fun v38 : @Rlist => pos_Rl v7 v28 + v2 * pos_Rl v18 v28 = pos_Rl (FF v38 (fun v39 : @R => v3 v39 + v2 * v4 v39)) v28) (eq_ind_r (fun v38 : @R => pos_Rl v7 v28 + v2 * pos_Rl v18 v28 = v38) (eq_ind_r (fun v38 : @R => pos_Rl v7 v28 + v2 * pos_Rl v18 v28 = v3 v38 + v2 * v4 v38) (eq_ind v5 (fun v38 : @Rlist => pos_Rl v7 v28 + v2 * pos_Rl v18 v28 = v3 ((pos_Rl v38 v28 + pos_Rl v38 (S v28)) / IZR 2) + v2 * v4 ((pos_Rl v38 v28 + pos_Rl v38 (S v28)) / IZR 2)) ((fun v38 : v4 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) = pos_Rl v18 v28 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER RelationClasses.eq_equivalence) (v3 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) + v2 * v4 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2)) (v3 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) + v2 * pos_Rl v18 v28) (Morphisms.Reflexive_partial_app_morphism (Morphisms.reflexive_proper (@Rplus)) (Morphisms.eq_proper_proxy (v3 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2))) (v2 * v4 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2)) (v2 * pos_Rl v18 v28) (Morphisms.Reflexive_partial_app_morphism (Morphisms.reflexive_proper (@Rmult)) (Morphisms.eq_proper_proxy v2) (v4 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2)) (pos_Rl v18 v28) v38))) (v27 v28 v29 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) (and_ind (fun (v38 : pos_Rl v5 v28 < v30) (v39 : v30 < pos_Rl v5 (S v28)) => conj (Rmult_lt_reg_l (IZR 2) (pos_Rl v5 v28) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < IZR 2 * v40) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < v40) (eq_ind (IZR 1) (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < v40 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (eq_ind_r (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < v40) (eq_ind_r (fun v40 : @R => v40 < pos_Rl v5 v28 + pos_Rl v5 (S v28)) (Rplus_lt_compat_l (pos_Rl v5 v28) (pos_Rl v5 v28) (pos_Rl v5 (S v28)) (Rlt_trans (pos_Rl v5 v28) v30 (pos_Rl v5 (S v28)) v38 v39)) (double (pos_Rl v5 v28))) (Rmult_1_l (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v40 : 2%Z = 0%Z => let v41 : @False := eq_ind 2%Z (fun v41 : @Z => match v41 as v42 in Z return Prop with | 0%Z => @False | Z.pos v42 => (fun v42 : @positive => @True) v42 | Z.neg v42 => (fun v42 : @positive => @False) v42 end) (@I) 0%Z v40 in False_ind (@False) v41) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28))) : IZR 2 * pos_Rl v5 v28 < IZR 2 * ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2))) (Rmult_lt_reg_l (IZR 2) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) (pos_Rl v5 (S v28)) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => IZR 2 * v40 < IZR 2 * pos_Rl v5 (S v28)) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => v40 < IZR 2 * pos_Rl v5 (S v28)) (eq_ind (IZR 1) (fun v40 : @R => v40 * (pos_Rl v5 v28 + pos_Rl v5 (S v28)) < IZR 2 * pos_Rl v5 (S v28)) (eq_ind_r (fun v40 : @R => v40 < IZR 2 * pos_Rl v5 (S v28)) (eq_ind_r (fun v40 : @R => pos_Rl v5 v28 + pos_Rl v5 (S v28) < v40) (eq_ind_r (fun v40 : @R => v40 < pos_Rl v5 (S v28) + pos_Rl v5 (S v28)) (Rplus_lt_compat_l (pos_Rl v5 (S v28)) (pos_Rl v5 v28) (pos_Rl v5 (S v28)) (Rlt_trans (pos_Rl v5 v28) v30 (pos_Rl v5 (S v28)) v38 v39)) (Rplus_comm (pos_Rl v5 v28) (pos_Rl v5 (S v28)))) (double (pos_Rl v5 (S v28)))) (Rmult_1_l (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v40 : 2%Z = 0%Z => let v41 : @False := eq_ind 2%Z (fun v41 : @Z => match v41 as v42 in Z return Prop with | 0%Z => @False | Z.pos v42 => (fun v42 : @positive => @True) v42 | Z.neg v42 => (fun v42 : @positive => @False) v42 end) (@I) 0%Z v40 in False_ind (@False) v41) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28))) : IZR 2 * ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) < IZR 2 * pos_Rl v5 (S v28)))) v31)) ((fun v38 : v3 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) = pos_Rl v7 v28 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER RelationClasses.eq_equivalence) (v3 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) + v2 * pos_Rl v18 v28) (pos_Rl v7 v28 + v2 * pos_Rl v18 v28) (Morphisms.reflexive_proper (@Rplus) (v3 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2)) (pos_Rl v7 v28) v38 (v2 * pos_Rl v18 v28) (v2 * pos_Rl v18 v28) (Morphisms.eq_proper_proxy (v2 * pos_Rl v18 v28)))) (v16 v28 v29 ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) (and_ind (fun (v38 : pos_Rl v5 v28 < v30) (v39 : v30 < pos_Rl v5 (S v28)) => conj (Rmult_lt_reg_l (IZR 2) (pos_Rl v5 v28) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < IZR 2 * v40) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < v40) (eq_ind (IZR 1) (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < v40 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (eq_ind_r (fun v40 : @R => IZR 2 * pos_Rl v5 v28 < v40) (eq_ind_r (fun v40 : @R => v40 < pos_Rl v5 v28 + pos_Rl v5 (S v28)) (Rplus_lt_compat_l (pos_Rl v5 v28) (pos_Rl v5 v28) (pos_Rl v5 (S v28)) (Rlt_trans (pos_Rl v5 v28) v30 (pos_Rl v5 (S v28)) v38 v39)) (double (pos_Rl v5 v28))) (Rmult_1_l (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v40 : 2%Z = 0%Z => let v41 : @False := eq_ind 2%Z (fun v41 : @Z => match v41 as v42 in Z return Prop with | 0%Z => @False | Z.pos v42 => (fun v42 : @positive => @True) v42 | Z.neg v42 => (fun v42 : @positive => @False) v42 end) (@I) 0%Z v40 in False_ind (@False) v41) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28))) : IZR 2 * pos_Rl v5 v28 < IZR 2 * ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2))) (Rmult_lt_reg_l (IZR 2) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) (pos_Rl v5 (S v28)) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => IZR 2 * v40 < IZR 2 * pos_Rl v5 (S v28)) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28))) (fun v40 : @R => v40 < IZR 2 * pos_Rl v5 (S v28)) (eq_ind (IZR 1) (fun v40 : @R => v40 * (pos_Rl v5 v28 + pos_Rl v5 (S v28)) < IZR 2 * pos_Rl v5 (S v28)) (eq_ind_r (fun v40 : @R => v40 < IZR 2 * pos_Rl v5 (S v28)) (eq_ind_r (fun v40 : @R => pos_Rl v5 v28 + pos_Rl v5 (S v28) < v40) (eq_ind_r (fun v40 : @R => v40 < pos_Rl v5 (S v28) + pos_Rl v5 (S v28)) (Rplus_lt_compat_l (pos_Rl v5 (S v28)) (pos_Rl v5 v28) (pos_Rl v5 (S v28)) (Rlt_trans (pos_Rl v5 v28) v30 (pos_Rl v5 (S v28)) v38 v39)) (Rplus_comm (pos_Rl v5 v28) (pos_Rl v5 (S v28)))) (double (pos_Rl v5 (S v28)))) (Rmult_1_l (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v40 : 2%Z = 0%Z => let v41 : @False := eq_ind 2%Z (fun v41 : @Z => match v41 as v42 in Z return Prop with | 0%Z => @False | Z.pos v42 => (fun v42 : @positive => @True) v42 | Z.neg v42 => (fun v42 : @positive => @False) v42 end) (@I) 0%Z v40 in False_ind (@False) v41) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28)))) ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl v5 v28 + pos_Rl v5 (S v28))) : IZR 2 * ((pos_Rl v5 v28 + pos_Rl v5 (S v28)) / IZR 2) < IZR 2 * pos_Rl v5 (S v28)))) v31)) eq_refl)) (cons v34 v36) v37) (RList_P13 (cons v34 v36) v28 v34 (eq_ind v5 (fun v38 : @Rlist => (v28 < Init.Nat.pred (Rlength v38))%nat) v29 (cons v34 v36) v37))) (RList_P12 (mid_Rlist (cons v34 v36) v34) (S v28) (fun v38 : @R => v3 v38 + v2 * v4 v38) (eq_ind_r (fun v38 : @nat => (S v28 < v38)%nat) ((let v38 : (v28 < Init.Nat.pred (Rlength (cons v34 v36)))%nat := eq_ind v5 (fun v38 : @Rlist => (v28 < Init.Nat.pred (Rlength v38))%nat) v29 (cons v34 v36) v37 in lt_n_S v28 (Rlength v36) v38) : (S v28 < Rlength (cons v34 v36))%nat) (RList_P14 (cons v34 v36) v34))) : pos_Rl v7 v28 + v2 * pos_Rl v18 v28 = pos_Rl (FF (cons v34 v36) (fun v38 : @R => v3 v38 + v2 * v4 v38)) v28) v37) v36 v37 end) v34 v35 end) (v16 v28 v29 v30 v31)) (v27 v28 v29 v30 v31)) : constant_D_eq (fun v30 : @R => v3 v30 + v2 * v4 v30) (open_interval (pos_Rl v5 v28) (pos_Rl v5 (S v28))) (pos_Rl (FF v5 (fun v30 : @R => v3 v30 + v2 * v4 v30)) v28))))))) v26 v27 end) v24 v25 end) v22 v23 end) v20 v21 end) v18 v19 end) v15 v16 end) v13 v14 end) v11 v12 end) v9 v10 end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P27	100	0.067516	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : forall v3 : @R, @R) (v4 : forall v4 : @R, @R) (v5 v6 : @Rlist) (v7 : is_subdivision v3 v0 v1 v5) (v8 : is_subdivision v4 v0 v1 v6) => StepFun_P26 v2 (StepFun_P23 v7 v8) (StepFun_P25 v7 v8))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P28	100	0.093657	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 v4 : StepFun v0 v1) => (let v5 : IsStepFun v3 v0 v1 := pre v3 in let v6 : IsStepFun v4 v0 v1 := pre v4 in sigT_rect (fun v7 : {v7 : @Rlist & is_subdivision v3 v0 v1 v7} => {v8 : @Rlist & is_subdivision (fun v9 : @R => v3 v9 + v2 * v4 v9) v0 v1 v8}) (sigT_rect (fun v7 : {v7 : @Rlist & is_subdivision v4 v0 v1 v7} => forall (v8 : @Rlist) (v9 : is_subdivision v3 v0 v1 v8), {v10 : @Rlist & is_subdivision (fun v11 : @R => v3 v11 + v2 * v4 v11) v0 v1 v10}) (fun (v7 : @Rlist) (v8 : is_subdivision v4 v0 v1 v7) (v9 : @Rlist) (v10 : is_subdivision v3 v0 v1 v9) => existT (fun v11 : @Rlist => is_subdivision (fun v12 : @R => v3 v12 + v2 * v4 v12) v0 v1 v11) (cons_ORlist v9 v7) (StepFun_P27 v2 v10 v8)) v6) v5) : IsStepFun (fun v5 : @R => v3 v5 + v2 * v4 v5) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P29	100	0.040864	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => existT (fun v3 : @Rlist => adapted_couple v2 v0 v1 (subdivision v2) v3) (subdivision_val v2) (StepFun_P1 v2) : is_subdivision v2 v0 v1 (subdivision v2))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P30	100	0.945272	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 v4 : StepFun v0 v1) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6 | right v6 => (fun v6 : ~ v0 <= v1 => - Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6 end = match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => Int_SF (subdivision_val v3) (subdivision v3)) v6 | right v6 => (fun v6 : ~ v0 <= v1 => - Int_SF (subdivision_val v3) (subdivision v3)) v6 end + v2 * match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => Int_SF (subdivision_val v4) (subdivision v4)) v6 | right v6 => (fun v6 : ~ v0 <= v1 => - Int_SF (subdivision_val v4) (subdivision v4)) v6 end) with | left v5 => (fun v5 : v0 <= v1 => let v6 : Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v6 : @R => v3 v6 + v2 * v4 v6)) (cons_ORlist (subdivision v3) (subdivision v4)) = Int_SF (subdivision_val {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) := StepFun_P17 (StepFun_P21 (StepFun_P27 v2 (StepFun_P29 v3) (StepFun_P29 v4))) (StepFun_P1 {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) in eq_ind (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v7 : @R => v3 v7 + v2 * v4 v7)) (cons_ORlist (subdivision v3) (subdivision v4))) (fun v7 : @R => v7 = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (eq_ind_r (fun v7 : @R => v7 = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (let v7 : Int_SF (subdivision_val v3) (subdivision v3) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v3) (StepFun_P21 (StepFun_P23 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v3) (subdivision v3)) (fun v8 : @R => v8 + v2 * Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4)) = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (let v8 : Int_SF (subdivision_val v4) (subdivision v4) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v4) (StepFun_P21 (StepFun_P25 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v4) (subdivision v4)) (fun v9 : @R => Int_SF (subdivision_val v3) (subdivision v3) + v2 * v9 = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v10 : list (@R) := (Int_SF (subdivision_val v3) (subdivision v3) :: v2 :: Int_SF (subdivision_val v4) (subdivision v4) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))))) = @true)) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4))) v8) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4))) v7) (StepFun_P19 (cons_ORlist (subdivision v3) (subdivision v4)) v3 v4 v2)) (Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6) v5 | right v5 => (fun v5 : ~ v0 <= v1 => let v6 : Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v6 : @R => v3 v6 + v2 * v4 v6)) (cons_ORlist (subdivision v3) (subdivision v4)) = Int_SF (subdivision_val {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) := StepFun_P17 (StepFun_P21 (StepFun_P27 v2 (StepFun_P29 v3) (StepFun_P29 v4))) (StepFun_P1 {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) in eq_ind (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v7 : @R => v3 v7 + v2 * v4 v7)) (cons_ORlist (subdivision v3) (subdivision v4))) (fun v7 : @R => - v7 = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (eq_ind_r (fun v7 : @R => - v7 = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (let v7 : Int_SF (subdivision_val v3) (subdivision v3) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v3) (StepFun_P21 (StepFun_P23 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v3) (subdivision v3)) (fun v8 : @R => - (v8 + v2 * Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4))) = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (let v8 : Int_SF (subdivision_val v4) (subdivision v4) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v4) (StepFun_P21 (StepFun_P25 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v4) (subdivision v4)) (fun v9 : @R => - (Int_SF (subdivision_val v3) (subdivision v3) + v2 * v9) = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v10 : list (@R) := (Int_SF (subdivision_val v3) (subdivision v3) :: v2 :: Int_SF (subdivision_val v4) (subdivision v4) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.PEadd (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3)))) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3)))))) = @true)) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4))) v8) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4))) v7) (StepFun_P19 (cons_ORlist (subdivision v3) (subdivision v4)) v3 v4 v2)) (Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6) v5 end : RiemannInt_SF {| fe := fun v5 : @R => v3 v5 + v2 * v4 v5; pre := StepFun_P28 v2 v3 v4 |} = RiemannInt_SF v3 + v2 * RiemannInt_SF v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P31	100	0.303296	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v5) (pos_Rl v3 (S v5))) (pos_Rl v4 v5))) => let v6 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v6) (pos_Rl v3 (S v6))) (pos_Rl v4 v6)) := v5 in (fun v7 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7)) => and_ind (fun (v8 : ordered_Rlist v3) (v9 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v9) (pos_Rl v3 (S v9))) (pos_Rl v4 v9))) => and_ind (fun (v10 : pos_Rl v3 0 = Rmin v0 v1) (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v11) (pos_Rl v3 (S v11))) (pos_Rl v4 v11))) => and_ind (fun (v12 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v13 : Rlength v3 = S (Rlength v4) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v13) (pos_Rl v3 (S v13))) (pos_Rl v4 v13))) => and_ind (fun (v14 : Rlength v3 = S (Rlength v4)) (v15 : forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v4 v15)) => conj v8 (conj v10 (conj v12 (conj (eq_sym (eq_ind_r (fun v16 : @nat => S (Rlength (app_Rlist v4 (@Rabs))) = v16) (eq_ind_r (fun v16 : @nat => S v16 = S (Rlength v4)) eq_refl (RList_P18 v4 (@Rabs))) v14)) (fun (v16 : @nat) (v17 : (v16 < Init.Nat.pred (Rlength v3))%nat) => ((fun (v18 : @R) (v19 : pos_Rl v3 v16 < v18 < pos_Rl v3 (S v16)) => eq_ind_r (fun v20 : @R => Rabs v20 = pos_Rl (app_Rlist v4 (@Rabs)) v16) (eq_ind_r (fun v20 : @R => Rabs (pos_Rl v4 v16) = v20) eq_refl (RList_P12 v4 v16 (@Rabs) (let v20 : (v16 < Init.Nat.pred (S (Rlength v4)))%nat := eq_ind (Rlength v3) (fun v20 : @nat => (v16 < Init.Nat.pred v20)%nat) v17 (S (Rlength v4)) v14 in v20))) (v15 v16 v17 v18 v19)) : forall (v18 : @R) (v19 : open_interval (pos_Rl v3 v16) (pos_Rl v3 (S v16)) v18), Rabs (v2 v18) = pos_Rl (app_Rlist v4 (@Rabs)) v16) : constant_D_eq (fun v18 : @R => Rabs (v2 v18)) (open_interval (pos_Rl v3 v16) (pos_Rl v3 (S v16))) (pos_Rl (app_Rlist v4 (@Rabs)) v16)))))) v13) v11) v9) v7) v6) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4), adapted_couple (fun v6 : @R => Rabs (v2 v6)) v0 v1 v3 (app_Rlist v4 (@Rabs)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P32	100	0.053757	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => existT (fun v3 : @Rlist => is_subdivision (fun v4 : @R => Rabs (v2 v4)) v0 v1 v3) (subdivision v2) (existT (fun v3 : @Rlist => adapted_couple (fun v4 : @R => Rabs (v2 v4)) v0 v1 (subdivision v2) v3) (app_Rlist (subdivision_val v2) (@Rabs)) (StepFun_P31 (StepFun_P1 v2)) : is_subdivision (fun v3 : @R => Rabs (v2 v3)) v0 v1 (subdivision v2)) : IsStepFun (fun v3 : @R => Rabs (v2 v3)) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P33	100	0.355654	1	1	0	synth with cache (only 1: refine (fun v0 : @Rlist => Rlist_ind (fun v1 : @Rlist => forall (v2 : @Rlist) (v3 : ordered_Rlist v2), Rabs (Int_SF v1 v2) <= Int_SF (app_Rlist v1 (@Rabs)) v2) (fun (v1 : @Rlist) (v2 : ordered_Rlist v1) => eq_ind_r (fun v3 : @R => v3 <= IZR 0) (or_intror eq_refl) (@Rabs_R0) : Rabs (Int_SF (@nil) v1) <= Int_SF (app_Rlist (@nil) (@Rabs)) v1) (fun (v1 : @R) (v2 : @Rlist) (v3 : forall (v3 : @Rlist) (v4 : ordered_Rlist v3), Rabs (Int_SF v2 v3) <= Int_SF (app_Rlist v2 (@Rabs)) v3) (v4 : @Rlist) (v5 : ordered_Rlist v4) => Rlist_ind (fun v6 : @Rlist => forall v7 : ordered_Rlist v6, Rabs match v6 as v8 in Rlist return (@R) with | nil => IZR 0 | cons v8 v9 => (fun (v8 : @R) (v9 : @Rlist) => match v9 as v10 in Rlist return (@R) with | nil => IZR 0 | cons v10 v11 => (fun (v10 : @R) (v11 : @Rlist) => v1 * (v10 - v8) + Int_SF v2 (cons v10 v11)) v10 v11 end) v8 v9 end <= match v6 as v8 in Rlist return (@R) with | nil => IZR 0 | cons v8 v9 => (fun (v8 : @R) (v9 : @Rlist) => match v9 as v10 in Rlist return (@R) with | nil => IZR 0 | cons v10 v11 => (fun (v10 : @R) (v11 : @Rlist) => Rabs v1 * (v10 - v8) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) v10 v11 end) v8 v9 end) (fun v6 : ordered_Rlist (@nil) => eq_ind_r (fun v7 : @R => v7 <= IZR 0) (or_intror eq_refl) (@Rabs_R0)) (fun (v6 : @R) (v7 : @Rlist) (v8 : forall v8 : ordered_Rlist v7, Rabs match v7 as v9 in Rlist return (@R) with | nil => IZR 0 | cons v9 v10 => (fun (v9 : @R) (v10 : @Rlist) => match v10 as v11 in Rlist return (@R) with | nil => IZR 0 | cons v11 v12 => (fun (v11 : @R) (v12 : @Rlist) => v1 * (v11 - v9) + Int_SF v2 (cons v11 v12)) v11 v12 end) v9 v10 end <= match v7 as v9 in Rlist return (@R) with | nil => IZR 0 | cons v9 v10 => (fun (v9 : @R) (v10 : @Rlist) => match v10 as v11 in Rlist return (@R) with | nil => IZR 0 | cons v11 v12 => (fun (v11 : @R) (v12 : @Rlist) => Rabs v1 * (v11 - v9) + Int_SF (app_Rlist v2 (@Rabs)) (cons v11 v12)) v11 v12 end) v9 v10 end) (v9 : ordered_Rlist (cons v6 v7)) => Rlist_ind (fun v10 : @Rlist => forall (v11 : ordered_Rlist (cons v6 v10)) (v12 : forall v12 : ordered_Rlist v10, Rabs match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => match v14 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => v1 * (v15 - v13) + Int_SF v2 (cons v15 v16)) v15 v16 end) v13 v14 end <= match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => match v14 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => Rabs v1 * (v15 - v13) + Int_SF (app_Rlist v2 (@Rabs)) (cons v15 v16)) v15 v16 end) v13 v14 end), Rabs match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => v1 * (v13 - v6) + Int_SF v2 (cons v13 v14)) v13 v14 end <= match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => Rabs v1 * (v13 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v13 v14)) v13 v14 end) (fun (v10 : ordered_Rlist (cons v6 (@nil))) (v11 : forall v11 : ordered_Rlist (@nil), Rabs (IZR 0) <= IZR 0) => eq_ind_r (fun v12 : @R => v12 <= IZR 0) (or_intror eq_refl) (@Rabs_R0)) (fun (v10 : @R) (v11 : @Rlist) (v12 : forall (v12 : ordered_Rlist (cons v6 v11)) (v13 : forall v13 : ordered_Rlist v11, Rabs match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => match v15 as v16 in Rlist return (@R) with | nil => IZR 0 | cons v16 v17 => (fun (v16 : @R) (v17 : @Rlist) => v1 * (v16 - v14) + Int_SF v2 (cons v16 v17)) v16 v17 end) v14 v15 end <= match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => match v15 as v16 in Rlist return (@R) with | nil => IZR 0 | cons v16 v17 => (fun (v16 : @R) (v17 : @Rlist) => Rabs v1 * (v16 - v14) + Int_SF (app_Rlist v2 (@Rabs)) (cons v16 v17)) v16 v17 end) v14 v15 end), Rabs match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => v1 * (v14 - v6) + Int_SF v2 (cons v14 v15)) v14 v15 end <= match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => Rabs v1 * (v14 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v14 v15)) v14 v15 end) (v13 : ordered_Rlist (cons v6 (cons v10 v11))) (v14 : forall v14 : ordered_Rlist (cons v10 v11), Rabs match v11 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => v1 * (v15 - v10) + Int_SF v2 (cons v15 v16)) v15 v16 end <= match v11 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => Rabs v1 * (v15 - v10) + Int_SF (app_Rlist v2 (@Rabs)) (cons v15 v16)) v15 v16 end) => Rle_trans (Rabs (v1 * (v10 - v6) + Int_SF v2 (cons v10 v11))) (Rabs (v1 * (v10 - v6)) + Rabs (Int_SF v2 (cons v10 v11))) (Rabs v1 * (v10 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (Rabs_triang (v1 * (v10 - v6)) (Int_SF v2 (cons v10 v11))) (eq_ind_r (fun v15 : @R => v15 + Rabs (Int_SF v2 (cons v10 v11)) <= Rabs v1 * (v10 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (eq_ind_r (fun v15 : @R => Rabs v1 * v15 + Rabs (Int_SF v2 (cons v10 v11)) <= Rabs v1 * (v10 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (Rplus_le_compat_l (Rabs v1 * (v10 - v6)) (Rabs (Int_SF v2 (cons v10 v11))) (Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (v3 (cons v10 v11) (RList_P4 (cons v10 v11) v6 v13))) (Rabs_right (v10 - v6) (Rge_minus v10 v6 (Rle_ge v6 v10 (v13 0%nat (Nat.lt_0_succ (Rlength v11) : (0 < Init.Nat.pred (Rlength (cons v6 (cons v10 v11))))%nat)))))) (Rabs_mult v1 (v10 - v6)))) v7 v9 v8) v4 v5 : Rabs (Int_SF (cons v1 v2) v4) <= Int_SF (app_Rlist (cons v1 v2) (@Rabs)) v4) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P34	100	0.321631	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) (v3 : v0 <= v1) => decide_left (Rle_dec v0 v1) v3 (fun v4 : {v0 <= v1} + {~ v0 <= v1} => Rabs match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => Int_SF (subdivision_val v2) (subdivision v2)) v5 | right v5 => (fun v5 : ~ v0 <= v1 => - Int_SF (subdivision_val v2) (subdivision v2)) v5 end <= match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => Int_SF (subdivision_val {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |})) v5 | right v5 => (fun v5 : ~ v0 <= v1 => - Int_SF (subdivision_val {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |})) v5 end) (fun v4 : v0 <= v1 => let v5 : Int_SF (app_Rlist (subdivision_val v2) (@Rabs)) (subdivision v2) = Int_SF (subdivision_val {| fe := fun v5 : @R => Rabs (v2 v5); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v5 : @R => Rabs (v2 v5); pre := StepFun_P32 v2 |}) := StepFun_P17 (StepFun_P31 (StepFun_P1 v2)) (StepFun_P1 {| fe := fun v5 : @R => Rabs (v2 v5); pre := StepFun_P32 v2 |}) in eq_ind (Int_SF (app_Rlist (subdivision_val v2) (@Rabs)) (subdivision v2)) (fun v6 : @R => Rabs (Int_SF (subdivision_val v2) (subdivision v2)) <= v6) (StepFun_P33 (subdivision_val v2) (let v6 : is_subdivision v2 v0 v1 (subdivision v2) := StepFun_P29 v2 in sigT_ind (fun v7 : {v7 : @Rlist & adapted_couple v2 v0 v1 (subdivision v2) v7} => ordered_Rlist (subdivision v2)) (fun (v7 : @Rlist) (v8 : adapted_couple v2 v0 v1 (subdivision v2) v7) => let v9 : ordered_Rlist (subdivision v2) /\ pos_Rl (subdivision v2) 0 = Rmin v0 v1 /\ pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v9) (pos_Rl (subdivision v2) (S v9))) (pos_Rl v7 v9)) := v8 in (fun v10 : ordered_Rlist (subdivision v2) /\ pos_Rl (subdivision v2) 0 = Rmin v0 v1 /\ pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v10) (pos_Rl (subdivision v2) (S v10))) (pos_Rl v7 v10)) => and_ind (fun (v11 : ordered_Rlist (subdivision v2)) (v12 : pos_Rl (subdivision v2) 0 = Rmin v0 v1 /\ pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v12) (pos_Rl (subdivision v2) (S v12))) (pos_Rl v7 v12))) => and_ind (fun (v13 : pos_Rl (subdivision v2) 0 = Rmin v0 v1) (v14 : pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v14) (pos_Rl (subdivision v2) (S v14))) (pos_Rl v7 v14))) => and_ind (fun (v15 : pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1) (v16 : Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v16 : @nat) (v17 : (v16 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v16) (pos_Rl (subdivision v2) (S v16))) (pos_Rl v7 v16))) => and_ind (fun (v17 : Rlength (subdivision v2) = S (Rlength v7)) (v18 : forall (v18 : @nat) (v19 : (v18 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v18) (pos_Rl (subdivision v2) (S v18))) (pos_Rl v7 v18)) => v11) v16) v14) v12) v10) v9) v6)) (Int_SF (subdivision_val {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |})) v5) : Rabs (RiemannInt_SF v2) <= RiemannInt_SF {| fe := fun v4 : @R => Rabs (v2 v4); pre := StepFun_P32 v2 |})).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P35	100	0.573153	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P36	100	0.332293	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 v3 : StepFun v0 v1) (v4 : @Rlist) (v5 : v0 <= v1) (v6 : is_subdivision v2 v0 v1 v4) (v7 : is_subdivision v3 v0 v1 v4) (v8 : forall (v8 : @R) (v9 : v0 < v8 < v1), v2 v8 <= v3 v8) => decide_left (Rle_dec v0 v1) v5 (fun v9 : {v0 <= v1} + {~ v0 <= v1} => match v9 as v10 in ({_} + {_}) return (@R) with | left v10 => (fun v10 : v0 <= v1 => Int_SF (subdivision_val v2) (subdivision v2)) v10 | right v10 => (fun v10 : ~ v0 <= v1 => - Int_SF (subdivision_val v2) (subdivision v2)) v10 end <= match v9 as v10 in ({_} + {_}) return (@R) with | left v10 => (fun v10 : v0 <= v1 => Int_SF (subdivision_val v3) (subdivision v3)) v10 | right v10 => (fun v10 : ~ v0 <= v1 => - Int_SF (subdivision_val v3) (subdivision v3)) v10 end) (fun v9 : v0 <= v1 => let v10 : Int_SF (FF v4 v2) v4 = Int_SF (subdivision_val v2) (subdivision v2) := StepFun_P17 (StepFun_P21 v6) (StepFun_P1 v2) in eq_ind (Int_SF (FF v4 v2) v4) (fun v11 : @R => v11 <= Int_SF (subdivision_val v3) (subdivision v3)) (let v11 : Int_SF (FF v4 v3) v4 = Int_SF (subdivision_val v3) (subdivision v3) := StepFun_P17 (StepFun_P21 v7) (StepFun_P1 v3) in eq_ind (Int_SF (FF v4 v3) v4) (fun v12 : @R => Int_SF (FF v4 v2) v4 <= v12) (sigT_ind (fun v12 : {v12 : @Rlist & adapted_couple v2 v0 v1 v4 v12} => Int_SF (FF v4 v2) v4 <= Int_SF (FF v4 v3) v4) (fun (v12 : @Rlist) (v13 : adapted_couple v2 v0 v1 v4 v12) => let v14 : ordered_Rlist v4 /\ pos_Rl v4 0 = Rmin v0 v1 /\ pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v14) (pos_Rl v4 (S v14))) (pos_Rl v12 v14)) := v13 in (fun v15 : ordered_Rlist v4 /\ pos_Rl v4 0 = Rmin v0 v1 /\ pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v15) (pos_Rl v4 (S v15))) (pos_Rl v12 v15)) => and_ind (fun (v16 : ordered_Rlist v4) (v17 : pos_Rl v4 0 = Rmin v0 v1 /\ pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v17) (pos_Rl v4 (S v17))) (pos_Rl v12 v17))) => and_ind (fun (v18 : pos_Rl v4 0 = Rmin v0 v1) (v19 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v19) (pos_Rl v4 (S v19))) (pos_Rl v12 v19))) => and_ind (fun (v20 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1) (v21 : Rlength v4 = S (Rlength v12) /\ (forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v21) (pos_Rl v4 (S v21))) (pos_Rl v12 v21))) => and_ind (fun (v22 : Rlength v4 = S (Rlength v12)) (v23 : forall (v23 : @nat) (v24 : (v23 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v23) (pos_Rl v4 (S v23))) (pos_Rl v12 v23)) => let v24 : Rmin v0 v1 = v0 := decide_left (Rle_dec v0 v1) v9 (fun v24 : {v0 <= v1} + {~ v0 <= v1} => match v24 as v25 in ({_} + {_}) return (@R) with | left v25 => (fun v25 : v0 <= v1 => v0) v25 | right v25 => (fun v25 : ~ v0 <= v1 => v1) v25 end = v0) (fun v24 : v0 <= v1 => eq_refl) : Rmin v0 v1 = v0 in let v25 : Rmax v0 v1 = v1 := decide_left (Rle_dec v0 v1) v9 (fun v25 : {v0 <= v1} + {~ v0 <= v1} => match v25 as v26 in ({_} + {_}) return (@R) with | left v26 => (fun v26 : v0 <= v1 => v1) v26 | right v26 => (fun v26 : ~ v0 <= v1 => v0) v26 end = v1) (fun v25 : v0 <= v1 => eq_refl) : Rmax v0 v1 = v1 in let v26 : pos_Rl v4 0 = v0 := eq_ind (Rmin v0 v1) (fun v26 : @R => pos_Rl v4 0 = v26) v18 v0 v24 in let v27 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = v1 := eq_ind (Rmax v0 v1) (fun v27 : @R => pos_Rl v4 (Init.Nat.pred (Rlength v4)) = v27) v20 v1 v25 in StepFun_P35 v2 v3 v16 v26 v27 v8) v21) v19) v17) v15) v14) v6) (Int_SF (subdivision_val v3) (subdivision v3)) v11) (Int_SF (subdivision_val v2) (subdivision v2)) v10) : RiemannInt_SF v2 <= RiemannInt_SF v3)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P37	100	0.080586	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 v3 : StepFun v0 v1) (v4 : v0 <= v1) (v5 : forall (v5 : @R) (v6 : v0 < v5 < v1), v2 v5 <= v3 v5) => StepFun_P36 v2 v3 v4 (StepFun_P25 (StepFun_P29 v3) (StepFun_P29 v2)) (StepFun_P23 (StepFun_P29 v3) (StepFun_P29 v2)) v5)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P38	100	1.524156	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P39	100	0.624567	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => match Rle_dec v0 v1 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 <= v1 => Int_SF (subdivision_val v2) (subdivision v2)) v4 | right v4 => (fun v4 : ~ v0 <= v1 => - Int_SF (subdivision_val v2) (subdivision v2)) v4 end = - match Rle_dec v1 v0 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 <= v0 => Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v4 | right v4 => (fun v4 : ~ v1 <= v0 => - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v4 end) with | left v3 => match Rle_dec v1 v0 as v3 in ({_} + {_}) return (forall v4 : v0 <= v1, Int_SF (subdivision_val v2) (subdivision v2) = - match v3 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v0 => Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 | right v5 => (fun v5 : ~ v1 <= v0 => - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 end) with | left v3 => (fun (v3 : v1 <= v0) (v4 : v0 <= v1) => let v5 : adapted_couple v2 v0 v1 (subdivision v2) (subdivision_val v2) := StepFun_P1 v2 in let v6 : adapted_couple {| fe := v2; pre := StepFun_P6 (pre v2) |} v1 v0 (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) := StepFun_P1 {| fe := v2; pre := StepFun_P6 (pre v2) |} in let v7 : v0 = v1 := Rle_antisym v0 v1 v4 v3 in eq_ind_r (fun v8 : @R => v8 = - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) (let v8 : v1 = v0 := eq_sym v7 in eq_ind_r (fun v9 : @R => IZR 0 = - v9) (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v10 : list (@R) := Datatypes.nil in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEopp (Ring_polynom.PEc 0%Z)) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEopp (Ring_polynom.PEc 0%Z)))) = @true)) (StepFun_P8 v6 v8)) (StepFun_P8 v5 v7)) v3 | right v3 => (fun (v3 : ~ v1 <= v0) (v4 : v0 <= v1) => eq_ind_r (fun v5 : @R => Int_SF (subdivision_val v2) (subdivision v2) = v5) (StepFun_P17 (StepFun_P1 v2) (StepFun_P2 (let v5 : IsStepFun v2 v1 v0 := StepFun_P6 (pre v2) in sigT_ind (fun v6 : {v6 : @Rlist & is_subdivision v2 v1 v0 v6} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := v6 |}) (subdivision_val {| fe := v2; pre := v6 |})) (fun (v6 : @Rlist) (v7 : is_subdivision v2 v1 v0 v6) => sigT_ind (fun v8 : {v8 : @Rlist & adapted_couple v2 v1 v0 v6 v8} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |}) (subdivision_val {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |})) (fun (v8 : @Rlist) (v9 : adapted_couple v2 v1 v0 v6 v8) => v9) v7 : adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |}) (subdivision_val {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |})) v5))) (Ropp_involutive (Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})))) v3 end v3 | right v3 => match Rle_dec v1 v0 as v3 in ({_} + {_}) return (forall v4 : ~ v0 <= v1, - Int_SF (subdivision_val v2) (subdivision v2) = - match v3 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v0 => Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 | right v5 => (fun v5 : ~ v1 <= v0 => - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 end) with | left v3 => (fun (v3 : v1 <= v0) (v4 : ~ v0 <= v1) => Ropp_eq_compat (Int_SF (subdivision_val v2) (subdivision v2)) (Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) (StepFun_P17 (StepFun_P1 v2) (StepFun_P2 (let v5 : IsStepFun v2 v1 v0 := StepFun_P6 (pre v2) in sigT_ind (fun v6 : {v6 : @Rlist & is_subdivision v2 v1 v0 v6} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := v6 |}) (subdivision_val {| fe := v2; pre := v6 |})) (fun (v6 : @Rlist) (v7 : is_subdivision v2 v1 v0 v6) => sigT_ind (fun v8 : {v8 : @Rlist & adapted_couple v2 v1 v0 v6 v8} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |}) (subdivision_val {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |})) (fun (v8 : @Rlist) (v9 : adapted_couple v2 v1 v0 v6 v8) => v9) v7 : adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |}) (subdivision_val {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |})) v5)))) v3 | right v3 => (fun (v3 : ~ v1 <= v0) (v4 : ~ v0 <= v1) => let v5 : v0 < v1 := Rnot_le_lt v1 v0 v3 in let v6 : v1 < v0 := Rnot_le_lt v0 v1 v4 in False_ind (- Int_SF (subdivision_val v2) (subdivision v2) = - - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) (Rlt_irrefl v0 (Rlt_trans v0 v1 v0 v5 v6))) v3 end v3 end : RiemannInt_SF v2 = - RiemannInt_SF {| fe := v2; pre := StepFun_P6 (pre v2) |})).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P40	100	2.647995	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P41	100	0.156194	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : v1 <= v2) (v5 : v2 <= v3) (v6 : IsStepFun v0 v1 v2) => match v6 as v7 in (sigT _) return (forall v8 : IsStepFun v0 v2 v3, IsStepFun v0 v1 v3) with | existT _ v7 v8 => (fun (v7 : @Rlist) (v8 : is_subdivision v0 v1 v2 v7) => match v8 as v9 in (sigT _) return (forall v10 : IsStepFun v0 v2 v3, IsStepFun v0 v1 v3) with | existT _ v9 v10 => (fun (v9 : @Rlist) (v10 : adapted_couple v0 v1 v2 v7 v9) (v11 : IsStepFun v0 v2 v3) => match v11 as v12 in (sigT _) return (IsStepFun v0 v1 v3) with | existT _ v12 v13 => (fun (v12 : @Rlist) (v13 : is_subdivision v0 v2 v3 v12) => match v13 as v14 in (sigT _) return (IsStepFun v0 v1 v3) with | existT _ v14 v15 => (fun (v14 : @Rlist) (v15 : adapted_couple v0 v2 v3 v12 v14) => let v16 : {v1 < v2} + {v1 = v2} + {v2 < v1} := total_order_T v1 v2 in match v16 as v17 in (_ + {_}) return (IsStepFun v0 v1 v3) with | inleft v17 => (fun v17 : {v1 < v2} + {v1 = v2} => match v17 as v18 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v18 => (fun v18 : v1 < v2 => let v19 : {v2 < v3} + {v2 = v3} + {v3 < v2} := total_order_T v2 v3 in match v19 as v20 in (_ + {_}) return (IsStepFun v0 v1 v3) with | inleft v20 => (fun v20 : {v2 < v3} + {v2 = v3} => match v20 as v21 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v21 => (fun v21 : v2 < v3 => existT (fun v22 : @Rlist => is_subdivision v0 v1 v3 v22) (cons_Rlist v7 v12) (existT (fun v22 : @Rlist => adapted_couple v0 v1 v3 (cons_Rlist v7 v12) v22) (FF (cons_Rlist v7 v12) v0) (StepFun_P40 v18 v21 v10 v15))) v21 | right v21 => (fun v21 : v2 = v3 => existT (fun v22 : @Rlist => is_subdivision v0 v1 v3 v22) v7 (existT (fun v22 : @Rlist => adapted_couple v0 v1 v3 v7 v22) v9 (let v22 : adapted_couple v0 v1 v3 v7 v9 := eq_ind v2 (fun v22 : @R => adapted_couple v0 v1 v22 v7 v9) v10 v3 v21 in v22))) v21 end) v20 | inright v20 => (fun v20 : v3 < v2 => False_rect (IsStepFun v0 v1 v3) (Rlt_irrefl v2 (Rle_lt_trans v2 v3 v2 v5 v20))) v20 end) v18 | right v18 => (fun v18 : v1 = v2 => existT (fun v19 : @Rlist => is_subdivision v0 v1 v3 v19) v12 (existT (fun v19 : @Rlist => adapted_couple v0 v1 v3 v12 v19) v14 (let v19 : adapted_couple v0 v1 v3 v12 v14 := eq_ind_r (fun v19 : @R => adapted_couple v0 v19 v3 v12 v14) v15 v18 in v19))) v18 end) v17 | inright v17 => (fun v17 : v2 < v1 => False_rect (IsStepFun v0 v1 v3) (Rlt_irrefl v1 (Rle_lt_trans v1 v2 v1 v4 v17))) v17 end) v14 v15 end) v12 v13 end) v9 v10 end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P42	100	0.346186	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Rlist) (v2 : forall v2 : @R, @R) => Rlist_ind (fun v3 : @Rlist => forall v4 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = pos_Rl v1 0, Int_SF (FF (cons_Rlist v3 v1) v2) (cons_Rlist v3 v1) = Int_SF (FF v3 v2) v3 + Int_SF (FF v1 v2) v1) (fun v3 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl v1 0 => (let v4 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v5 : list (@R) := (Int_SF (FF v1 v2) v1 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v5 v4 (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (@I) (eq_refl : (let v6 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)))) = @true)) : Int_SF (FF (cons_Rlist (@nil) v1) v2) (cons_Rlist (@nil) v1) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF v1 v2) v1) (fun (v3 : @R) (v4 : @Rlist) (v5 : forall v5 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = pos_Rl v1 0, Int_SF (FF (cons_Rlist v4 v1) v2) (cons_Rlist v4 v1) = Int_SF (FF v4 v2) v4 + Int_SF (FF v1 v2) v1) (v6 : pos_Rl (cons v3 v4) (Init.Nat.pred (Rlength (cons v3 v4))) = pos_Rl v1 0) => match v4 as v7 in Rlist return (forall (v8 : forall v8 : pos_Rl v7 (Init.Nat.pred (Rlength v7)) = pos_Rl v1 0, Int_SF (FF (cons_Rlist v7 v1) v2) (cons_Rlist v7 v1) = Int_SF (FF v7 v2) v7 + Int_SF (FF v1 v2) v1) (v9 : pos_Rl (cons v3 v7) (Init.Nat.pred (Rlength (cons v3 v7))) = pos_Rl v1 0), Int_SF (FF (cons_Rlist (cons v3 v7) v1) v2) (cons_Rlist (cons v3 v7) v1) = Int_SF (FF (cons v3 v7) v2) (cons v3 v7) + Int_SF (FF v1 v2) v1) with | nil => fun (v7 : forall v7 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl v1 0, Int_SF (FF (cons_Rlist (@nil) v1) v2) (cons_Rlist (@nil) v1) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF v1 v2) v1) (v8 : pos_Rl (cons v3 (@nil)) (Init.Nat.pred (Rlength (cons v3 (@nil)))) = pos_Rl v1 0) => match v1 as v9 in Rlist return (forall (v10 : forall v10 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl v9 0, Int_SF (FF (cons_Rlist (@nil) v9) v2) (cons_Rlist (@nil) v9) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF v9 v2) v9) (v11 : v3 = pos_Rl v9 0), Int_SF (app_Rlist (mid_Rlist v9 v3) v2) (cons v3 v9) = IZR 0 + Int_SF (FF v9 v2) v9) with | nil => fun (v9 : forall v9 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl (@nil) 0, Int_SF (FF (cons_Rlist (@nil) (@nil)) v2) (cons_Rlist (@nil) (@nil)) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF (@nil) v2) (@nil)) (v10 : v3 = pos_Rl (@nil) 0) => (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v12 : list (@R) := Datatypes.nil in RField_ring_lemma1 (@ring_subst_niter) v12 v11 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 0%Z)) (@I) (eq_refl : (let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 0%Z)))) = @true)) : Int_SF (app_Rlist (mid_Rlist (@nil) v3) v2) (cons v3 (@nil)) = IZR 0 + Int_SF (FF (@nil) v2) (@nil) | cons v9 v10 => (fun (v9 : @R) (v10 : @Rlist) (v11 : forall v11 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl (cons v9 v10) 0, Int_SF (FF (cons_Rlist (@nil) (cons v9 v10)) v2) (cons_Rlist (@nil) (cons v9 v10)) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF (cons v9 v10) v2) (cons v9 v10)) (v12 : v3 = pos_Rl (cons v9 v10) 0) => eq_ind_r (fun v13 : @R => v2 ((v13 + v9) / IZR 2) * (v9 - v13) + Int_SF (app_Rlist (mid_Rlist v10 v9) v2) (cons v9 v10) = IZR 0 + Int_SF (app_Rlist (mid_Rlist v10 v9) v2) (cons v9 v10)) (let v13 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v14 : list (@R) := (v2 ((v9 + v9) / IZR 2) :: v9 :: Int_SF (app_Rlist (mid_Rlist v10 v9) v2) (cons v9 v10) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v14 v13 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 3)) (@I) (eq_refl : (let v15 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v13 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v15 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v15 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 3)))) = @true)) v12 : Int_SF (app_Rlist (mid_Rlist (cons v9 v10) v3) v2) (cons v3 (cons v9 v10)) = IZR 0 + Int_SF (FF (cons v9 v10) v2) (cons v9 v10)) v9 v10 end v7 v8 : Int_SF (FF (cons_Rlist (cons v3 (@nil)) v1) v2) (cons_Rlist (cons v3 (@nil)) v1) = Int_SF (FF (cons v3 (@nil)) v2) (cons v3 (@nil)) + Int_SF (FF v1 v2) v1 | cons v7 v8 => (fun (v7 : @R) (v8 : @Rlist) (v9 : forall v9 : pos_Rl (cons v7 v8) (Init.Nat.pred (Rlength (cons v7 v8))) = pos_Rl v1 0, Int_SF (FF (cons_Rlist (cons v7 v8) v1) v2) (cons_Rlist (cons v7 v8) v1) = Int_SF (FF (cons v7 v8) v2) (cons v7 v8) + Int_SF (FF v1 v2) v1) (v10 : pos_Rl (cons v3 (cons v7 v8)) (Init.Nat.pred (Rlength (cons v3 (cons v7 v8)))) = pos_Rl v1 0) => eq_ind_r (fun v11 : @R => v2 ((v3 + v7) / IZR 2) * (v7 - v3) + Int_SF (app_Rlist (mid_Rlist (cons_Rlist v8 v1) v7) v2) (cons v7 (cons_Rlist v8 v1)) = v11) (Rplus_eq_compat_l (v2 ((v3 + v7) / IZR 2) * (v7 - v3)) (Int_SF (app_Rlist (mid_Rlist (cons_Rlist v8 v1) v7) v2) (cons v7 (cons_Rlist v8 v1))) (Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8) + Int_SF (FF v1 v2) v1) (v9 (eq_ind (pos_Rl (cons v3 (cons v7 v8)) (Init.Nat.pred (Rlength (cons v3 (cons v7 v8))))) (fun v11 : @R => pos_Rl (cons v7 v8) (Init.Nat.pred (Rlength (cons v7 v8))) = v11) eq_refl (pos_Rl v1 0) v10))) (Rplus_assoc (v2 ((v3 + v7) / IZR 2) * (v7 - v3)) (Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8)) (Int_SF (FF v1 v2) v1)) : Int_SF (FF (cons_Rlist (cons v3 (cons v7 v8)) v1) v2) (cons_Rlist (cons v3 (cons v7 v8)) v1) = Int_SF (FF (cons v3 (cons v7 v8)) v2) (cons v3 (cons v7 v8)) + Int_SF (FF v1 v2) v1) v7 v8 end v5 v6) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P43	100	3.051751	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P44	100	2.150017	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P45	100	1.749128	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : IsStepFun v0 v1 v2) (v5 : v1 <= v3 <= v2) => let v6 : v1 <= v2 := and_ind (fun (v6 : v1 <= v3) (v7 : v3 <= v2) => Rle_trans v1 v3 v2 v6 v7) v5 in and_rect (fun (v7 : v1 <= v3) (v8 : v3 <= v2) => sigT_rect (fun v9 : {v9 : @Rlist & {v10 : @Rlist & adapted_couple v0 v1 v2 v9 v10}} => IsStepFun v0 v3 v2) (fun (v9 : @Rlist) (v10 : {v10 : @Rlist & adapted_couple v0 v1 v2 v9 v10}) => match v10 as v11 in (sigT _) return (IsStepFun v0 v3 v2) with | existT _ v11 v12 => (fun (v11 : @Rlist) (v12 : adapted_couple v0 v1 v2 v9 v11) => let v13 : forall (v13 v14 : @Rlist) (v15 v16 v17 : @R) (v18 : forall v18 : @R, @R) (v19 : adapted_couple v18 v15 v16 v13 v14) (v20 : v15 <= v17 <= v16), {v21 : @Rlist & {v22 : @Rlist & adapted_couple v18 v17 v16 v21 v22}} := fun v13 : @Rlist => Rlist_rec (fun v14 : @Rlist => forall (v15 : @Rlist) (v16 v17 v18 : @R) (v19 : forall v19 : @R, @R) (v20 : adapted_couple v19 v16 v17 v14 v15) (v21 : v16 <= v18 <= v17), {v22 : @Rlist & {v23 : @Rlist & adapted_couple v19 v18 v17 v22 v23}}) (fun (v14 : @Rlist) (v15 v16 v17 : @R) (v18 : forall v18 : @R, @R) (v19 : adapted_couple v18 v15 v16 (@nil) v14) (v20 : v15 <= v17 <= v16) => let v21 : ordered_Rlist (@nil) /\ pos_Rl (@nil) 0 = Rmin v15 v16 /\ pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v21) (pos_Rl (@nil) (S v21))) (pos_Rl v14 v21)) := v19 in (fun v22 : ordered_Rlist (@nil) /\ pos_Rl (@nil) 0 = Rmin v15 v16 /\ pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v22) (pos_Rl (@nil) (S v22))) (pos_Rl v14 v22)) => and_rec (fun (v23 : ordered_Rlist (@nil)) (v24 : pos_Rl (@nil) 0 = Rmin v15 v16 /\ pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v24) (pos_Rl (@nil) (S v24))) (pos_Rl v14 v24))) => and_rec (fun (v25 : pos_Rl (@nil) 0 = Rmin v15 v16) (v26 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v26) (pos_Rl (@nil) (S v26))) (pos_Rl v14 v26))) => and_rec (fun (v27 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16) (v28 : Rlength (@nil) = S (Rlength v14) /\ (forall (v28 : @nat) (v29 : (v28 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v28) (pos_Rl (@nil) (S v28))) (pos_Rl v14 v28))) => and_rec (fun (v29 : Rlength (@nil) = S (Rlength v14)) (v30 : forall (v30 : @nat) (v31 : (v30 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v30) (pos_Rl (@nil) (S v30))) (pos_Rl v14 v30)) => let v31 : @False := eq_ind 0%nat (fun v31 : @nat => match v31 as v32 in nat return Prop with | 0%nat => @True | S v32 => (fun v32 : @nat => @False) v32 end) (@I) (S (Rlength v14)) v29 in False_rec {v32 : @Rlist & {v33 : @Rlist & adapted_couple v18 v17 v16 v32 v33}} v31) v28) v26) v24) v22) v21) (fun (v14 : @R) (v15 : @Rlist) => Rlist_rec (fun v16 : @Rlist => forall (v17 : forall (v17 : @Rlist) (v18 v19 v20 : @R) (v21 : forall v21 : @R, @R) (v22 : adapted_couple v21 v18 v19 v16 v17) (v23 : v18 <= v20 <= v19), {v24 : @Rlist & {v25 : @Rlist & adapted_couple v21 v20 v19 v24 v25}}) (v18 : @Rlist) (v19 v20 v21 : @R) (v22 : forall v22 : @R, @R) (v23 : adapted_couple v22 v19 v20 (cons v14 v16) v18) (v24 : v19 <= v21 <= v20), {v25 : @Rlist & {v26 : @Rlist & adapted_couple v22 v21 v20 v25 v26}}) (fun (v16 : forall (v16 : @Rlist) (v17 v18 v19 : @R) (v20 : forall v20 : @R, @R) (v21 : adapted_couple v20 v17 v18 (@nil) v16) (v22 : v17 <= v19 <= v18), {v23 : @Rlist & {v24 : @Rlist & adapted_couple v20 v19 v18 v23 v24}}) (v17 : @Rlist) (v18 v19 v20 : @R) (v21 : forall v21 : @R, @R) (v22 : adapted_couple v21 v18 v19 (cons v14 (@nil)) v17) (v23 : v18 <= v20 <= v19) => let v24 : v18 = v19 := let v24 : ordered_Rlist (cons v14 (@nil)) /\ pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19 /\ pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v24) (pos_Rl (cons v14 (@nil)) (S v24))) (pos_Rl v17 v24)) := v22 in (fun v25 : ordered_Rlist (cons v14 (@nil)) /\ pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19 /\ pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v25 : @nat) (v26 : (v25 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v25) (pos_Rl (cons v14 (@nil)) (S v25))) (pos_Rl v17 v25)) => and_ind (fun (v26 : ordered_Rlist (cons v14 (@nil))) (v27 : pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19 /\ pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v27 : @nat) (v28 : (v27 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v27) (pos_Rl (cons v14 (@nil)) (S v27))) (pos_Rl v17 v27))) => and_ind (fun (v28 : pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19) (v29 : pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v29 : @nat) (v30 : (v29 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v29) (pos_Rl (cons v14 (@nil)) (S v29))) (pos_Rl v17 v29))) => and_ind (fun (v30 : pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19) (v31 : Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v31 : @nat) (v32 : (v31 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v31) (pos_Rl (cons v14 (@nil)) (S v31))) (pos_Rl v17 v31))) => and_ind (fun (v32 : Rlength (cons v14 (@nil)) = S (Rlength v17)) (v33 : forall (v33 : @nat) (v34 : (v33 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v33) (pos_Rl (cons v14 (@nil)) (S v33))) (pos_Rl v17 v33)) => let v34 : v18 <= v19 := and_ind (fun (v34 : v18 <= v20) (v35 : v20 <= v19) => Rle_trans v18 v20 v19 v34 v35) v23 in let v35 : Rmin v18 v19 = v18 := decide_left (Rle_dec v18 v19) v34 (fun v35 : {v18 <= v19} + {~ v18 <= v19} => match v35 as v36 in ({_} + {_}) return (@R) with | left v36 => (fun v36 : v18 <= v19 => v18) v36 | right v36 => (fun v36 : ~ v18 <= v19 => v19) v36 end = v18) (fun v35 : v18 <= v19 => eq_refl) : Rmin v18 v19 = v18 in eq_ind (Rmin v18 v19) (fun v36 : @R => v36 = v19) ((let v36 : Rmax v18 v19 = v19 := decide_left (Rle_dec v18 v19) v34 (fun v36 : {v18 <= v19} + {~ v18 <= v19} => match v36 as v37 in ({_} + {_}) return (@R) with | left v37 => (fun v37 : v18 <= v19 => v19) v37 | right v37 => (fun v37 : ~ v18 <= v19 => v18) v37 end = v19) (fun v36 : v18 <= v19 => eq_refl) : Rmax v18 v19 = v19 in eq_ind (Rmax v18 v19) (fun v37 : @R => Rmin v18 v19 = v37) (eq_ind v14 (fun v37 : @R => Rmin v18 v19 = v37) (eq_ind_r (fun v37 : @R => Rmin v18 v19 = v37) eq_refl v28) (Rmax v18 v19) v30) v19 v36) : Rmin v18 v19 = v19) v18 v35) v31) v29) v27) v25) v24 in existT (fun v25 : @Rlist => {v26 : @Rlist & adapted_couple v21 v20 v19 v25 v26}) (cons v14 (@nil)) (existT (fun v25 : @Rlist => adapted_couple v21 v20 v19 (cons v14 (@nil)) v25) v17 (let v25 : v20 = v19 := let v25 : v19 <= v20 <= v19 := eq_ind v18 (fun v25 : @R => v25 <= v20 <= v19) v23 v19 v24 in and_ind (fun (v26 : v19 <= v20) (v27 : v20 <= v19) => Rle_antisym v20 v19 v27 v26) v25 in let v26 : v18 = v20 := eq_ind_r (fun v26 : @R => v18 = v26) v24 v25 in eq_ind v18 (fun v27 : @R => adapted_couple v21 v27 v19 (cons v14 (@nil)) v17) v22 v20 v26))) (fun (v16 : @R) (v17 : @Rlist) (v18 : forall (v18 : forall (v18 : @Rlist) (v19 v20 v21 : @R) (v22 : forall v22 : @R, @R) (v23 : adapted_couple v22 v19 v20 v17 v18) (v24 : v19 <= v21 <= v20), {v25 : @Rlist & {v26 : @Rlist & adapted_couple v22 v21 v20 v25 v26}}) (v19 : @Rlist) (v20 v21 v22 : @R) (v23 : forall v23 : @R, @R) (v24 : adapted_couple v23 v20 v21 (cons v14 v17) v19) (v25 : v20 <= v22 <= v21), {v26 : @Rlist & {v27 : @Rlist & adapted_couple v23 v22 v21 v26 v27}}) (v19 : forall (v19 : @Rlist) (v20 v21 v22 : @R) (v23 : forall v23 : @R, @R) (v24 : adapted_couple v23 v20 v21 (cons v16 v17) v19) (v25 : v20 <= v22 <= v21), {v26 : @Rlist & {v27 : @Rlist & adapted_couple v23 v22 v21 v26 v27}}) (v20 : @Rlist) (v21 v22 v23 : @R) (v24 : forall v24 : @R, @R) (v25 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) v20) (v26 : v21 <= v23 <= v22) => Rlist_rec (fun v27 : @Rlist => forall v28 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) v27, {v29 : @Rlist & {v30 : @Rlist & adapted_couple v24 v23 v22 v29 v30}}) (fun v27 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) (@nil) => let v28 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v28 : @nat) (v29 : (v28 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v28) (pos_Rl (cons v14 (cons v16 v17)) (S v28))) (pos_Rl (@nil) v28)) := v27 in (fun v29 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v29 : @nat) (v30 : (v29 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v29) (pos_Rl (cons v14 (cons v16 v17)) (S v29))) (pos_Rl (@nil) v29)) => and_rec (fun (v30 : ordered_Rlist (cons v14 (cons v16 v17))) (v31 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v31 : @nat) (v32 : (v31 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v31) (pos_Rl (cons v14 (cons v16 v17)) (S v31))) (pos_Rl (@nil) v31))) => and_rec (fun (v32 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22) (v33 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v33 : @nat) (v34 : (v33 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v33) (pos_Rl (cons v14 (cons v16 v17)) (S v33))) (pos_Rl (@nil) v33))) => and_rec (fun (v34 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22) (v35 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v35 : @nat) (v36 : (v35 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v35) (pos_Rl (cons v14 (cons v16 v17)) (S v35))) (pos_Rl (@nil) v35))) => and_rec (fun (v36 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil))) (v37 : forall (v37 : @nat) (v38 : (v37 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v37) (pos_Rl (cons v14 (cons v16 v17)) (S v37))) (pos_Rl (@nil) v37)) => let v38 : @False := eq_ind (S (S (Rlength v17))) (fun v38 : @nat => match v38 as v39 in nat return Prop with | 0%nat => @False | S v39 => (fun v39 : @nat => match v39 as v40 in nat return Prop with | 0%nat => @False | S v40 => (fun v40 : @nat => @True) v40 end) v39 end) (@I) 1%nat v36 in False_rec {v39 : @Rlist & {v40 : @Rlist & adapted_couple v24 v23 v22 v39 v40}} v38) v35) v33) v31) v29) v28) (fun (v27 : @R) (v28 : @Rlist) (v29 : forall v29 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) v28, {v30 : @Rlist & {v31 : @Rlist & adapted_couple v24 v23 v22 v30 v31}}) (v30 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) (cons v27 v28)) => let v31 : {v23 <= v16} + {v16 < v23} := match Rle_dec v23 v16 as v31 in ({_} + {_}) return ({v23 <= v16} + {v16 < v23}) with | left v31 => (fun v31 : v23 <= v16 => left v31) v31 | right v31 => (fun v31 : ~ v23 <= v16 => right (Rnot_le_lt v23 v16 v31)) v31 end in sumbool_rec (fun v32 : {v23 <= v16} + {v16 < v23} => {v33 : @Rlist & {v34 : @Rlist & adapted_couple v24 v23 v22 v33 v34}}) (fun v32 : v23 <= v16 => existT (fun v33 : @Rlist => {v34 : @Rlist & adapted_couple v24 v23 v22 v33 v34}) (cons v23 (cons v16 v17)) (existT (fun v33 : @Rlist => adapted_couple v24 v23 v22 (cons v23 (cons v16 v17)) v33) (cons v27 v28) (let v33 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v33 : @nat) (v34 : (v33 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v33) (pos_Rl (cons v14 (cons v16 v17)) (S v33))) (pos_Rl (cons v27 v28) v33)) := v30 in (fun v34 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v34 : @nat) (v35 : (v34 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v34) (pos_Rl (cons v14 (cons v16 v17)) (S v34))) (pos_Rl (cons v27 v28) v34)) => and_ind (fun (v35 : ordered_Rlist (cons v14 (cons v16 v17))) (v36 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v36 : @nat) (v37 : (v36 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v36) (pos_Rl (cons v14 (cons v16 v17)) (S v36))) (pos_Rl (cons v27 v28) v36))) => and_ind (fun (v37 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22) (v38 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v38 : @nat) (v39 : (v38 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v38) (pos_Rl (cons v14 (cons v16 v17)) (S v38))) (pos_Rl (cons v27 v28) v38))) => and_ind (fun (v39 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22) (v40 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v40 : @nat) (v41 : (v40 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v40) (pos_Rl (cons v14 (cons v16 v17)) (S v40))) (pos_Rl (cons v27 v28) v40))) => and_ind (fun (v41 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28))) (v42 : forall (v42 : @nat) (v43 : (v42 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v42) (pos_Rl (cons v14 (cons v16 v17)) (S v42))) (pos_Rl (cons v27 v28) v42)) => conj ((fun (v43 : @nat) (v44 : (v43 < Init.Nat.pred (Rlength (cons v23 (cons v16 v17))))%nat) => nat_ind (fun v45 : @nat => forall v46 : (v45 < S (Rlength v17))%nat, pos_Rl (cons v23 (cons v16 v17)) v45 <= pos_Rl (cons v23 (cons v16 v17)) (S v45)) (fun v45 : (0 < S (Rlength v17))%nat => v32 : pos_Rl (cons v23 (cons v16 v17)) 0 <= pos_Rl (cons v23 (cons v16 v17)) 1) (fun (v45 : @nat) (v46 : forall v46 : (v45 < S (Rlength v17))%nat, pos_Rl (cons v23 (cons v16 v17)) v45 <= pos_Rl (cons v23 (cons v16 v17)) (S v45)) (v47 : (S v45 < S (Rlength v17))%nat) => v35 (S v45) (v47 : (S v45 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat)) v43 v44) : ordered_Rlist (cons v23 (cons v16 v17))) (conj (((let v43 : {v23 <= v22} + {~ v23 <= v22} := Rle_dec v23 v22 in match v43 as v44 in ({_} + {_}) return (v23 = match v44 as v45 in ({_} + {_}) return (@R) with | left v45 => (fun v45 : v23 <= v22 => v23) v45 | right v45 => (fun v45 : ~ v23 <= v22 => v22) v45 end) with | left v44 => (fun v44 : v23 <= v22 => eq_refl) v44 | right v44 => (fun v44 : ~ v23 <= v22 => let v45 : @False := v44 (and_ind (fun (v45 : v21 <= v23) (v46 : v23 <= v22) => v46) v26) in match v45 as v46 in False return (v23 = v22) with end) v44 end) : v23 = Rmin v23 v22) : pos_Rl (cons v23 (cons v16 v17)) 0 = Rmin v23 v22) (conj (let v43 : Rmax v21 v22 = Rmax v23 v22 := (let v43 : {v23 <= v22} + {~ v23 <= v22} := Rle_dec v23 v22 in match v43 as v44 in ({_} + {_}) return (match Rle_dec v21 v22 as v45 in ({_} + {_}) return (@R) with | left v45 => (fun v45 : v21 <= v22 => v22) v45 | right v45 => (fun v45 : ~ v21 <= v22 => v21) v45 end = match v44 as v45 in ({_} + {_}) return (@R) with | left v45 => (fun v45 : v23 <= v22 => v22) v45 | right v45 => (fun v45 : ~ v23 <= v22 => v23) v45 end) with | left v44 => (fun v44 : v23 <= v22 => let v45 : {v21 <= v22} + {~ v21 <= v22} := Rle_dec v21 v22 in match v45 as v46 in ({_} + {_}) return (match v46 as v47 in ({_} + {_}) return (@R) with | left v47 => (fun v47 : v21 <= v22 => v22) v47 | right v47 => (fun v47 : ~ v21 <= v22 => v21) v47 end = v22) with | left v46 => (fun v46 : v21 <= v22 => eq_refl) v46 | right v46 => (fun v46 : ~ v21 <= v22 => let v47 : @False := v46 (and_ind (fun (v47 : v21 <= v23) (v48 : v23 <= v22) => Rle_trans v21 v23 v22 v47 v48) v26) in match v47 as v48 in False return (v21 = v22) with end) v46 end) v44 | right v44 => (fun v44 : ~ v23 <= v22 => let v45 : @False := v44 (let v45 : {v21 <= v22} + {~ v21 <= v22} := Rle_dec v21 v22 in match v45 as v46 in ({_} + {_}) return (v23 <= v22) with | left v46 => (fun v46 : v21 <= v22 => and_ind (fun (v47 : v21 <= v23) (v48 : v23 <= v22) => v48) v26) v46 | right v46 => (fun v46 : ~ v21 <= v22 => let v47 : @False := v46 (and_ind (fun (v47 : v21 <= v23) (v48 : v23 <= v22) => Rle_trans v21 v23 v22 v47 v48) v26) in match v47 as v48 in False return (v23 <= v22) with end) v46 end) in match v45 as v46 in False return (match Rle_dec v21 v22 as v47 in ({_} + {_}) return (@R) with | left v47 => (fun v47 : v21 <= v22 => v22) v47 | right v47 => (fun v47 : ~ v21 <= v22 => v21) v47 end = v23) with end) v44 end) : Rmax v21 v22 = Rmax v23 v22 in eq_ind (Rmax v21 v22) (fun v44 : @R => pos_Rl (cons v23 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v23 (cons v16 v17)))) = v44) (eq_ind (pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))) (fun v44 : @R => pos_Rl (cons v23 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v23 (cons v16 v17)))) = v44) eq_refl (Rmax v21 v22) v39) (Rmax v23 v22) v43) (conj (v41 : Rlength (cons v23 (cons v16 v17)) = S (Rlength (cons v27 v28))) (fun (v43 : @nat) (v44 : (v43 < Init.Nat.pred (Rlength (cons v23 (cons v16 v17))))%nat) => nat_ind (fun v45 : @nat => forall v46 : (v45 < S (Rlength v17))%nat, constant_D_eq v24 (open_interval (pos_Rl (cons v23 (cons v16 v17)) v45) (pos_Rl (cons v23 (cons v16 v17)) (S v45))) (pos_Rl (cons v27 v28) v45)) (fun v45 : (0 < S (Rlength v17))%nat => ((fun (v46 : @R) (v47 : pos_Rl (cons v23 (cons v16 v17)) 0 < v46 < pos_Rl (cons v23 (cons v16 v17)) 1) => v42 0%nat (Nat.lt_0_succ (Rlength v17) : (0 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat) v46 ((and_ind (fun (v48 : v23 < v46) (v49 : v46 < v16) => conj (Rle_lt_trans v14 v23 v46 (let v50 : v21 = v14 := eq_ind_r (fun v50 : @R => v21 = v50) ((let v50 : {v21 <= v22} + {~ v21 <= v22} := Rle_dec v21 v22 in match v50 as v51 in ({_} + {_}) return (v21 = match v51 as v52 in ({_} + {_}) return (@R) with | left v52 => (fun v52 : v21 <= v22 => v21) v52 | right v52 => (fun v52 : ~ v21 <= v22 => v22) v52 end) with | left v51 => (fun v51 : v21 <= v22 => eq_refl) v51 | right v51 => (fun v51 : ~ v21 <= v22 => let v52 : @False := v51 (and_ind (fun (v52 : v21 <= v23) (v53 : v23 <= v22) => Rle_trans v21 v23 v22 v52 v53) v26) in match v52 as v53 in False return (v21 = v22) with end) v51 end) : v21 = Rmin v21 v22) v37 in eq_ind v21 (fun v51 : @R => v51 <= v23) (and_ind (fun (v51 : v21 <= v23) (v52 : v23 <= v22) => v51) v26) v14 v50) v48) v49) v47 : pos_Rl (cons v14 (cons v16 v17)) 0 < v46 < pos_Rl (cons v14 (cons v16 v17)) 1) : open_interval (pos_Rl (cons v14 (cons v16 v17)) 0) (pos_Rl (cons v14 (cons v16 v17)) 1) v46) : v24 v46 = pos_Rl (cons v27 v28) 0) : forall (v46 : @R) (v47 : open_interval (pos_Rl (cons v23 (cons v16 v17)) 0) (pos_Rl (cons v23 (cons v16 v17)) 1) v46), v24 v46 = pos_Rl (cons v27 v28) 0) : constant_D_eq v24 (open_interval (pos_Rl (cons v23 (cons v16 v17)) 0) (pos_Rl (cons v23 (cons v16 v17)) 1)) (pos_Rl (cons v27 v28) 0)) (fun (v45 : @nat) (v46 : forall v46 : (v45 < S (Rlength v17))%nat, constant_D_eq v24 (open_interval (pos_Rl (cons v23 (cons v16 v17)) v45) (pos_Rl (cons v23 (cons v16 v17)) (S v45))) (pos_Rl (cons v27 v28) v45)) (v47 : (S v45 < S (Rlength v17))%nat) => v42 (S v45) (v47 : (S v45 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat)) v43 v44)))) : adapted_couple v24 v23 v22 (cons v23 (cons v16 v17)) (cons v27 v28)) v40) v38) v36) v34) v33))) (fun v32 : v16 < v23 => let v33 : adapted_couple v24 v16 v22 (cons v16 v17) v28 := StepFun_P7 (and_ind (fun (v33 : v21 <= v23) (v34 : v23 <= v22) => Rle_trans v21 v23 v22 v33 v34) v26) v30 in (let v34 : v16 <= v23 <= v22 := conj (or_introl v32) (and_ind (fun (v34 : v21 <= v23) (v35 : v23 <= v22) => v35) v26) in (fun (v35 : v16 <= v23 <= v22) (v36 : adapted_couple v24 v16 v22 (cons v16 v17) v28) => sigT_rec (fun v37 : {v37 : @Rlist & {v38 : @Rlist & adapted_couple v24 v23 v22 v37 v38}} => {v38 : @Rlist & {v39 : @Rlist & adapted_couple v24 v23 v22 v38 v39}}) (fun (v37 : @Rlist) (v38 : {v38 : @Rlist & adapted_couple v24 v23 v22 v37 v38}) => match v38 as v39 in (sigT _) return {v40 : @Rlist & {v41 : @Rlist & adapted_couple v24 v23 v22 v40 v41}} with | existT _ v39 v40 => (fun (v39 : @Rlist) (v40 : adapted_couple v24 v23 v22 v37 v39) => existT (fun v41 : @Rlist => {v42 : @Rlist & adapted_couple v24 v23 v22 v41 v42}) v37 (existT (fun v41 : @Rlist => adapted_couple v24 v23 v22 v37 v41) v39 v40)) v39 v40 end) (v19 v28 v16 v22 v23 v24 v36 v35)) v34) v33) v31) v20 v25) v15) v13 in (fun v14 : forall (v14 v15 : @Rlist) (v16 v17 v18 : @R) (v19 : forall v19 : @R, @R) (v20 : adapted_couple v19 v16 v17 v14 v15) (v21 : v16 <= v18 <= v17), {v22 : @Rlist & {v23 : @Rlist & adapted_couple v19 v18 v17 v22 v23}} => (v14 v9 v11 v1 v2 v3 v0 v12 (conj v7 v8) : {v15 : @Rlist & is_subdivision v0 v3 v2 v15}) : IsStepFun v0 v3 v2) v13) v11 v12 end) v4) v5)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P46	100	0.111726	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : IsStepFun v0 v1 v2) (v5 : IsStepFun v0 v2 v3) => match Rle_dec v1 v2 as v6 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v6 => match Rle_dec v2 v3 as v6 in ({_} + {_}) return (forall v7 : v1 <= v2, IsStepFun v0 v1 v3) with | left v6 => (fun (v6 : v2 <= v3) (v7 : v1 <= v2) => StepFun_P41 v7 v6 v4 v5) v6 | right v6 => (fun (v6 : ~ v2 <= v3) (v7 : v1 <= v2) => match Rle_dec v1 v3 as v8 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v8 => (fun v8 : v1 <= v3 => StepFun_P44 v4 (conj v8 (Rlt_le v3 v2 (Rnot_le_lt v2 v3 v6)))) v8 | right v8 => (fun v8 : ~ v1 <= v3 => StepFun_P6 (StepFun_P44 (StepFun_P6 v5) (conj (Rlt_le v3 v1 (Rnot_le_lt v1 v3 v8)) v7))) v8 end) v6 end v6 | right v6 => match Rle_dec v2 v3 as v6 in ({_} + {_}) return (forall v7 : ~ v1 <= v2, IsStepFun v0 v1 v3) with | left v6 => (fun (v6 : v2 <= v3) (v7 : ~ v1 <= v2) => match Rle_dec v1 v3 as v8 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v8 => (fun v8 : v1 <= v3 => StepFun_P45 v5 (conj (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v7)) v8)) v8 | right v8 => (fun v8 : ~ v1 <= v3 => StepFun_P6 (StepFun_P45 (StepFun_P6 v4) (conj v6 (Rlt_le v3 v1 (Rnot_le_lt v1 v3 v8))))) v8 end) v6 | right v6 => (fun (v6 : ~ v2 <= v3) (v7 : ~ v1 <= v2) => StepFun_P6 (StepFun_P41 (Rlt_le v3 v2 (Rnot_le_lt v2 v3 v6)) (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v7)) (StepFun_P6 v5) (StepFun_P6 v4))) v6 end v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.atan_sub_correct	100	0.445215	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : IZR 1 + v0 * v1 <> IZR 0) (v3 : - @PI / IZR 2 < atan v0 - atan v1 < @PI / IZR 2) (v4 : - @PI / IZR 2 < atan (atan_sub v0 v1) < @PI / IZR 2) => let v5 : cos (atan v0) <> IZR 0 := let v5 : - @PI / IZR 2 < atan v0 < @PI / IZR 2 := atan_bound v0 in match v5 as v6 in (_ /\ _) return (cos (atan v0) <> IZR 0) with | conj v6 v7 => (fun (v6 : - @PI / IZR 2 < atan v0) (v7 : atan v0 < @PI / IZR 2) => Rgt_not_eq (cos (atan v0)) (IZR 0) (cos_gt_0 (atan v0) (eq_ind (- @PI / IZR 2) (fun v8 : @R => v8 < atan v0) v6 (- (@PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) v7)) v6 v7 end in let v6 : cos (atan v1) <> IZR 0 := let v6 : - @PI / IZR 2 < atan v1 < @PI / IZR 2 := atan_bound v1 in match v6 as v7 in (_ /\ _) return (cos (atan v1) <> IZR 0) with | conj v7 v8 => (fun (v7 : - @PI / IZR 2 < atan v1) (v8 : atan v1 < @PI / IZR 2) => Rgt_not_eq (cos (atan v1)) (IZR 0) (cos_gt_0 (atan v1) (eq_ind (- @PI / IZR 2) (fun v9 : @R => v9 < atan v1) v7 (- (@PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) v8)) v7 v8 end in let v7 : forall (v7 v8 v9 : @R) (v10 : v7 - v8 = v9), v7 = v8 + v9 := fun (v7 v8 v9 : @R) (v10 : v7 - v8 = v9) => eq_ind (v7 - v8) (fun v11 : @R => v7 = v8 + v11) (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v12 : forall (v12 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v13 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 = v12) (v14 : linear (@Z)) (v15 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEX (@Z) 1) = v14) (v16 : linear (@Z)) (v17 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) = v16) (v18 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v12 (Ring_polynom.PEmul (num v14) (denum v16))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v12 (Ring_polynom.PEmul (num v16) (denum v14))) = @true) (v19 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) (condition v14 ++ condition v16)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) (FEX (@Z) 1) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) := RField_field_lemma1 (@ring_subst_niter) (v7 :: v8 :: nil) v11 (FEX (@Z) 1) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) (@I) in let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v14 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 = v13 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 = v13 in let v15 : linear (@Z) := {| num := Ring_polynom.PEX (@Z) 1; denum := Ring_polynom.PEc 1%Z; condition := nil |} in let v16 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEX (@Z) 1) = v15 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEX (@Z) 1) = v15 in let v17 : linear (@Z) := {| num := Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)); denum := Ring_polynom.PEc 1%Z; condition := nil |} in let v18 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) = v17 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) = v17 in v12 v13 v14 v15 v16 v17 v18 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEmul (num v15) (denum v17))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEmul (num v17) (denum v15))) = @true) (RField_lemma5 (v7 :: v8 :: nil) (condition v15 ++ condition v17) (fun (v19 : forall v19 : list (Ring_polynom.PExpr (@Z)), Prop) (v20 : v19 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil)) => eq_ind_r (fun v21 : forall v21 : list (Ring_polynom.PExpr (@Z)), Prop => v21 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) nil) v20 : v19 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v15 ++ condition v17) nil)))) v9 v10 in v7 (atan v0) (atan v1) (atan (atan_sub v0 v1)) (tan_is_inj (atan v0 - atan v1) (atan (atan_sub v0 v1)) v3 v4 (eq_ind_r (fun v8 : @R => v8 = tan (atan (atan_sub v0 v1))) (eq_ind_r (fun v8 : @R => (v8 - tan (atan v1)) / (IZR 1 + v8 * tan (atan v1)) = tan (atan (atan_sub v0 v1))) (eq_ind_r (fun v8 : @R => (v0 - v8) / (IZR 1 + v0 * v8) = tan (atan (atan_sub v0 v1))) (eq_ind_r (fun v8 : @R => (v0 - v1) / (IZR 1 + v0 * v1) = v8) eq_refl (atan_right_inv (atan_sub v0 v1))) (atan_right_inv v1)) (atan_right_inv v0)) (tan_minus (atan v0) (atan v1) v5 v6 (Rgt_not_eq (cos (atan v0 - atan v1)) (IZR 0) (cos_gt_0 (atan v0 - atan v1) (eq_ind (- @PI / IZR 2) (fun v8 : @R => v8 < atan v0 - atan v1) (and_ind (fun (v8 : - @PI / IZR 2 < atan v0 - atan v1) (v9 : atan v0 - atan v1 < @PI / IZR 2) => and_ind (fun (v10 : - @PI / IZR 2 < atan (atan_sub v0 v1)) (v11 : atan (atan_sub v0 v1) < @PI / IZR 2) => v8) v4) v3) (- (@PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) (and_ind (fun (v8 : - @PI / IZR 2 < atan v0 - atan v1) (v9 : atan v0 - atan v1 < @PI / IZR 2) => and_ind (fun (v10 : - @PI / IZR 2 < atan (atan_sub v0 v1)) (v11 : atan (atan_sub v0 v1) < @PI / IZR 2) => v9) v4) v3))) (eq_ind_r (fun v8 : @R => IZR 1 + v8 * tan (atan v1) <> IZR 0) (eq_ind_r (fun v8 : @R => IZR 1 + v0 * v8 <> IZR 0) v2 (atan_right_inv v1)) (atan_right_inv v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.tech	100	0.559159	1	1	0	synth with cache (only 1: refine (let v0 : @PI > IZR 0 := @PI_RGT_0 in fun (v1 v2 : @R) (v3 : IZR (-1) <= v1 <= IZR 1) => match v3 as v4 in (_ /\ _) return (forall v5 : IZR (-1) < v2 < IZR 1, - @PI / IZR 2 < atan v1 - atan v2 < @PI / IZR 2) with | conj v4 v5 => (fun (v4 : IZR (-1) <= v1) (v5 : v1 <= IZR 1) (v6 : IZR (-1) < v2 < IZR 1) => match v6 as v7 in (_ /\ _) return (- @PI / IZR 2 < atan v1 - atan v2 < @PI / IZR 2) with | conj v7 v8 => (fun (v7 : IZR (-1) < v2) (v8 : v2 < IZR 1) => let v9 : - (@PI / IZR 4) <= atan v1 := match v4 as v9 in (_ \/ _) return (- (@PI / IZR 4) <= atan v1) with | or_introl v9 => (fun v9 : IZR (-1) < v1 => eq_ind (atan (IZR 1)) (fun v10 : @R => - v10 <= atan v1) (eq_ind (atan (- IZR 1)) (fun v10 : @R => v10 <= atan v1) (Rlt_le (atan (- IZR 1)) (atan v1) (atan_increasing (- IZR 1) v1 v9)) (- atan (IZR 1)) (atan_opp (IZR 1))) (@PI / IZR 4) (@atan_1)) v9 | or_intror v9 => (fun v9 : IZR (-1) = v1 => eq_ind (IZR (-1)) (fun v10 : @R => - (@PI / IZR 4) <= atan v10) (eq_ind_r (fun v10 : @R => - (@PI / IZR 4) <= v10) (eq_ind_r (fun v10 : @R => - (@PI / IZR 4) <= - v10) (Rle_refl (- (@PI / IZR 4))) (@atan_1)) (atan_opp (IZR 1))) v1 v9) v9 end in let v10 : - (@PI / IZR 4) < atan v2 := eq_ind (atan (IZR 1)) (fun v10 : @R => - v10 < atan v2) (eq_ind (atan (- IZR 1)) (fun v10 : @R => v10 < atan v2) (atan_increasing (- IZR 1) v2 v7) (- atan (IZR 1)) (atan_opp (IZR 1))) (@PI / IZR 4) (@atan_1) in let v11 : atan v1 <= @PI / IZR 4 := match v5 as v11 in (_ \/ _) return (atan v1 <= @PI / IZR 4) with | or_introl v11 => (fun v11 : v1 < IZR 1 => eq_ind (atan (IZR 1)) (fun v12 : @R => atan v1 <= v12) (Rlt_le (atan v1) (atan (IZR 1)) (atan_increasing v1 (IZR 1) v11)) (@PI / IZR 4) (@atan_1)) v11 | or_intror v11 => (fun v11 : v1 = IZR 1 => eq_ind_r (fun v12 : @R => atan v12 <= @PI / IZR 4) (eq_ind_r (fun v12 : @R => v12 <= @PI / IZR 4) (Rle_refl (@PI / IZR 4)) (@atan_1)) v11) v11 end in let v12 : atan v2 < @PI / IZR 4 := eq_ind (atan (IZR 1)) (fun v12 : @R => atan v2 < v12) (atan_increasing v2 (IZR 1) v8) (@PI / IZR 4) (@atan_1) in eq_ind_r (fun v13 : @R => v13 < atan v1 - atan v2 < @PI / IZR 2) (conj ((let v13 : forall (v13 v14 v15 : @R) (v16 : v13 < v15 * / IZR 4) (v17 : - (v15 * / IZR 4) <= v14), - (v15 * / IZR 2) < v14 - v13 := fun v13 v14 v15 : @R => let v16 : list (@QMicromega.QWitness) := (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 2) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 1) (RingMicromega.PsatzIn (@QArith_base.Q) 0)) :: nil)%list in let v17 : VarMap.t (@R) := VarMap.Branch (VarMap.Elt v14) v15 (VarMap.Elt v13) in let v18 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 3; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4))) |} (@tt)) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4)))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)))); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEsub (EnvRing.PEX 2) (EnvRing.PEX 3) |} (@tt))) in RMicromega.RTautoChecker_sound v18 v16 (eq_refl : RMicromega.RTautoChecker v18 v16 = @true) (VarMap.find (IZR 0) v17) in v13 (atan v2) (atan v1) (@PI) v12 v9) : - (@PI / IZR 2) < atan v1 - atan v2) ((let v13 : forall (v13 v14 v15 : @R) (v16 : v15 <= v13 * / IZR 4) (v17 : - (v13 * / IZR 4) < v14), v15 - v14 < v13 * / IZR 2 := fun v13 v14 v15 : @R => let v16 : list (@QMicromega.QWitness) := (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 2) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 1) (RingMicromega.PsatzIn (@QArith_base.Q) 0)) :: nil)%list in let v17 : VarMap.t (@R) := VarMap.Branch (VarMap.Elt v14) v15 (VarMap.Elt v13) in let v18 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 3) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4))) |} (@tt)) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEmul (EnvRing.PEX 3) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4)))); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEsub (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 3) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2))) |} (@tt))) in RMicromega.RTautoChecker_sound v18 v16 (eq_refl : RMicromega.RTautoChecker v18 v16 = @true) (VarMap.find (IZR 0) v17) in v13 (@PI) (atan v2) (atan v1) v11 v10) : atan v1 - atan v2 < @PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.Machin_2_3	100	0.382827	1	1	0	synth with cache (only 1: refine (let v0 : IZR 0 < @PI / IZR 2 := @PI2_RGT_0 in eq_ind (atan (IZR 1)) (fun v1 : @R => v1 = atan (/ IZR 2) + atan (/ IZR 3)) (eq_ind_r (fun v1 : @R => v1 = atan (/ IZR 2) + atan (/ IZR 3)) (f_equal (Rplus (atan (/ IZR 2))) (f_equal (@atan) ((let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : forall (v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v3 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v2) (v4 : linear (@Z)) (v5 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 3%Z)) = v6) (v8 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v4) (denum v6))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v6) (denum v4))) = @true) (v9 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v4 ++ condition v6)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEinv (FEc 3%Z)) := RField_field_lemma1 (@ring_subst_niter) nil v1 (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) (FEinv (FEc 3%Z)) (@I) in let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 in let v5 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 3%Z; condition := Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 2%Z :: Ring_polynom.PEc 2%Z :: nil |} in let v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = v5 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 3%Z; condition := Ring_polynom.PEc 3%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 3%Z)) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 3%Z)) = v7 in v2 v3 v4 v5 v6 v7 v8 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (RField_lemma5 nil (condition v5 ++ condition v7) (fun (v9 : forall v9 : list (Ring_polynom.PExpr (@Z)), Prop) (v10 : v9 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop => v11 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v10 : v9 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v5 ++ condition v7) nil)))) : atan_sub (IZR 1) (/ IZR 2) = / IZR 3))) (atan_sub_correct (IZR 1) (/ IZR 2) (Rgt_not_eq (IZR 1 + IZR 1 * / IZR 2) (IZR 0) ((let v1 : IZR 1 + IZR 1 * / IZR 2 > IZR 0 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CZ 1) (RMicromega.CInv (RMicromega.CZ 2)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR 1 + IZR 1 * / IZR 2 > IZR 0)) (tech (IZR 1) (/ IZR 2) (conj ((let v1 : IZR (-1) <= IZR 1 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR (-1) <= IZR 1) ((let v1 : IZR 1 <= IZR 1 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ 1); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR 1 <= IZR 1)) (conj ((let v1 : IZR (-1) < / IZR 2 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR (-1) < / IZR 2) ((let v1 : / IZR 2 < IZR 1 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : / IZR 2 < IZR 1))) (atan_bound (atan_sub (IZR 1) (/ IZR 2))))) (@PI / IZR 4) (@atan_1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.Machin_4_5_239	100	1.850077	1	1	0	synth with cache (only 1: refine (eq_ind (atan (IZR 1)) (fun v0 : @R => v0 = IZR 4 * atan (/ IZR 5) - atan (/ IZR 239)) (eq_ind_r (fun v0 : @R => v0 = IZR 4 * atan (/ IZR 5) - atan (/ IZR 239)) (let v0 : atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239)))) = IZR 4 * atan (/ IZR 5) - atan (/ IZR 239) := let v0 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v1 : list (@R) := (atan (/ IZR 5) :: atan (/ IZR 239) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v1 v0 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 2)))))) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEc 4%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (@I) (eq_refl : (let v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v0 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 2))))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEc 4%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)))) = @true) in eq_ind (atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239))))) (fun v1 : @R => atan (/ IZR 5) + atan (atan_sub (IZR 1) (/ IZR 5)) = v1) (f_equal (Rplus (atan (/ IZR 5))) (let v1 : IZR 2 / IZR 3 = atan_sub (IZR 1) (/ IZR 5) := (let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : forall (v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v3 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v2) (v4 : linear (@Z)) (v5 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 2%Z) (FEc 3%Z)) = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) = v6) (v8 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v4) (denum v6))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v6) (denum v4))) = @true) (v9 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v4 ++ condition v6)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEc 2%Z) (FEc 3%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v1 (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) (@I) in let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 in let v5 : linear (@Z) := {| num := Ring_polynom.PEc 2%Z; denum := Ring_polynom.PEc 3%Z; condition := Ring_polynom.PEc 3%Z :: nil |} in let v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 2%Z) (FEc 3%Z)) = v5 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 2%Z) (FEc 3%Z)) = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 4%Z; denum := Ring_polynom.PEc 6%Z; condition := Ring_polynom.PEc 6%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) = v7 in v2 v3 v4 v5 v6 v7 v8 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (RField_lemma5 nil (condition v5 ++ condition v7) (fun (v9 : forall v9 : list (Ring_polynom.PExpr (@Z)), Prop) (v10 : v9 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop => v11 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v10 : v9 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v5 ++ condition v7) nil)))) : IZR 2 / IZR 3 = atan_sub (IZR 1) (/ IZR 5) in eq_ind (IZR 2 / IZR 3) (fun v2 : @R => atan v2 = atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239)))) (eq_ind_r (fun v2 : @R => v2 = atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239)))) (f_equal (Rplus (atan (/ IZR 5))) (let v2 : IZR 7 / IZR 17 = atan_sub (IZR 2 / IZR 3) (/ IZR 5) := (let v2 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v3 : forall (v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v3) (v5 : linear (@Z)) (v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 7%Z) (FEc 17%Z)) = v5) (v7 : linear (@Z)) (v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) = v7) (v9 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (v10 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v5 ++ condition v7)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEc 7%Z) (FEc 17%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v2 (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) (@I) in let v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v5 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 in let v6 : linear (@Z) := {| num := Ring_polynom.PEc 7%Z; denum := Ring_polynom.PEc 17%Z; condition := Ring_polynom.PEc 17%Z :: nil |} in let v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 7%Z) (FEc 17%Z)) = v6 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 7%Z) (FEc 17%Z)) = v6 in let v8 : linear (@Z) := {| num := Ring_polynom.PEc 7%Z; denum := Ring_polynom.PEc 17%Z; condition := Ring_polynom.PEc 17%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) = v8 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) = v8 in v3 v4 v5 v6 v7 v8 v9 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v6) (denum v8))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v8) (denum v6))) = @true) (RField_lemma5 nil (condition v6 ++ condition v8) (fun (v10 : forall v10 : list (Ring_polynom.PExpr (@Z)), Prop) (v11 : v10 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v12 : forall v12 : list (Ring_polynom.PExpr (@Z)), Prop => v12 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v11 : v10 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v6 ++ condition v8) nil)))) : IZR 7 / IZR 17 = atan_sub (IZR 2 / IZR 3) (/ IZR 5) in eq_ind (IZR 7 / IZR 17) (fun v3 : @R => atan v3 = atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239))) (eq_ind_r (fun v3 : @R => v3 = atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239))) (f_equal (Rplus (atan (/ IZR 5))) (let v3 : IZR 9 / IZR 46 = atan_sub (IZR 7 / IZR 17) (/ IZR 5) := (let v3 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v4 : forall (v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v5 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 9%Z) (FEc 46%Z)) = v6) (v8 : linear (@Z)) (v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) = v8) (v10 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v6) (denum v8))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v8) (denum v6))) = @true) (v11 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v6 ++ condition v8)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEc 9%Z) (FEc 46%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v3 (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) (@I) in let v5 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v6 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 = v5 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 9%Z; denum := Ring_polynom.PEc 46%Z; condition := Ring_polynom.PEc 46%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 9%Z) (FEc 46%Z)) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 9%Z) (FEc 46%Z)) = v7 in let v9 : linear (@Z) := {| num := Ring_polynom.PEc 18%Z; denum := Ring_polynom.PEc 92%Z; condition := Ring_polynom.PEc 92%Z :: Ring_polynom.PEc 17%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 17%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v10 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) = v9 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) = v9 in v4 v5 v6 v7 v8 v9 v10 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v7) (denum v9))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v9) (denum v7))) = @true) (RField_lemma5 nil (condition v7 ++ condition v9) (fun (v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop) (v12 : v11 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v13 : forall v13 : list (Ring_polynom.PExpr (@Z)), Prop => v13 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v12 : v11 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v7 ++ condition v9) nil)))) : IZR 9 / IZR 46 = atan_sub (IZR 7 / IZR 17) (/ IZR 5) in eq_ind (IZR 9 / IZR 46) (fun v4 : @R => atan v4 = atan (/ IZR 5) + - atan (/ IZR 239)) (eq_ind_r (fun v4 : @R => v4 = atan (/ IZR 5) + - atan (/ IZR 239)) (f_equal (Rplus (atan (/ IZR 5))) (eq_ind (atan (- / IZR 239)) (fun v4 : @R => atan (atan_sub (IZR 9 / IZR 46) (/ IZR 5)) = v4) (f_equal (@atan) ((let v4 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v5 : forall (v5 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v6 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 = v5) (v7 : linear (@Z)) (v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = v7) (v9 : linear (@Z)) (v10 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEopp (FEinv (FEc 239%Z))) = v9) (v11 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v7) (denum v9))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v9) (denum v7))) = @true) (v12 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v7 ++ condition v9)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEopp (FEinv (FEc 239%Z))) := RField_field_lemma1 (@ring_subst_niter) nil v4 (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) (FEopp (FEinv (FEc 239%Z))) (@I) in let v6 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v7 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 = v6 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 = v6 in let v8 : linear (@Z) := {| num := Ring_polynom.PEc (-1)%Z; denum := Ring_polynom.PEc 239%Z; condition := Ring_polynom.PEc 239%Z :: Ring_polynom.PEc 46%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 46%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = v8 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = v8 in let v10 : linear (@Z) := {| num := Ring_polynom.PEc (-1)%Z; denum := Ring_polynom.PEc 239%Z; condition := Ring_polynom.PEc 239%Z :: nil |} in let v11 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEopp (FEinv (FEc 239%Z))) = v10 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEopp (FEinv (FEc 239%Z))) = v10 in v5 v6 v7 v8 v9 v10 v11 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEmul (num v8) (denum v10))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEmul (num v10) (denum v8))) = @true) (RField_lemma5 nil (condition v8 ++ condition v10) (fun (v12 : forall v12 : list (Ring_polynom.PExpr (@Z)), Prop) (v13 : v12 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v14 : forall v14 : list (Ring_polynom.PExpr (@Z)), Prop => v14 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v13 : v12 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v8 ++ condition v10) nil)))) : atan_sub (IZR 9 / IZR 46) (/ IZR 5) = - / IZR 239)) (- atan (/ IZR 239)) (atan_opp (/ IZR 239)))) (atan_sub_correct (IZR 9 / IZR 46) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 9 / IZR 46 * / IZR 5) (IZR 0) ((let v4 : IZR 1 + IZR 9 * / IZR 46 * / IZR 5 > IZR 0 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CMult (RMicromega.CZ 9) (RMicromega.CInv (RMicromega.CZ 46))) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR 1 + IZR 9 / IZR 46 * / IZR 5 > IZR 0)) (tech (IZR 9 / IZR 46) (/ IZR 5) (conj ((let v4 : IZR (-1) <= IZR 9 * / IZR 46 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 9) (RMicromega.CInv (RMicromega.CZ 46))) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR (-1) <= IZR 9 / IZR 46) ((let v4 : IZR 9 * / IZR 46 <= IZR 1 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 9) (RMicromega.CInv (RMicromega.CZ 46))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR 9 / IZR 46 <= IZR 1)) (conj ((let v4 : IZR (-1) < / IZR 5 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR (-1) < / IZR 5) ((let v4 : / IZR 5 < IZR 1 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 9 / IZR 46) (/ IZR 5))))) (atan_sub (IZR 7 / IZR 17) (/ IZR 5)) v3)) (atan_sub_correct (IZR 7 / IZR 17) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 7 / IZR 17 * / IZR 5) (IZR 0) ((let v3 : IZR 1 + IZR 7 * / IZR 17 * / IZR 5 > IZR 0 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CMult (RMicromega.CZ 7) (RMicromega.CInv (RMicromega.CZ 17))) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR 1 + IZR 7 / IZR 17 * / IZR 5 > IZR 0)) (tech (IZR 7 / IZR 17) (/ IZR 5) (conj ((let v3 : IZR (-1) <= IZR 7 * / IZR 17 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 7) (RMicromega.CInv (RMicromega.CZ 17))) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR (-1) <= IZR 7 / IZR 17) ((let v3 : IZR 7 * / IZR 17 <= IZR 1 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 7) (RMicromega.CInv (RMicromega.CZ 17))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR 7 / IZR 17 <= IZR 1)) (conj ((let v3 : IZR (-1) < / IZR 5 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR (-1) < / IZR 5) ((let v3 : / IZR 5 < IZR 1 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 7 / IZR 17) (/ IZR 5))))) (atan_sub (IZR 2 / IZR 3) (/ IZR 5)) v2)) (atan_sub_correct (IZR 2 / IZR 3) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 2 / IZR 3 * / IZR 5) (IZR 0) ((let v2 : IZR 1 + IZR 2 * / IZR 3 * / IZR 5 > IZR 0 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CMult (RMicromega.CZ 2) (RMicromega.CInv (RMicromega.CZ 3))) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR 1 + IZR 2 / IZR 3 * / IZR 5 > IZR 0)) (tech (IZR 2 / IZR 3) (/ IZR 5) (conj ((let v2 : IZR (-1) <= IZR 2 * / IZR 3 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 2) (RMicromega.CInv (RMicromega.CZ 3))) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) <= IZR 2 / IZR 3) ((let v2 : IZR 2 * / IZR 3 <= IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 2) (RMicromega.CInv (RMicromega.CZ 3))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR 2 / IZR 3 <= IZR 1)) (conj ((let v2 : IZR (-1) < / IZR 5 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) < / IZR 5) ((let v2 : / IZR 5 < IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 2 / IZR 3) (/ IZR 5))))) (atan_sub (IZR 1) (/ IZR 5)) v1)) (IZR 4 * atan (/ IZR 5) - atan (/ IZR 239)) v0) (atan_sub_correct (IZR 1) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 1 * / IZR 5) (IZR 0) ((let v0 : IZR 1 + IZR 1 * / IZR 5 > IZR 0 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CZ 1) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 + IZR 1 * / IZR 5 > IZR 0)) (tech (IZR 1) (/ IZR 5) (conj ((let v0 : IZR (-1) <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) <= IZR 1) ((let v0 : IZR 1 <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ 1); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 <= IZR 1)) (conj ((let v0 : IZR (-1) < / IZR 5 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) < / IZR 5) ((let v0 : / IZR 5 < IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 1) (/ IZR 5))))) (@PI / IZR 4) (@atan_1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.Machin_2_3_7	100	0.884738	1	1	0	synth with cache (only 1: refine (eq_ind (atan (IZR 1)) (fun v0 : @R => v0 = IZR 2 * atan (/ IZR 3) + atan (/ IZR 7)) (eq_ind_r (fun v0 : @R => v0 = IZR 2 * atan (/ IZR 3) + atan (/ IZR 7)) (let v0 : atan (/ IZR 3) + (atan (/ IZR 3) + atan (/ IZR 7)) = IZR 2 * atan (/ IZR 3) + atan (/ IZR 7) := let v0 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v1 : list (@R) := (atan (/ IZR 3) :: atan (/ IZR 7) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v1 v0 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 2%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (@I) (eq_refl : (let v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v0 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 2%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)))) = @true) in eq_ind (atan (/ IZR 3) + (atan (/ IZR 3) + atan (/ IZR 7))) (fun v1 : @R => atan (/ IZR 3) + atan (atan_sub (IZR 1) (/ IZR 3)) = v1) (f_equal (Rplus (atan (/ IZR 3))) (let v1 : / IZR 2 = atan_sub (IZR 1) (/ IZR 3) := (let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : forall (v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v3 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v2) (v4 : linear (@Z)) (v5 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 2%Z)) = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) = v6) (v8 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v4) (denum v6))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v6) (denum v4))) = @true) (v9 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v4 ++ condition v6)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEinv (FEc 2%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v1 (FEinv (FEc 2%Z)) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) (@I) in let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 in let v5 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 2%Z; condition := Ring_polynom.PEc 2%Z :: nil |} in let v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 2%Z)) = v5 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 2%Z)) = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 2%Z; denum := Ring_polynom.PEc 4%Z; condition := Ring_polynom.PEc 4%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 3%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) = v7 in v2 v3 v4 v5 v6 v7 v8 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (RField_lemma5 nil (condition v5 ++ condition v7) (fun (v9 : forall v9 : list (Ring_polynom.PExpr (@Z)), Prop) (v10 : v9 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop => v11 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v10 : v9 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v5 ++ condition v7) nil)))) : / IZR 2 = atan_sub (IZR 1) (/ IZR 3) in eq_ind (/ IZR 2) (fun v2 : @R => atan v2 = atan (/ IZR 3) + atan (/ IZR 7)) (eq_ind_r (fun v2 : @R => v2 = atan (/ IZR 3) + atan (/ IZR 7)) (f_equal (Rplus (atan (/ IZR 3))) (f_equal (@atan) ((let v2 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v3 : forall (v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v3) (v5 : linear (@Z)) (v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = v5) (v7 : linear (@Z)) (v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 7%Z)) = v7) (v9 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (v10 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v5 ++ condition v7)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEinv (FEc 7%Z)) := RField_field_lemma1 (@ring_subst_niter) nil v2 (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) (FEinv (FEc 7%Z)) (@I) in let v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v5 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 in let v6 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 7%Z; condition := Ring_polynom.PEc 7%Z :: Ring_polynom.PEc 2%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 2%Z :: Ring_polynom.PEc 3%Z :: nil |} in let v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = v6 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = v6 in let v8 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 7%Z; condition := Ring_polynom.PEc 7%Z :: nil |} in let v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 7%Z)) = v8 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 7%Z)) = v8 in v3 v4 v5 v6 v7 v8 v9 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v6) (denum v8))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v8) (denum v6))) = @true) (RField_lemma5 nil (condition v6 ++ condition v8) (fun (v10 : forall v10 : list (Ring_polynom.PExpr (@Z)), Prop) (v11 : v10 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v12 : forall v12 : list (Ring_polynom.PExpr (@Z)), Prop => v12 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v11 : v10 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v6 ++ condition v8) nil)))) : atan_sub (/ IZR 2) (/ IZR 3) = / IZR 7))) (atan_sub_correct (/ IZR 2) (/ IZR 3) (Rgt_not_eq (IZR 1 + / IZR 2 * / IZR 3) (IZR 0) ((let v2 : IZR 1 + / IZR 2 * / IZR 3 > IZR 0 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CInv (RMicromega.CZ 2)) (RMicromega.CInv (RMicromega.CZ 3)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR 1 + / IZR 2 * / IZR 3 > IZR 0)) (tech (/ IZR 2) (/ IZR 3) (conj ((let v2 : IZR (-1) <= / IZR 2 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) <= / IZR 2) ((let v2 : / IZR 2 <= IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : / IZR 2 <= IZR 1)) (conj ((let v2 : IZR (-1) < / IZR 3 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) < / IZR 3) ((let v2 : / IZR 3 < IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : / IZR 3 < IZR 1))) (atan_bound (atan_sub (/ IZR 2) (/ IZR 3))))) (atan_sub (IZR 1) (/ IZR 3)) v1)) (IZR 2 * atan (/ IZR 3) + atan (/ IZR 7)) v0) (atan_sub_correct (IZR 1) (/ IZR 3) (Rgt_not_eq (IZR 1 + IZR 1 * / IZR 3) (IZR 0) ((let v0 : IZR 1 + IZR 1 * / IZR 3 > IZR 0 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CZ 1) (RMicromega.CInv (RMicromega.CZ 3)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 + IZR 1 * / IZR 3 > IZR 0)) (tech (IZR 1) (/ IZR 3) (conj ((let v0 : IZR (-1) <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) <= IZR 1) ((let v0 : IZR 1 <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ 1); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 <= IZR 1)) (conj ((let v0 : IZR (-1) < / IZR 3 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) < / IZR 3) ((let v0 : / IZR 3 < IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : / IZR 3 < IZR 1))) (atan_bound (atan_sub (IZR 1) (/ IZR 3))))) (@PI / IZR 4) (@atan_1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.PI_2_3_7_ineq	100	2.195610	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.FTCN_step1	100	0.192803	1	1	0	synth with cache (only 1: refine (fun (v0 : @Differential) (v1 v2 : @R) => exist (fun v3 : forall v3 : @R, @R => antiderivative (fun v4 : @R => derive_pt v0 v4 (cond_diff v0 v4)) v3 v1 v2 \/ antiderivative (fun v4 : @R => derive_pt v0 v4 (cond_diff v0 v4)) v3 v2 v1) v0 (match Rle_dec v1 v2 as v3 in ({_} + {_}) return ((forall (v4 : @R) (v5 : v1 <= v4 <= v2), exists v6 : derivable_pt v0 v4, derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) /\ v1 <= v2 \/ (forall (v4 : @R) (v5 : v2 <= v4 <= v1), exists v6 : derivable_pt v0 v4, derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) /\ v2 <= v1) with | left v3 => (fun v3 : v1 <= v2 => or_introl (conj (fun (v4 : @R) (v5 : v1 <= v4 <= v2) => ex_intro (fun v6 : derivable_pt v0 v4 => derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) (cond_diff v0 v4) eq_refl) v3)) v3 | right v3 => (fun v3 : ~ v1 <= v2 => or_intror (conj (fun (v4 : @R) (v5 : v2 <= v4 <= v1) => ex_intro (fun v6 : derivable_pt v0 v4 => derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) (cond_diff v0 v4) eq_refl) (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v3)))) v3 end : antiderivative (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v0 v1 v2 \/ antiderivative (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v0 v2 v1) : Newton_integrable (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.FTC_Newton	100	0.057588	1	1	0	synth with cache (only 1: refine (fun (v0 : @Differential) (v1 v2 : @R) => eq_refl : NewtonInt (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v1 v2 (FTCN_step1 v0 v1 v2) = v0 v2 - v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P1	100	0.171322	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : @R) => exist (fun v2 : forall v2 : @R, @R => antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) (fct_cte (v0 v1) * @id)%F (or_introl (conj (fun (v2 : @R) (v3 : v1 <= v2 <= v1) => let v4 : derivable_pt (fct_cte (v0 v1) * @id) v2 := derivable_pt_mult (fct_cte (v0 v1)) (@id) v2 (derivable_pt_const (v0 v1) v2) (derivable_pt_id v2) in ex_intro (fun v5 : derivable_pt (fct_cte (v0 v1) * @id) v2 => v0 v2 = derive_pt (fct_cte (v0 v1) * @id) v2 v5) v4 (let v5 : v2 = v1 := and_ind (fun (v5 : v1 <= v2) (v6 : v2 <= v1) => Rle_antisym v2 v1 v6 v5) v3 in eq_sym (derive_pt_eq_0 (fct_cte (v0 v1) * @id)%F v2 (v0 v2) v4 (let v6 : IZR 0 * id v2 + fct_cte (v0 v1) v2 * IZR 1 = v0 v2 := (eq_ind_r (fun v6 : @R => IZR 0 * v6 + v0 v1 * IZR 1 = v0 v6) (let v6 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v7 : list (@R) := (v1 :: v0 v1 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v7 v6 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEX (@Z) 2) (@I) (eq_refl : (let v8 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v6 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEc 1%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEX (@Z) 2))) = @true)) v5 : IZR 0 * v2 + fct_cte (v0 v1) v2 * IZR 1 = v0 v2) : IZR 0 * id v2 + fct_cte (v0 v1) v2 * IZR 1 = v0 v2 in eq_ind (IZR 0 * id v2 + fct_cte (v0 v1) v2 * IZR 1) (fun v7 : @R => derivable_pt_lim (fct_cte (v0 v1) * @id) v2 v7) (derivable_pt_lim_mult (fct_cte (v0 v1)) (@id) v2 (IZR 0) (IZR 1) (derivable_pt_lim_const (v0 v1) v2) (derivable_pt_lim_id v2)) (v0 v2) v6)))) (or_intror eq_refl) : antiderivative v0 (fct_cte (v0 v1) * @id)%F v1 v1)) : Newton_integrable v0 v1 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P2	100	0.115478	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : @R) => (((((let v2 : Newton_integrable v0 v1 v1 := NewtonInt_P1 v0 v1 in match v2 as v3 in (sig _) return (match v3 as v4 in (sig _) return (@R) with | exist _ v4 v5 => (fun (v4 : forall v4 : @R, @R) (v5 : antiderivative v0 v4 v1 v1 \/ antiderivative v0 v4 v1 v1) => v4 v1 - v4 v1) v4 v5 end = IZR 0) with | exist _ v3 v4 => (fun (v3 : forall v3 : @R, @R) (v4 : antiderivative v0 v3 v1 v1 \/ antiderivative v0 v3 v1 v1) => Rminus_diag_eq (v3 v1) (v3 v1) eq_refl) v3 v4 end) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : NewtonInt v0 v1 v1 (NewtonInt_P1 v0 v1) = IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P3	100	0.069231	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : {v3 : forall v3 : @R, @R | antiderivative v0 v3 v1 v2 \/ antiderivative v0 v3 v2 v1}) => sig_rec (fun v4 : {v4 : forall v4 : @R, @R | antiderivative v0 v4 v1 v2 \/ antiderivative v0 v4 v2 v1} => {v5 : forall v5 : @R, @R | antiderivative v0 v5 v2 v1 \/ antiderivative v0 v5 v1 v2}) (fun (v4 : forall v4 : @R, @R) (v5 : antiderivative v0 v4 v1 v2 \/ antiderivative v0 v4 v2 v1) => exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v2 v1 \/ antiderivative v0 v6 v1 v2) v4 (or_ind (fun v6 : antiderivative v0 v4 v1 v2 => or_intror v6) (fun v6 : antiderivative v0 v4 v2 v1 => or_introl v6) v5)) v3) : forall (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : Newton_integrable v0 v1 v2), Newton_integrable v0 v2 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P4	100	0.327146	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : Newton_integrable v0 v1 v2) => match v3 as v4 in (sig _) return (NewtonInt v0 v1 v2 v4 = - NewtonInt v0 v2 v1 (NewtonInt_P3 v0 v1 v2 v4)) with | exist _ v4 v5 => (fun (v4 : forall v4 : @R, @R) (v5 : antiderivative v0 v4 v1 v2 \/ antiderivative v0 v4 v2 v1) => (((let v6 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v7 : list (@R) := (v4 v2 :: v4 v1 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v7 v6 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEopp (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 1))) (@I) (eq_refl : (let v8 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v6 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEopp (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 1))))) = @true)) : v4 v2 - v4 v1 = - match sig_rec (fun v6 : {v6 : forall v6 : @R, @R | antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1} => {v7 : forall v7 : @R, @R | antiderivative v0 v7 v2 v1 \/ antiderivative v0 v7 v1 v2}) (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) => exist (fun v8 : forall v8 : @R, @R => antiderivative v0 v8 v2 v1 \/ antiderivative v0 v8 v1 v2) v6 (or_ind (fun v8 : antiderivative v0 v6 v1 v2 => or_intror v8) (fun v8 : antiderivative v0 v6 v2 v1 => or_introl v8) v7)) (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5) as v6 in (sig _) return (@R) with | exist _ v6 v7 => (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v2 v1 \/ antiderivative v0 v6 v1 v2) => v6 v1 - v6 v2) v6 v7 end) : v4 v2 - v4 v1 = - match NewtonInt_P3 v0 v1 v2 (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5) as v6 in (sig _) return (@R) with | exist _ v6 v7 => (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v2 v1 \/ antiderivative v0 v6 v1 v2) => v6 v1 - v6 v2) v6 v7 end) : NewtonInt v0 v1 v2 (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5) = - NewtonInt v0 v2 v1 (NewtonInt_P3 v0 v1 v2 (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P5	100	2.431731	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P1	100	0.713397	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 v6 : @R) (v7 : (forall (v7 : @R) (v8 : v5 <= v7 <= v6), exists v9 : derivable_pt v2 v7, v0 v7 = derive_pt v2 v7 v9) /\ v5 <= v6) (v8 : (forall (v8 : @R) (v9 : v5 <= v8 <= v6), exists v10 : derivable_pt v3 v8, v1 v8 = derive_pt v3 v8 v10) /\ v5 <= v6) => and_ind (and_ind (fun (v9 : forall (v9 : @R) (v10 : v5 <= v9 <= v6), exists v11 : derivable_pt v3 v9, v1 v9 = derive_pt v3 v9 v11) (v10 : v5 <= v6) (v11 : forall (v11 : @R) (v12 : v5 <= v11 <= v6), exists v13 : derivable_pt v2 v11, v0 v11 = derive_pt v2 v11 v13) (v12 : v5 <= v6) => conj (fun (v13 : @R) (v14 : v5 <= v13 <= v6) => ex_ind (ex_ind (fun (v15 : derivable_pt v2 v13) (v16 : v0 v13 = derive_pt v2 v13 v15) (v17 : derivable_pt v3 v13) (v18 : v1 v13 = derive_pt v3 v13 v17) => let v19 : derivable_pt (fun v19 : @R => v4 * v2 v19 + v3 v19) v13 := derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17 in ex_intro (fun v20 : derivable_pt (fun v20 : @R => v4 * v2 v20 + v3 v20) v13 => v4 * v0 v13 + v1 v13 = derive_pt (fun v21 : @R => v4 * v2 v21 + v3 v21) v13 v20) v19 (eq_sym (let v20 : derive_pt (fct_cte v4 * v2 + v3) v13 (derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17) = derive_pt (fun v20 : @R => v4 * v2 v20 + v3 v20) v13 v19 := pr_nu (fun v20 : @R => v4 * v2 v20 + v3 v20) v13 (derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17) v19 in eq_ind (derive_pt (fct_cte v4 * v2 + v3) v13 (derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17)) (fun v21 : @R => v21 = v4 * v0 v13 + v1 v13) (eq_ind_r (fun v21 : @R => v21 = v4 * v0 v13 + v1 v13) (eq_ind_r (fun v21 : @R => v21 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) (eq_ind_r (fun v21 : @R => v21 * v2 v13 + fct_cte v4 v13 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) ((let v21 : list (@R) := (IZR 0 * v2 v13 + v4 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 :: v4 * v0 v13 + v1 v13 :: nil)%list in ((fun v22 : v21 = (IZR 0 * v2 v13 + v4 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 :: v4 * v0 v13 + v1 v13 :: nil)%list => let v23 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v24 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v25 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v23 = v24 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v23 = v24 in let v26 : forall (v26 : Ring_polynom.PExpr (@Z)) (v27 : Ring_polynom.Pol (@Z)) (v28 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 v26 = v27), Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v26 = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v27 := RField_ring_lemma2 (@ring_subst_niter) v23 (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) (@I) v24 v25 in let v27 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v28 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v27 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v27 in let v29 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v27 := v26 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) v27 v28 in eq_ind_r (fun v30 : @R => v30 = v4 * v0 v13 + v1 v13) (let v30 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v31 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v30 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v30 in let v32 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v30 := v26 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) v30 v31 in eq_ind (v0 v13) (fun v33 : @R => v4 * v33 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) (eq_ind (v1 v13) (fun v33 : @R => v4 * v0 v13 + v33 = v4 * v0 v13 + v1 v13) (let v33 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v34 : list (@R) := (v4 :: v0 v13 :: v1 v13 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v34 v33 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (@I) (eq_refl : (let v35 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v33 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v35 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v35 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)))) = @true)) (derive_pt v3 v13 v17) v18) (derive_pt v2 v13 v15) v16) v29) : forall v22 : v21 = v21, IZR 0 * v2 v13 + v4 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) eq_refl) : IZR 0 * v2 v13 + fct_cte v4 v13 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) (derive_pt_const v4 v13)) (derive_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15)) (derive_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17)) (derive_pt (fun v21 : @R => v4 * v2 v21 + v3 v21) v13 v19) v20))) (v11 v13 v14)) (v9 v13 v14)) v12) v8) v7) : forall (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 v6 : @R) (v7 : antiderivative v0 v2 v5 v6) (v8 : antiderivative v1 v3 v5 v6), antiderivative (fun v9 : @R => v4 * v0 v9 + v1 v9) (fun v9 : @R => v4 * v2 v9 + v3 v9) v5 v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P6	100	0.721657	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 v3 v4 : @R) (v5 : Newton_integrable v0 v3 v4) (v6 : Newton_integrable v1 v3 v4) => (let v7 : Newton_integrable (fun v7 : @R => v2 * v0 v7 + v1 v7) v3 v4 := NewtonInt_P5 v0 v1 v2 v3 v4 v5 v6 in match v7 as v8 in (sig _) return (match v8 as v9 in (sig _) return (@R) with | exist _ v9 v10 => (fun (v9 : forall v9 : @R, @R) (v10 : antiderivative (fun v10 : @R => v2 * v0 v10 + v1 v10) v9 v3 v4 \/ antiderivative (fun v10 : @R => v2 * v0 v10 + v1 v10) v9 v4 v3) => v9 v4 - v9 v3) v9 v10 end = v2 * match v5 as v9 in (sig _) return (@R) with | exist _ v9 v10 => (fun (v9 : forall v9 : @R, @R) (v10 : antiderivative v0 v9 v3 v4 \/ antiderivative v0 v9 v4 v3) => v9 v4 - v9 v3) v9 v10 end + match v6 as v9 in (sig _) return (@R) with | exist _ v9 v10 => (fun (v9 : forall v9 : @R, @R) (v10 : antiderivative v1 v9 v3 v4 \/ antiderivative v1 v9 v4 v3) => v9 v4 - v9 v3) v9 v10 end) with | exist _ v8 v9 => (fun (v8 : forall v8 : @R, @R) (v9 : antiderivative (fun v9 : @R => v2 * v0 v9 + v1 v9) v8 v3 v4 \/ antiderivative (fun v9 : @R => v2 * v0 v9 + v1 v9) v8 v4 v3) => match v5 as v10 in (sig _) return (v8 v4 - v8 v3 = v2 * match v10 as v11 in (sig _) return (@R) with | exist _ v11 v12 => (fun (v11 : forall v11 : @R, @R) (v12 : antiderivative v0 v11 v3 v4 \/ antiderivative v0 v11 v4 v3) => v11 v4 - v11 v3) v11 v12 end + match v6 as v11 in (sig _) return (@R) with | exist _ v11 v12 => (fun (v11 : forall v11 : @R, @R) (v12 : antiderivative v1 v11 v3 v4 \/ antiderivative v1 v11 v4 v3) => v11 v4 - v11 v3) v11 v12 end) with | exist _ v10 v11 => (fun (v10 : forall v10 : @R, @R) (v11 : antiderivative v0 v10 v3 v4 \/ antiderivative v0 v10 v4 v3) => match v6 as v12 in (sig _) return (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + match v12 as v13 in (sig _) return (@R) with | exist _ v13 v14 => (fun (v13 : forall v13 : @R, @R) (v14 : antiderivative v1 v13 v3 v4 \/ antiderivative v1 v13 v4 v3) => v13 v4 - v13 v3) v13 v14 end) with | exist _ v12 v13 => (fun (v12 : forall v12 : @R, @R) (v13 : antiderivative v1 v12 v3 v4 \/ antiderivative v1 v12 v4 v3) => let v14 : {v3 < v4} + {v3 = v4} + {v4 < v3} := total_order_T v3 v4 in match v14 as v15 in (_ + {_}) return (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) with | inleft v15 => (fun v15 : {v3 < v4} + {v3 = v4} => match v15 as v16 in ({_} + {_}) return (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) with | left v16 => (fun v16 : v3 < v4 => or_ind (fun v17 : antiderivative (fun v17 : @R => v2 * v0 v17 + v1 v17) v8 v3 v4 => or_ind (fun v18 : antiderivative v0 v10 v3 v4 => or_ind (fun v19 : antiderivative v1 v12 v3 v4 => let v20 : antiderivative (fun v20 : @R => v2 * v0 v20 + v1 v20) (fun v20 : @R => v2 * v10 v20 + v12 v20) v3 v4 := antiderivative_P1 v0 v1 v10 v12 v2 v3 v4 v18 v19 in let v21 : exists v21 : @R, forall (v22 : @R) (v23 : v3 <= v22 <= v4), v8 v22 = (fun v24 : @R => v2 * v10 v24 + v12 v24) v22 + v21 := antiderivative_Ucte (fun v21 : @R => v2 * v0 v21 + v1 v21) v8 (fun v21 : @R => v2 * v10 v21 + v12 v21) v3 v4 v17 v20 in ex_ind (fun (v22 : @R) (v23 : forall (v23 : @R) (v24 : v3 <= v23 <= v4), v8 v23 = v2 * v10 v23 + v12 v23 + v22) => let v24 : v3 <= v3 <= v4 := conj (or_intror eq_refl) (or_introl v16) in let v25 : v3 <= v4 <= v4 := conj (or_introl v16) (or_intror eq_refl) in let v26 : v8 v3 = v2 * v10 v3 + v12 v3 + v22 := v23 v3 v24 in let v27 : v8 v4 = v2 * v10 v4 + v12 v4 + v22 := v23 v4 v25 in eq_ind_r (fun v28 : @R => v8 v4 - v28 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (eq_ind_r (fun v28 : @R => v28 - (v2 * v10 v3 + v12 v3 + v22) = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (let v28 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v29 : list (@R) := (v2 :: v10 v4 :: v12 v4 :: v22 :: v10 v3 :: v12 v3 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v29 v28 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))) (@I) (eq_refl : (let v30 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v28 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v30 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v30 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))))) = @true)) v27) v26) v21) (fun v19 : antiderivative v1 v12 v4 v3 => and_ind (fun (v20 : forall (v20 : @R) (v21 : v4 <= v20 <= v3), exists v22 : derivable_pt v12 v20, v1 v20 = derive_pt v12 v20 v22) (v21 : v4 <= v3) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v4 (Rle_lt_trans v4 v3 v4 v21 v16))) v19) v13) (fun v18 : antiderivative v0 v10 v4 v3 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v4 <= v19 <= v3), exists v21 : derivable_pt v10 v19, v0 v19 = derive_pt v10 v19 v21) (v20 : v4 <= v3) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v4 (Rle_lt_trans v4 v3 v4 v20 v16))) v18) v11) (fun v17 : antiderivative (fun v17 : @R => v2 * v0 v17 + v1 v17) v8 v4 v3 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v4 <= v18 <= v3), exists v20 : derivable_pt v8 v18, v2 * v0 v18 + v1 v18 = derive_pt v8 v18 v20) (v19 : v4 <= v3) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v4 (Rle_lt_trans v4 v3 v4 v19 v16))) v17) v9) v16 | right v16 => (fun v16 : v3 = v4 => eq_ind_r (fun v17 : @R => v8 v4 - v8 v17 = v2 * (v10 v4 - v10 v17) + (v12 v4 - v12 v17)) (let v17 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v18 : list (@R) := (v8 v4 :: v2 :: v10 v4 :: v12 v4 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v18 v17 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 4))) (@I) (eq_refl : (let v19 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v17 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 1))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 4))))) = @true)) v16) v16 end) v15 | inright v15 => (fun v15 : v4 < v3 => or_ind (fun v16 : antiderivative (fun v16 : @R => v2 * v0 v16 + v1 v16) v8 v3 v4 => and_ind (fun (v17 : forall (v17 : @R) (v18 : v3 <= v17 <= v4), exists v19 : derivable_pt v8 v17, v2 * v0 v17 + v1 v17 = derive_pt v8 v17 v19) (v18 : v3 <= v4) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v3 (Rle_lt_trans v3 v4 v3 v18 v15))) v16) (fun v16 : antiderivative (fun v16 : @R => v2 * v0 v16 + v1 v16) v8 v4 v3 => or_ind (fun v17 : antiderivative v0 v10 v3 v4 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v3 <= v18 <= v4), exists v20 : derivable_pt v10 v18, v0 v18 = derive_pt v10 v18 v20) (v19 : v3 <= v4) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v3 (Rle_lt_trans v3 v4 v3 v19 v15))) v17) (fun v17 : antiderivative v0 v10 v4 v3 => or_ind (fun v18 : antiderivative v1 v12 v3 v4 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v3 <= v19 <= v4), exists v21 : derivable_pt v12 v19, v1 v19 = derive_pt v12 v19 v21) (v20 : v3 <= v4) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v3 (Rle_lt_trans v3 v4 v3 v20 v15))) v18) (fun v18 : antiderivative v1 v12 v4 v3 => let v19 : antiderivative (fun v19 : @R => v2 * v0 v19 + v1 v19) (fun v19 : @R => v2 * v10 v19 + v12 v19) v4 v3 := antiderivative_P1 v0 v1 v10 v12 v2 v4 v3 v17 v18 in let v20 : exists v20 : @R, forall (v21 : @R) (v22 : v4 <= v21 <= v3), v8 v21 = (fun v23 : @R => v2 * v10 v23 + v12 v23) v21 + v20 := antiderivative_Ucte (fun v20 : @R => v2 * v0 v20 + v1 v20) v8 (fun v20 : @R => v2 * v10 v20 + v12 v20) v4 v3 v16 v19 in ex_ind (fun (v21 : @R) (v22 : forall (v22 : @R) (v23 : v4 <= v22 <= v3), v8 v22 = v2 * v10 v22 + v12 v22 + v21) => let v23 : v4 <= v3 <= v3 := conj (or_introl v15) (or_intror eq_refl) in let v24 : v4 <= v4 <= v3 := conj (or_intror eq_refl) (or_introl v15) in let v25 : v8 v3 = v2 * v10 v3 + v12 v3 + v21 := v22 v3 v23 in let v26 : v8 v4 = v2 * v10 v4 + v12 v4 + v21 := v22 v4 v24 in eq_ind_r (fun v27 : @R => v8 v4 - v27 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (eq_ind_r (fun v27 : @R => v27 - (v2 * v10 v3 + v12 v3 + v21) = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (let v27 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v28 : list (@R) := (v2 :: v10 v4 :: v12 v4 :: v21 :: v10 v3 :: v12 v3 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v28 v27 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))) (@I) (eq_refl : (let v29 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v27 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v29 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v29 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))))) = @true)) v26) v25) v20) v13) v11) v9) v15 end) v12 v13 end) v10 v11 end) v8 v9 end) : NewtonInt (fun v7 : @R => v2 * v0 v7 + v1 v7) v3 v4 (NewtonInt_P5 v0 v1 v2 v3 v4 v5 v6) = v2 * NewtonInt v0 v3 v4 v5 + NewtonInt v1 v3 v4 v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P2	100	1.959255	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P3	100	0.236350	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 v4 v5 : @R) (v6 : antiderivative v0 v1 v3 v4) (v7 : antiderivative v0 v2 v5 v4) => and_ind (and_ind (fun (v8 : forall (v8 : @R) (v9 : v5 <= v8 <= v4), exists v10 : derivable_pt v2 v8, v0 v8 = derive_pt v2 v8 v10) (v9 : v5 <= v4) (v10 : forall (v10 : @R) (v11 : v3 <= v10 <= v4), exists v12 : derivable_pt v1 v10, v0 v10 = derive_pt v1 v10 v12) (v11 : v3 <= v4) => let v12 : {v3 < v5} + {v3 = v5} + {v5 < v3} := total_order_T v3 v5 in match v12 as v13 in (_ + {_}) return (antiderivative v0 v2 v5 v3 \/ antiderivative v0 v1 v3 v5) with | inleft v13 => (fun v13 : {v3 < v5} + {v3 = v5} => match v13 as v14 in ({_} + {_}) return (antiderivative v0 v2 v5 v3 \/ antiderivative v0 v1 v3 v5) with | left v14 => (fun v14 : v3 < v5 => or_intror (conj (fun (v15 : @R) (v16 : v3 <= v15 <= v5) => v10 v15 (and_ind (fun (v17 : v3 <= v15) (v18 : v15 <= v5) => conj v17 (Rle_trans v15 v5 v4 v18 v9)) v16)) (or_introl v14) : antiderivative v0 v1 v3 v5)) v14 | right v14 => (fun v14 : v3 = v5 => or_intror (conj (fun (v15 : @R) (v16 : v3 <= v15 <= v5) => v10 v15 (and_ind (fun (v17 : v3 <= v15) (v18 : v15 <= v5) => conj v17 (Rle_trans v15 v5 v4 v18 v9)) v16)) (or_intror v14) : antiderivative v0 v1 v3 v5)) v14 end) v13 | inright v13 => (fun v13 : v5 < v3 => or_introl (conj (fun (v14 : @R) (v15 : v5 <= v14 <= v3) => v8 v14 (and_ind (fun (v16 : v5 <= v14) (v17 : v14 <= v3) => conj v16 (Rle_trans v14 v3 v4 v17 v11)) v15)) (or_introl v13) : antiderivative v0 v2 v5 v3)) v13 end) v7) v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P4	100	0.213658	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 v4 v5 : @R) (v6 : antiderivative v0 v1 v3 v4) (v7 : antiderivative v0 v2 v3 v5) => and_ind (and_ind (fun (v8 : forall (v8 : @R) (v9 : v3 <= v8 <= v5), exists v10 : derivable_pt v2 v8, v0 v8 = derive_pt v2 v8 v10) (v9 : v3 <= v5) (v10 : forall (v10 : @R) (v11 : v3 <= v10 <= v4), exists v12 : derivable_pt v1 v10, v0 v10 = derive_pt v1 v10 v12) (v11 : v3 <= v4) => let v12 : {v5 < v4} + {v5 = v4} + {v4 < v5} := total_order_T v5 v4 in match v12 as v13 in (_ + {_}) return (antiderivative v0 v2 v4 v5 \/ antiderivative v0 v1 v5 v4) with | inleft v13 => (fun v13 : {v5 < v4} + {v5 = v4} => match v13 as v14 in ({_} + {_}) return (antiderivative v0 v2 v4 v5 \/ antiderivative v0 v1 v5 v4) with | left v14 => (fun v14 : v5 < v4 => or_intror (conj (fun (v15 : @R) (v16 : v5 <= v15 <= v4) => v10 v15 (and_ind (fun (v17 : v5 <= v15) (v18 : v15 <= v4) => conj (Rle_trans v3 v5 v15 v9 v17) v18) v16)) (or_introl v14) : antiderivative v0 v1 v5 v4)) v14 | right v14 => (fun v14 : v5 = v4 => or_intror (conj (fun (v15 : @R) (v16 : v5 <= v15 <= v4) => v10 v15 (and_ind (fun (v17 : v5 <= v15) (v18 : v15 <= v4) => conj (Rle_trans v3 v5 v15 v9 v17) v18) v16)) (or_intror v14) : antiderivative v0 v1 v5 v4)) v14 end) v13 | inright v13 => (fun v13 : v4 < v5 => or_introl (conj (fun (v14 : @R) (v15 : v4 <= v14 <= v5) => v8 v14 (and_ind (fun (v16 : v4 <= v14) (v17 : v14 <= v5) => conj (Rle_trans v3 v4 v14 v11 v16) v17) v15)) (or_introl v13) : antiderivative v0 v2 v4 v5)) v13 end) v7) v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P7	100	0.365639	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : v1 < v2) (v5 : v2 < v3) (v6 : {v6 : forall v6 : @R, @R | antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1}) (v7 : {v7 : forall v7 : @R, @R | antiderivative v0 v7 v2 v3 \/ antiderivative v0 v7 v3 v2}) => sig_rec (fun v8 : {v8 : forall v8 : @R, @R | antiderivative v0 v8 v1 v2 \/ antiderivative v0 v8 v2 v1} => {v9 : forall v9 : @R, @R | antiderivative v0 v9 v1 v3 \/ antiderivative v0 v9 v3 v1}) (fun (v8 : forall v8 : @R, @R) (v9 : antiderivative v0 v8 v1 v2 \/ antiderivative v0 v8 v2 v1) => sig_rec (fun v10 : {v10 : forall v10 : @R, @R | antiderivative v0 v10 v2 v3 \/ antiderivative v0 v10 v3 v2} => {v11 : forall v11 : @R, @R | antiderivative v0 v11 v1 v3 \/ antiderivative v0 v11 v3 v1}) (fun (v10 : forall v10 : @R, @R) (v11 : antiderivative v0 v10 v2 v3 \/ antiderivative v0 v10 v3 v2) => let v12 : forall v12 : @R, @R := fun v12 : @R => match Rle_dec v12 v2 as v13 in ({_} + {_}) return (@R) with | left v13 => (fun v13 : v12 <= v2 => v8 v12) v13 | right v13 => (fun v13 : ~ v12 <= v2 => v10 v12 + (v8 v2 - v10 v2)) v13 end in exist (fun v13 : forall v13 : @R, @R => antiderivative v0 v13 v1 v3 \/ antiderivative v0 v13 v3 v1) v12 (or_introl (antiderivative_P2 v0 v8 v10 v1 v2 v3 (or_ind (fun v13 : antiderivative v0 v8 v1 v2 => v13) (fun v13 : antiderivative v0 v8 v2 v1 => and_ind (fun (v14 : forall (v14 : @R) (v15 : v2 <= v14 <= v1), exists v16 : derivable_pt v8 v14, v0 v14 = derive_pt v8 v14 v16) (v15 : v2 <= v1) => False_ind (antiderivative v0 v8 v1 v2) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v15 v4))) v13) v9) (or_ind (fun v13 : antiderivative v0 v10 v2 v3 => v13) (fun v13 : antiderivative v0 v10 v3 v2 => and_ind (fun (v14 : forall (v14 : @R) (v15 : v3 <= v14 <= v2), exists v16 : derivable_pt v10 v14, v0 v14 = derive_pt v10 v14 v16) (v15 : v3 <= v2) => False_ind (antiderivative v0 v10 v2 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v15 v5))) v13) v11) : antiderivative v0 v12 v1 v3))) v7) v6) : forall (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : v1 < v2) (v5 : v2 < v3) (v6 : Newton_integrable v0 v1 v2) (v7 : Newton_integrable v0 v2 v3), Newton_integrable v0 v1 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P8	100	0.716157	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : Newton_integrable v0 v1 v2) (v5 : Newton_integrable v0 v2 v3) => sig_rect (fun v6 : {v6 : forall v6 : @R, @R | antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1} => Newton_integrable v0 v1 v3) (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) => sig_rect (fun v8 : {v8 : forall v8 : @R, @R | antiderivative v0 v8 v2 v3 \/ antiderivative v0 v8 v3 v2} => Newton_integrable v0 v1 v3) (fun (v8 : forall v8 : @R, @R) (v9 : antiderivative v0 v8 v2 v3 \/ antiderivative v0 v8 v3 v2) => let v10 : {v1 < v2} + {v1 = v2} + {v2 < v1} := total_order_T v1 v2 in match v10 as v11 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v11 => (fun v11 : {v1 < v2} + {v1 = v2} => match v11 as v12 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v12 => (fun v12 : v1 < v2 => let v13 : {v2 < v3} + {v2 = v3} + {v3 < v2} := total_order_T v2 v3 in match v13 as v14 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v14 => (fun v14 : {v2 < v3} + {v2 = v3} => match v14 as v15 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v15 => (fun v15 : v2 < v3 => exist (fun v16 : forall v16 : @R, @R => antiderivative v0 v16 v1 v3 \/ antiderivative v0 v16 v3 v1) (fun v16 : @R => match Rle_dec v16 v2 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v16 <= v2 => v6 v16) v17 | right v17 => (fun v17 : ~ v16 <= v2 => v8 v16 + (v6 v2 - v8 v2)) v17 end) (or_ind (fun v16 : antiderivative v0 v6 v1 v2 => or_ind (fun v17 : antiderivative v0 v8 v2 v3 => or_introl (antiderivative_P2 v0 v6 v8 v1 v2 v3 v16 v17)) (fun v17 : antiderivative v0 v8 v3 v2 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v3 <= v18 <= v2), exists v20 : derivable_pt v8 v18, v0 v18 = derive_pt v8 v18 v20) (v19 : v3 <= v2) => False_ind (antiderivative v0 (fun v20 : @R => match Rle_dec v20 v2 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v20 <= v2 => v6 v20) v21 | right v21 => (fun v21 : ~ v20 <= v2 => v8 v20 + (v6 v2 - v8 v2)) v21 end) v1 v3 \/ antiderivative v0 (fun v20 : @R => match Rle_dec v20 v2 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v20 <= v2 => v6 v20) v21 | right v21 => (fun v21 : ~ v20 <= v2 => v8 v20 + (v6 v2 - v8 v2)) v21 end) v3 v1) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v19 v15))) v17) v9) (fun v16 : antiderivative v0 v6 v2 v1 => and_ind (fun (v17 : forall (v17 : @R) (v18 : v2 <= v17 <= v1), exists v19 : derivable_pt v6 v17, v0 v17 = derive_pt v6 v17 v19) (v18 : v2 <= v1) => False_ind (antiderivative v0 (fun v19 : @R => match Rle_dec v19 v2 as v20 in ({_} + {_}) return (@R) with | left v20 => (fun v20 : v19 <= v2 => v6 v19) v20 | right v20 => (fun v20 : ~ v19 <= v2 => v8 v19 + (v6 v2 - v8 v2)) v20 end) v1 v3 \/ antiderivative v0 (fun v19 : @R => match Rle_dec v19 v2 as v20 in ({_} + {_}) return (@R) with | left v20 => (fun v20 : v19 <= v2 => v6 v19) v20 | right v20 => (fun v20 : ~ v19 <= v2 => v8 v19 + (v6 v2 - v8 v2)) v20 end) v3 v1) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v18 v12))) v16) v7) : Newton_integrable v0 v1 v3) v15 | right v15 => (fun v15 : v2 = v3 => let v16 : Newton_integrable v0 v1 v3 := eq_rect v2 (fun v16 : @R => Newton_integrable v0 v1 v16) v4 v3 v15 in v16) v15 end) v14 | inright v14 => (fun v14 : v3 < v2 => let v15 : {v1 < v3} + {v1 = v3} + {v3 < v1} := total_order_T v1 v3 in match v15 as v16 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v16 => (fun v16 : {v1 < v3} + {v1 = v3} => match v16 as v17 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v17 => (fun v17 : v1 < v3 => exist (fun v18 : forall v18 : @R, @R => antiderivative v0 v18 v1 v3 \/ antiderivative v0 v18 v3 v1) v6 (or_introl (or_ind (fun v18 : antiderivative v0 v8 v2 v3 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v2 <= v19 <= v3), exists v21 : derivable_pt v8 v19, v0 v19 = derive_pt v8 v19 v21) (v20 : v2 <= v3) => False_ind (antiderivative v0 v6 v1 v3) (Rlt_irrefl v2 (Rle_lt_trans v2 v3 v2 v20 v14))) v18) (fun v18 : antiderivative v0 v8 v3 v2 => or_ind (fun v19 : antiderivative v0 v6 v1 v2 => let v20 : antiderivative v0 v8 v3 v1 \/ antiderivative v0 v6 v1 v3 := antiderivative_P3 v0 v6 v8 v1 v2 v3 v19 v18 in or_ind (fun v21 : antiderivative v0 v8 v3 v1 => and_ind (fun (v22 : forall (v22 : @R) (v23 : v3 <= v22 <= v1), exists v24 : derivable_pt v8 v22, v0 v22 = derive_pt v8 v22 v24) (v23 : v3 <= v1) => False_ind (antiderivative v0 v6 v1 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v1 v3 v23 v17))) v21) (fun v21 : antiderivative v0 v6 v1 v3 => v21) v20) (fun v19 : antiderivative v0 v6 v2 v1 => and_ind (fun (v20 : forall (v20 : @R) (v21 : v2 <= v20 <= v1), exists v22 : derivable_pt v6 v20, v0 v20 = derive_pt v6 v20 v22) (v21 : v2 <= v1) => False_ind (antiderivative v0 v6 v1 v3) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v21 v12))) v19) v7) v9)) : Newton_integrable v0 v1 v3) v17 | right v17 => (fun v17 : v1 = v3 => eq_rect_r (fun v18 : @R => Newton_integrable v0 v18 v3) (NewtonInt_P1 v0 v3) v17) v17 end) v16 | inright v16 => (fun v16 : v3 < v1 => exist (fun v17 : forall v17 : @R, @R => antiderivative v0 v17 v1 v3 \/ antiderivative v0 v17 v3 v1) v8 (or_intror (or_ind (fun v17 : antiderivative v0 v8 v2 v3 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v2 <= v18 <= v3), exists v20 : derivable_pt v8 v18, v0 v18 = derive_pt v8 v18 v20) (v19 : v2 <= v3) => False_ind (antiderivative v0 v8 v3 v1) (Rlt_irrefl v2 (Rle_lt_trans v2 v3 v2 v19 v14))) v17) (fun v17 : antiderivative v0 v8 v3 v2 => or_ind (fun v18 : antiderivative v0 v6 v1 v2 => let v19 : antiderivative v0 v8 v3 v1 \/ antiderivative v0 v6 v1 v3 := antiderivative_P3 v0 v6 v8 v1 v2 v3 v18 v17 in or_ind (fun v20 : antiderivative v0 v8 v3 v1 => v20) (fun v20 : antiderivative v0 v6 v1 v3 => and_ind (fun (v21 : forall (v21 : @R) (v22 : v1 <= v21 <= v3), exists v23 : derivable_pt v6 v21, v0 v21 = derive_pt v6 v21 v23) (v22 : v1 <= v3) => False_ind (antiderivative v0 v8 v3 v1) (Rlt_irrefl v1 (Rle_lt_trans v1 v3 v1 v22 v16))) v20) v19) (fun v18 : antiderivative v0 v6 v2 v1 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v2 <= v19 <= v1), exists v21 : derivable_pt v6 v19, v0 v19 = derive_pt v6 v19 v21) (v20 : v2 <= v1) => False_ind (antiderivative v0 v8 v3 v1) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v20 v12))) v18) v7) v9)) : Newton_integrable v0 v1 v3) v16 end) v14 end) v12 | right v12 => (fun v12 : v1 = v2 => eq_rect_r (fun v13 : @R => Newton_integrable v0 v13 v3) v5 v12) v12 end) v11 | inright v11 => (fun v11 : v2 < v1 => let v12 : {v2 < v3} + {v2 = v3} + {v3 < v2} := total_order_T v2 v3 in match v12 as v13 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v13 => (fun v13 : {v2 < v3} + {v2 = v3} => match v13 as v14 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v14 => (fun v14 : v2 < v3 => let v15 : {v1 < v3} + {v1 = v3} + {v3 < v1} := total_order_T v1 v3 in match v15 as v16 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v16 => (fun v16 : {v1 < v3} + {v1 = v3} => match v16 as v17 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v17 => (fun v17 : v1 < v3 => exist (fun v18 : forall v18 : @R, @R => antiderivative v0 v18 v1 v3 \/ antiderivative v0 v18 v3 v1) v8 (or_introl (or_ind (fun v18 : antiderivative v0 v8 v2 v3 => or_ind (fun v19 : antiderivative v0 v6 v1 v2 => and_ind (fun (v20 : forall (v20 : @R) (v21 : v1 <= v20 <= v2), exists v22 : derivable_pt v6 v20, v0 v20 = derive_pt v6 v20 v22) (v21 : v1 <= v2) => False_ind (antiderivative v0 v8 v1 v3) (Rlt_irrefl v1 (Rle_lt_trans v1 v2 v1 v21 v11))) v19) (fun v19 : antiderivative v0 v6 v2 v1 => let v20 : antiderivative v0 v8 v1 v3 \/ antiderivative v0 v6 v3 v1 := antiderivative_P4 v0 v6 v8 v2 v1 v3 v19 v18 in or_ind (fun v21 : antiderivative v0 v8 v1 v3 => v21) (fun v21 : antiderivative v0 v6 v3 v1 => and_ind (fun (v22 : forall (v22 : @R) (v23 : v3 <= v22 <= v1), exists v24 : derivable_pt v6 v22, v0 v22 = derive_pt v6 v22 v24) (v23 : v3 <= v1) => False_ind (antiderivative v0 v8 v1 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v1 v3 v23 v17))) v21) v20) v7) (fun v18 : antiderivative v0 v8 v3 v2 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v3 <= v19 <= v2), exists v21 : derivable_pt v8 v19, v0 v19 = derive_pt v8 v19 v21) (v20 : v3 <= v2) => False_ind (antiderivative v0 v8 v1 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v20 v14))) v18) v9)) : Newton_integrable v0 v1 v3) v17 | right v17 => (fun v17 : v1 = v3 => eq_rect_r (fun v18 : @R => Newton_integrable v0 v18 v3) (NewtonInt_P1 v0 v3) v17) v17 end) v16 | inright v16 => (fun v16 : v3 < v1 => exist (fun v17 : forall v17 : @R, @R => antiderivative v0 v17 v1 v3 \/ antiderivative v0 v17 v3 v1) v6 (or_intror (or_ind (fun v17 : antiderivative v0 v6 v1 v2 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v1 <= v18 <= v2), exists v20 : derivable_pt v6 v18, v0 v18 = derive_pt v6 v18 v20) (v19 : v1 <= v2) => False_ind (antiderivative v0 v6 v3 v1) (Rlt_irrefl v1 (Rle_lt_trans v1 v2 v1 v19 v11))) v17) (fun v17 : antiderivative v0 v6 v2 v1 => or_ind (fun v18 : antiderivative v0 v8 v2 v3 => let v19 : antiderivative v0 v8 v1 v3 \/ antiderivative v0 v6 v3 v1 := antiderivative_P4 v0 v6 v8 v2 v1 v3 v17 v18 in or_ind (fun v20 : antiderivative v0 v8 v1 v3 => and_ind (fun (v21 : forall (v21 : @R) (v22 : v1 <= v21 <= v3), exists v23 : derivable_pt v8 v21, v0 v21 = derive_pt v8 v21 v23) (v22 : v1 <= v3) => False_ind (antiderivative v0 v6 v3 v1) (Rlt_irrefl v1 (Rle_lt_trans v1 v3 v1 v22 v16))) v20) (fun v20 : antiderivative v0 v6 v3 v1 => v20) v19) (fun v18 : antiderivative v0 v8 v3 v2 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v3 <= v19 <= v2), exists v21 : derivable_pt v8 v19, v0 v19 = derive_pt v8 v19 v21) (v20 : v3 <= v2) => False_ind (antiderivative v0 v6 v3 v1) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v20 v14))) v18) v9) v7)) : Newton_integrable v0 v1 v3) v16 end) v14 | right v14 => (fun v14 : v2 = v3 => let v15 : Newton_integrable v0 v1 v3 := eq_rect v2 (fun v15 : @R => Newton_integrable v0 v1 v15) v4 v3 v14 in v15) v14 end) v13 | inright v13 => (fun v13 : v3 < v2 => let v14 : Newton_integrable v0 v2 v1 := NewtonInt_P3 v0 v1 v2 v4 in let v15 : Newton_integrable v0 v3 v2 := NewtonInt_P3 v0 v2 v3 v5 in NewtonInt_P3 v0 v3 v1 (NewtonInt_P7 v0 v3 v2 v1 v13 v11 v15 v14)) v13 end) v11 end) v5) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P9	100	3.390954	1	1
