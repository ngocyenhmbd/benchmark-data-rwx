coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj1	100	0.650749	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@A) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v1) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj2	100	0.016453	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@B) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_refl	100	0.009427	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : v0 => v1) (fun v1 : v0 => v1))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_trans	100	0.028482	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v1 <-> v2, v0 <-> v2) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v1 <-> v2) => match v6 as v7 in (_ /\ _) return (v0 <-> v2) with | conj v7 v8 => (fun (v7 : forall v7 : v1, v2) (v8 : forall v8 : v2, v1) => conj (fun v9 : v0 => v7 (v4 v9)) (fun v9 : v2 => v5 (v4 (v5 (v8 v9))))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_sym	100	0.017800	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return (v1 <-> v0) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v4 v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_l	100	0.033890	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 /\ v1 <-> v0 /\ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 /\ v1 => match v6 as v7 in (_ /\ _) return (v0 /\ v2) with | conj v7 v8 => (fun (v7 : v0) (v8 : v1) => conj v7 (v4 v8)) v7 v8 end) (fun v6 : v0 /\ v2 => match v6 as v7 in (_ /\ _) return (v0 /\ v1) with | conj v7 v8 => (fun (v7 : v0) (v8 : v2) => conj v7 (v5 v8)) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_r	100	0.035058	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 /\ v0 <-> v2 /\ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 /\ v0 => match v6 as v7 in (_ /\ _) return (v2 /\ v0) with | conj v7 v8 => (fun (v7 : v1) (v8 : v0) => conj (v4 v7) v8) v7 v8 end) (fun v6 : v2 /\ v0 => match v6 as v7 in (_ /\ _) return (v1 /\ v0) with | conj v7 v8 => (fun (v7 : v2) (v8 : v0) => conj (v5 v7) v8) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_l	100	0.037957	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 \/ v1 <-> v0 \/ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 \/ v1 => match v6 as v7 in (_ \/ _) return (v0 \/ v2) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v1 => or_intror (v4 v7)) v7 end) (fun v6 : v0 \/ v2 => match v6 as v7 in (_ \/ _) return (v0 \/ v1) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v2 => or_intror (v5 v7)) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_r	100	0.039725	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 \/ v0 <-> v2 \/ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 \/ v0 => match v6 as v7 in (_ \/ _) return (v2 \/ v0) with | or_introl v7 => (fun v7 : v1 => or_introl (v4 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end) (fun v6 : v2 \/ v0 => match v6 as v7 in (_ \/ _) return (v1 \/ v0) with | or_introl v7 => (fun v7 : v2 => or_introl (v5 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_l	100	0.021294	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v0, v1) <-> (forall v5 : v0, v2)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v0, v1) (v7 : v0) => v4 (v6 v7)) (fun (v6 : forall v6 : v0, v2) (v7 : v0) => v5 (v6 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_r	100	0.021615	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v1, v0) <-> (forall v5 : v2, v0)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v1, v0) (v7 : v2) => v6 (v5 v7)) (fun (v6 : forall v6 : v2, v0) (v7 : v1) => v6 (v4 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.not_iff_compat	100	0.014508	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => imp_iff_compat_r (@False) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.neg_false	100	0.022623	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : forall v1 : v0, @False => conj v1 (fun v2 : @False => False_ind v0 v2)) (fun v1 : v0 <-> @False => match v1 as v2 in (_ /\ _) return (forall v3 : v0, @False) with | conj v2 v3 => (fun (v2 : forall v2 : v0, @False) (v3 : forall v3 : @False, v0) => v2) v2 v3 end) : ~ v0 <-> (v0 <-> @False))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_l	100	0.049805	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v0 /\ v1 <-> v0 /\ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 /\ v1, v0 /\ v2) (v7 : forall v7 : v0 /\ v2, v0 /\ v1) => conj (fun v8 : v1 => let v9 : forall v9 : v0 /\ v1, v2 := fun v9 : v0 /\ v1 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v0) (v11 : v2) => v11) v10 v11 end in v9 (conj (v3 v8) v8)) (fun v8 : v2 => let v9 : forall v9 : v0 /\ v2, v1 := fun v9 : v0 /\ v2 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v0) (v11 : v1) => v11) v10 v11 end in v9 (conj (v4 v8) v8))) v6 v7 end) (and_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_r	100	0.047016	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v1 /\ v0 <-> v2 /\ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 /\ v0, v2 /\ v0) (v7 : forall v7 : v2 /\ v0, v1 /\ v0) => conj (fun v8 : v1 => let v9 : forall v9 : v1 /\ v0, v2 := fun v9 : v1 /\ v0 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v2) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v3 v8))) (fun v8 : v2 => let v9 : forall v9 : v2 /\ v0, v1 := fun v9 : v2 /\ v0 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v1) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v4 v8)))) v6 v7 end) (and_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_comm	100	0.026599	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 /\ v1 => match v2 as v3 in (_ /\ _) return (v1 /\ v0) with | conj v3 v4 => (fun (v3 : v0) (v4 : v1) => conj v4 v3) v3 v4 end) (fun v2 : v1 /\ v0 => match v2 as v3 in (_ /\ _) return (v0 /\ v1) with | conj v3 v4 => (fun (v3 : v1) (v4 : v0) => conj v4 v3) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_assoc	100	0.048835	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 /\ v1) /\ v2 => match v3 as v4 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v4 v5 => (fun (v4 : v0 /\ v1) (v5 : v2) => match v4 as v6 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v6 v7 => (fun (v6 : v0) (v7 : v1) => conj v6 (conj v7 v5)) v6 v7 end) v4 v5 end) (fun v3 : v0 /\ v1 /\ v2 => match v3 as v4 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v4 v5 => (fun (v4 : v0) (v5 : v1 /\ v2) => match v5 as v6 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v6 v7 => (fun (v6 : v1) (v7 : v2) => conj (conj v4 v6) v7) v6 v7 end) v4 v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_l	100	0.055038	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v0 \/ v1 <-> v0 \/ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 \/ v1, v0 \/ v2) (v7 : forall v7 : v0 \/ v2, v0 \/ v1) => conj (fun v8 : v1 => let v9 : v0 \/ v2 := v6 (or_intror v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 | or_intror v10 => (fun v10 : v2 => v10) v10 end) (fun v8 : v2 => let v9 : v0 \/ v1 := v7 (or_intror v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 | or_intror v10 => (fun v10 : v1 => v10) v10 end)) v6 v7 end) (or_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_r	100	0.056256	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v1 \/ v0 <-> v2 \/ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 \/ v0, v2 \/ v0) (v7 : forall v7 : v2 \/ v0, v1 \/ v0) => conj (fun v8 : v1 => let v9 : v2 \/ v0 := v6 (or_introl v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v2 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 end) (fun v8 : v2 => let v9 : v1 \/ v0 := v7 (or_introl v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v1 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 end)) v6 v7 end) (or_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_comm	100	0.036747	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 \/ v1 => match v2 as v3 in (_ \/ _) return (v1 \/ v0) with | or_introl v3 => (fun v3 : v0 => or_intror v3) v3 | or_intror v3 => (fun v3 : v1 => or_introl v3) v3 end) (fun v2 : v1 \/ v0 => match v2 as v3 in (_ \/ _) return (v0 \/ v1) with | or_introl v3 => (fun v3 : v1 => or_intror v3) v3 | or_intror v3 => (fun v3 : v0 => or_introl v3) v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_assoc	100	0.058032	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 \/ v1) \/ v2 => match v3 as v4 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v4 => (fun v4 : v0 \/ v1 => match v4 as v5 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v5 => (fun v5 : v0 => or_introl v5) v5 | or_intror v5 => (fun v5 : v1 => or_intror (or_introl v5)) v5 end) v4 | or_intror v4 => (fun v4 : v2 => or_intror (or_intror v4)) v4 end) (fun v3 : v0 \/ v1 \/ v2 => match v3 as v4 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v4 => (fun v4 : v0 => or_introl (or_introl v4)) v4 | or_intror v4 => (fun v4 : v1 \/ v2 => match v4 as v5 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v5 => (fun v5 : v1 => or_introl (or_intror v5)) v5 | or_intror v5 => (fun v5 : v2 => or_intror v5) v5 end) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_and	100	0.020788	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v3 v4) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_to_and	100	0.035437	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 <-> v1 => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end) (fun v2 : (forall v2 : v0, v1) /\ (forall v2 : v1, v0) => match v2 as v3 in (_ /\ _) return (v0 <-> v1) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.inst	100	0.020282	1	1	0	synth with cache (only 1: refine ((fun (v0 : @A) (v1 : forall v1 : @A, P v1) => v1 v0) : forall (v0 : @A) (v1 : all (fun v1 : @A => P v1)), P v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.gen	100	0.019604	1	1	0	synth with cache (only 1: refine ((fun (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0) (v3 : @A) => v1 v3 v2) : forall (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0), all (@P))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.absurd	100	0.013443	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : Prop) (v2 : v0) (v3 : forall v3 : v0, @False) => let v4 : @False := v3 v2 in match v4 as v5 in False return v1 with end) : forall (v0 v1 : Prop) (v2 : v0) (v3 : ~ v0), v1)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_sym	100	0.023040	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (v1 = @x) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans	100	0.028541	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @y = @z) => match v1 as v3 in (_ = v2) return (@x = v2) with | eq_refl => v0 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans_r	100	0.029632	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @z = @y) => match v1 as v3 in (_ = v2) return (forall v4 : @x = v2, @x = @z) with | eq_refl => fun v2 : @x = @z => v2 end v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.f_equal	100	0.024952	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.not_eq_sym	100	0.028250	1	1	0	synth with cache (only 1: refine ((fun (v0 : @x <> @y) (v1 : @y = @x) => v0 (match v1 as v3 in (_ = v2) return (forall v4 : v2 <> @y, v2 = @y) with | eq_refl => fun v2 : @y <> @y => eq_refl end v0)) : forall v0 : @x <> @y, @y <> @x)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_sind_r	100	0.016190	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, SProp) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_sind (fun v6 : v0 => v2 v6) v3 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_ind_r	100	0.016322	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Prop) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_ind v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rec_r	100	0.016003	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Set) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rec v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rect_r	100	0.030590	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rect v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep.f_equal_dep	100	0.072117	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (rew [@B] v2 in f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep2.f_equal_dep2	100	0.126137	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v2 v6) (v9 : v2 v7) (v10 : v6 = v7) => match v10 as v12 in (_ = v11) return (forall (v13 : v2 v11) (v14 : rew [v2] v12 in v8 = v13), rew [v3] f_equal v4 v12 in v5 v6 v8 = v5 v11 v13) with | eq_refl => fun (v11 : v2 v6) (v12 : rew [v2] eq_refl in v8 = v11) => match v12 as v14 in (_ = v13) return (rew [v3] f_equal v4 eq_refl in v5 v6 v8 = v5 v6 v13) with | eq_refl => eq_refl end end v9)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_r	100	0.066280	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v3) => match v4 as v7 in (_ = v6) return (forall v8 : v1 v6, rew [v1] v7 in rew <- [v1] v7 in v8 = v8) with | eq_refl => fun v6 : v1 v2 => eq_refl end v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_l	100	0.056803	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v2) => match v4 as v7 in (_ = v6) return (rew <- [v1] v7 in rew [v1] v7 in v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal2	100	0.065420	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 : forall (v3 : v0) (v4 : v1), v2) (v4 v5 : v0) (v6 v7 : v1) (v8 : v4 = v5) => match v8 as v10 in (_ = v9) return (forall v11 : v6 = v7, v3 v4 v6 = v3 v9 v7) with | eq_refl => fun v9 : v6 = v7 => match v9 as v11 in (_ = v10) return (v3 v4 v6 = v3 v4 v10) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal3	100	0.088859	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : Type) (v4 : forall (v4 : v0) (v5 : v1) (v6 : v2), v3) (v5 v6 : v0) (v7 v8 : v1) (v9 v10 : v2) (v11 : v5 = v6) => match v11 as v13 in (_ = v12) return (forall (v14 : v7 = v8) (v15 : v9 = v10), v4 v5 v7 v9 = v4 v12 v8 v10) with | eq_refl => fun v12 : v7 = v8 => match v12 as v14 in (_ = v13) return (forall v15 : v9 = v10, v4 v5 v7 v9 = v4 v5 v13 v10) with | eq_refl => fun v13 : v9 = v10 => match v13 as v15 in (_ = v14) return (v4 v5 v7 v9 = v4 v5 v7 v14) with | eq_refl => eq_refl end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal4	100	0.092070	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 : Type) (v5 : forall (v5 : v0) (v6 : v1) (v7 : v2) (v8 : v3), v4) (v6 v7 : v0) (v8 v9 : v1) (v10 v11 : v2) (v12 v13 : v3) (v14 : v6 = v7) => match v14 as v16 in (_ = v15) return (forall (v17 : v8 = v9) (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v15 v9 v11 v13) with | eq_refl => fun v15 : v8 = v9 => match v15 as v17 in (_ = v16) return (forall (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v6 v16 v11 v13) with | eq_refl => fun v16 : v10 = v11 => match v16 as v18 in (_ = v17) return (forall v19 : v12 = v13, v5 v6 v8 v10 v12 = v5 v6 v8 v17 v13) with | eq_refl => fun v17 : v12 = v13 => match v17 as v19 in (_ = v18) return (v5 v6 v8 v10 v12 = v5 v6 v8 v10 v18) with | eq_refl => eq_refl end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal5	100	0.140893	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 v5 : Type) (v6 : forall (v6 : v0) (v7 : v1) (v8 : v2) (v9 : v3) (v10 : v4), v5) (v7 v8 : v0) (v9 v10 : v1) (v11 v12 : v2) (v13 v14 : v3) (v15 v16 : v4) (v17 : v7 = v8) => match v17 as v19 in (_ = v18) return (forall (v20 : v9 = v10) (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v18 v10 v12 v14 v16) with | eq_refl => fun v18 : v9 = v10 => match v18 as v20 in (_ = v19) return (forall (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v19 v12 v14 v16) with | eq_refl => fun v19 : v11 = v12 => match v19 as v21 in (_ = v20) return (forall (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v9 v20 v14 v16) with | eq_refl => fun v20 : v13 = v14 => match v20 as v22 in (_ = v21) return (forall v23 : v15 = v16, v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v21 v16) with | eq_refl => fun v21 : v15 = v16 => match v21 as v23 in (_ = v22) return (v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v13 v22) with | eq_refl => eq_refl end end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal_compose	100	0.089269	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : forall v6 : v1, v2) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v6 (f_equal v5 v9) = f_equal (fun v10 : v0 => v6 (v5 v10)) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_l	100	0.038466	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans eq_refl v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_r	100	0.057631	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 eq_refl = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_involutive	100	0.056470	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_sym (eq_sym v5) = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_l	100	0.049760	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans (eq_sym v5) v5 = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_r	100	0.069280	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 (eq_sym v5) = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_assoc	100	0.068228	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 v4 : v0) (v5 : v1 = v2) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (eq_trans v5 (eq_trans v6 v9) = eq_trans (eq_trans v5 v6) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_map	100	0.096185	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v1, Type) (v3 : forall v3 : v0, v1) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v2 (v3 v4), rew [fun v10 : v0 => v2 (v3 v10)] v8 in v9 = rew [v2] f_equal v3 v8 in v9) with | eq_refl => fun v7 : v2 (v3 v4) => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map	100	0.088555	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v1 v2) (v6 : v1 v3) (v7 : v1 v4) (v8 : v2 = v3) (v9 : v3 = v4) (v10 : rew [v1] v8 in v5 = v6) (v11 : rew [v1] v9 in v6 = v7) => match v9 as v13 in (_ = v12) return (forall (v14 : v1 v12) (v15 : rew [v1] v13 in v6 = v14), rew [v1] eq_trans v8 v13 in v5 = v14) with | eq_refl => fun (v12 : v1 v3) (v13 : rew [v1] eq_refl in v6 = v12) => eq_trans v10 v13 end v7 v11)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst	100	0.050756	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v1 v3), v2 v3) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v4, rew [v2] v8 in v3 v4 v9 = v3 v7 (rew [v1] v8 in v9)) with | eq_refl => fun v7 : v1 v4 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst_map	100	0.099058	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v6 = v7) => match v8 as v10 in (_ = v9) return (forall v11 : v2 v6, rew [v3] f_equal v4 v10 in v5 v6 v11 = v5 v9 (rew [v2] v10 in v11)) with | eq_refl => fun v9 : v2 v6 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_swap	100	0.080034	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall (v7 : v1 v2) (v8 : v1 v5) (v9 : rew [v1] v6 in v7 = v8), v7 = rew <- [v1] v6 in v8) with | eq_refl => fun (v5 v6 : v1 v2) (v7 : rew [v1] eq_refl in v5 = v6) => v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_compose	100	0.092369	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) (v6 : v3 = v4) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] v8 in rew [v1] v5 in v9 = rew [v1] eq_trans v5 v8 in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_l	100	0.113535	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v2 = v1 v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 v3)) (v2 v3)) (fun v4 : v1 v3 = v1 v3 => match v2 v3 as v6 in (_ = v5) return (v1 v3 = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : v3 = v1 v3 := v2 v3 in let v5 : v0 := v1 v3 in match v4 as v7 in (_ = v6) return (match v7 as v9 in (_ = v8) return (v6 = v1 v8) with | eq_refl => eq_trans (eq_sym v7) (v2 v3) end = v2 v6) with | eq_refl => let v6 : v3 = v1 v3 := v2 v3 in let v7 : v0 := v1 v3 in match v6 as v9 in (_ = v8) return (eq_trans (eq_sym eq_refl) v9 = v9) with | eq_refl => eq_refl end end) eq_refl (eq_trans_sym_inv_l (v2 v3)) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_r	100	0.454325	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v1 v2 = v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 (v1 (v1 v3)))) (v2 (v1 (v1 v3)))) (fun v4 : v1 (v1 v3) = v1 (v1 v3) => match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : forall v4 : v0, v4 = v1 v4 := fun v4 : v0 => eq_sym (v2 v4) in (let v5 : f_equal v1 (v4 (v1 v3)) = v4 (v1 (v1 v3)) := eq_id_comm_l v1 v4 (v1 v3) in let v6 : v1 (v1 v3) = v1 (v1 (v1 v3)) := v4 (v1 (v1 v3)) in match v5 as v8 in (_ = v7) return (match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans v7 (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => let v7 : f_equal v1 (v4 v3) = v4 (v1 v3) := eq_id_comm_l v1 v4 v3 in let v8 : v1 v3 = v1 (v1 v3) := v4 (v1 v3) in match v7 as v10 in (_ = v9) return (match v2 v3 as v12 in (_ = v11) return (v1 (v1 v3) = v1 v11) with | eq_refl => eq_trans (f_equal v1 v9) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => (let v9 : v1 v3 = v3 := v2 v3 in match v9 as v11 in (_ = v10) return (match v11 as v13 in (_ = v12) return (v1 (v1 v10) = v1 v12) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (eq_sym v11))) (v2 (v1 (v1 v3))) end = v2 (v1 v10)) with | eq_refl => eq_ind_r (fun v10 : v1 (v1 (v1 v3)) = v1 (v1 v3) => v10 = v2 (v1 (v1 v3))) eq_refl (eq_trans_refl_l (v2 (v1 (v1 v3)))) : eq_trans (f_equal v1 (f_equal v1 (eq_sym eq_refl))) (v2 (v1 (v1 v3))) = v2 (v1 (v1 v3)) end) : match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (v4 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3) end end) : match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => eq_trans (v4 (v1 (v1 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) eq_refl (eq_trans_sym_inv_l (v2 (v1 (v1 v3)))) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_refl_map_distr	100	0.044972	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : v0) (v3 : forall v3 : v0, v1) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map_distr	100	0.118905	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v5 (eq_trans v6 v9) = eq_trans (f_equal v5 v6) (f_equal v5 v9)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_map_distr	100	0.106570	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : forall v4 : v0, v1) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (eq_sym (f_equal v4 v7) = f_equal v4 (eq_sym v7)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_distr	100	0.080507	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) => match v4 as v6 in (_ = v5) return (forall v7 : v5 = v3, eq_sym (eq_trans v6 v7) = eq_trans (eq_sym v7) (eq_sym v6)) with | eq_refl => fun v5 : v1 = v3 => match v5 as v7 in (_ = v6) return (eq_sym (eq_trans eq_refl v7) = eq_trans (eq_sym v7) (eq_sym eq_refl)) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_rew_distr	100	0.140069	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (forall (v8 : v6 = v4) (v9 : v1 v2), rew [v1] eq_trans v7 v8 in v9 = rew [v1] v8 in rew [v1] v7 in v9) with | eq_refl => fun v6 : v2 = v4 => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] eq_trans eq_refl v8 in v9 = rew [v1] v8 in rew [v1] eq_refl in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_const	100	0.030780	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall v7 : v1, rew [fun v8 : v0 => v1] v6 in v7 = v7) with | eq_refl => fun v5 : v1 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.unique_existence	100	0.097032	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) => conj (fun v2 : (exists v2 : v0, v1 v2) /\ uniqueness v1 => match v2 as v3 in (_ /\ _) return (exists ! v4 : v0, v1 v4) with | conj v3 v4 => (fun (v3 : exists v3 : v0, v1 v3) (v4 : uniqueness v1) => match v3 as v5 in (ex _) return (exists ! v6 : v0, v1 v6) with | ex_intro _ v5 v6 => (fun (v5 : v0) (v6 : v1 v5) => ex_intro (unique (fun v7 : v0 => v1 v7)) v5 (conj v6 (fun (v7 : v0) (v8 : v1 v7) => v4 v5 v7 v6 v8) : unique (fun v7 : v0 => v1 v7) v5)) v5 v6 end) v3 v4 end) (fun v2 : exists ! v2 : v0, v1 v2 => match v2 as v3 in (ex _) return ((exists v4 : v0, v1 v4) /\ uniqueness v1) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return ((exists v6 : v0, v1 v6) /\ uniqueness v1) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) => conj (ex_intro (fun v7 : v0 => v1 v7) v3 v5) ((fun (v7 v8 : v0) (v9 : v1 v7) (v10 : v1 v8) => eq_trans (eq_sym (v6 v7 v9)) (v6 v8 v10)) : uniqueness v1)) v5 v6 end) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_unique_domain_coincide	100	0.094464	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists ! v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (forall v4 : forall v4 : v0, Prop, (forall (v5 : v0) (v6 : v1 v5), v4 v5) <-> (exists v5 : v0, v1 v5 /\ v4 v5)) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return (forall v6 : forall v6 : v0, Prop, (forall (v7 : v0) (v8 : v1 v7), v6 v7) <-> (exists v7 : v0, v1 v7 /\ v6 v7)) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) (v7 : forall v7 : v0, Prop) => conj (fun v8 : forall (v8 : v0) (v9 : v1 v8), v7 v8 => ex_intro (fun v9 : v0 => v1 v9 /\ v7 v9) v3 (conj v5 (v8 v3 v5))) (fun v8 : exists v8 : v0, v1 v8 /\ v7 v8 => match v8 as v9 in (ex _) return (forall (v10 : v0) (v11 : v1 v10), v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v0) (v10 : v1 v9 /\ v7 v9) => match v10 as v11 in (_ /\ _) return (forall (v12 : v0) (v13 : v1 v12), v7 v12) with | conj v11 v12 => (fun (v11 : v1 v9) (v12 : v7 v9) (v13 : v0) (v14 : v1 v13) => let v15 : v9 = v13 := eq_trans (eq_sym (v6 v9 v11)) (v6 v13 v14) in match v15 as v17 in (_ = v16) return (forall v18 : v1 v16, v7 v16) with | eq_refl => fun v16 : v1 v9 => v12 end v14) v11 v12 end) v9 v10 end)) v5 v6 end) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_coincide_unique_domain	100	0.095257	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : forall v2 : v0, Prop, (forall (v3 : v0) (v4 : v1 v3), v2 v3) <-> (exists v3 : v0, v1 v3 /\ v2 v3)) => let v3 : (forall v3 : forall (v3 : v0) (v4 : v1 v3), v1 v3, exists v4 : v0, v1 v4 /\ v1 v4) /\ (forall (v3 : exists v3 : v0, v1 v3 /\ v1 v3) (v4 : v0) (v5 : v1 v4), v1 v4) := v2 v1 in match v3 as v4 in (_ /\ _) return (exists ! v5 : v0, v1 v5) with | conj v4 v5 => (fun (v4 : forall v4 : forall (v4 : v0) (v5 : v1 v4), v1 v4, exists v5 : v0, v1 v5 /\ v1 v5) (v5 : forall (v5 : exists v5 : v0, v1 v5 /\ v1 v5) (v6 : v0) (v7 : v1 v6), v1 v6) => let v6 : exists v6 : v0, v1 v6 /\ v1 v6 := v4 (fun (v6 : v0) (v7 : v1 v6) => v7) in match v6 as v7 in (ex _) return (exists ! v8 : v0, v1 v8) with | ex_intro _ v7 v8 => (fun (v7 : v0) (v8 : v1 v7 /\ v1 v7) => match v8 as v9 in (_ /\ _) return (exists ! v10 : v0, v1 v10) with | conj v9 v10 => (fun v9 v10 : v1 v7 => ex_intro (unique (fun v11 : v0 => v1 v11)) v7 (conj v9 (let v11 : (forall v11 : forall (v11 : v0) (v12 : v1 v11), v7 = v11, exists v12 : v0, v1 v12 /\ v7 = v12) /\ (forall (v11 : exists v11 : v0, v1 v11 /\ v7 = v11) (v12 : v0) (v13 : v1 v12), v7 = v12) := v2 (fun v11 : v0 => v7 = v11) in match v11 as v12 in (_ /\ _) return (forall (v13 : v0) (v14 : v1 v13), v7 = v13) with | conj v12 v13 => (fun (v12 : forall v12 : forall (v12 : v0) (v13 : v1 v12), v7 = v12, exists v13 : v0, v1 v13 /\ v7 = v13) (v13 : forall (v13 : exists v13 : v0, v1 v13 /\ v7 = v13) (v14 : v0) (v15 : v1 v14), v7 = v14) => v13 (ex_intro (fun v14 : v0 => v1 v14 /\ v7 = v14) v7 (conj v9 eq_refl))) v12 v13 end))) v9 v10 end) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.exists_inhabited	100	0.022470	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (inhabited v0) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : v1 v3) => inhabits v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.inhabited_covariant	100	0.024571	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, v1) (v3 : inhabited v0) => match v3 as v4 in (inhabited _) return (inhabited v1) with | inhabits v4 => (fun v4 : v0 => inhabits (v2 v4)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_stepl	100	0.023606	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) (v5 : v1 = v3) => eq_ind v1 (fun v6 : v0 => v6 = v2) v4 v3 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_stepl	100	0.032646	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v0 <-> v2, v2 <-> v1) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v0 <-> v2) => match v6 as v7 in (_ /\ _) return (v2 <-> v1) with | conj v7 v8 => (fun (v7 : forall v7 : v0, v2) (v8 : forall v8 : v2, v0) => conj (fun v9 : v2 => v4 (v5 (v4 (v8 v9)))) (fun v9 : v1 => v7 (v5 v9))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.eq_ex_uncurried	100	0.105791	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 v3 : v0) (v4 : v1 v2) (v5 : v1 v3) (v6 : exists v6 : v2 = v3, rew [v1] v6 in v4 = v5) => match v6 as v7 in (ex _) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v5) with | ex_intro _ v7 v8 => (fun (v7 : v2 = v3) (v8 : rew [v1] v7 in v4 = v5) => match v8 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v9) with | eq_refl => match v7 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v9 (rew [v1] v10 in v4)) with | eq_refl => eq_refl end : ex_intro v1 v2 v4 = ex_intro v1 v3 (rew [v1] v7 in v4) end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.rew_ex	100	0.123893	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : exists v4 : v2 v1, v3 v1 v4) (v5 : v0) (v6 : v1 = v5) => match v6 as v8 in (_ = v7) return (rew [fun v9 : v0 => exists v10 : v2 v9, v3 v9 v10] v8 in v4 = match v4 as v9 in (ex _) return (exists v10 : v2 v7, v3 v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) => ex_intro (v3 v7) (rew [v2] v8 in v9) match v8 as v12 in (_ = v11) return (v3 v11 (rew [v2] v12 in v9)) with | eq_refl => v10 end) v9 v10 end) with | eq_refl => match v4 as v7 in (ex _) return (rew [fun v8 : v0 => exists v9 : v2 v8, v3 v8 v9] eq_refl in v7 = match v7 as v8 in (ex _) return (exists v9 : v2 v1, v3 v1 v9) with | ex_intro _ v8 v9 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) => ex_intro (v3 v1) (rew [v2] eq_refl in v8) v9) v8 v9 end) with | ex_intro _ v7 v8 => (fun (v7 : v2 v1) (v8 : v3 v1 v7) => eq_refl) v7 v8 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.eq_ex2_uncurried	100	0.134971	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : v0, Prop) (v3 v4 : v0) (v5 : v1 v3) (v6 : v1 v4) (v7 : v2 v3) (v8 : v2 v4) (v9 : exists2 v9 : v3 = v4, rew [v1] v9 in v5 = v6 & rew [v2] v9 in v7 = v8) => match v9 as v10 in (ex2 _ _) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v8) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v3 = v4) (v11 : rew [v1] v10 in v5 = v6) (v12 : rew [v2] v10 in v7 = v8) => match v12 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v13) with | eq_refl => match v11 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v13 (rew [v2] v10 in v7)) with | eq_refl => match v10 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v13 (rew [v1] v14 in v5) (rew [v2] v14 in v7)) with | eq_refl => eq_refl : ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v3 (rew [v1] eq_refl in v5) (rew [v2] eq_refl in v7) end end end) v10 v11 v12 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.rew_ex2	100	0.178519	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : forall (v4 : v0) (v5 : v2 v4), Prop) (v5 : exists2 v5 : v2 v1, v3 v1 v5 & v4 v1 v5) (v6 : v0) (v7 : v1 = v6) => match v7 as v9 in (_ = v8) return (rew [fun v10 : v0 => exists2 v11 : v2 v10, v3 v10 v11 & v4 v10 v11] v9 in v5 = match v5 as v10 in (ex2 _ _) return (exists2 v11 : v2 v8, v3 v8 v11 & v4 v8 v11) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v2 v1) (v11 : v3 v1 v10) (v12 : v4 v1 v10) => ex_intro2 (v3 v8) (v4 v8) (rew [v2] v9 in v10) match v9 as v14 in (_ = v13) return (v3 v13 (rew [v2] v14 in v10)) with | eq_refl => v11 end match v9 as v14 in (_ = v13) return (v4 v13 (rew [v2] v14 in v10)) with | eq_refl => v12 end) v10 v11 v12 end) with | eq_refl => match v5 as v8 in (ex2 _ _) return (rew [fun v9 : v0 => exists2 v10 : v2 v9, v3 v9 v10 & v4 v9 v10] eq_refl in v8 = match v8 as v9 in (ex2 _ _) return (exists2 v10 : v2 v1, v3 v1 v10 & v4 v1 v10) with | ex_intro2 _ _ v9 v10 v11 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) (v11 : v4 v1 v9) => ex_intro2 (v3 v1) (v4 v1) (rew [v2] eq_refl in v9) v10 v11) v9 v10 v11 end) with | ex_intro2 _ _ v8 v9 v10 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) (v10 : v4 v1 v8) => eq_refl) v8 v9 v10 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Setoids.Setoid.Seq_refl	100	0.018695	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : relation v0) (v2 : Setoid_Theory v0 v1) (v3 : v0) => reflexivity v3)).
coq-tactician-stdlib.8.11.dev	Coq.Setoids.Setoid.Seq_sym	100	0.021263	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : relation v0) (v2 : Setoid_Theory v0 v1) (v3 v4 : v0) (v5 : v1 v3 v4) => symmetry v5)).
coq-tactician-stdlib.8.11.dev	Coq.Setoids.Setoid.Seq_trans	100	0.023553	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : relation v0) (v2 : Setoid_Theory v0 v1) (v3 v4 v5 : v0) (v6 : v1 v3 v4) (v7 : v1 v4 v5) => transitivity v6 v7)).
coq-tactician-stdlib.8.11.dev	Coq.Setoids.Setoid.gen_st	100	0.020485	1	1	0	synth with cache (only 1: refine (fun v0 : Set => {| Equivalence_Reflexive := (fun v1 : v0 => eq_refl) : Reflexive eq; Equivalence_Symmetric := (fun (v1 v2 : v0) (v3 : v1 = v2) => eq_sym v3) : Symmetric eq; Equivalence_Transitive := (fun (v1 v2 v3 : v0) (v4 : v1 = v2) (v5 : v2 = v3) => eq_trans v4 v5) : Transitive eq |})).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_eq_iff	100	0.119600	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Eq <-> v0 == v1) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Eq => v2) (fun v3 : v0 == v1 => eq_refl)) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Eq => let v4 : forall v4 : @Eq = @Eq, v0 == v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, v0 == v1) with | eq_refl => fun v4 : @Lt = @Eq => (fun v5 : @Lt = @Eq => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (v0 == v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 == v1 => False_ind (@Lt = @Eq) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v1) (v1 < v1) (lt_compat v4 (reflexive_proper_proxy Equivalence_Reflexive v1))) v3 (irreflexivity (x:=v1)) : forall v4 : v0 < v1, @False) v2))) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Eq => let v4 : forall v4 : @Eq = @Eq, v0 == v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, v0 == v1) with | eq_refl => fun v4 : @Gt = @Eq => (fun v5 : @Gt = @Eq => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (v0 == v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 == v1 => False_ind (@Gt = @Eq) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v1 < v0) (v1 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v0 v1 v4)) v3 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_eq	100	0.033439	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => let v2 : forall (v2 v3 : @t) (v4 : (v2 ?= v3) = @Eq), v2 == v3 := fun v2 v3 : @t => match compare_eq_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Eq, v2 == v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Eq, v2 == v3) (v5 : forall v5 : v2 == v3, (v2 ?= v3) = @Eq) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_lt_iff	100	0.170146	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Lt <-> v0 < v1) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Lt => let v4 : forall v4 : @Lt = @Lt, v0 < v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, v0 < v1) with | eq_refl => fun v4 : @Eq = @Lt => (fun v5 : @Eq = @Lt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (v0 < v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 < v1 => False_ind (@Eq = @Lt) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v1) (v1 < v1) (lt_compat v4 (reflexive_proper_proxy Equivalence_Reflexive v1))) v2 (irreflexivity (x:=v1)) : forall v4 : v0 < v1, @False) v3))) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Lt => v2) (fun v3 : v0 < v1 => eq_refl)) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Lt => let v4 : forall v4 : @Lt = @Lt, v0 < v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, v0 < v1) with | eq_refl => fun v4 : @Gt = @Lt => (fun v5 : @Gt = @Lt => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (v0 < v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 < v1 => False_ind (@Gt = @Lt) (((fun v4 : v1 < v0 => proper_normalizes_proper (forall v5 : Prop, Prop) (flip_arrow (flip_atom Prop (@impl)) (flip_atom Prop (flip (@impl)))) (proper_flip_proper (subrelation_proper (@Morphisms_Prop.not_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (flip (@impl))) (flip2 (subrelation_refl (@impl)))))) (v0 < v1) (v0 < v0) (trans_co_impl_morphism StrictOrder_Transitive v1 v0 v4)) v2 (irreflexivity (x:=v0)) : forall v4 : v0 < v1, @False) v3))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_gt_iff	100	0.173156	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Gt <-> v1 < v0) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Gt => let v4 : forall v4 : @Gt = @Gt, v1 < v0 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, v1 < v0) with | eq_refl => fun v4 : @Eq = @Gt => (fun v5 : @Eq = @Gt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (v1 < v0) v6) v4 end in v4 eq_refl) (fun v3 : v1 < v0 => False_ind (@Eq = @Gt) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v1 < v0) (v1 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v0 v1 v4)) v2 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v3))) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Gt => let v4 : forall v4 : @Gt = @Gt, v1 < v0 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, v1 < v0) with | eq_refl => fun v4 : @Lt = @Gt => (fun v5 : @Lt = @Gt => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (v1 < v0) v6) v4 end in v4 eq_refl) (fun v3 : v1 < v0 => False_ind (@Lt = @Gt) (((fun v4 : v0 < v1 => proper_normalizes_proper (forall v5 : Prop, Prop) (flip_arrow (flip_atom Prop (@impl)) (flip_atom Prop (flip (@impl)))) (proper_flip_proper (subrelation_proper (@Morphisms_Prop.not_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (flip (@impl))) (flip2 (subrelation_refl (@impl)))))) (v1 < v0) (v1 < v1) (trans_co_impl_morphism StrictOrder_Transitive v0 v1 v4)) v2 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v3))) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Gt => v2) (fun v3 : v1 < v0 => eq_refl)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_nlt_iff	100	0.041512	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Lt) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Lt) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (compare_lt_iff v0 v1) (conj (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1) (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_ngt_iff	100	0.042699	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Gt <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Gt) (~ v1 < v0) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Gt) (v1 < v0) v2) (~ v1 < v0) (~ v1 < v0) (eq_proper_proxy (~ v1 < v0))) (compare_gt_iff v0 v1) (conj (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_compat	100	0.301163	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => (fun (v3 v4 : @t) (v5 : v3 == v4) => match compare_spec v1 v4 as v7 in (CompareSpec _ _ _ v6) return ((v0 ?= v3) = v6) with | CompEq _ _ v6 => (fun v6 : (v0 ?= v3) = @Eq <-> v0 == v3 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) ((v0 ?= v3) = @Eq) (v0 == v3) v6) (compare_eq_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) (v0 == v3) (v1 == v3) (PER_morphism (Equivalence_PER (@eq_equiv)) v0 v1 v6 v3 v3 (reflexive_proper_proxy Equivalence_Reflexive v3))) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) (v1 == v3) (v1 == v4) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) v3 v4 v6)) v5 (fun v6 : v1 == v4 => v6))) v6 | CompLt _ _ v6 => (fun v6 : (v0 ?= v3) = @Lt <-> v0 < v3 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) ((v0 ?= v3) = @Lt) (v0 < v3) v6) (compare_lt_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) (v0 < v3) (v1 < v3) (lt_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v3))) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) (v1 < v3) (v1 < v4) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v3 v4 v6)) v5 (fun v6 : v1 < v4 => v6))) v6 | CompGt _ _ v6 => (fun v6 : (v0 ?= v3) = @Gt <-> v3 < v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) ((v0 ?= v3) = @Gt) (v3 < v0) v6) (compare_gt_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) (v3 < v0) (v3 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v3) v0 v1 v6)) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) (v3 < v1) (v4 < v1) (lt_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v1))) v5 (fun v6 : v4 < v1 => v6))) v6 end) : (@eq ==> Logic.eq)%signature (compare v0) (compare v1)) : Proper (@eq ==> @eq ==> Logic.eq) (@compare))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_refl	100	0.034325	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => match compare_spec v0 v0 as v2 in (CompareSpec _ _ _ v1) return (v1 = @Eq) with | CompEq _ _ v1 => (fun v1 : v0 == v0 => eq_refl) v1 | CompLt _ _ v1 => (fun v1 : v0 < v0 => False_ind (@Lt = @Eq) (irreflexivity v1)) v1 | CompGt _ _ v1 => (fun v1 : v0 < v0 => False_ind (@Gt = @Eq) (irreflexivity v1)) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_antisym	100	0.142527	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return ((v1 ?= v0) = CompOpp v2) with | CompEq _ _ v2 => ((fun v2 : (v1 ?= v0) = @Eq <-> v1 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 == v1)) ((v1 ?= v0) = @Eq) (v1 == v0) v2) (compare_eq_iff v1 v0) (fun v2 : v0 == v1 => symmetry v2) : forall v2 : v0 == v1, (v1 ?= v0) = CompOpp (@Eq)) v2 | CompLt _ _ v2 => ((fun v2 : (v1 ?= v0) = @Gt <-> v0 < v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 < v1)) ((v1 ?= v0) = @Gt) (v0 < v1) v2) (compare_gt_iff v1 v0) (fun v2 : v0 < v1 => v2) : forall v2 : v0 < v1, (v1 ?= v0) = CompOpp (@Lt)) v2 | CompGt _ _ v2 => ((fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0)) ((v1 ?= v0) = @Lt) (v1 < v0) v2) (compare_lt_iff v1 v0) (fun v2 : v1 < v0 => v2) : forall v2 : v1 < v0, (v1 ?= v0) = CompOpp (@Gt)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_compat	100	0.054274	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_preorder	100	0.021143	1	1	0	synth with cache (only 1: refine {| PreOrder_Reflexive := (fun v0 : @t => OrderTac.le_refl v0) : Reflexive (@le); PreOrder_Transitive := (fun (v0 v1 v2 : @t) (v3 : v0 <= v1) (v4 : v1 <= v2) => OrderTac.not_gt_le ((fun v5 : v2 < v0 => (fun v6 : v1 < v0 => (fun v7 : v0 < v0 => OrderTac.lt_irrefl v7) (OrderTac.le_lt_trans v3 v6)) (OrderTac.le_lt_trans v4 v5)) : ~ v2 < v0)) : Transitive (@le) |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_order	100	0.050730	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj (OrderTac.not_gt_le ((fun v3 : v1 < v0 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2)) : ~ v1 < v0) : v0 <= v1) (OrderTac.not_gt_le ((fun v3 : v0 < v1 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3)) : ~ v0 < v1) : v1 <= v0)) (fun v2 : v0 <= v1 <= v0 => and_ind (fun (v3 : v0 <= v1) (v4 : v1 <= v0) => OrderTac.not_neq_eq ((fun v5 : v0 ~= v1 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v5)) (OrderTac.le_antisym v3 v4)) : ~ v0 ~= v1) : v0 == v1) v2)) : PartialOrder (@eq) (@le))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_antisym	100	0.017966	1	1	0	synth with cache (only 1: refine (partial_order_antisym (@le_order))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_not_gt_iff	100	0.034079	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 <= v1 => (fun v3 : v1 < v0 => False_ind (@False) ((fun v4 : v0 < v0 => OrderTac.lt_irrefl v4) (OrderTac.le_lt_trans v2 v3)) : @False) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (let v3 : v0 <= v1 := OrderTac.not_gt_le v2 in OrderTac.not_gt_le ((fun v4 : v1 < v0 => (fun v5 : v0 < v0 => OrderTac.lt_irrefl v5) (OrderTac.le_lt_trans v3 v4)) : ~ v1 < v0)) : v0 <= v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.lt_not_ge_iff	100	0.034556	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 < v1 => (fun v3 : v1 <= v0 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.le_lt_trans v3 v2)) : @False) : ~ v1 <= v0) (fun v2 : ~ v1 <= v0 => (let v3 : v0 < v1 := OrderTac.not_ge_lt v2 in OrderTac.not_ge_lt ((fun v4 : v1 <= v0 => (fun v5 : v1 < v1 => OrderTac.lt_irrefl v5) (OrderTac.le_lt_trans v4 v3)) : ~ v1 <= v0)) : v0 < v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_or_gt	100	0.068581	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <= v1 <-> v0 < v1 \/ v0 == v1 => subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 <= v1) (v0 < v1 \/ v0 == v1) v2 (v1 < v0) (v1 < v0) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0))) (le_lteq v0 v1) (let v2 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v3 : @comparison := v0 ?= v1 in match v2 as v5 in (CompareSpec _ _ _ v4) return ((v0 < v1 \/ v0 == v1) \/ v1 < v0) with | CompEq _ _ v4 => (fun v4 : v0 == v1 => or_introl (or_intror v4)) v4 | CompLt _ _ v4 => (fun v4 : v0 < v1 => or_introl (or_introl v4)) v4 | CompGt _ _ v4 => (fun v4 : v1 < v0 => or_intror v4) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.lt_or_ge	100	0.070686	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => (fun v2 : v1 <= v0 <-> v1 < v0 \/ v1 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 < v1)) (v1 <= v0) (v1 < v0 \/ v1 == v0) v2) (le_lteq v1 v0) (let v2 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v3 : @comparison := v0 ?= v1 in match v2 as v5 in (CompareSpec _ _ _ v4) return (v0 < v1 \/ v1 < v0 \/ v1 == v0) with | CompEq _ _ v4 => (fun v4 : v0 == v1 => or_intror (or_intror (OrderTac.not_neq_eq ((fun v5 : v1 ~= v0 => (fun v6 : v1 ~= v1 => v6 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v5 v4)) : ~ v1 ~= v0) : v1 == v0))) v4 | CompLt _ _ v4 => (fun v4 : v0 < v1 => or_introl v4) v4 | CompGt _ _ v4 => (fun v4 : v1 < v0 => or_intror (or_introl v4)) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.eq_is_le_ge	100	0.050081	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj (OrderTac.not_gt_le ((fun v3 : v1 < v0 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2)) : ~ v1 < v0) : v0 <= v1) (OrderTac.not_gt_le ((fun v3 : v0 < v1 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3)) : ~ v0 < v1) : v1 <= v0)) (fun v2 : v0 <= v1 <= v0 => and_ind (fun (v3 : v0 <= v1) (v4 : v1 <= v0) => OrderTac.not_neq_eq ((fun v5 : v0 ~= v1 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v5)) (OrderTac.le_antisym v3 v4)) : ~ v0 ~= v1) : v0 == v1) v2))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.compare_le_iff	100	0.033739	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <= v1 <-> ~ v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <= v1) (~ v1 < v0) v2) (le_not_gt_iff v0 v1) (compare_ngt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.compare_ge_iff	100	0.031708	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v1 <= v0 <-> ~ v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) (~ v0 < v1) v2) (le_not_gt_iff v1 v0) (compare_nlt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.lt_dec	100	0.031119	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.if_eq_dec	100	0.147542	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : Type) (v3 v4 : v2) => let v5 : {v0 == v1} + {v0 ~= v1} := eq_dec v0 v1 in match v5 as v6 in ({_} + {_}) return (match v6 as v7 in ({_} + {_}) return v2 with | left v7 => (fun v7 : v0 == v1 => v3) v7 | right v7 => (fun v7 : v0 ~= v1 => v4) v7 end = match v0 ?= v1 as v7 in comparison return v2 with | Eq => v3 | _ => v4 end) with | left v6 => (fun v6 : v0 == v1 => let v7 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v8 : @comparison := v0 ?= v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (v3 = match v9 as v11 in comparison return v2 with | Eq => v3 | _ => v4 end) with | CompEq _ _ v9 => (fun v9 : v0 == v1 => Logic.eq_refl) v9 | CompLt _ _ v9 => (fun v9 : v0 < v1 => False_ind (v3 = v4) ((fun v10 : v1 < v1 => OrderTac.lt_irrefl v10) (OrderTac.eq_lt (OrderTac.eq_sym v6) v9))) v9 | CompGt _ _ v9 => (fun v9 : v1 < v0 => False_ind (v3 = v4) ((fun v10 : v1 < v1 => OrderTac.lt_irrefl v10) (OrderTac.lt_eq v9 v6))) v9 end) v6 | right v6 => (fun v6 : v0 ~= v1 => let v7 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v8 : @comparison := v0 ?= v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (v4 = match v9 as v11 in comparison return v2 with | Eq => v3 | _ => v4 end) with | CompEq _ _ v9 => (fun v9 : v0 == v1 => False_ind (v4 = v3) ((fun v10 : v1 ~= v1 => v10 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v9) v6))) v9 | CompLt _ _ v9 => (fun v9 : v0 < v1 => Logic.eq_refl) v9 | CompGt _ _ v9 => (fun v9 : v1 < v0 => Logic.eq_refl) v9 end) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.eqb_alt	100	0.043988	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @t => if_eq_dec v0 v1 (@true) (@false)) : forall v0 v1 : @t, eqb v0 v1 = match v0 ?= v1 as v2 in comparison return (@bool) with | Eq => @true | _ => @false end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.eqb_compat	100	0.194852	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => (fun (v3 v4 : @t) (v5 : v3 == v4) => eq_ind_r (fun v6 : @bool => v6 = eqb v1 v4) (eq_ind_r (fun v6 : @bool => match v0 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end = v6) ((fun v6 : v0 == v1 => trans_co_eq_inv_impl_morphism eq_Transitive match v0 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (f_equal (fun v7 : @comparison => match v7 as v8 in comparison return (@bool) with | Eq => @true | _ => @false end) (compare_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v3))) match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (eq_proper_proxy match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end)) v2 ((fun v6 : v3 == v4 => trans_co_eq_inv_impl_morphism eq_Transitive match v1 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (f_equal (fun v7 : @comparison => match v7 as v8 in comparison return (@bool) with | Eq => @true | _ => @false end) (Reflexive_partial_app_morphism (@compare_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v3 v4 v6)) match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (eq_proper_proxy match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end)) v5 Logic.eq_refl)) (eqb_alt v1 v4)) (eqb_alt v0 v3)) : (@eq ==> Logic.eq)%signature (eqb v0) (eqb v1)) : Proper (@eq ==> @eq ==> Logic.eq) (@eqb))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_not_eq	100	0.023983	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : v0 < v1) => (fun v3 : v0 == v1 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v3) v2))) : v0 ~= v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_eq	100	0.037931	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_lt	100	0.039511	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_eq	100	0.030501	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 <= v1) (v4 : v1 == v2) => let v5 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v3 in (fun v6 : v2 < v0 => False_ind (@False) ((fun v7 : OrderTac.OTF.le v0 v2 => (fun v8 : v0 < v0 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v7 v6)) (OrderTac.le_eq v5 v4))) : v0 <= v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_le	100	0.030740	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 == v1) (v4 : v1 <= v2) => let v5 : OrderTac.OTF.le v1 v2 := OrderTac.not_gt_le v4 in (fun v6 : v2 < v0 => False_ind (@False) ((fun v7 : v2 < v1 => (fun v8 : v1 < v1 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v5 v7)) (OrderTac.lt_eq v6 v3))) : v0 <= v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.neq_eq	100	0.025675	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_neq	100	0.025386	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_lt_trans	100	0.028559	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_le_trans	100	0.029668	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_trans	100	0.032957	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_antisym	100	0.031240	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_neq	100	0.030500	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : v0 <= v1) (v3 : v0 ~= v1) => let v4 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v2 in OrderTac.not_ge_lt ((fun v5 : OrderTac.OTF.le v1 v0 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v3)) (OrderTac.le_antisym v4 v5)) : ~ OrderTac.OTF.le v1 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.neq_sym	100	0.021673	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_le	100	0.021941	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.gt_not_eq	100	0.022185	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_not_lt	100	0.022935	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_not_gt	100	0.023334	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_not_gt	100	0.022440	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_is_nlt_ngt	100	0.060004	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj ((fun v3 : v0 < v1 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3))) : v1 <= v0) ((fun v3 : v1 < v0 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2))) : v0 <= v1)) (fun v2 : v1 <= v0 /\ v0 <= v1 => and_ind (fun (v3 : v1 <= v0) (v4 : v0 <= v1) => let v5 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v4 in let v6 : OrderTac.OTF.le v1 v0 := OrderTac.not_gt_le v3 in OrderTac.not_neq_eq ((fun v7 : v0 ~= v1 => (fun v8 : v1 == v0 => (fun v9 : v0 ~= v0 => v9 (OrderTac.eq_refl v0)) (OrderTac.neq_eq v7 v8)) (OrderTac.le_antisym v6 v5)) : ~ v0 ~= v1)) v2))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.lt_strorder	100	0.013413	1	1	0	synth with cache (only 1: refine (flip_StrictOrder (@O.lt_strorder) : StrictOrder (@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.lt_compat	100	0.030074	1	1	0	synth with cache (only 1: refine (flip_proper (@O.lt_compat) : Proper (@eq ==> @eq ==> @iff) (@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.le_lteq	100	0.064708	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @O.t => (((fun v2 : O.le v1 v0 <-> O.lt v1 v0 \/ O.eq v1 v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (O.le v1 v0) (O.lt v1 v0 \/ O.eq v1 v0) v2 (O.lt v1 v0 \/ eq v0 v1) (O.lt v1 v0 \/ eq v0 v1) (eq_proper_proxy (O.lt v1 v0 \/ eq v0 v1))) (O.le_lteq v1 v0) (conj (fun v2 : O.lt v1 v0 \/ O.eq v1 v0 => or_ind (fun v3 : O.lt v1 v0 => or_introl v3) (fun v3 : O.eq v1 v0 => or_intror (symmetry v3 : eq v0 v1)) v2) (fun v2 : O.lt v1 v0 \/ eq v0 v1 => or_ind (fun v3 : O.lt v1 v0 => or_introl v3) (fun v3 : eq v0 v1 => or_intror (symmetry v3 : O.eq v1 v0)) v2)) : flip (@O.le) v0 v1 <-> flip (@O.lt) v0 v1 \/ eq v0 v1) : flip (@O.le) v0 v1 <-> lt v0 v1 \/ eq v0 v1) : le v0 v1 <-> lt v0 v1 \/ eq v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.compare_spec	100	0.059811	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @O.t => ((((let v2 : CompareSpec (O.eq v1 v0) (O.lt v1 v0) (O.lt v0 v1) (O.compare v1 v0) := O.compare_spec v1 v0 in let v3 : @comparison := O.compare v1 v0 in match v2 as v5 in (CompareSpec _ _ _ v4) return (CompSpec (@O.eq) (fun v6 v7 : @O.t => O.lt v7 v6) v0 v1 v4) with | CompEq _ _ v4 => (fun v4 : O.eq v1 v0 => CompEq (O.lt v1 v0) (O.lt v0 v1) (symmetry v4) : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Eq)) v4 | CompLt _ _ v4 => (fun v4 : O.lt v1 v0 => CompLt (O.eq v0 v1) (O.lt v0 v1) v4 : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Lt)) v4 | CompGt _ _ v4 => (fun v4 : O.lt v0 v1 => CompGt (O.eq v0 v1) (O.lt v1 v0) v4 : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Gt)) v4 end) : CompSpec (@O.eq) (flip (@O.lt)) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@O.eq) (@lt) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@eq) (@lt) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@eq) (@lt) v0 v1 (compare v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_spec	100	0.097539	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (match v0 ?= v1 as v2 in comparison return (forall v3 : (v0 ?= v1) = v2, CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) v2) with | Eq => fun v2 : (v0 ?= v1) = @Eq => CompEq (v0 < v1) (v1 < v0) (let v3 : forall (v3 v4 : @t) (v5 : (v3 ?= v4) = @Eq), v3 == v4 := fun v3 v4 : @t => match compare_eq_iff v3 v4 as v5 in (_ /\ _) return (forall v6 : (v3 ?= v4) = @Eq, v3 == v4) with | conj v5 v6 => (fun (v5 : forall v5 : (v3 ?= v4) = @Eq, v3 == v4) (v6 : forall v6 : v3 == v4, (v3 ?= v4) = @Eq) => v5) v5 v6 end in v3 v0 v1 v2) | Lt => fun v2 : (v0 ?= v1) = @Lt => CompLt (v0 == v1) (v1 < v0) (let v3 : forall (v3 v4 : @t) (v5 : (v3 ?= v4) = @Lt), v3 < v4 := fun v3 v4 : @t => match compare_lt_iff v3 v4 as v5 in (_ /\ _) return (forall v6 : (v3 ?= v4) = @Lt, v3 < v4) with | conj v5 v6 => (fun (v5 : forall v5 : (v3 ?= v4) = @Lt, v3 < v4) (v6 : forall v6 : v3 < v4, (v3 ?= v4) = @Lt) => v5) v5 v6 end in v3 v0 v1 v2) | Gt => fun v2 : (v0 ?= v1) = @Gt => CompGt (v0 == v1) (v0 < v1) (let v3 : CompOpp (v1 ?= v0) = @Gt := eq_ind (v0 ?= v1) (fun v3 : @comparison => v3 = @Gt) v2 (CompOpp (v1 ?= v0)) (compare_antisym v1 v0) in let v4 : forall (v4 v5 : @t) (v6 : (v4 ?= v5) = @Lt), v4 < v5 := fun v4 v5 : @t => match compare_lt_iff v4 v5 as v6 in (_ /\ _) return (forall v7 : (v4 ?= v5) = @Lt, v4 < v5) with | conj v6 v7 => (fun (v6 : forall v6 : (v4 ?= v5) = @Lt, v4 < v5) (v7 : forall v7 : v4 < v5, (v4 ?= v5) = @Lt) => v6) v6 v7 end in v4 v1 v0 ((fun v5 : CompOpp (v1 ?= v0) = @Gt <-> (v1 ?= v0) = CompOpp (@Gt) => iff_impl_subrelation (CompOpp (v1 ?= v0) = @Gt) ((v1 ?= v0) = CompOpp (@Gt)) v5) (CompOpp_iff (v1 ?= v0) (@Gt)) v3)) end : forall v2 : (v0 ?= v1) = (v0 ?= v1), CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1)) eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_eq	100	0.033825	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => let v2 : forall (v2 v3 : @t) (v4 : (v2 ?= v3) = @Eq), v2 == v3 := fun v2 v3 : @t => match compare_eq_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Eq, v2 == v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Eq, v2 == v3) (v5 : forall v5 : v2 == v3, (v2 ?= v3) = @Eq) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_refl	100	0.031651	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v1 == v2), (v1 ?= v2) = @Eq := fun v1 v2 : @t => match compare_eq_iff v1 v2 as v3 in (_ /\ _) return (forall v4 : v1 == v2, (v1 ?= v2) = @Eq) with | conj v3 v4 => (fun (v3 : forall v3 : (v1 ?= v2) = @Eq, v1 == v2) (v4 : forall v4 : v1 == v2, (v1 ?= v2) = @Eq) => v4) v3 v4 end in v1 v0 v0 (reflexivity v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_gt_iff	100	0.047128	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v2)) (compare_lt_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 = @Gt <-> (v1 ?= v0) = @Lt) ((fun v2 : CompOpp (v1 ?= v0) = @Gt <-> (v1 ?= v0) = CompOpp (@Gt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) = @Gt) ((v1 ?= v0) = CompOpp (@Gt)) v2 ((v1 ?= v0) = @Lt) ((v1 ?= v0) = @Lt) (eq_proper_proxy ((v1 ?= v0) = @Lt))) (CompOpp_iff (v1 ?= v0) (@Gt)) (reflexivity ((v1 ?= v0) = @Lt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_ge_iff	100	0.052864	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v2)) (compare_le_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 <> @Lt <-> (v1 ?= v0) <> @Gt) ((fun v2 : CompOpp (v1 ?= v0) = @Lt <-> (v1 ?= v0) = CompOpp (@Lt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) <> @Lt) ((v1 ?= v0) <> CompOpp (@Lt)) (Morphisms_Prop.not_iff_morphism (CompOpp (v1 ?= v0) = @Lt) ((v1 ?= v0) = CompOpp (@Lt)) v2) ((v1 ?= v0) <> @Gt) ((v1 ?= v0) <> @Gt) (eq_proper_proxy ((v1 ?= v0) <> @Gt))) (CompOpp_iff (v1 ?= v0) (@Lt)) (reflexivity ((v1 ?= v0) <> @Gt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_ngt_iff	100	0.041988	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Gt <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Gt) (~ v1 < v0) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Gt) (v1 < v0) v2) (~ v1 < v0) (~ v1 < v0) (eq_proper_proxy (~ v1 < v0))) (compare_gt_iff v0 v1) (conj (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nlt_iff	100	0.041666	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Lt) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Lt) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (compare_lt_iff v0 v1) (conj (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1) (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nle_iff	100	0.188715	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (~ v0 <= v1) (~ (v0 ?= v1) <> @Gt) (Morphisms_Prop.not_iff_morphism (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2))) (compare_le_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Gt <-> ~ v3 <> @Gt) with | Eq => conj (fun v3 : @Eq = @Gt => let v4 : forall v4 : @Gt = @Gt, ~ @Eq <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, ~ @Eq <> @Gt) with | eq_refl => fun v4 : @Eq = @Gt => (fun v5 : @Eq = @Gt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (~ @Eq <> @Gt) v6) v4 end in v4 eq_refl) (fun v3 : ~ @Eq <> @Gt => let v4 : @False := v3 ((fun v4 : @Eq = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Eq = @Gt => (fun v6 : @Eq = @Gt => let v7 : @False := eq_ind (@Eq) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Eq <> @Gt) in match v4 as v5 in False return (@Eq = @Gt) with end) | Lt => conj (fun v3 : @Lt = @Gt => let v4 : forall v4 : @Gt = @Gt, ~ @Lt <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, ~ @Lt <> @Gt) with | eq_refl => fun v4 : @Lt = @Gt => (fun v5 : @Lt = @Gt => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (~ @Lt <> @Gt) v6) v4 end in v4 eq_refl) (fun v3 : ~ @Lt <> @Gt => let v4 : @False := v3 ((fun v4 : @Lt = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Lt = @Gt => (fun v6 : @Lt = @Gt => let v7 : @False := eq_ind (@Lt) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Lt <> @Gt) in match v4 as v5 in False return (@Lt = @Gt) with end) | Gt => conj (fun v3 : @Gt = @Gt => (fun v4 : @Gt <> @Gt => False_ind (@False) (v4 eq_refl)) : ~ @Gt <> @Gt) (fun v3 : ~ @Gt <> @Gt => eq_refl) end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nge_iff	100	0.049072	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) = @Gt <-> ~ v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (~ v1 <= v0) ((v1 ?= v0) = @Gt) (symmetry v2)) (compare_nle_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 = @Lt <-> (v1 ?= v0) = @Gt) ((fun v2 : CompOpp (v1 ?= v0) = @Lt <-> (v1 ?= v0) = CompOpp (@Lt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) = @Lt) ((v1 ?= v0) = CompOpp (@Lt)) v2 ((v1 ?= v0) = @Gt) ((v1 ?= v0) = @Gt) (eq_proper_proxy ((v1 ?= v0) = @Gt))) (CompOpp_iff (v1 ?= v0) (@Lt)) (reflexivity ((v1 ?= v0) = @Gt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.lt_irrefl	100	0.048410	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => (fun v1 : (v0 ?= v0) = @Lt <-> v0 < v0 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v0) ((v0 ?= v0) = @Lt) (symmetry v1)) (compare_lt_iff v0 v0) (eq_ind_r (fun v1 : @comparison => v1 <> @Lt) ((fun v1 : @Eq = @Lt => let v2 : forall v2 : @Lt = @Lt, @False := match v1 as v3 in (_ = v2) return (forall v4 : v2 = @Lt, @False) with | eq_refl => fun v2 : @Eq = @Lt => (fun v3 : @Eq = @Lt => let v4 : @False := eq_ind (@Eq) (fun v4 : @comparison => match v4 as v5 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v3 in False_ind (@False) v4) v2 end in v2 eq_refl) : @Eq <> @Lt) (compare_refl v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.lt_eq_cases	100	0.294723	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 < v1 \/ v0 == v1) ((v0 ?= v1) = @Lt \/ v0 == v1) (Morphisms_Prop.or_iff_morphism (v0 < v1) ((v0 ?= v1) = @Lt) (symmetry v2) (v0 == v1) (v0 == v1) (reflexive_proper_proxy (@iff_Reflexive) (v0 == v1)))) (compare_lt_iff v0 v1) ((fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2) ((v0 ?= v1) = @Lt \/ v0 == v1) ((v0 ?= v1) = @Lt \/ v0 == v1) (eq_proper_proxy ((v0 ?= v1) = @Lt \/ v0 == v1))) (compare_le_iff v0 v1) ((fun v2 : (v0 ?= v1) = @Eq <-> v0 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v0 ?= v1) = @Lt \/ v0 == v1) ((v0 ?= v1) = @Lt \/ (v0 ?= v1) = @Eq) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) ((v0 ?= v1) = @Lt)) (v0 == v1) ((v0 ?= v1) = @Eq) (symmetry v2))) (compare_eq_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 <> @Gt <-> v3 = @Lt \/ v3 = @Eq) with | Eq => conj (fun v3 : @Eq <> @Gt => or_intror eq_refl) (fun v3 : @Eq = @Lt \/ @Eq = @Eq => (fun v4 : @Eq = @Gt => or_ind (fun v5 : @Eq = @Lt => let v6 : forall v6 : @Lt = @Lt, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Lt, @False) with | eq_refl => fun v6 : @Eq = @Lt => (fun v7 : @Eq = @Lt => let v8 : @False := eq_ind (@Eq) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Eq = @Eq => let v6 : forall v6 : @Gt = @Gt, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Gt, @False) with | eq_refl => fun v6 : @Eq = @Gt => (fun v7 : @Eq = @Gt => let v8 : @False := eq_ind (@Eq) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Eq <> @Gt) | Lt => conj (fun v3 : @Lt <> @Gt => or_introl eq_refl) (fun v3 : @Lt = @Lt \/ @Lt = @Eq => (fun v4 : @Lt = @Gt => or_ind (fun v5 : @Lt = @Lt => let v6 : forall v6 : @Gt = @Gt, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Gt, @False) with | eq_refl => fun v6 : @Lt = @Gt => (fun v7 : @Lt = @Gt => let v8 : @False := eq_ind (@Lt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Lt = @Eq => let v6 : forall v6 : @Eq = @Eq, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Eq, @False) with | eq_refl => fun v6 : @Lt = @Eq => (fun v7 : @Lt = @Eq => let v8 : @False := eq_ind (@Lt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Lt <> @Gt) | Gt => conj (fun v3 : @Gt <> @Gt => let v4 : @False := let v4 : @Gt = @Gt := eq_refl in v3 v4 in (fun v5 : @False => False_ind (@Gt = @Lt \/ @Gt = @Eq) v5) v4) (fun v3 : @Gt = @Lt \/ @Gt = @Eq => (fun v4 : @Gt = @Gt => or_ind (fun v5 : @Gt = @Lt => let v6 : forall v6 : @Lt = @Lt, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Lt, @False) with | eq_refl => fun v6 : @Gt = @Lt => (fun v7 : @Gt = @Lt => let v8 : @False := eq_ind (@Gt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Gt = @Eq => let v6 : forall v6 : @Eq = @Eq, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Eq, @False) with | eq_refl => fun v6 : @Gt = @Eq => (fun v7 : @Gt = @Eq => let v8 : @False := eq_ind (@Gt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Gt <> @Gt) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_spec0	100	0.021912	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => iff_reflect (v0 <= v1) (v0 <=? v1) (symmetry (leb_le v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_spec	100	0.042730	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match leb_spec0 v0 v1 as v3 in (reflect _ v2) return (BoolSpec (v0 <= v1) (v1 < v0) v2) with | ReflectT _ v2 => (fun v2 : v0 <= v1 => BoolSpecT (v1 < v0) v2) v2 | ReflectF _ v2 => (fun v2 : ~ v0 <= v1 => BoolSpecF (v0 <= v1) ((fun v3 : (v1 ?= v0) = @Lt <-> v1 < v0 => iff_flip_impl_subrelation (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v3)) (compare_lt_iff v1 v0) ((fun v3 : (v1 ?= v0) = @Lt <-> ~ v0 <= v1 => iff_flip_impl_subrelation ((v1 ?= v0) = @Lt) (~ v0 <= v1) v3) (compare_nge_iff v1 v0) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_spec0	100	0.020738	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => iff_reflect (v0 < v1) (v0 <? v1) (symmetry (ltb_lt v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_spec	100	0.043307	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match ltb_spec0 v0 v1 as v3 in (reflect _ v2) return (BoolSpec (v0 < v1) (v1 <= v0) v2) with | ReflectT _ v2 => (fun v2 : v0 < v1 => BoolSpecT (v1 <= v0) v2) v2 | ReflectF _ v2 => (fun v2 : ~ v0 < v1 => BoolSpecF (v0 < v1) ((fun v3 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => iff_flip_impl_subrelation (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v3)) (compare_le_iff v1 v0) ((fun v3 : (v1 ?= v0) <> @Gt <-> ~ v0 < v1 => iff_flip_impl_subrelation ((v1 ?= v0) <> @Gt) (~ v0 < v1) v3) (compare_ngt_iff v1 v0) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_nle	100	0.045104	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <=? v1 <> @true <-> v0 <=? v1 = @false => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @false) (v0 <=? v1 <> @true) (symmetry v2) (~ v0 <= v1) (~ v0 <= v1) (eq_proper_proxy (~ v0 <= v1))) (not_true_iff_false (v0 <=? v1)) ((fun v2 : v0 <=? v1 = @true <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 <> @true) (~ v0 <= v1) (Morphisms_Prop.not_iff_morphism (v0 <=? v1 = @true) (v0 <= v1) v2) (~ v0 <= v1) (~ v0 <= v1) (eq_proper_proxy (~ v0 <= v1))) (leb_le v0 v1) (reflexivity (~ v0 <= v1))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_gt	100	0.044045	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <=? v1 = @false <-> ~ v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @false) (~ v0 <= v1) v2 (v1 < v0) (v1 < v0) (eq_proper_proxy (v1 < v0))) (leb_nle v0 v1) ((fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v2)) (compare_lt_iff v1 v0) ((fun v2 : (v1 ?= v0) = @Lt <-> ~ v0 <= v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v1 ?= v0) = @Lt) (~ v0 <= v1) v2) (compare_nge_iff v1 v0) (reflexivity (~ v0 <= v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_nlt	100	0.046215	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <? v1 <> @true <-> v0 <? v1 = @false => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @false) (v0 <? v1 <> @true) (symmetry v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (not_true_iff_false (v0 <? v1)) ((fun v2 : v0 <? v1 = @true <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 <> @true) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism (v0 <? v1 = @true) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (ltb_lt v0 v1) (reflexivity (~ v0 < v1))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_ge	100	0.046163	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <? v1 = @false <-> ~ v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @false) (~ v0 < v1) v2 (v1 <= v0) (v1 <= v0) (eq_proper_proxy (v1 <= v0))) (ltb_nlt v0 v1) ((fun v2 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v2)) (compare_le_iff v1 v0) ((fun v2 : (v1 ?= v0) <> @Gt <-> ~ v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v1 ?= v0) <> @Gt) (~ v0 < v1) v2) (compare_ngt_iff v1 v0) (reflexivity (~ v0 < v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_refl	100	0.047259	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v1 <= v2), v1 <=? v2 = @true := fun v1 v2 : @t => match leb_le v1 v2 as v3 in (_ /\ _) return (forall v4 : v1 <= v2, v1 <=? v2 = @true) with | conj v3 v4 => (fun (v3 : forall v3 : v1 <=? v2 = @true, v1 <= v2) (v4 : forall v4 : v1 <= v2, v1 <=? v2 = @true) => v4) v3 v4 end in v1 v0 v0 (let v2 : forall (v2 v3 : @t) (v4 : v2 < v3 \/ v2 == v3), v2 <= v3 := fun v2 v3 : @t => match lt_eq_cases v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 <= v3, v2 < v3 \/ v2 == v3) (v5 : forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) => v5) v4 v5 end in v2 v0 v0 (or_intror (reflexivity v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_antisym	100	0.044153	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v1 <=? v0) (negb (v0 <? v1)) ((fun v2 : negb (v0 <? v1) = @true <-> v0 <? v1 = @false => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (negb (v0 <? v1) = @true) (v0 <? v1 = @false) v2) (negb_true_iff (v0 <? v1)) ((fun v2 : v1 <=? v0 = @true <-> v1 <= v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v1 <=? v0 = @true) (v1 <= v0) v2 (v0 <? v1 = @false) (v0 <? v1 = @false) (eq_proper_proxy (v0 <? v1 = @false))) (leb_le v1 v0) ((fun v2 : v0 <? v1 = @false <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <? v1 = @false) (v1 <= v0) v2) (ltb_ge v0 v1) (reflexivity (v1 <= v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_irrefl	100	0.047667	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v2 <= v1), v1 <? v2 = @false := fun v1 v2 : @t => match ltb_ge v1 v2 as v3 in (_ /\ _) return (forall v4 : v2 <= v1, v1 <? v2 = @false) with | conj v3 v4 => (fun (v3 : forall v3 : v1 <? v2 = @false, v2 <= v1) (v4 : forall v4 : v2 <= v1, v1 <? v2 = @false) => v4) v3 v4 end in v1 v0 v0 (let v2 : forall (v2 v3 : @t) (v4 : v2 < v3 \/ v2 == v3), v2 <= v3 := fun v2 v3 : @t => match lt_eq_cases v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 <= v3, v2 < v3 \/ v2 == v3) (v5 : forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) => v5) v4 v5 end in v2 v0 v0 (or_intror (reflexivity v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_antisym	100	0.044753	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v1 <? v0) (negb (v0 <=? v1)) ((fun v2 : negb (v0 <=? v1) = @true <-> v0 <=? v1 = @false => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (negb (v0 <=? v1) = @true) (v0 <=? v1 = @false) v2) (negb_true_iff (v0 <=? v1)) ((fun v2 : v1 <? v0 = @true <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v1 <? v0 = @true) (v1 < v0) v2 (v0 <=? v1 = @false) (v0 <=? v1 = @false) (eq_proper_proxy (v0 <=? v1 = @false))) (ltb_lt v1 v0) ((fun v2 : v0 <=? v1 = @false <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <=? v1 = @false) (v1 < v0) v2) (leb_gt v0 v1) (reflexivity (v1 < v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.eqb_compare	100	0.248878	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 =? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Eq => @true | _ => @false end ((fun v2 : (v0 =? v1) = @true <-> v0 == v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 =? v1) = @true) (v0 == v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true))) (eqb_eq v0 v1) ((fun v2 : (v0 ?= v1) = @Eq <-> v0 == v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 == v1) ((v0 ?= v1) = @Eq) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true))) (compare_eq_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Eq <-> match v3 as v4 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) with | Eq => conj (fun v3 : @Eq = @Eq => eq_refl) (fun v3 : @true = @true => eq_refl) | Lt => conj (fun v3 : @Lt = @Eq => let v4 : forall v4 : @Eq = @Eq, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, @false = @true) with | eq_refl => fun v4 : @Lt = @Eq => (fun v5 : @Lt = @Eq => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Lt = @Eq := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Lt = @Eq) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Lt = @Eq) v6) v4 end in v4 eq_refl) | Gt => conj (fun v3 : @Gt = @Eq => let v4 : forall v4 : @Eq = @Eq, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, @false = @true) with | eq_refl => fun v4 : @Gt = @Eq => (fun v5 : @Gt = @Eq => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt = @Eq := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt = @Eq) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt = @Eq) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_compare	100	0.249681	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 <? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Lt => @true | _ => @false end ((fun v2 : v0 <? v1 = @true <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @true) (v0 < v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true))) (ltb_lt v0 v1) ((fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 < v1) ((v0 ?= v1) = @Lt) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true))) (compare_lt_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Lt <-> match v3 as v4 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) with | Eq => conj (fun v3 : @Eq = @Lt => let v4 : forall v4 : @Lt = @Lt, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, @false = @true) with | eq_refl => fun v4 : @Eq = @Lt => (fun v5 : @Eq = @Lt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Eq = @Lt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Eq = @Lt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Eq = @Lt) v6) v4 end in v4 eq_refl) | Lt => conj (fun v3 : @Lt = @Lt => eq_refl) (fun v3 : @true = @true => eq_refl) | Gt => conj (fun v3 : @Gt = @Lt => let v4 : forall v4 : @Lt = @Lt, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, @false = @true) with | eq_refl => fun v4 : @Gt = @Lt => (fun v5 : @Gt = @Lt => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt = @Lt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt = @Lt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt = @Lt) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_compare	100	0.240765	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 <=? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Gt => @false | _ => @true end ((fun v2 : v0 <=? v1 = @true <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @true) (v0 <= v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true))) (leb_le v0 v1) ((fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true))) (compare_le_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 <> @Gt <-> match v3 as v4 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) with | Eq => conj (fun v3 : @Eq <> @Gt => eq_refl) (fun v3 : @true = @true => (fun v4 : @Eq = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Eq = @Gt => (fun v6 : @Eq = @Gt => let v7 : @False := eq_ind (@Eq) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Eq <> @Gt) | Lt => conj (fun v3 : @Lt <> @Gt => eq_refl) (fun v3 : @true = @true => (fun v4 : @Lt = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Lt = @Gt => (fun v6 : @Lt = @Gt => let v7 : @False := eq_ind (@Lt) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Lt <> @Gt) | Gt => conj (fun v3 : @Gt <> @Gt => False_ind (@false = @true) (v3 eq_refl)) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt <> @Gt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt <> @Gt) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_0_l	100	0.230723	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 < v0) => let v2 : exists v2 : @t, v0 == S v2 /\ 0 <= v2 := lt_exists_pred 0 v0 v1 in match v2 as v3 in (ex _) return (0 ^ v0 == 0) with | ex_intro _ v3 v4 => (fun (v3 : @t) (v4 : v0 == S v3 /\ 0 <= v3) => match v4 as v5 in (_ /\ _) return (0 ^ v0 == 0) with | conj v5 v6 => (fun (v5 : v0 == S v3) (v6 : 0 <= v3) => (fun v7 : v0 == S v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 ^ v0) (0 ^ S v3) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) v0 (S v3) v7) 0 0 (eq_proper_proxy 0)) v5 ((fun v7 : 0 ^ S v3 == 0 * 0 ^ v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 ^ S v3) (0 * 0 ^ v3) v7 0 0 (eq_proper_proxy 0)) (pow_succ_r 0 v3 v6) ((fun v7 : 0 * 0 ^ v3 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 * 0 ^ v3) 0 v7 0 0 (eq_proper_proxy 0)) (mul_0_l (0 ^ v3)) (reflexivity 0)))) v5 v6 end) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_0_l'	100	0.052926	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : v0 ~= 0) => let v2 : v0 < 0 \/ v0 == 0 \/ 0 < v0 := lt_trichotomy v0 0 in match v2 as v3 in (_ \/ _) return (0 ^ v0 == 0) with | or_introl v3 => (fun v3 : v0 < 0 => (fun v4 : 0 ^ v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 ^ v0) 0 v4 0 0 (eq_proper_proxy 0)) (pow_neg_r 0 v0 v3) (reflexivity 0)) v3 | or_intror v3 => (fun v3 : v0 == 0 \/ 0 < v0 => match v3 as v4 in (_ \/ _) return (0 ^ v0 == 0) with | or_introl v4 => (fun v4 : v0 == 0 => Private_OrderTac.Tac.not_neq_eq ((fun v5 : 0 ^ v0 ~= 0 => (fun v6 : 0 ~= 0 => v6 (Private_OrderTac.Tac.eq_refl 0)) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v4) v1)) : ~ 0 ^ v0 ~= 0)) v4 | or_intror v4 => (fun v4 : 0 < v0 => pow_0_l v0 v4) v4 end) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_1_r	100	0.046876	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : 1 == S 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ 1) (v0 ^ S 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) 1 (S 0) v1) v0 v0 (eq_proper_proxy v0)) (@one_succ) ((fun v1 : v0 ^ S 0 == v0 * v0 ^ 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ S 0) (v0 * v0 ^ 0) v1 v0 v0 (eq_proper_proxy v0)) (pow_succ_r v0 0 (reflexivity 0)) ((fun v1 : v0 ^ 0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * v0 ^ 0) (v0 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 ^ 0) 1 v1) v0 v0 (eq_proper_proxy v0)) (pow_0_r v0) ((fun v1 : v0 * 1 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * 1) v0 v1 v0 v0 (eq_proper_proxy v0)) (mul_1_r v0) (reflexivity v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_1_l	100	0.061445	1	1	0	synth with cache (only 1: refine (le_ind (fun v0 : @t => 1 ^ v0 == 1) (((fun (v0 v1 : @t) (v2 : v0 == v1) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (1 ^ v0 == 1) (1 ^ v1 == 1) (PER_morphism (Equivalence_PER (@eq_equiv)) (1 ^ v0) (1 ^ v1) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive 1) v0 v1 v2) 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1)) (1 ^ v1 == 1) (1 ^ v1 == 1) (eq_proper_proxy (1 ^ v1 == 1)) (reflexivity (1 ^ v1 == 1))) : (@eq ==> @iff)%signature (fun v0 : @t => 1 ^ v0 == 1) (fun v0 : @t => 1 ^ v0 == 1)) : Proper (@eq ==> @iff) (fun v0 : @t => 1 ^ v0 == 1)) 0 ((fun v0 : 1 ^ 0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (1 ^ 0) 1 v0 1 1 (eq_proper_proxy 1)) (pow_0_r 1) (reflexivity 1)) (fun (v0 : @t) (v1 : 0 <= v0) (v2 : 1 ^ v0 == 1) => (fun v3 : 1 ^ S v0 == 1 * 1 ^ v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (1 ^ S v0) (1 * 1 ^ v0) v3 1 1 (eq_proper_proxy 1)) (pow_succ_r 1 v0 v1) ((fun v3 : 1 * 1 ^ v0 == 1 ^ v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (1 * 1 ^ v0) (1 ^ v0) v3 1 1 (eq_proper_proxy 1)) (mul_1_l (1 ^ v0)) v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_2_r	100	0.052392	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : 2 == S 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ 2) (v0 ^ S 1) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) 2 (S 1) v1) (v0 * v0) (v0 * v0) (eq_proper_proxy (v0 * v0))) (@two_succ) ((fun v1 : v0 ^ S 1 == v0 * v0 ^ 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ S 1) (v0 * v0 ^ 1) v1 (v0 * v0) (v0 * v0) (eq_proper_proxy (v0 * v0))) (pow_succ_r v0 1 ((fun (v1 : 0 < 1) (v2 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v3 : 1 < 0 => (fun v4 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v4) (Private_OrderTac.Tac.lt_trans v1 v3)) : ~ 1 < 0)) (@lt_0_1) (@lt_1_2))) ((fun v1 : v0 ^ 1 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * v0 ^ 1) (v0 * v0) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 ^ 1) v0 v1) (v0 * v0) (v0 * v0) (eq_proper_proxy (v0 * v0))) (pow_1_r v0) ((fun (v1 : 0 < 1) (v2 : 1 < 2) => Private_OrderTac.Tac.eq_refl (v0 * v0)) (@lt_0_1) (@lt_1_2)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_eq_0	100	0.184334	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 <= v1) => le_ind (fun v3 : @t => forall v4 : v0 ^ v3 == 0, v0 == 0) (((fun (v3 v4 : @t) (v5 : v3 == v4) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (forall v6 : v0 ^ v3 == 0, v0 == 0) (forall v6 : v0 ^ v4 == 0, v0 == 0) (iff_iff_iff_impl_morphism (v0 ^ v3 == 0) (v0 ^ v4 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ v3) (v0 ^ v4) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v3 v4 v5) 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (forall v6 : v0 ^ v4 == 0, v0 == 0) (forall v6 : v0 ^ v4 == 0, v0 == 0) (eq_proper_proxy (forall v6 : v0 ^ v4 == 0, v0 == 0)) (reflexivity (forall v6 : v0 ^ v4 == 0, v0 == 0))) : (@eq ==> @iff)%signature (fun v3 : @t => forall v4 : v0 ^ v3 == 0, v0 == 0) (fun v3 : @t => forall v4 : v0 ^ v3 == 0, v0 == 0)) : Proper (@eq ==> @iff) (fun v3 : @t => forall v4 : v0 ^ v3 == 0, v0 == 0)) 0 ((fun v3 : v0 ^ 0 == 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 ^ 0 == 0) (1 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ 0) 1 v3 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (pow_0_r v0) ((fun (v3 : 0 < 1) (v4 : 1 < 2) (v5 : 1 == 0) => Private_OrderTac.Tac.not_neq_eq ((fun v6 : v0 ~= 0 => (fun v7 : 0 < 2 => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.lt_eq v3 v5)) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v5) v4)) : ~ v0 ~= 0)) (@lt_0_1) (@lt_1_2))) (fun (v3 : @t) (v4 : 0 <= v3) (v5 : forall v5 : v0 ^ v3 == 0, v0 == 0) => (fun v6 : v0 ^ S v3 == v0 * v0 ^ v3 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 ^ S v3 == 0) (v0 * v0 ^ v3 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ S v3) (v0 * v0 ^ v3) v6 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (pow_succ_r v0 v3 v4) (fun v6 : v0 * v0 ^ v3 == 0 => let v7 : forall (v7 v8 : @t) (v9 : v7 * v8 == 0), v7 == 0 \/ v8 == 0 := fun v7 v8 : @t => match eq_mul_0 v7 v8 as v9 in (_ /\ _) return (forall v10 : v7 * v8 == 0, v7 == 0 \/ v8 == 0) with | conj v9 v10 => (fun (v9 : forall v9 : v7 * v8 == 0, v7 == 0 \/ v8 == 0) (v10 : forall v10 : v7 == 0 \/ v8 == 0, v7 * v8 == 0) => v9) v9 v10 end in let v8 : v0 == 0 \/ v0 ^ v3 == 0 := v7 v0 (v0 ^ v3) v6 in match v8 as v9 in (_ \/ _) return (v0 == 0) with | or_introl v9 => (fun v9 : v0 == 0 => v9) v9 | or_intror v9 => (fun v9 : v0 ^ v3 == 0 => v5 v9) v9 end)) v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_nonzero	100	0.029962	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : v0 ~= 0) (v3 : 0 <= v1) => (fun v4 : v0 ^ v1 == 0 => match v2 (pow_eq_0 v0 v1 v3 v4) as v5 in False return (@False) with end) : v0 ^ v1 ~= 0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_eq_0_iff	100	0.231089	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 ^ v1 == 0 => let v3 : v1 < 0 \/ v1 == 0 \/ 0 < v1 := lt_trichotomy v1 0 in match v3 as v4 in (_ \/ _) return (v1 < 0 \/ 0 < v1 /\ v0 == 0) with | or_introl v4 => (fun v4 : v1 < 0 => or_introl v4) v4 | or_intror v4 => (fun v4 : v1 == 0 \/ 0 < v1 => match v4 as v5 in (_ \/ _) return (v1 < 0 \/ 0 < v1 /\ v0 == 0) with | or_introl v5 => (fun v5 : v1 == 0 => (fun (v6 : 0 < 1) (v7 : 1 < 2) => False_ind (v1 < 0 \/ 0 < v1 /\ v0 == 0) ((fun v8 : 0 < 2 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_eq v6 ((fun v9 : v0 ^ 0 == 1 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (v0 ^ 0) 1 v9 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (pow_0_r v0) ((fun v9 : v1 == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (v0 ^ v1) (v0 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v1 0 v9) 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) v5 v2)))) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym ((fun v8 : v0 ^ 0 == 1 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (v0 ^ 0) 1 v8 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (pow_0_r v0) ((fun v8 : v1 == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (v0 ^ v1) (v0 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v1 0 v8) 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) v5 v2))) v7))) (@lt_0_1) (@lt_1_2)) v5 | or_intror v5 => (fun v5 : 0 < v1 => or_intror (conj v5 (pow_eq_0 v0 v1 (Private_OrderTac.Tac.not_gt_le ((fun v6 : v1 < 0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v5 v6)) : ~ v1 < 0)) (Private_OrderTac.Tac.not_neq_eq ((fun v6 : v0 ^ v1 ~= 0 => (fun v7 : 0 ~= 0 => v7 (Private_OrderTac.Tac.eq_refl 0)) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v2) v6)) : ~ v0 ^ v1 ~= 0))))) v5 end) v4 end) (fun v2 : v1 < 0 \/ 0 < v1 /\ v0 == 0 => match v2 as v3 in (_ \/ _) return (v0 ^ v1 == 0) with | or_introl v3 => (fun v3 : v1 < 0 => (fun v4 : v0 ^ v1 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ v1) 0 v4 0 0 (eq_proper_proxy 0)) (pow_neg_r v0 v1 v3) (reflexivity 0)) v3 | or_intror v3 => (fun v3 : 0 < v1 /\ v0 == 0 => match v3 as v4 in (_ /\ _) return (v0 ^ v1 == 0) with | conj v4 v5 => (fun (v4 : 0 < v1) (v5 : v0 == 0) => (fun v6 : v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ v1) (0 ^ v1) (pow_wd v0 0 v6 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) 0 0 (eq_proper_proxy 0)) v5 (pow_0_l' v1 ((fun v6 : v1 == 0 => False_ind (@False) ((fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_eq v4 v6))) : v1 ~= 0))) v4 v5 end) v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_add_r	100	0.341517	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v1) => le_ind (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2) (((fun (v4 v5 : @t) (v6 : v4 == v5) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (forall v7 : 0 <= v2, v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2) (forall v7 : 0 <= v2, v0 ^ (v5 + v2) == v0 ^ v5 * v0 ^ v2) (Reflexive_partial_app_morphism (@iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v2)) (v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2) (v0 ^ (v5 + v2) == v0 ^ v5 * v0 ^ v2) (PER_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ (v4 + v2)) (v0 ^ (v5 + v2)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v4 + v2) (v5 + v2) (add_wd v4 v5 v6 v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2))) (v0 ^ v4 * v0 ^ v2) (v0 ^ v5 * v0 ^ v2) (mul_wd (v0 ^ v4) (v0 ^ v5) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v4 v5 v6) (v0 ^ v2) (v0 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2))))) (forall v7 : 0 <= v2, v0 ^ (v5 + v2) == v0 ^ v5 * v0 ^ v2) (forall v7 : 0 <= v2, v0 ^ (v5 + v2) == v0 ^ v5 * v0 ^ v2) (eq_proper_proxy (forall v7 : 0 <= v2, v0 ^ (v5 + v2) == v0 ^ v5 * v0 ^ v2)) (reflexivity (forall v7 : 0 <= v2, v0 ^ (v5 + v2) == v0 ^ v5 * v0 ^ v2))) : (@eq ==> @iff)%signature (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2) (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2)) : Proper (@eq ==> @iff) (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2)) 0 ((fun v4 : v0 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v2)) (v0 ^ (0 + v2) == v0 ^ 0 * v0 ^ v2) (v0 ^ (0 + v2) == 1 * v0 ^ v2) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ 0 * v0 ^ v2) (1 * v0 ^ v2) (mul_wd (v0 ^ 0) 1 v4 (v0 ^ v2) (v0 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2))))) (pow_0_r v0) ((fun v4 : 1 * v0 ^ v2 == v0 ^ v2 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v2)) (v0 ^ (0 + v2) == 1 * v0 ^ v2) (v0 ^ (0 + v2) == v0 ^ v2) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (1 * v0 ^ v2) (v0 ^ v2) v4)) (mul_1_l (v0 ^ v2)) ((fun v4 : 0 + v2 == v2 => Reflexive_partial_app_morphism (subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v2)) (v0 ^ (0 + v2) == v0 ^ v2) (v0 ^ v2 == v0 ^ v2) (PER_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ (0 + v2)) (v0 ^ v2) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (0 + v2) v2 v4) (v0 ^ v2) (v0 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2)))) (add_0_l v2) (fun v4 : 0 <= v2 => reflexivity (v0 ^ v2))))) (fun (v4 : @t) (v5 : 0 <= v4) (v6 : forall v6 : 0 <= v2, v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2) (v7 : 0 <= v2) => (fun v8 : v0 ^ S v4 == v0 * v0 ^ v4 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ S v4 * v0 ^ v2) (v0 * v0 ^ v4 * v0 ^ v2) (mul_wd (v0 ^ S v4) (v0 * v0 ^ v4) v8 (v0 ^ v2) (v0 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2)))) (pow_succ_r v0 v4 v5) ((fun v8 : S v4 + v2 == S (v4 + v2) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ (S v4 + v2)) (v0 ^ S (v4 + v2)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (S v4 + v2) (S (v4 + v2)) v8) (v0 * v0 ^ v4 * v0 ^ v2) (v0 * v0 ^ v4 * v0 ^ v2) (eq_proper_proxy (v0 * v0 ^ v4 * v0 ^ v2))) (add_succ_l v4 v2) ((fun v8 : v0 ^ S (v4 + v2) == v0 * v0 ^ (v4 + v2) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ S (v4 + v2)) (v0 * v0 ^ (v4 + v2)) v8 (v0 * v0 ^ v4 * v0 ^ v2) (v0 * v0 ^ v4 * v0 ^ v2) (eq_proper_proxy (v0 * v0 ^ v4 * v0 ^ v2))) (pow_succ_r v0 (v4 + v2) (add_nonneg_nonneg v4 v2 v5 v7)) ((fun v8 : v0 ^ (v4 + v2) == v0 ^ v4 * v0 ^ v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * v0 ^ (v4 + v2)) (v0 * (v0 ^ v4 * v0 ^ v2)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 ^ (v4 + v2)) (v0 ^ v4 * v0 ^ v2) v8) (v0 * v0 ^ v4 * v0 ^ v2) (v0 * v0 ^ v4 * v0 ^ v2) (eq_proper_proxy (v0 * v0 ^ v4 * v0 ^ v2))) (v6 v7) (mul_assoc v0 (v0 ^ v4) (v0 ^ v2)))))) v1 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_mul_l	100	0.284053	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @t => let v3 : v2 < 0 \/ 0 <= v2 := lt_ge_cases v2 0 in match v3 as v4 in (_ \/ _) return ((v0 * v1) ^ v2 == v0 ^ v2 * v1 ^ v2) with | or_introl v4 => (fun v4 : v2 < 0 => (fun v5 : (v0 * v1) ^ v2 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive ((v0 * v1) ^ v2) 0 v5 (v0 ^ v2 * v1 ^ v2) (v0 ^ v2 * v1 ^ v2) (eq_proper_proxy (v0 ^ v2 * v1 ^ v2))) (pow_neg_r (v0 * v1) v2 v4) ((fun v5 : v0 ^ v2 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ v2 * v1 ^ v2) (0 * v1 ^ v2) (mul_wd (v0 ^ v2) 0 v5 (v1 ^ v2) (v1 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ v2)))) (pow_neg_r v0 v2 v4) ((fun v5 : v1 ^ v2 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (0 * v1 ^ v2) (0 * 0) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (v1 ^ v2) 0 v5)) (pow_neg_r v1 v2 v4) ((fun v5 : 0 * 0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (0 * 0) 0 v5) (mul_0_r 0) (reflexivity 0))))) v4 | or_intror v4 => (fun v4 : 0 <= v2 => le_ind (fun v5 : @t => (v0 * v1) ^ v5 == v0 ^ v5 * v1 ^ v5) (((fun (v5 v6 : @t) (v7 : v5 == v6) => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 * v1) ^ v5 == v0 ^ v5 * v1 ^ v5) ((v0 * v1) ^ v6 == v0 ^ v6 * v1 ^ v6) (PER_morphism (Equivalence_PER (@eq_equiv)) ((v0 * v1) ^ v5) ((v0 * v1) ^ v6) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v1)) v5 v6 v7) (v0 ^ v5 * v1 ^ v5) (v0 ^ v6 * v1 ^ v6) (mul_wd (v0 ^ v5) (v0 ^ v6) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v5 v6 v7) (v1 ^ v5) (v1 ^ v6) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) v5 v6 v7))) ((v0 * v1) ^ v6 == v0 ^ v6 * v1 ^ v6) ((v0 * v1) ^ v6 == v0 ^ v6 * v1 ^ v6) (eq_proper_proxy ((v0 * v1) ^ v6 == v0 ^ v6 * v1 ^ v6)) (reflexivity ((v0 * v1) ^ v6 == v0 ^ v6 * v1 ^ v6))) : (@eq ==> @iff)%signature (fun v5 : @t => (v0 * v1) ^ v5 == v0 ^ v5 * v1 ^ v5) (fun v5 : @t => (v0 * v1) ^ v5 == v0 ^ v5 * v1 ^ v5)) : Proper (@eq ==> @iff) (fun v5 : @t => (v0 * v1) ^ v5 == v0 ^ v5 * v1 ^ v5)) 0 ((fun v5 : (v0 * v1) ^ 0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive ((v0 * v1) ^ 0) 1 v5 (v0 ^ 0 * v1 ^ 0) (v0 ^ 0 * v1 ^ 0) (eq_proper_proxy (v0 ^ 0 * v1 ^ 0))) (pow_0_r (v0 * v1)) ((fun v5 : v0 ^ 0 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ 0 * v1 ^ 0) (1 * v1 ^ 0) (mul_wd (v0 ^ 0) 1 v5 (v1 ^ 0) (v1 ^ 0) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ 0)))) (pow_0_r v0) ((fun v5 : v1 ^ 0 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (1 * v1 ^ 0) (1 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive 1) (v1 ^ 0) 1 v5)) (pow_0_r v1) ((fun v5 : 1 * 1 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (1 * 1) 1 v5) (mul_1_r 1) (reflexivity 1))))) (fun (v5 : @t) (v6 : 0 <= v5) (v7 : (v0 * v1) ^ v5 == v0 ^ v5 * v1 ^ v5) => (fun v8 : (v0 * v1) ^ S v5 == v0 * v1 * (v0 * v1) ^ v5 => trans_co_eq_inv_impl_morphism Equivalence_Transitive ((v0 * v1) ^ S v5) (v0 * v1 * (v0 * v1) ^ v5) v8 (v0 ^ S v5 * v1 ^ S v5) (v0 ^ S v5 * v1 ^ S v5) (eq_proper_proxy (v0 ^ S v5 * v1 ^ S v5))) (pow_succ_r (v0 * v1) v5 v6) ((fun v8 : v0 ^ S v5 == v0 * v0 ^ v5 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ S v5 * v1 ^ S v5) (v0 * v0 ^ v5 * v1 ^ S v5) (mul_wd (v0 ^ S v5) (v0 * v0 ^ v5) v8 (v1 ^ S v5) (v1 ^ S v5) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ S v5)))) (pow_succ_r v0 v5 v6) ((fun v8 : v1 ^ S v5 == v1 * v1 ^ v5 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * v0 ^ v5 * v1 ^ S v5) (v0 * v0 ^ v5 * (v1 * v1 ^ v5)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v5)) (v1 ^ S v5) (v1 * v1 ^ v5) v8)) (pow_succ_r v1 v5 v6) ((fun v8 : (v0 * v1) ^ v5 == v0 ^ v5 * v1 ^ v5 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * v1 * (v0 * v1) ^ v5) (v0 * v1 * (v0 ^ v5 * v1 ^ v5)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v1)) ((v0 * v1) ^ v5) (v0 ^ v5 * v1 ^ v5) v8) (v0 * v0 ^ v5 * (v1 * v1 ^ v5)) (v0 * v0 ^ v5 * (v1 * v1 ^ v5)) (eq_proper_proxy (v0 * v0 ^ v5 * (v1 * v1 ^ v5)))) v7 (mul_shuffle1 v0 v1 (v0 ^ v5) (v1 ^ v5)))))) v2 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_mul_r	100	0.270037	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v1) => le_ind (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2) (((fun (v4 v5 : @t) (v6 : v4 == v5) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (forall v7 : 0 <= v2, v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2) (forall v7 : 0 <= v2, v0 ^ (v5 * v2) == (v0 ^ v5) ^ v2) (Reflexive_partial_app_morphism (@iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v2)) (v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2) (v0 ^ (v5 * v2) == (v0 ^ v5) ^ v2) (PER_morphism (Equivalence_PER (@eq_equiv)) (v0 ^ (v4 * v2)) (v0 ^ (v5 * v2)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v4 * v2) (v5 * v2) (mul_wd v4 v5 v6 v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2))) ((v0 ^ v4) ^ v2) ((v0 ^ v5) ^ v2) (pow_wd (v0 ^ v4) (v0 ^ v5) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v4 v5 v6) v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2)))) (forall v7 : 0 <= v2, v0 ^ (v5 * v2) == (v0 ^ v5) ^ v2) (forall v7 : 0 <= v2, v0 ^ (v5 * v2) == (v0 ^ v5) ^ v2) (eq_proper_proxy (forall v7 : 0 <= v2, v0 ^ (v5 * v2) == (v0 ^ v5) ^ v2)) (reflexivity (forall v7 : 0 <= v2, v0 ^ (v5 * v2) == (v0 ^ v5) ^ v2))) : (@eq ==> @iff)%signature (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2) (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2)) : Proper (@eq ==> @iff) (fun v4 : @t => forall v5 : 0 <= v2, v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2)) 0 (fun v4 : 0 <= v2 => (fun v5 : v0 ^ 0 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) ((v0 ^ 0) ^ v2) (1 ^ v2) (pow_wd (v0 ^ 0) 1 v5 v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2))) (pow_0_r v0) ((fun v5 : 0 * v2 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ (0 * v2)) (v0 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (0 * v2) 0 v5) (1 ^ v2) (1 ^ v2) (eq_proper_proxy (1 ^ v2))) (mul_0_l v2) ((fun v5 : 1 ^ v2 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (1 ^ v2) 1 v5) (pow_1_l v2 v4) ((fun v5 : v0 ^ 0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ 0) 1 v5 1 1 (eq_proper_proxy 1)) (pow_0_r v0) (reflexivity 1))))) (fun (v4 : @t) (v5 : 0 <= v4) (v6 : forall v6 : 0 <= v2, v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2) (v7 : 0 <= v2) => (fun v8 : v0 ^ S v4 == v0 * v0 ^ v4 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) ((v0 ^ S v4) ^ v2) ((v0 * v0 ^ v4) ^ v2) (pow_wd (v0 ^ S v4) (v0 * v0 ^ v4) v8 v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2))) (pow_succ_r v0 v4 v5) ((fun v8 : S v4 * v2 == v4 * v2 + v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ (S v4 * v2)) (v0 ^ (v4 * v2 + v2)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (S v4 * v2) (v4 * v2 + v2) v8) ((v0 * v0 ^ v4) ^ v2) ((v0 * v0 ^ v4) ^ v2) (eq_proper_proxy ((v0 * v0 ^ v4) ^ v2))) (mul_succ_l v4 v2) ((fun v8 : v0 ^ (v4 * v2 + v2) == v0 ^ (v4 * v2) * v0 ^ v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ (v4 * v2 + v2)) (v0 ^ (v4 * v2) * v0 ^ v2) v8 ((v0 * v0 ^ v4) ^ v2) ((v0 * v0 ^ v4) ^ v2) (eq_proper_proxy ((v0 * v0 ^ v4) ^ v2))) (pow_add_r v0 (v4 * v2) v2 (mul_nonneg_nonneg v4 v2 v5 v7) v7) ((fun v8 : v0 ^ (v4 * v2) == (v0 ^ v4) ^ v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 ^ (v4 * v2) * v0 ^ v2) ((v0 ^ v4) ^ v2 * v0 ^ v2) (mul_wd (v0 ^ (v4 * v2)) ((v0 ^ v4) ^ v2) v8 (v0 ^ v2) (v0 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2))) ((v0 * v0 ^ v4) ^ v2) ((v0 * v0 ^ v4) ^ v2) (eq_proper_proxy ((v0 * v0 ^ v4) ^ v2))) (v6 v7) ((fun v8 : (v0 * v0 ^ v4) ^ v2 == v0 ^ v2 * (v0 ^ v4) ^ v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) ((v0 * v0 ^ v4) ^ v2) (v0 ^ v2 * (v0 ^ v4) ^ v2) v8) (pow_mul_l v0 (v0 ^ v4) v2) (mul_comm ((v0 ^ v4) ^ v2) (v0 ^ v2))))))) v1 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_nonneg	100	0.173613	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 <= v0) => let v3 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v3 as v4 in (_ \/ _) return (0 <= v0 ^ v1) with | or_introl v4 => (fun v4 : v1 < 0 => (fun v5 : v0 ^ v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ v1) 0 v5) (pow_neg_r v0 v1 v4) (reflexivity 0)) v4 | or_intror v4 => (fun v4 : 0 <= v1 => le_ind (fun v5 : @t => 0 <= v0 ^ v5) (((fun (v5 v6 : @t) (v7 : v5 == v6) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (0 <= v0 ^ v5) (0 <= v0 ^ v6) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ v5) (v0 ^ v6) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v5 v6 v7)) (0 <= v0 ^ v6) (0 <= v0 ^ v6) (eq_proper_proxy (0 <= v0 ^ v6)) (reflexivity (0 <= v0 ^ v6))) : (@eq ==> @iff)%signature (fun v5 : @t => 0 <= v0 ^ v5) (fun v5 : @t => 0 <= v0 ^ v5)) : Proper (@eq ==> @iff) (fun v5 : @t => 0 <= v0 ^ v5)) 0 ((fun v5 : v0 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ 0) 1 v5) (pow_0_r v0) ((fun (v5 : 0 < 1) (v6 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v7 : 1 < 0 => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.lt_trans v5 v7)) : ~ 1 < 0)) (@lt_0_1) (@lt_1_2))) (fun (v5 : @t) (v6 : 0 <= v5) (v7 : 0 <= v0 ^ v5) => (fun v8 : v0 ^ S v5 == v0 * v0 ^ v5 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ S v5) (v0 * v0 ^ v5) v8) (pow_succ_r v0 v5 v6) (mul_nonneg_nonneg v0 (v0 ^ v5) v2 v7)) v1 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_pos_nonneg	100	0.103899	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) (v3 : 0 <= v1) => le_ind (fun v4 : @t => 0 < v0 ^ v4) (((fun (v4 v5 : @t) (v6 : v4 == v5) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (0 < v0 ^ v4) (0 < v0 ^ v5) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ v4) (v0 ^ v5) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v4 v5 v6)) (0 < v0 ^ v5) (0 < v0 ^ v5) (eq_proper_proxy (0 < v0 ^ v5)) (reflexivity (0 < v0 ^ v5))) : (@eq ==> @iff)%signature (fun v4 : @t => 0 < v0 ^ v4) (fun v4 : @t => 0 < v0 ^ v4)) : Proper (@eq ==> @iff) (fun v4 : @t => 0 < v0 ^ v4)) 0 ((fun v4 : v0 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ 0) 1 v4) (pow_0_r v0) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : 1 <= 0 => (fun v7 : 0 < 2 => (fun v8 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v6 v4)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ 1 <= 0)) (@lt_0_1) (@lt_1_2))) (fun (v4 : @t) (v5 : 0 <= v4) (v6 : 0 < v0 ^ v4) => (fun v7 : v0 ^ S v4 == v0 * v0 ^ v4 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ S v4) (v0 * v0 ^ v4) v7) (pow_succ_r v0 v4 v5) (mul_pos_pos v0 (v0 ^ v4) v2 v6)) v1 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_lt_mono_l	100	0.611696	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 < v2) => lt_ind (fun v4 : @t => forall v5 : 0 <= v0 < v1, v0 ^ v4 < v1 ^ v4) (((fun (v4 v5 : @t) (v6 : v4 == v5) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (forall v7 : 0 <= v0 < v1, v0 ^ v4 < v1 ^ v4) (forall v7 : 0 <= v0 < v1, v0 ^ v5 < v1 ^ v5) (Reflexive_partial_app_morphism (@iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v0 < v1)) (v0 ^ v4 < v1 ^ v4) (v0 ^ v5 < v1 ^ v5) (lt_wd (v0 ^ v4) (v0 ^ v5) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v4 v5 v6) (v1 ^ v4) (v1 ^ v5) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) v4 v5 v6))) (forall v7 : 0 <= v0 < v1, v0 ^ v5 < v1 ^ v5) (forall v7 : 0 <= v0 < v1, v0 ^ v5 < v1 ^ v5) (eq_proper_proxy (forall v7 : 0 <= v0 < v1, v0 ^ v5 < v1 ^ v5)) (reflexivity (forall v7 : 0 <= v0 < v1, v0 ^ v5 < v1 ^ v5))) : (@eq ==> @iff)%signature (fun v4 : @t => forall v5 : 0 <= v0 < v1, v0 ^ v4 < v1 ^ v4) (fun v4 : @t => forall v5 : 0 <= v0 < v1, v0 ^ v4 < v1 ^ v4)) : Proper (@eq ==> @iff) (fun v4 : @t => forall v5 : 0 <= v0 < v1, v0 ^ v4 < v1 ^ v4)) 0 (fun v4 : 0 <= v0 < v1 => match v4 as v5 in (_ /\ _) return (v0 ^ S 0 < v1 ^ S 0) with | conj v5 v6 => (fun (v5 : 0 <= v0) (v6 : v0 < v1) => (fun v7 : v0 ^ S 0 == v0 * v0 ^ 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ S 0) (v0 * v0 ^ 0) v7 (v1 ^ S 0) (v1 ^ S 0) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ S 0))) (pow_succ_r v0 0 (Private_OrderTac.Tac.le_refl 0)) ((fun v7 : v1 ^ S 0 == v1 * v1 ^ 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ 0)) (v1 ^ S 0) (v1 * v1 ^ 0) v7) (pow_succ_r v1 0 (Private_OrderTac.Tac.le_refl 0)) ((fun v7 : v0 ^ 0 == 1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * v0 ^ 0) (v0 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 ^ 0) 1 v7) (v1 * v1 ^ 0) (v1 * v1 ^ 0) (reflexive_proper_proxy Equivalence_Reflexive (v1 * v1 ^ 0))) (pow_0_r v0) ((fun v7 : v1 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 1)) (v1 * v1 ^ 0) (v1 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) (v1 ^ 0) 1 v7)) (pow_0_r v1) ((fun v7 : v0 * 1 == v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * 1) v0 v7 (v1 * 1) (v1 * 1) (reflexive_proper_proxy Equivalence_Reflexive (v1 * 1))) (mul_1_r v0) ((fun v7 : v1 * 1 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (v1 * 1) v1 v7) (mul_1_r v1) v6)))))) v5 v6 end) (fun (v4 : @t) (v5 : 0 < v4) (v6 : forall v6 : 0 <= v0 < v1, v0 ^ v4 < v1 ^ v4) (v7 : 0 <= v0 < v1) => match v7 as v8 in (_ /\ _) return (v0 ^ S v4 < v1 ^ S v4) with | conj v8 v9 => (fun (v8 : 0 <= v0) (v9 : v0 < v1) => (fun v10 : v0 ^ S v4 == v0 * v0 ^ v4 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ S v4) (v0 * v0 ^ v4) v10 (v1 ^ S v4) (v1 ^ S v4) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ S v4))) (pow_succ_r v0 v4 (Private_OrderTac.Tac.not_gt_le ((fun v10 : v4 < 0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.lt_trans v5 v10)) : ~ v4 < 0))) ((fun v10 : v1 ^ S v4 == v1 * v1 ^ v4 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v4)) (v1 ^ S v4) (v1 * v1 ^ v4) v10) (pow_succ_r v1 v4 (Private_OrderTac.Tac.not_gt_le ((fun v10 : v4 < 0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.lt_trans v5 v10)) : ~ v4 < 0))) (mul_lt_mono_nonneg v0 v1 (v0 ^ v4) (v1 ^ v4) v8 v9 (pow_nonneg v0 v4 (Private_OrderTac.Tac.not_gt_le ((fun v10 : v0 < 0 => (fun v11 : v0 < v4 => (fun v12 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v8 v10)) (Private_OrderTac.Tac.lt_trans v10 v5)) : ~ v0 < 0))) (v6 (conj v8 v9))))) v8 v9 end) v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_le_mono_l	100	0.283429	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v0 <= v1) => match v3 as v4 in (_ /\ _) return (v0 ^ v2 <= v1 ^ v2) with | conj v4 v5 => (fun (v4 : 0 <= v0) (v5 : v0 <= v1) => let v6 : v2 < 0 \/ v2 == 0 \/ 0 < v2 := lt_trichotomy v2 0 in match v6 as v7 in (_ \/ _) return (v0 ^ v2 <= v1 ^ v2) with | or_introl v7 => (fun v7 : v2 < 0 => (fun v8 : v0 ^ v2 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ v2) 0 v8 (v1 ^ v2) (v1 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ v2))) (pow_neg_r v0 v2 v7) ((fun v8 : v1 ^ v2 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (v1 ^ v2) 0 v8) (pow_neg_r v1 v2 v7) (reflexivity 0))) v7 | or_intror v7 => (fun v7 : v2 == 0 \/ 0 < v2 => match v7 as v8 in (_ \/ _) return (v0 ^ v2 <= v1 ^ v2) with | or_introl v8 => (fun v8 : v2 == 0 => (fun v9 : v2 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ v2) (v0 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v2 0 v9) (v1 ^ v2) (v1 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) v2 0 v9)) v8 ((fun v9 : v0 ^ 0 == 1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ 0) 1 v9 (v1 ^ 0) (v1 ^ 0) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ 0))) (pow_0_r v0) ((fun v9 : v1 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (v1 ^ 0) 1 v9) (pow_0_r v1) (reflexivity 1)))) v8 | or_intror v8 => (fun v8 : 0 < v2 => let v9 : forall (v9 v10 : @t) (v11 : v9 <= v10), v9 < v10 \/ v9 == v10 := fun v9 v10 : @t => match lt_eq_cases v9 v10 as v11 in (_ /\ _) return (forall v12 : v9 <= v10, v9 < v10 \/ v9 == v10) with | conj v11 v12 => (fun (v11 : forall v11 : v9 <= v10, v9 < v10 \/ v9 == v10) (v12 : forall v12 : v9 < v10 \/ v9 == v10, v9 <= v10) => v11) v11 v12 end in let v10 : v0 < v1 \/ v0 == v1 := v9 v0 v1 v5 in match v10 as v11 in (_ \/ _) return (v0 ^ v2 <= v1 ^ v2) with | or_introl v11 => (fun v11 : v0 < v1 => lt_le_incl (v0 ^ v2) (v1 ^ v2) (pow_lt_mono_l v0 v1 v2 v8 (conj v4 v11))) v11 | or_intror v11 => (fun v11 : v0 == v1 => (fun v12 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2)) (v1 ^ v2) (v0 ^ v2) (pow_wd v1 v0 (symmetry v12) v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2))) v11 (reflexivity (v0 ^ v2))) v11 end) v8 end) v7 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_gt_1	100	0.247198	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 1 < v0) => conj (fun v3 : 0 < v1 => (fun v4 : 1 ^ v1 == 1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) 1 (1 ^ v1) (symmetry v4) (v0 ^ v1) (v0 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v1))) (pow_1_l v1 (Private_OrderTac.Tac.not_gt_le ((fun v4 : v1 < 0 => (fun v5 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v5) (Private_OrderTac.Tac.lt_trans v3 v4)) : ~ v1 < 0))) (pow_lt_mono_l 1 v0 v1 ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : v1 <= 0 => (fun v7 : 0 < 2 => (fun v8 : 0 < v0 => (fun v9 : v1 < v0 => (fun v10 : v1 < 2 => (fun v11 : v1 < 1 => (fun v12 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v6 v3)) (Private_OrderTac.Tac.le_lt_trans v6 v4)) (Private_OrderTac.Tac.le_lt_trans v6 v7)) (Private_OrderTac.Tac.le_lt_trans v6 v8)) (Private_OrderTac.Tac.lt_trans v4 v2)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2)) (conj ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v6 : 1 < 0 => (fun v7 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_trans v4 v6)) : ~ 1 < 0)) (@lt_0_1) (@lt_1_2)) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : v0 <= 1 => (fun v7 : 0 < 2 => (fun v8 : 0 < v0 => (fun v9 : v0 < 2 => (fun v10 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v6 v2)) (Private_OrderTac.Tac.le_lt_trans v6 v5)) (Private_OrderTac.Tac.lt_trans v4 v2)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ v0 <= 1)) (@lt_0_1) (@lt_1_2))))) (fun v3 : 1 < v0 ^ v1 => let v4 : v1 < 0 \/ v1 == 0 \/ 0 < v1 := lt_trichotomy v1 0 in match v4 as v5 in (_ \/ _) return (0 < v1) with | or_introl v5 => (fun v5 : v1 < 0 => (fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : v1 <= 0 => (fun v9 : 0 < 2 => (fun v10 : v1 < 2 => (fun v11 : v1 < 1 => (fun v12 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.lt_trans ((fun v12 : v0 ^ v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (v0 ^ v1) 0 v12) (pow_neg_r v0 v1 ((fun (v12 : 0 < 1) (v13 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v14 : 0 <= v1 => (fun v15 : 0 < 2 => (fun v16 : v1 < 2 => (fun v17 : v1 < 1 => (fun v18 : v1 < v0 ^ v1 => (fun v19 : 0 < v0 ^ v1 => (fun v20 : v1 < v0 => (fun v21 : 0 < v0 => (fun v22 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v22) (Private_OrderTac.Tac.le_lt_trans v14 v5)) (Private_OrderTac.Tac.lt_trans v12 v2)) (Private_OrderTac.Tac.lt_trans v17 v2)) (Private_OrderTac.Tac.lt_trans v12 v3)) (Private_OrderTac.Tac.lt_trans v17 v3)) (Private_OrderTac.Tac.lt_trans v5 v12)) (Private_OrderTac.Tac.lt_trans v5 v15)) (Private_OrderTac.Tac.lt_trans v12 v13)) : ~ 0 <= v1)) (@lt_0_1) (@lt_1_2))) v3) v6)) (Private_OrderTac.Tac.lt_trans v5 v6)) (Private_OrderTac.Tac.lt_trans v5 v9)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ v1 <= 0)) (@lt_0_1) (@lt_1_2)) v5 | or_intror v5 => (fun v5 : v1 == 0 \/ 0 < v1 => match v5 as v6 in (_ \/ _) return (0 < v1) with | or_introl v6 => (fun v6 : v1 == 0 => Private_OrderTac.Tac.not_ge_lt ((fun v7 : v1 <= 0 => Private_OrderTac.Tac.lt_irrefl ((fun v8 : v0 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (v0 ^ 0) 1 v8) (pow_0_r v0) ((fun v8 : v1 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (v0 ^ v1) (v0 ^ 0) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v1 0 v8)) v6 v3))) : ~ v1 <= 0)) v6 | or_intror v6 => (fun v6 : 0 < v1 => v6) v6 end) v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_lt_mono_r	100	0.582187	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 1 < v0) (v4 : 0 <= v2) (v5 : v1 < v2) => let v6 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v6 as v7 in (_ \/ _) return (v0 ^ v1 < v0 ^ v2) with | or_introl v7 => (fun v7 : v1 < 0 => (fun v8 : v0 ^ v1 == 0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ v1) 0 v8 (v0 ^ v2) (v0 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2))) (pow_neg_r v0 v1 v7) (pow_pos_nonneg v0 v2 ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : v0 <= 0 => (fun v11 : 0 < 2 => (fun v12 : v1 < 2 => (fun v13 : v1 < 1 => (fun v14 : v1 < v0 => (fun v15 : 0 < v0 => (fun v16 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v10 v15)) (Private_OrderTac.Tac.lt_trans v8 v3)) (Private_OrderTac.Tac.lt_trans v13 v3)) (Private_OrderTac.Tac.lt_trans v7 v8)) (Private_OrderTac.Tac.lt_trans v7 v11)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v10 : v2 < 0 => (fun v11 : 0 < 2 => (fun v12 : v2 < 2 => (fun v13 : v1 < 2 => (fun v14 : v2 < 1 => (fun v15 : v1 < 1 => (fun v16 : v1 < v0 => (fun v17 : v2 < v0 => (fun v18 : 0 < v0 => (fun v19 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v19) (Private_OrderTac.Tac.le_lt_trans v4 v10)) (Private_OrderTac.Tac.lt_trans v8 v3)) (Private_OrderTac.Tac.lt_trans v14 v3)) (Private_OrderTac.Tac.lt_trans v15 v3)) (Private_OrderTac.Tac.lt_trans v5 v14)) (Private_OrderTac.Tac.lt_trans v10 v8)) (Private_OrderTac.Tac.lt_trans v5 v12)) (Private_OrderTac.Tac.lt_trans v10 v11)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v2 < 0)) (@lt_0_1) (@lt_1_2)))) v7 | or_intror v7 => (fun v7 : 0 <= v1 => let v8 : v1 <= v2 := Private_OrderTac.Tac.not_gt_le ((fun v8 : v2 < v1 => (fun v9 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v5 v8)) : ~ v2 < v1) in let v9 : exists v9 : @t, v2 == v9 + v1 /\ 0 <= v9 := le_exists_sub v1 v2 v8 in match v9 as v10 in (ex _) return (v0 ^ v1 < v0 ^ v2) with | ex_intro _ v10 v11 => (fun (v10 : @t) (v11 : v2 == v10 + v1 /\ 0 <= v10) => match v11 as v12 in (_ /\ _) return (v0 ^ v1 < v0 ^ v2) with | conj v12 v13 => (fun (v12 : v2 == v10 + v1) (v13 : 0 <= v10) => (fun v14 : v2 == v10 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v1)) (v0 ^ v2) (v0 ^ (v10 + v1)) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v2 (v10 + v1) v14)) v12 ((fun v14 : v0 ^ (v10 + v1) == v0 ^ v10 * v0 ^ v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v1)) (v0 ^ (v10 + v1)) (v0 ^ v10 * v0 ^ v1) v14) (pow_add_r v0 v10 v1 v13 v7) ((fun v14 : 1 * v0 ^ v1 == v0 ^ v1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ v1) (1 * v0 ^ v1) (symmetry v14) (v0 ^ v10 * v0 ^ v1) (v0 ^ v10 * v0 ^ v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v10 * v0 ^ v1))) (mul_1_l (v0 ^ v1)) (let v14 : forall (v14 v15 v16 : @t) (v17 : 0 < v14) (v18 : v15 < v16), v15 * v14 < v16 * v14 := fun (v14 v15 v16 : @t) (v17 : 0 < v14) => match mul_lt_mono_pos_r v14 v15 v16 v17 as v18 in (_ /\ _) return (forall v19 : v15 < v16, v15 * v14 < v16 * v14) with | conj v18 v19 => (fun (v18 : forall v18 : v15 < v16, v15 * v14 < v16 * v14) (v19 : forall v19 : v15 * v14 < v16 * v14, v15 < v16) => v18) v18 v19 end in v14 (v0 ^ v1) 1 (v0 ^ v10) (pow_pos_nonneg v0 v1 ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v17 : v0 <= 0 => (fun v18 : v1 < v10 + v1 => (fun v19 : v1 <= v10 + v1 => (fun v20 : 0 <= v10 + v1 => (fun v21 : 0 < 2 => (fun v22 : 0 < v0 => (fun v23 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v23) (Private_OrderTac.Tac.le_lt_trans v17 v22)) (Private_OrderTac.Tac.lt_trans v15 v3)) (Private_OrderTac.Tac.lt_trans v15 v16)) (Private_OrderTac.Tac.le_eq v4 v12)) (Private_OrderTac.Tac.le_eq v8 v12)) (Private_OrderTac.Tac.lt_eq v5 v12)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v17 : v1 < 0 => (fun v18 : v1 < v10 + v1 => (fun v19 : v1 <= v10 + v1 => (fun v20 : 0 <= v10 + v1 => (fun v21 : 0 < 2 => (fun v22 : v1 < 2 => (fun v23 : v1 < 1 => (fun v24 : v1 < v0 => (fun v25 : 0 < v0 => (fun v26 : 0 < v10 + v1 => (fun v27 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v27) (Private_OrderTac.Tac.le_lt_trans v7 v17)) (Private_OrderTac.Tac.le_lt_trans v7 v18)) (Private_OrderTac.Tac.lt_trans v15 v3)) (Private_OrderTac.Tac.lt_trans v23 v3)) (Private_OrderTac.Tac.lt_trans v17 v15)) (Private_OrderTac.Tac.lt_trans v17 v21)) (Private_OrderTac.Tac.lt_trans v15 v16)) (Private_OrderTac.Tac.le_eq v4 v12)) (Private_OrderTac.Tac.le_eq v8 v12)) (Private_OrderTac.Tac.lt_eq v5 v12)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2))) (let v15 : forall (v15 v16 : @t) (v17 : 1 < v15) (v18 : 0 < v16), 1 < v15 ^ v16 := fun (v15 v16 : @t) (v17 : 1 < v15) => match pow_gt_1 v15 v16 v17 as v18 in (_ /\ _) return (forall v19 : 0 < v16, 1 < v15 ^ v16) with | conj v18 v19 => (fun (v18 : forall v18 : 0 < v16, 1 < v15 ^ v16) (v19 : forall v19 : 1 < v15 ^ v16, 0 < v16) => v18) v18 v19 end in v15 v0 v10 v3 (let v16 : forall (v16 v17 : @t) (v18 : v16 <= v17), v16 < v17 \/ v16 == v17 := fun v16 v17 : @t => match lt_eq_cases v16 v17 as v18 in (_ /\ _) return (forall v19 : v16 <= v17, v16 < v17 \/ v16 == v17) with | conj v18 v19 => (fun (v18 : forall v18 : v16 <= v17, v16 < v17 \/ v16 == v17) (v19 : forall v19 : v16 < v17 \/ v16 == v17, v16 <= v17) => v18) v18 v19 end in let v17 : 0 < v10 \/ 0 == v10 := v16 0 v10 v13 in match v17 as v18 in (_ \/ _) return (0 < v10) with | or_introl v18 => (fun v18 : 0 < v10 => v18) v18 | or_intror v18 => (fun v18 : 0 == v10 => (fun v19 : 0 == v10 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) v10 0 (symmetry v19)) v18 (False_ind (0 < 0) ((fun v19 : v10 <= v1 => (fun v20 : v10 <= v2 => (fun v21 : v1 < v1 => (fun v22 : v10 <= v1 => (fun v23 : v1 <= v1 => Private_OrderTac.Tac.lt_irrefl v21) (Private_OrderTac.Tac.le_eq v8 ((fun v23 : 0 + v1 == v1 => trans_co_impl_morphism Equivalence_Transitive (0 + v1) v1 v23) (add_0_l v1) ((fun v23 : 0 == v10 => trans_co_impl_morphism Equivalence_Transitive (v10 + v1) (0 + v1) (add_wd v10 0 (symmetry v23) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) v18 v12)))) (Private_OrderTac.Tac.le_eq v20 ((fun v22 : 0 + v1 == v1 => trans_co_impl_morphism Equivalence_Transitive (0 + v1) v1 v22) (add_0_l v1) ((fun v22 : 0 == v10 => trans_co_impl_morphism Equivalence_Transitive (v10 + v1) (0 + v1) (add_wd v10 0 (symmetry v22) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) v18 v12)))) (Private_OrderTac.Tac.lt_eq v5 ((fun v21 : 0 + v1 == v1 => trans_co_impl_morphism Equivalence_Transitive (0 + v1) v1 v21) (add_0_l v1) ((fun v21 : 0 == v10 => trans_co_impl_morphism Equivalence_Transitive (v10 + v1) (0 + v1) (add_wd v10 0 (symmetry v21) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1))) v18 v12)))) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v18) v4)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v18) v7)))) v18 end)))))) v12 v13 end) v10 v11 end) v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_le_mono_r	100	0.303909	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 < v0) (v4 : v1 <= v2) => let v5 : v1 < 0 \/ 0 <= v1 := lt_ge_cases v1 0 in match v5 as v6 in (_ \/ _) return (v0 ^ v1 <= v0 ^ v2) with | or_introl v6 => (fun v6 : v1 < 0 => (fun v7 : v0 ^ v1 == 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ v1) 0 v7 (v0 ^ v2) (v0 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v2))) (pow_neg_r v0 v1 v6) (pow_nonneg v0 v2 (Private_OrderTac.Tac.not_gt_le ((fun v7 : v0 < 0 => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.lt_trans v3 v7)) : ~ v0 < 0)))) v6 | or_intror v6 => (fun v6 : 0 <= v1 => let v7 : forall (v7 v8 : @t) (v9 : v7 < v8), S v7 <= v8 := fun v7 v8 : @t => match le_succ_l v7 v8 as v9 in (_ /\ _) return (forall v10 : v7 < v8, S v7 <= v8) with | conj v9 v10 => (fun (v9 : forall v9 : S v7 <= v8, v7 < v8) (v10 : forall v10 : v7 < v8, S v7 <= v8) => v10) v9 v10 end in let v8 : S 0 <= v0 := v7 0 v0 v3 in let v9 : forall (v9 v10 : @t) (v11 : v9 <= v10), v9 < v10 \/ v9 == v10 := fun v9 v10 : @t => match lt_eq_cases v9 v10 as v11 in (_ /\ _) return (forall v12 : v9 <= v10, v9 < v10 \/ v9 == v10) with | conj v11 v12 => (fun (v11 : forall v11 : v9 <= v10, v9 < v10 \/ v9 == v10) (v12 : forall v12 : v9 < v10 \/ v9 == v10, v9 <= v10) => v11) v11 v12 end in let v10 : 1 < v0 \/ 1 == v0 := v9 1 v0 ((fun v10 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 0) 1 (symmetry v10) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (@one_succ) v8) in match v10 as v11 in (_ \/ _) return (v0 ^ v1 <= v0 ^ v2) with | or_introl v11 => (fun v11 : 1 < v0 => let v12 : forall (v12 v13 : @t) (v14 : v12 <= v13), v12 < v13 \/ v12 == v13 := fun v12 v13 : @t => match lt_eq_cases v12 v13 as v14 in (_ /\ _) return (forall v15 : v12 <= v13, v12 < v13 \/ v12 == v13) with | conj v14 v15 => (fun (v14 : forall v14 : v12 <= v13, v12 < v13 \/ v12 == v13) (v15 : forall v15 : v12 < v13 \/ v12 == v13, v12 <= v13) => v14) v14 v15 end in let v13 : v1 < v2 \/ v1 == v2 := v12 v1 v2 v4 in match v13 as v14 in (_ \/ _) return (v0 ^ v1 <= v0 ^ v2) with | or_introl v14 => (fun v14 : v1 < v2 => lt_le_incl (v0 ^ v1) (v0 ^ v2) (pow_lt_mono_r v0 v1 v2 (Private_OrderTac.Tac.not_ge_lt ((fun v15 : v0 <= 1 => (fun v16 : 0 < v2 => (fun v17 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v15 v11)) (Private_OrderTac.Tac.le_lt_trans v6 v14)) : ~ v0 <= 1)) (Private_OrderTac.Tac.not_gt_le ((fun v15 : v2 < 0 => (fun v16 : v1 < 0 => (fun v17 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.le_lt_trans v6 v16)) (Private_OrderTac.Tac.lt_trans v14 v15)) : ~ v2 < 0)) (Private_OrderTac.Tac.not_ge_lt ((fun v15 : v2 <= v1 => (fun v16 : v2 < v2 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.le_lt_trans v15 v14)) : ~ v2 <= v1)))) v14 | or_intror v14 => (fun v14 : v1 == v2 => (fun v15 : v1 == v2 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 ^ v1)) (v0 ^ v2) (v0 ^ v1) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v2 v1 (symmetry v15))) v14 (reflexivity (v0 ^ v1))) v14 end) v11 | or_intror v11 => (fun v11 : 1 == v0 => (fun v12 : 1 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ v1) (1 ^ v1) (pow_wd v0 1 (symmetry v12) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (v0 ^ v2) (1 ^ v2) (pow_wd v0 1 (symmetry v12) v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2))) v11 ((fun v12 : 1 ^ v1 == 1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (1 ^ v1) 1 v12 (1 ^ v2) (1 ^ v2) (reflexive_proper_proxy Equivalence_Reflexive (1 ^ v2))) (pow_1_l v1 (Private_OrderTac.Tac.not_gt_le ((fun v12 : v1 < 0 => (fun v13 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v6 v12)) : ~ v1 < 0))) ((fun v12 : 1 ^ v2 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 1) (1 ^ v2) 1 v12) (pow_1_l v2 (Private_OrderTac.Tac.not_gt_le ((fun v12 : v2 < 0 => (fun v13 : v1 < 0 => (fun v14 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v14) (Private_OrderTac.Tac.le_lt_trans v6 v13)) (Private_OrderTac.Tac.le_lt_trans v4 v12)) : ~ v2 < 0))) (Private_OrderTac.Tac.le_refl 1)))) v11 end) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_le_mono	100	0.054877	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @t) (v4 : 0 < v0 <= v2) (v5 : v1 <= v3) => transitivity (pow_le_mono_r v0 v1 v3 (and_ind (fun (v6 : 0 < v0) (v7 : v0 <= v2) => v6) v4) (and_ind (fun (v6 : 0 < v0) (v7 : v0 <= v2) => v5) v4)) (pow_le_mono_l v0 v2 v3 (and_ind (fun (v6 : 0 < v0) (v7 : v0 <= v2) => conj (Private_OrderTac.Tac.not_gt_le ((fun v8 : v0 < 0 => (fun v9 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.lt_trans v6 v8)) : ~ v0 < 0) : 0 <= v0) v7) v4)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_lt_mono	100	0.294037	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @t) (v4 : 0 < v0 < v2) => match v4 as v5 in (_ /\ _) return (forall v6 : 0 < v1 < v3, v0 ^ v1 < v2 ^ v3) with | conj v5 v6 => (fun (v5 : 0 < v0) (v6 : v0 < v2) (v7 : 0 < v1 < v3) => match v7 as v8 in (_ /\ _) return (v0 ^ v1 < v2 ^ v3) with | conj v8 v9 => (fun (v8 : 0 < v1) (v9 : v1 < v3) => let v10 : forall (v10 v11 : @t) (v12 : v10 < v11), S v10 <= v11 := fun v10 v11 : @t => match le_succ_l v10 v11 as v12 in (_ /\ _) return (forall v13 : v10 < v11, S v10 <= v11) with | conj v12 v13 => (fun (v12 : forall v12 : S v10 <= v11, v10 < v11) (v13 : forall v13 : v10 < v11, S v10 <= v11) => v13) v12 v13 end in let v11 : S 0 <= v0 := v10 0 v0 v5 in let v12 : forall (v12 v13 : @t) (v14 : v12 <= v13), v12 < v13 \/ v12 == v13 := fun v12 v13 : @t => match lt_eq_cases v12 v13 as v14 in (_ /\ _) return (forall v15 : v12 <= v13, v12 < v13 \/ v12 == v13) with | conj v14 v15 => (fun (v14 : forall v14 : v12 <= v13, v12 < v13 \/ v12 == v13) (v15 : forall v15 : v12 < v13 \/ v12 == v13, v12 <= v13) => v14) v14 v15 end in let v13 : 1 < v0 \/ 1 == v0 := v12 1 v0 ((fun v13 : 1 == S 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 0) 1 (symmetry v13) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (@one_succ) v11) in match v13 as v14 in (_ \/ _) return (v0 ^ v1 < v2 ^ v3) with | or_introl v14 => (fun v14 : 1 < v0 => transitivity (pow_lt_mono_r v0 v1 v3 v14 (Private_OrderTac.Tac.not_gt_le ((fun v15 : v3 < 0 => (fun v16 : v1 < 0 => (fun v17 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v17) (Private_OrderTac.Tac.lt_trans v8 v16)) (Private_OrderTac.Tac.lt_trans v9 v15)) : ~ v3 < 0) : 0 <= v3) v9) (pow_lt_mono_l v0 v2 v3 ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v17 : v3 <= 0 => (fun v18 : 0 < 2 => (fun v19 : 0 < v3 => (fun v20 : 1 < v2 => (fun v21 : 0 < v2 => (fun v22 : 0 < v0 => (fun v23 : v3 < v0 => (fun v24 : v1 < v0 => (fun v25 : v1 < v2 => (fun v26 : v3 < v2 => (fun v27 : v3 < v3 => Private_OrderTac.Tac.lt_irrefl v27) (Private_OrderTac.Tac.le_lt_trans v17 v19)) (Private_OrderTac.Tac.lt_trans v23 v6)) (Private_OrderTac.Tac.lt_trans v24 v6)) (Private_OrderTac.Tac.lt_trans v9 v23)) (Private_OrderTac.Tac.le_lt_trans v17 v22)) (Private_OrderTac.Tac.lt_trans v15 v14)) (Private_OrderTac.Tac.lt_trans v15 v20)) (Private_OrderTac.Tac.lt_trans v14 v6)) (Private_OrderTac.Tac.lt_trans v8 v9)) (Private_OrderTac.Tac.lt_trans v15 v16)) : ~ v3 <= 0)) (@lt_0_1) (@lt_1_2)) (conj ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v17 : v0 < 0 => (fun v18 : 1 < 0 => (fun v19 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v19) (Private_OrderTac.Tac.lt_trans v15 v18)) (Private_OrderTac.Tac.lt_trans v14 v17)) : ~ v0 < 0)) (@lt_0_1) (@lt_1_2)) ((fun (v15 : 0 < 1) (v16 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v17 : v2 <= v0 => (fun v18 : 0 < 2 => (fun v19 : 0 < v3 => (fun v20 : 1 < v2 => (fun v21 : 0 < v2 => (fun v22 : 0 < v0 => (fun v23 : v2 < v2 => Private_OrderTac.Tac.lt_irrefl v23) (Private_OrderTac.Tac.le_lt_trans v17 v6)) (Private_OrderTac.Tac.lt_trans v15 v14)) (Private_OrderTac.Tac.lt_trans v15 v20)) (Private_OrderTac.Tac.lt_trans v14 v6)) (Private_OrderTac.Tac.lt_trans v8 v9)) (Private_OrderTac.Tac.lt_trans v15 v16)) : ~ v2 <= v0)) (@lt_0_1) (@lt_1_2))))) v14 | or_intror v14 => (fun v14 : 1 == v0 => (fun v15 : 1 == v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ v1) (1 ^ v1) (pow_wd v0 1 (symmetry v15) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (v2 ^ v3) (v2 ^ v3) (reflexive_proper_proxy Equivalence_Reflexive (v2 ^ v3))) v14 ((fun v15 : 1 ^ v1 == 1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (1 ^ v1) 1 v15 (v2 ^ v3) (v2 ^ v3) (reflexive_proper_proxy Equivalence_Reflexive (v2 ^ v3))) (pow_1_l v1 (Private_OrderTac.Tac.not_gt_le ((fun v15 : v1 < 0 => (fun v16 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v16) (Private_OrderTac.Tac.lt_trans v8 v15)) : ~ v1 < 0))) (let v15 : forall (v15 v16 : @t) (v17 : 1 < v15) (v18 : 0 < v16), 1 < v15 ^ v16 := fun (v15 v16 : @t) (v17 : 1 < v15) => match pow_gt_1 v15 v16 v17 as v18 in (_ /\ _) return (forall v19 : 0 < v16, 1 < v15 ^ v16) with | conj v18 v19 => (fun (v18 : forall v18 : 0 < v16, 1 < v15 ^ v16) (v19 : forall v19 : 1 < v15 ^ v16, 0 < v16) => v18) v18 v19 end in v15 v2 v3 (Private_OrderTac.Tac.not_ge_lt ((fun v16 : v2 <= 1 => (fun v17 : v2 <= v0 => (fun v18 : 0 < v3 => (fun v19 : v2 < v2 => Private_OrderTac.Tac.lt_irrefl v19) (Private_OrderTac.Tac.le_lt_trans v17 v6)) (Private_OrderTac.Tac.lt_trans v8 v9)) (Private_OrderTac.Tac.le_eq v16 v14)) : ~ v2 <= 1)) (Private_OrderTac.Tac.not_ge_lt ((fun v16 : v3 <= 0 => (fun v17 : 0 < v3 => (fun v18 : v3 < v3 => Private_OrderTac.Tac.lt_irrefl v18) (Private_OrderTac.Tac.le_lt_trans v16 v17)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v3 <= 0))))) v14 end) v8 v9 end) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_inj_l	100	0.079981	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v0) (v4 : 0 <= v1) (v5 : 0 < v2) (v6 : v0 ^ v2 == v1 ^ v2) => let v7 : v0 < v1 \/ v0 == v1 \/ v1 < v0 := lt_trichotomy v0 v1 in match v7 as v8 in (_ \/ _) return (v0 == v1) with | or_introl v8 => (fun v8 : v0 < v1 => let v9 : v0 ^ v2 < v1 ^ v2 := pow_lt_mono_l v0 v1 v2 v5 (conj v3 v8) in Private_OrderTac.Tac.not_neq_eq ((fun v10 : v0 ~= v1 => (fun v11 : v1 ^ v2 < v1 ^ v2 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v6) v9)) : ~ v0 ~= v1)) v8 | or_intror v8 => (fun v8 : v0 == v1 \/ v1 < v0 => match v8 as v9 in (_ \/ _) return (v0 == v1) with | or_introl v9 => (fun v9 : v0 == v1 => v9) v9 | or_intror v9 => (fun v9 : v1 < v0 => let v10 : v1 ^ v2 < v0 ^ v2 := pow_lt_mono_l v1 v0 v2 v5 (conj v4 v9) in Private_OrderTac.Tac.not_neq_eq ((fun v11 : v0 ~= v1 => (fun v12 : v1 ^ v2 < v1 ^ v2 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.lt_eq v10 v6)) : ~ v0 ~= v1)) v9 end) v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_inj_r	100	0.077290	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 1 < v0) (v4 : 0 <= v1) (v5 : 0 <= v2) (v6 : v0 ^ v1 == v0 ^ v2) => let v7 : v1 < v2 \/ v1 == v2 \/ v2 < v1 := lt_trichotomy v1 v2 in match v7 as v8 in (_ \/ _) return (v1 == v2) with | or_introl v8 => (fun v8 : v1 < v2 => let v9 : v0 ^ v1 < v0 ^ v2 := pow_lt_mono_r v0 v1 v2 v3 v5 v8 in Private_OrderTac.Tac.not_neq_eq ((fun v10 : v1 ~= v2 => (fun v11 : v0 ^ v2 < v0 ^ v2 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v6) v9)) : ~ v1 ~= v2)) v8 | or_intror v8 => (fun v8 : v1 == v2 \/ v2 < v1 => match v8 as v9 in (_ \/ _) return (v1 == v2) with | or_introl v9 => (fun v9 : v1 == v2 => v9) v9 | or_intror v9 => (fun v9 : v2 < v1 => let v10 : v0 ^ v2 < v0 ^ v1 := pow_lt_mono_r v0 v2 v1 v3 v4 v9 in Private_OrderTac.Tac.not_neq_eq ((fun v11 : v1 ~= v2 => (fun v12 : v0 ^ v2 < v0 ^ v2 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.lt_eq v10 v6)) : ~ v1 ~= v2)) v9 end) v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_lt_mono_l_iff	100	0.070933	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v0) (v4 : 0 <= v1) (v5 : 0 < v2) => conj (fun v6 : v0 < v1 => pow_lt_mono_l v0 v1 v2 v5 (conj v3 v6)) (fun v6 : v0 ^ v2 < v1 ^ v2 => let v7 : v1 <= v0 \/ v0 < v1 := le_gt_cases v1 v0 in match v7 as v8 in (_ \/ _) return (v0 < v1) with | or_introl v8 => (fun v8 : v1 <= v0 => let v9 : v1 ^ v2 <= v0 ^ v2 := pow_le_mono_l v1 v0 v2 (conj (Private_OrderTac.Tac.not_gt_le ((fun v9 : v1 < 0 => (fun v10 : v1 < v2 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v4 v9)) (Private_OrderTac.Tac.lt_trans v9 v5)) : ~ v1 < 0)) (Private_OrderTac.Tac.not_gt_le ((fun v9 : v0 < v1 => (fun v10 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v9)) : ~ v0 < v1))) in Private_OrderTac.Tac.not_ge_lt ((fun v10 : v1 <= v0 => (fun v11 : v1 ^ v2 < v1 ^ v2 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v9 v6)) : ~ v1 <= v0)) v8 | or_intror v8 => (fun v8 : v0 < v1 => v8) v8 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_le_mono_l_iff	100	0.072014	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v0) (v4 : 0 <= v1) (v5 : 0 < v2) => conj (fun v6 : v0 <= v1 => pow_le_mono_l v0 v1 v2 (conj v3 v6)) (fun v6 : v0 ^ v2 <= v1 ^ v2 => let v7 : v0 <= v1 \/ v1 < v0 := le_gt_cases v0 v1 in match v7 as v8 in (_ \/ _) return (v0 <= v1) with | or_introl v8 => (fun v8 : v0 <= v1 => v8) v8 | or_intror v8 => (fun v8 : v1 < v0 => let v9 : v1 ^ v2 < v0 ^ v2 := pow_lt_mono_l v1 v0 v2 v5 (conj v4 v8) in Private_OrderTac.Tac.not_gt_le ((fun v10 : v1 < v0 => (fun v11 : 0 < v0 => (fun v12 : v0 ^ v2 < v0 ^ v2 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v6 v9)) (Private_OrderTac.Tac.le_lt_trans v4 v10)) : ~ v1 < v0)) v8 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_lt_mono_r_iff	100	0.083197	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 1 < v0) (v4 : 0 <= v2) => conj (fun v5 : v1 < v2 => pow_lt_mono_r v0 v1 v2 v3 v4 v5) (fun v5 : v0 ^ v1 < v0 ^ v2 => let v6 : v2 <= v1 \/ v1 < v2 := le_gt_cases v2 v1 in match v6 as v7 in (_ \/ _) return (v1 < v2) with | or_introl v7 => (fun v7 : v2 <= v1 => let v8 : v0 ^ v2 <= v0 ^ v1 := pow_le_mono_r v0 v2 v1 ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : v0 <= 0 => (fun v11 : 0 < 2 => (fun v12 : 0 < v0 => (fun v13 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v10 v12)) (Private_OrderTac.Tac.lt_trans v8 v3)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v10 : v1 < v2 => (fun v11 : 0 < 2 => (fun v12 : 0 < v0 => (fun v13 : v2 < v2 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v7 v10)) (Private_OrderTac.Tac.lt_trans v8 v3)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v1 < v2)) (@lt_0_1) (@lt_1_2)) in Private_OrderTac.Tac.not_ge_lt ((fun v9 : v2 <= v1 => (fun v10 : v0 ^ v2 < v0 ^ v2 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v5)) : ~ v2 <= v1)) v7 | or_intror v7 => (fun v7 : v1 < v2 => v7) v7 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_le_mono_r_iff	100	0.113025	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 1 < v0) (v4 : 0 <= v2) => conj (fun v5 : v1 <= v2 => pow_le_mono_r v0 v1 v2 ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v8 : v0 <= 0 => (fun v9 : 0 < 2 => (fun v10 : 0 < v0 => (fun v11 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v8 v10)) (Private_OrderTac.Tac.lt_trans v6 v3)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ v0 <= 0)) (@lt_0_1) (@lt_1_2)) ((fun (v6 : 0 < 1) (v7 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v8 : v2 < v1 => (fun v9 : 0 < 2 => (fun v10 : 0 < v0 => (fun v11 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v5 v8)) (Private_OrderTac.Tac.lt_trans v6 v3)) (Private_OrderTac.Tac.lt_trans v6 v7)) : ~ v2 < v1)) (@lt_0_1) (@lt_1_2))) (fun v5 : v0 ^ v1 <= v0 ^ v2 => let v6 : v1 <= v2 \/ v2 < v1 := le_gt_cases v1 v2 in match v6 as v7 in (_ \/ _) return (v1 <= v2) with | or_introl v7 => (fun v7 : v1 <= v2 => v7) v7 | or_intror v7 => (fun v7 : v2 < v1 => let v8 : v0 ^ v2 < v0 ^ v1 := pow_lt_mono_r v0 v2 v1 ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : v0 <= 1 => (fun v11 : 0 < 2 => (fun v12 : 0 < v0 => (fun v13 : v0 < 2 => (fun v14 : 0 < v1 => (fun v15 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v15) (Private_OrderTac.Tac.le_lt_trans v10 v3)) (Private_OrderTac.Tac.le_lt_trans v4 v7)) (Private_OrderTac.Tac.le_lt_trans v10 v9)) (Private_OrderTac.Tac.lt_trans v8 v3)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v0 <= 1)) (@lt_0_1) (@lt_1_2)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v10 : v1 < 0 => (fun v11 : v2 < 0 => (fun v12 : 0 < 2 => (fun v13 : v2 < 2 => (fun v14 : v1 < 2 => (fun v15 : v2 < 1 => (fun v16 : v1 < 1 => (fun v17 : v1 < v0 => (fun v18 : v2 < v0 => (fun v19 : 0 < v0 => (fun v20 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v20) (Private_OrderTac.Tac.le_lt_trans v4 v11)) (Private_OrderTac.Tac.lt_trans v8 v3)) (Private_OrderTac.Tac.lt_trans v7 v17)) (Private_OrderTac.Tac.lt_trans v16 v3)) (Private_OrderTac.Tac.lt_trans v10 v8)) (Private_OrderTac.Tac.lt_trans v11 v8)) (Private_OrderTac.Tac.lt_trans v10 v12)) (Private_OrderTac.Tac.lt_trans v11 v12)) (Private_OrderTac.Tac.lt_trans v8 v9)) (Private_OrderTac.Tac.lt_trans v7 v10)) : ~ v1 < 0)) (@lt_0_1) (@lt_1_2)) ((fun (v8 : 0 < 1) (v9 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v10 : v1 <= v2 => (fun v11 : 0 < 2 => (fun v12 : 0 < v0 => (fun v13 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v13) (Private_OrderTac.Tac.le_lt_trans v10 v7)) (Private_OrderTac.Tac.lt_trans v8 v3)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ v1 <= v2)) (@lt_0_1) (@lt_1_2)) in Private_OrderTac.Tac.not_gt_le ((fun v9 : v2 < v1 => (fun v10 : 0 < v1 => (fun v11 : v0 ^ v1 < v0 ^ v1 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v5 v8)) (Private_OrderTac.Tac.le_lt_trans v4 v9)) : ~ v2 < v1)) v7 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_gt_lin_r	100	0.632328	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 1 < v0) (v3 : 0 <= v1) => le_ind (fun v4 : @t => v4 < v0 ^ v4) (((fun (v4 v5 : @t) (v6 : v4 == v5) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v4 < v0 ^ v4) (v5 < v0 ^ v5) (lt_wd v4 v5 v6 (v0 ^ v4) (v0 ^ v5) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v4 v5 v6)) (v5 < v0 ^ v5) (v5 < v0 ^ v5) (eq_proper_proxy (v5 < v0 ^ v5)) (reflexivity (v5 < v0 ^ v5))) : (@eq ==> @iff)%signature (fun v4 : @t => v4 < v0 ^ v4) (fun v4 : @t => v4 < v0 ^ v4)) : Proper (@eq ==> @iff) (fun v4 : @t => v4 < v0 ^ v4)) 0 ((fun v4 : v0 ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (v0 ^ 0) 1 v4) (pow_0_r v0) ((fun (v4 : 0 < 1) (v5 : 1 < 2) => Private_OrderTac.Tac.not_ge_lt ((fun v6 : 1 <= 0 => (fun v7 : 0 < 2 => (fun v8 : 0 < v0 => (fun v9 : 1 < 1 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v6 v4)) (Private_OrderTac.Tac.lt_trans v4 v2)) (Private_OrderTac.Tac.lt_trans v4 v5)) : ~ 1 <= 0)) (@lt_0_1) (@lt_1_2))) (fun (v4 : @t) (v5 : 0 <= v4) (v6 : v4 < v0 ^ v4) => (fun v7 : v0 ^ S v4 == v0 * v0 ^ v4 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S v4)) (v0 ^ S v4) (v0 * v0 ^ v4) v7) (pow_succ_r v0 v4 v5) ((fun v7 : S (S v4) <= v0 * v0 ^ v4 <-> S v4 < v0 * v0 ^ v4 => iff_flip_impl_subrelation (S v4 < v0 * v0 ^ v4) (S (S v4) <= v0 * v0 ^ v4) (symmetry v7)) (le_succ_l (S v4) (v0 * v0 ^ v4)) (transitivity ((fun v7 : 2 * S v4 == 2 * v4 + 2 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (2 * S v4) (2 * v4 + 2) v7) (mul_succ_r 2 v4) ((fun v7 : 2 == S 1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (2 * v4 + 2) (S 1 * v4 + S 1) (add_wd (2 * v4) (S 1 * v4) (mul_wd 2 (S 1) v7 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) 2 (S 1) v7)) (@two_succ) ((fun v7 : 1 == S 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S 1 * v4 + S 1) (S (S 0) * v4 + S (S 0)) (add_wd (S 1 * v4) (S (S 0) * v4) (mul_wd (S 1) (S (S 0)) (succ_wd 1 (S 0) v7) v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) (S 1) (S (S 0)) (succ_wd 1 (S 0) v7))) (@one_succ) ((fun v7 : S (S 0) * v4 + S (S 0) == S (S (S 0) * v4 + S 0) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S (S 0) * v4 + S (S 0)) (S (S (S 0) * v4 + S 0)) v7) (add_succ_r (S (S 0) * v4) (S 0)) ((fun v7 : S (S 0) * v4 + S 0 == S (S (S 0) * v4 + 0) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S (S (S 0) * v4 + S 0)) (S (S (S (S 0) * v4 + 0))) (succ_wd (S (S 0) * v4 + S 0) (S (S (S 0) * v4 + 0)) v7)) (add_succ_r (S (S 0) * v4) 0) ((fun v7 : S (S 0) * v4 + 0 == S (S 0) * v4 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S (S (S (S 0) * v4 + 0))) (S (S (S (S 0) * v4))) (succ_wd (S (S (S 0) * v4 + 0)) (S (S (S 0) * v4)) (succ_wd (S (S 0) * v4 + 0) (S (S 0) * v4) v7))) (add_0_r (S (S 0) * v4)) ((fun v7 : S (S 0) * v4 == S 0 * v4 + v4 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S (S (S (S 0) * v4))) (S (S (S 0 * v4 + v4))) (succ_wd (S (S (S 0) * v4)) (S (S 0 * v4 + v4)) (succ_wd (S (S 0) * v4) (S 0 * v4 + v4) v7))) (mul_succ_l (S 0) v4) ((fun v7 : S 0 * v4 == 0 * v4 + v4 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S (S (S 0 * v4 + v4))) (S (S (0 * v4 + v4 + v4))) (succ_wd (S (S 0 * v4 + v4)) (S (0 * v4 + v4 + v4)) (succ_wd (S 0 * v4 + v4) (0 * v4 + v4 + v4) (add_wd (S 0 * v4) (0 * v4 + v4) v7 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4))))) (mul_succ_l 0 v4) ((fun v7 : 0 * v4 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S (S (0 * v4 + v4 + v4))) (S (S (0 + v4 + v4))) (succ_wd (S (0 * v4 + v4 + v4)) (S (0 + v4 + v4)) (succ_wd (0 * v4 + v4 + v4) (0 + v4 + v4) (add_wd (0 * v4 + v4) (0 + v4) (add_wd (0 * v4) 0 v7 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4))))) (mul_0_l v4) ((fun v7 : 0 + v4 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (S (S v4))) (S (S (0 + v4 + v4))) (S (S (v4 + v4))) (succ_wd (S (0 + v4 + v4)) (S (v4 + v4)) (succ_wd (0 + v4 + v4) (v4 + v4) (add_wd (0 + v4) v4 v7 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4))))) (add_0_l v4) ((fun v7 : S v4 <= S (v4 + v4) <-> S (S v4) <= S (S (v4 + v4)) => iff_flip_impl_subrelation (S (S v4) <= S (S (v4 + v4))) (S v4 <= S (v4 + v4)) (symmetry v7)) (succ_le_mono (S v4) (S (v4 + v4))) ((fun v7 : v4 <= v4 + v4 <-> S v4 <= S (v4 + v4) => iff_flip_impl_subrelation (S v4 <= S (v4 + v4)) (v4 <= v4 + v4) (symmetry v7)) (succ_le_mono v4 (v4 + v4)) ((fun v7 : 0 + v4 == v4 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v4 (0 + v4) (symmetry v7) (v4 + v4) (v4 + v4) (reflexive_proper_proxy Equivalence_Reflexive (v4 + v4))) (add_0_l v4) (add_le_mono 0 v4 v4 v4 (Private_OrderTac.Tac.not_gt_le ((fun v7 : v4 < 0 => (fun v8 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v5 v7)) : ~ v4 < 0)) (Private_OrderTac.Tac.le_refl v4))))))))))))))) (mul_le_mono_nonneg 2 v0 (S v4) (v0 ^ v4) ((fun (v7 : 0 < 1) (v8 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v9 : 2 < 0 => (fun v10 : 1 < 0 => (fun v11 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.lt_trans v7 v10)) (Private_OrderTac.Tac.lt_trans v8 v9)) : ~ 2 < 0)) (@lt_0_1) (@lt_1_2)) ((fun v7 : 2 == S 1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation))) (S 1) 2 (symmetry v7) v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (@two_succ) ((fun v7 : S 1 <= v0 <-> 1 < v0 => iff_impl_subrelation (1 < v0) (S 1 <= v0) (symmetry v7)) (le_succ_l 1 v0) v2)) (lt_le_incl 0 (S v4) (let v7 : forall (v7 v8 : @t) (v9 : v7 <= v8), v7 < S v8 := fun v7 v8 : @t => match lt_succ_r v7 v8 as v9 in (_ /\ _) return (forall v10 : v7 <= v8, v7 < S v8) with | conj v9 v10 => (fun (v9 : forall v9 : v7 < S v8, v7 <= v8) (v10 : forall v10 : v7 <= v8, v7 < S v8) => v10) v9 v10 end in v7 0 v4 v5)) ((fun v7 : S v4 <= v0 ^ v4 <-> v4 < v0 ^ v4 => iff_impl_subrelation (v4 < v0 ^ v4) (S v4 <= v0 ^ v4) (symmetry v7)) (le_succ_l v4 (v0 ^ v4)) v6))))) v1 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_add_lower	100	0.885623	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : 0 <= v0) (v4 : 0 <= v1) (v5 : 0 < v2) => lt_ind (fun v6 : @t => v0 ^ v6 + v1 ^ v6 <= (v0 + v1) ^ v6) (((fun (v6 v7 : @t) (v8 : v6 == v7) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 ^ v6 + v1 ^ v6 <= (v0 + v1) ^ v6) (v0 ^ v7 + v1 ^ v7 <= (v0 + v1) ^ v7) (le_wd (v0 ^ v6 + v1 ^ v6) (v0 ^ v7 + v1 ^ v7) (add_wd (v0 ^ v6) (v0 ^ v7) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v6 v7 v8) (v1 ^ v6) (v1 ^ v7) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) v6 v7 v8)) ((v0 + v1) ^ v6) ((v0 + v1) ^ v7) (Reflexive_partial_app_morphism (@pow_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) v6 v7 v8)) (v0 ^ v7 + v1 ^ v7 <= (v0 + v1) ^ v7) (v0 ^ v7 + v1 ^ v7 <= (v0 + v1) ^ v7) (eq_proper_proxy (v0 ^ v7 + v1 ^ v7 <= (v0 + v1) ^ v7)) (reflexivity (v0 ^ v7 + v1 ^ v7 <= (v0 + v1) ^ v7))) : (@eq ==> @iff)%signature (fun v6 : @t => v0 ^ v6 + v1 ^ v6 <= (v0 + v1) ^ v6) (fun v6 : @t => v0 ^ v6 + v1 ^ v6 <= (v0 + v1) ^ v6)) : Proper (@eq ==> @iff) (fun v6 : @t => v0 ^ v6 + v1 ^ v6 <= (v0 + v1) ^ v6)) 0 ((fun v6 : v0 ^ S 0 == v0 * v0 ^ 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ S 0 + v1 ^ S 0) (v0 * v0 ^ 0 + v1 ^ S 0) (add_wd (v0 ^ S 0) (v0 * v0 ^ 0) v6 (v1 ^ S 0) (v1 ^ S 0) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ S 0))) ((v0 + v1) ^ S 0) ((v0 + v1) ^ S 0) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) ^ S 0))) (pow_succ_r v0 0 (Private_OrderTac.Tac.le_refl 0)) ((fun v6 : v1 ^ S 0 == v1 * v1 ^ 0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * v0 ^ 0 + v1 ^ S 0) (v0 * v0 ^ 0 + v1 * v1 ^ 0) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ 0)) (v1 ^ S 0) (v1 * v1 ^ 0) v6) ((v0 + v1) ^ S 0) ((v0 + v1) ^ S 0) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) ^ S 0))) (pow_succ_r v1 0 (Private_OrderTac.Tac.le_refl 0)) ((fun v6 : (v0 + v1) ^ S 0 == (v0 + v1) * (v0 + v1) ^ 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ 0 + v1 * v1 ^ 0)) ((v0 + v1) ^ S 0) ((v0 + v1) * (v0 + v1) ^ 0) v6) (pow_succ_r (v0 + v1) 0 (Private_OrderTac.Tac.le_refl 0)) ((fun v6 : v0 ^ 0 == 1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * v0 ^ 0 + v1 * v1 ^ 0) (v0 * 1 + v1 * v1 ^ 0) (add_wd (v0 * v0 ^ 0) (v0 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 ^ 0) 1 v6) (v1 * v1 ^ 0) (v1 * v1 ^ 0) (reflexive_proper_proxy Equivalence_Reflexive (v1 * v1 ^ 0))) ((v0 + v1) * (v0 + v1) ^ 0) ((v0 + v1) * (v0 + v1) ^ 0) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) * (v0 + v1) ^ 0))) (pow_0_r v0) ((fun v6 : v1 ^ 0 == 1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * 1 + v1 * v1 ^ 0) (v0 * 1 + v1 * 1) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 1)) (v1 * v1 ^ 0) (v1 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v1) (v1 ^ 0) 1 v6)) ((v0 + v1) * (v0 + v1) ^ 0) ((v0 + v1) * (v0 + v1) ^ 0) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) * (v0 + v1) ^ 0))) (pow_0_r v1) ((fun v6 : (v0 + v1) ^ 0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * 1 + v1 * 1)) ((v0 + v1) * (v0 + v1) ^ 0) ((v0 + v1) * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) ((v0 + v1) ^ 0) 1 v6)) (pow_0_r (v0 + v1)) ((fun v6 : v0 * 1 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * 1 + v1 * 1) (v0 + v1 * 1) (add_wd (v0 * 1) v0 v6 (v1 * 1) (v1 * 1) (reflexive_proper_proxy Equivalence_Reflexive (v1 * 1))) ((v0 + v1) * 1) ((v0 + v1) * 1) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) * 1))) (mul_1_r v0) ((fun v6 : v1 * 1 == v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 + v1 * 1) (v0 + v1) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v1 * 1) v1 v6) ((v0 + v1) * 1) ((v0 + v1) * 1) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) * 1))) (mul_1_r v1) ((fun v6 : (v0 + v1) * 1 == v0 + v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1)) ((v0 + v1) * 1) (v0 + v1) v6) (mul_1_r (v0 + v1)) (Private_OrderTac.Tac.le_refl (v0 + v1))))))))))) (fun (v6 : @t) (v7 : 0 < v6) (v8 : v0 ^ v6 + v1 ^ v6 <= (v0 + v1) ^ v6) => let v9 : 0 <= v6 := (fun (v9 : 0 < 1) (v10 : 1 < 2) => Private_OrderTac.Tac.not_gt_le ((fun v11 : v6 < 0 => (fun v12 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.lt_trans v7 v11)) : ~ v6 < 0)) (@lt_0_1) (@lt_1_2) in (fun v10 : v0 ^ S v6 == v0 * v0 ^ v6 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 ^ S v6 + v1 ^ S v6) (v0 * v0 ^ v6 + v1 ^ S v6) (add_wd (v0 ^ S v6) (v0 * v0 ^ v6) v10 (v1 ^ S v6) (v1 ^ S v6) (reflexive_proper_proxy Equivalence_Reflexive (v1 ^ S v6))) ((v0 + v1) ^ S v6) ((v0 + v1) ^ S v6) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) ^ S v6))) (pow_succ_r v0 v6 v9) ((fun v10 : v1 ^ S v6 == v1 * v1 ^ v6 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * v0 ^ v6 + v1 ^ S v6) (v0 * v0 ^ v6 + v1 * v1 ^ v6) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v6)) (v1 ^ S v6) (v1 * v1 ^ v6) v10) ((v0 + v1) ^ S v6) ((v0 + v1) ^ S v6) (reflexive_proper_proxy Equivalence_Reflexive ((v0 + v1) ^ S v6))) (pow_succ_r v1 v6 v9) ((fun v10 : (v0 + v1) ^ S v6 == (v0 + v1) * (v0 + v1) ^ v6 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v6 + v1 * v1 ^ v6)) ((v0 + v1) ^ S v6) ((v0 + v1) * (v0 + v1) ^ v6) v10) (pow_succ_r (v0 + v1) v6 v9) (transitivity ((fun v10 : (v0 + v1) * (v0 ^ v6 + v1 ^ v6) == v0 * (v0 ^ v6 + v1 ^ v6) + v1 * (v0 ^ v6 + v1 ^ v6) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v6 + v1 * v1 ^ v6)) ((v0 + v1) * (v0 ^ v6 + v1 ^ v6)) (v0 * (v0 ^ v6 + v1 ^ v6) + v1 * (v0 ^ v6 + v1 ^ v6)) v10) (mul_add_distr_r v0 v1 (v0 ^ v6 + v1 ^ v6)) ((fun v10 : v0 * (v0 ^ v6 + v1 ^ v6) == v0 * v0 ^ v6 + v0 * v1 ^ v6 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v6 + v1 * v1 ^ v6)) (v0 * (v0 ^ v6 + v1 ^ v6) + v1 * (v0 ^ v6 + v1 ^ v6)) (v0 * v0 ^ v6 + v0 * v1 ^ v6 + v1 * (v0 ^ v6 + v1 ^ v6)) (add_wd (v0 * (v0 ^ v6 + v1 ^ v6)) (v0 * v0 ^ v6 + v0 * v1 ^ v6) v10 (v1 * (v0 ^ v6 + v1 ^ v6)) (v1 * (v0 ^ v6 + v1 ^ v6)) (reflexive_proper_proxy Equivalence_Reflexive (v1 * (v0 ^ v6 + v1 ^ v6))))) (mul_add_distr_l v0 (v0 ^ v6) (v1 ^ v6)) ((fun v10 : v1 * (v0 ^ v6 + v1 ^ v6) == v1 * v0 ^ v6 + v1 * v1 ^ v6 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v6 + v1 * v1 ^ v6)) (v0 * v0 ^ v6 + v0 * v1 ^ v6 + v1 * (v0 ^ v6 + v1 ^ v6)) (v0 * v0 ^ v6 + v0 * v1 ^ v6 + (v1 * v0 ^ v6 + v1 * v1 ^ v6)) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v6 + v0 * v1 ^ v6)) (v1 * (v0 ^ v6 + v1 ^ v6)) (v1 * v0 ^ v6 + v1 * v1 ^ v6) v10)) (mul_add_distr_l v1 (v0 ^ v6) (v1 ^ v6)) (add_le_mono (v0 * v0 ^ v6) (v0 * v0 ^ v6 + v0 * v1 ^ v6) (v1 * v1 ^ v6) (v1 * v0 ^ v6 + v1 * v1 ^ v6) ((fun v10 : v0 * v0 ^ v6 + 0 == v0 * v0 ^ v6 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v0 * v0 ^ v6) (v0 * v0 ^ v6 + 0) (symmetry v10) (v0 * v0 ^ v6 + v0 * v1 ^ v6) (v0 * v0 ^ v6 + v0 * v1 ^ v6) (reflexive_proper_proxy Equivalence_Reflexive (v0 * v0 ^ v6 + v0 * v1 ^ v6))) (add_0_r (v0 * v0 ^ v6)) (let v10 : forall (v10 v11 v12 : @t) (v13 : v10 <= v11), v12 + v10 <= v12 + v11 := fun v10 v11 v12 : @t => match add_le_mono_l v10 v11 v12 as v13 in (_ /\ _) return (forall v14 : v10 <= v11, v12 + v10 <= v12 + v11) with | conj v13 v14 => (fun (v13 : forall v13 : v10 <= v11, v12 + v10 <= v12 + v11) (v14 : forall v14 : v12 + v10 <= v12 + v11, v10 <= v11) => v13) v13 v14 end in v10 0 (v0 * v1 ^ v6) (v0 * v0 ^ v6) (mul_nonneg_nonneg v0 (v1 ^ v6) v3 (pow_nonneg v1 v6 v4)))) ((fun v10 : 0 + v1 * v1 ^ v6 == v1 * v1 ^ v6 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (v1 * v1 ^ v6) (0 + v1 * v1 ^ v6) (symmetry v10) (v1 * v0 ^ v6 + v1 * v1 ^ v6) (v1 * v0 ^ v6 + v1 * v1 ^ v6) (reflexive_proper_proxy Equivalence_Reflexive (v1 * v0 ^ v6 + v1 * v1 ^ v6))) (add_0_l (v1 * v1 ^ v6)) (let v10 : forall (v10 v11 v12 : @t) (v13 : v10 <= v11), v10 + v12 <= v11 + v12 := fun v10 v11 v12 : @t => match add_le_mono_r v10 v11 v12 as v13 in (_ /\ _) return (forall v14 : v10 <= v11, v10 + v12 <= v11 + v12) with | conj v13 v14 => (fun (v13 : forall v13 : v10 <= v11, v10 + v12 <= v11 + v12) (v14 : forall v14 : v10 + v12 <= v11 + v12, v10 <= v11) => v13) v13 v14 end in v10 0 (v1 * v0 ^ v6) (v1 * v1 ^ v6) (mul_nonneg_nonneg v1 (v0 ^ v6) v4 (pow_nonneg v0 v6 v3)))))))) (mul_le_mono_nonneg_l (v0 ^ v6 + v1 ^ v6) ((v0 + v1) ^ v6) (v0 + v1) (add_nonneg_nonneg v0 v1 v3 v4) v8))))) v2 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.NatInt.NZPow.NZPowProp.pow_add_upper	100	3.673659	1	1
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.eq_nat_refl	100	0.021261	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => nat_ind (fun v1 : @nat => eq_nat v1 v1) (@I : eq_nat 0 0) (fun (v1 : @nat) (v2 : eq_nat v1 v1) => v2 : eq_nat (S v1) (S v1)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.eq_nat_is_eq	100	0.058579	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => conj (nat_ind (fun v2 : @nat => forall (v3 : @nat) (v4 : eq_nat v2 v3), v2 = v3) (fun v2 : @nat => match v2 as v3 in nat return (forall v4 : eq_nat 0 v3, 0 = v3) with | 0 => (fun v3 : @True => eq_refl) : forall v3 : eq_nat 0 0, 0 = 0 | S v3 => (fun v3 : @nat => (fun v4 : @False => False_ind (0 = S v3) v4) : forall v4 : eq_nat 0 (S v3), 0 = S v3) v3 end) (fun (v2 : @nat) (v3 : forall (v3 : @nat) (v4 : eq_nat v2 v3), v2 = v3) (v4 : @nat) => match v4 as v5 in nat return (forall v6 : eq_nat (S v2) v5, S v2 = v5) with | 0 => (fun v5 : @False => False_ind (S v2 = 0) v5) : forall v5 : eq_nat (S v2) 0, S v2 = 0 | S v5 => (fun v5 : @nat => (fun v6 : eq_nat v2 v5 => f_equal_nat (@nat) (@S) v2 v5 (v3 v5 v6)) : forall v6 : eq_nat (S v2) (S v5), S v2 = S v5) v5 end) v0 v1) (fun v2 : v0 = v1 => eq_ind v0 (fun v3 : @nat => eq_nat v0 v3) (eq_nat_refl v0) v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.eq_eq_nat	100	0.032593	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : v2 = v3), eq_nat v2 v3 := fun v2 v3 : @nat => match eq_nat_is_eq v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 = v3, eq_nat v2 v3) with | conj v4 v5 => (fun (v4 : forall v4 : eq_nat v2 v3, v2 = v3) (v5 : forall v5 : v2 = v3, eq_nat v2 v3) => v5) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.eq_nat_eq	100	0.032331	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : eq_nat v2 v3), v2 = v3 := fun v2 v3 : @nat => match eq_nat_is_eq v2 v3 as v4 in (_ /\ _) return (forall v5 : eq_nat v2 v3, v2 = v3) with | conj v4 v5 => (fun (v4 : forall v4 : eq_nat v2 v3, v2 = v3) (v5 : forall v5 : v2 = v3, eq_nat v2 v3) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.eq_nat_elim	100	0.021481	1	1	0	synth with cache (only 1: refine (fun (v0 : @nat) (v1 : forall v1 : @nat, Prop) (v2 : v1 v0) (v3 : @nat) (v4 : eq_nat v0 v3) => let v5 : v0 = v3 := eq_nat_eq v0 v3 v4 in eq_ind v0 (fun v6 : @nat => v1 v6) v2 v3 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.eq_nat_decide	100	0.047906	1	1	0	synth with cache (only 1: refine (fun v0 : @nat => nat_rec (fun v1 : @nat => forall v2 : @nat, {eq_nat v1 v2} + {~ eq_nat v1 v2}) (fun v1 : @nat => match v1 as v2 in nat return ({eq_nat 0 v2} + {~ eq_nat 0 v2}) with | 0 => left (@I) : {eq_nat 0 0} + {~ eq_nat 0 0} | S v2 => (fun v2 : @nat => right ((fun v3 : @False => v3) : ~ @False) : {eq_nat 0 (S v2)} + {~ eq_nat 0 (S v2)}) v2 end) (fun (v1 : @nat) (v2 : forall v2 : @nat, {eq_nat v1 v2} + {~ eq_nat v1 v2}) (v3 : @nat) => match v3 as v4 in nat return ({eq_nat (S v1) v4} + {~ eq_nat (S v1) v4}) with | 0 => right ((fun v4 : @False => v4) : ~ @False) : {eq_nat (S v1) 0} + {~ eq_nat (S v1) 0} | S v4 => (fun v4 : @nat => v2 v4 : {eq_nat (S v1) (S v4)} + {~ eq_nat (S v1) (S v4)}) v4 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.beq_nat_refl	100	0.018639	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => eq_sym (Nat.eqb_refl v0))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.beq_nat_true	100	0.039931	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : (v2 =? v3) = @true), v2 = v3 := fun v2 v3 : @nat => match Nat.eqb_eq v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 =? v3) = @true, v2 = v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 =? v3) = @true, v2 = v3) (v5 : forall v5 : v2 = v3, (v2 =? v3) = @true) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.beq_nat_false	100	0.041836	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : (v2 =? v3) = @false), v2 <> v3 := fun v2 v3 : @nat => match Nat.eqb_neq v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 =? v3) = @false, v2 <> v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 =? v3) = @false, v2 <> v3) (v5 : forall v5 : v2 <> v3, (v2 =? v3) = @false) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.EqNat.beq_nat_eq	100	0.078631	1	1	0	synth with cache (only 1: refine (fun v0 : @nat => nat_ind (fun v1 : @nat => forall (v2 : @nat) (v3 : @true = (v1 =? v2)), v1 = v2) (fun v1 : @nat => match v1 as v2 in nat return (forall v3 : @true = (0 =? v2), 0 = v2) with | 0 => (fun v2 : @true = @true => eq_refl) : forall v2 : @true = (0 =? 0), 0 = 0 | S v2 => (fun v2 : @nat => (fun v3 : @true = @false => let v4 : @False := eq_ind (@true) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v3 in False_ind (0 = S v2) v4) : forall v3 : @true = (0 =? S v2), 0 = S v2) v2 end) (fun (v1 : @nat) (v2 : forall (v2 : @nat) (v3 : @true = (v1 =? v2)), v1 = v2) (v3 : @nat) => match v3 as v4 in nat return (forall v5 : @true = (S v1 =? v4), S v1 = v4) with | 0 => (fun v4 : @true = @false => let v5 : @False := eq_ind (@true) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v4 in False_ind (S v1 = 0) v5) : forall v4 : @true = (S v1 =? 0), S v1 = 0 | S v4 => (fun v4 : @nat => (fun v5 : @true = (v1 =? v4) => match v2 v4 v5 as v7 in (_ = v6) return (S v1 = S v6) with | eq_refl => eq_refl end) : forall v5 : @true = (S v1 =? S v4), S v1 = S v4) v4 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.zerop	100	0.041225	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => match v0 as v1 in nat return ({v1 = 0} + {0 < v1}) with | 0 => left eq_refl | S v1 => (fun v1 : @nat => right (gt_le_S 0 (S v1) (Nat.lt_0_succ v1 : S v1 > 0) : 0 < S v1)) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.lt_eq_lt_dec	100	0.132242	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_rec (fun v2 : @nat => forall v3 : @nat, {v2 < v3} + {v2 = v3} + {v3 < v2}) (fun v2 : @nat => match v2 as v3 in nat return ({0 < v3} + {0 = v3} + {v3 < 0}) with | 0 => inleft (right eq_refl) | S v3 => (fun v3 : @nat => inleft (left (gt_le_S 0 (S v3) (gt_Sn_O v3) : 0 < S v3))) v3 end) (fun (v2 : @nat) (v3 : forall v3 : @nat, {v2 < v3} + {v2 = v3} + {v3 < v2}) (v4 : @nat) => match v4 as v5 in nat return ({S v2 < v5} + {S v2 = v5} + {v5 < S v2}) with | 0 => inright (gt_le_S 0 (S v2) (Nat.lt_0_succ v2 : S v2 > 0) : 0 < S v2) | S v5 => (fun v5 : @nat => let v6 : {v2 < v5} + {v2 = v5} + {v5 < v2} := v3 v5 in match v6 as v7 in (_ + {_}) return ({S v2 < S v5} + {S v2 = S v5} + {S v5 < S v2}) with | inleft v7 => (fun v7 : {v2 < v5} + {v2 = v5} => match v7 as v8 in ({_} + {_}) return ({S v2 < S v5} + {S v2 = S v5} + {S v5 < S v2}) with | left v8 => (fun v8 : v2 < v5 => inleft (left (le_n_S (S v2) v5 v8 : S v2 < S v5))) v8 | right v8 => (fun v8 : v2 = v5 => inleft (right (f_equal_nat (@nat) (@S) v2 v5 v8))) v8 end) v7 | inright v7 => (fun v7 : v5 < v2 => inright (gt_le_S (S v5) (S v2) (le_lt_n_Sm (S v5) v2 v7 : S v2 > S v5) : S v5 < S v2)) v7 end) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.gt_eq_gt_dec	100	0.028613	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => lt_eq_lt_dec v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.le_lt_dec	100	0.062065	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_rec (fun v2 : @nat => forall v3 : @nat, {v2 <= v3} + {v3 < v2}) (fun v2 : @nat => left (Nat.le_0_l v2)) (fun (v2 : @nat) (v3 : forall v3 : @nat, {v2 <= v3} + {v3 < v2}) (v4 : @nat) => match v4 as v5 in nat return ({S v2 <= v5} + {v5 < S v2}) with | 0 => right (gt_le_S 0 (S v2) ((lt_le_S 0 (S v2) (Nat.lt_0_succ v2) : 0 < S v2) : S v2 > 0) : 0 < S v2) | S v5 => (fun v5 : @nat => sumbool_rec (fun v6 : {v2 <= v5} + {v5 < v2} => {S v2 <= S v5} + {S v5 < S v2}) (fun v6 : v2 <= v5 => left (gt_le_S v2 (S v5) ((le_n_S v2 v5 v6 : v2 < S v5) : S v5 > v2))) (fun v6 : v5 < v2 => right (gt_le_S (S v5) (S v2) (lt_n_S v5 v2 v6 : S v2 > S v5) : S v5 < S v2)) (v3 v5)) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.le_le_S_dec	100	0.023097	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => le_lt_dec v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.le_ge_dec	100	0.033940	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => sumbool_rec (fun v2 : {v0 <= v1} + {v1 < v0} => {v0 <= v1} + {v0 >= v1}) (fun v2 : v0 <= v1 => left v2) (fun v2 : v1 < v0 => right (Nat.lt_le_incl v1 v0 v2 : v0 >= v1)) (le_lt_dec v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.le_gt_dec	100	0.023714	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => le_lt_dec v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.le_lt_eq_dec	100	0.043718	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @nat) (v2 : v0 <= v1) => let v3 : {v0 < v1} + {v0 = v1} + {v1 < v0} := lt_eq_lt_dec v0 v1 in match v3 as v4 in (_ + {_}) return ({v0 < v1} + {v0 = v1}) with | inleft v4 => (fun v4 : {v0 < v1} + {v0 = v1} => v4) v4 | inright v4 => (fun v4 : v1 < v0 => False_rec ({v0 < v1} + {v0 = v1}) (le_not_lt v0 v1 v2 v4)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.le_dec	100	0.039089	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : {v0 <= v1} + {v0 > v1} := le_gt_dec v0 v1 in match v2 as v3 in ({_} + {_}) return ({v0 <= v1} + {~ v0 <= v1}) with | left v3 => (fun v3 : v0 <= v1 => left v3) v3 | right v3 => (fun v3 : v0 > v1 => right (gt_not_le v0 v1 v3)) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.lt_dec	100	0.026470	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => le_dec (S v0) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.gt_dec	100	0.030415	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => lt_dec v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.ge_dec	100	0.025919	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => le_dec v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.dec_le	100	0.023841	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => Nat.le_decidable v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.dec_lt	100	0.022355	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => Nat.lt_decidable v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.dec_gt	100	0.022665	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => Nat.lt_decidable v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.dec_ge	100	0.037030	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => Nat.le_decidable v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.not_eq	100	0.065157	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : v2 <> v3), v2 < v3 \/ v3 < v2 := fun v2 v3 : @nat => match Nat.lt_gt_cases v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 <> v3, v2 < v3 \/ v3 < v2) with | conj v4 v5 => (fun (v4 : forall v4 : v2 <> v3, v2 < v3 \/ v3 < v2) (v5 : forall v5 : v2 < v3 \/ v3 < v2, v2 <> v3) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.not_le	100	0.039527	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : ~ v2 <= v3), v3 < v2 := fun v2 v3 : @nat => match Nat.nle_gt v2 v3 as v4 in (_ /\ _) return (forall v5 : ~ v2 <= v3, v3 < v2) with | conj v4 v5 => (fun (v4 : forall v4 : ~ v2 <= v3, v3 < v2) (v5 : forall v5 : v3 < v2, ~ v2 <= v3) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.not_gt	100	0.038595	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : ~ v2 < v3), v3 <= v2 := fun v2 v3 : @nat => match Nat.nlt_ge v2 v3 as v4 in (_ /\ _) return (forall v5 : ~ v2 < v3, v3 <= v2) with | conj v4 v5 => (fun (v4 : forall v4 : ~ v2 < v3, v3 <= v2) (v5 : forall v5 : v3 <= v2, ~ v2 < v3) => v4) v4 v5 end in v2 v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.not_ge	100	0.040035	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : ~ v2 <= v3), v3 < v2 := fun v2 v3 : @nat => match Nat.nle_gt v2 v3 as v4 in (_ /\ _) return (forall v5 : ~ v2 <= v3, v3 < v2) with | conj v4 v5 => (fun (v4 : forall v4 : ~ v2 <= v3, v3 < v2) (v5 : forall v5 : v3 < v2, ~ v2 <= v3) => v4) v4 v5 end in v2 v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.not_lt	100	0.041738	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : ~ v2 < v3), v3 <= v2 := fun v2 v3 : @nat => match Nat.nlt_ge v2 v3 as v4 in (_ /\ _) return (forall v5 : ~ v2 < v3, v3 <= v2) with | conj v4 v5 => (fun (v4 : forall v4 : ~ v2 < v3, v3 <= v2) (v5 : forall v5 : v3 <= v2, ~ v2 < v3) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_lt	100	0.034057	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => RelationClasses.symmetry (Nat.compare_lt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_gt	100	0.033675	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => RelationClasses.symmetry (Nat.compare_gt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_le	100	0.035302	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => RelationClasses.symmetry (Nat.compare_le_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_ge	100	0.040506	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => RelationClasses.symmetry (Nat.compare_ge_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_eq	100	0.057492	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : (v2 ?= v3) = @Eq), v2 = v3 := fun v2 v3 : @nat => match Nat.compare_eq_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Eq, v2 = v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Eq, v2 = v3) (v5 : forall v5 : v2 = v3, (v2 ?= v3) = @Eq) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_Lt_lt	100	0.045191	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : (v2 ?= v3) = @Lt), v2 < v3 := fun v2 v3 : @nat => match Nat.compare_lt_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Lt, v2 < v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Lt, v2 < v3) (v5 : forall v5 : v2 < v3, (v2 ?= v3) = @Lt) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_Gt_gt	100	0.047583	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : (v2 ?= v3) = @Gt), v3 < v2 := fun v2 v3 : @nat => match Nat.compare_gt_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Gt, v3 < v2) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Gt, v3 < v2) (v5 : forall v5 : v3 < v2, (v2 ?= v3) = @Gt) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.nat_compare_equiv	100	0.124640	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => (let v2 : {v0 < v1} + {v0 = v1} + {v1 < v0} := lt_eq_lt_dec v0 v1 in match v2 as v3 in (_ + {_}) return ((v0 ?= v1) = match v3 as v4 in (_ + {_}) return (@comparison) with | inleft v4 => (fun v4 : {v0 < v1} + {v0 = v1} => match v4 as v5 in ({_} + {_}) return (@comparison) with | left v5 => (fun v5 : v0 < v1 => @Lt) v5 | right v5 => (fun v5 : v0 = v1 => @Eq) v5 end) v4 | inright v4 => (fun v4 : v1 < v0 => @Gt) v4 end) with | inleft v3 => (fun v3 : {v0 < v1} + {v0 = v1} => match v3 as v4 in ({_} + {_}) return ((v0 ?= v1) = match v4 as v5 in ({_} + {_}) return (@comparison) with | left v5 => (fun v5 : v0 < v1 => @Lt) v5 | right v5 => (fun v5 : v0 = v1 => @Eq) v5 end) with | left v4 => (fun v4 : v0 < v1 => let v5 : forall (v5 v6 : @nat) (v7 : v5 < v6), (v5 ?= v6) = @Lt := fun v5 v6 : @nat => match Nat.compare_lt_iff v5 v6 as v7 in (_ /\ _) return (forall v8 : v5 < v6, (v5 ?= v6) = @Lt) with | conj v7 v8 => (fun (v7 : forall v7 : (v5 ?= v6) = @Lt, v5 < v6) (v8 : forall v8 : v5 < v6, (v5 ?= v6) = @Lt) => v8) v7 v8 end in v5 v0 v1 v4) v4 | right v4 => (fun v4 : v0 = v1 => let v5 : forall (v5 v6 : @nat) (v7 : v5 = v6), (v5 ?= v6) = @Eq := fun v5 v6 : @nat => match Nat.compare_eq_iff v5 v6 as v7 in (_ /\ _) return (forall v8 : v5 = v6, (v5 ?= v6) = @Eq) with | conj v7 v8 => (fun (v7 : forall v7 : (v5 ?= v6) = @Eq, v5 = v6) (v8 : forall v8 : v5 = v6, (v5 ?= v6) = @Eq) => v8) v7 v8 end in v5 v0 v1 v4) v4 end) v3 | inright v3 => (fun v3 : v1 < v0 => let v4 : forall (v4 v5 : @nat) (v6 : v5 < v4), (v4 ?= v5) = @Gt := fun v4 v5 : @nat => match Nat.compare_gt_iff v4 v5 as v6 in (_ /\ _) return (forall v7 : v5 < v4, (v4 ?= v5) = @Gt) with | conj v6 v7 => (fun (v6 : forall v6 : (v4 ?= v5) = @Gt, v5 < v4) (v7 : forall v7 : v5 < v4, (v4 ?= v5) = @Gt) => v7) v6 v7 end in v4 v0 v1 v3) v3 end) : (v0 ?= v1) = nat_compare_alt v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.leb_iff_conv	100	0.034682	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => (fun v2 : (v1 <=? v0) = @false <-> ~ v1 <= v0 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) ((v1 <=? v0) = @false) (~ v1 <= v0) v2 (v0 < v1) (v0 < v1) (Morphisms.eq_proper_proxy (v0 < v1))) (Nat.leb_nle v1 v0) (Nat.nle_gt v1 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.leb_correct	100	0.042470	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : v2 <= v3), (v2 <=? v3) = @true := fun v2 v3 : @nat => match Nat.leb_le v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 <= v3, (v2 <=? v3) = @true) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 <=? v3) = @true, v2 <= v3) (v5 : forall v5 : v2 <= v3, (v2 <=? v3) = @true) => v5) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.leb_complete	100	0.041026	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : (v2 <=? v3) = @true), v2 <= v3 := fun v2 v3 : @nat => match Nat.leb_le v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 <=? v3) = @true, v2 <= v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 <=? v3) = @true, v2 <= v3) (v5 : forall v5 : v2 <= v3, (v2 <=? v3) = @true) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.leb_correct_conv	100	0.043706	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : v2 < v3), (v3 <=? v2) = @false := fun v2 v3 : @nat => match leb_iff_conv v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3, (v3 <=? v2) = @false) with | conj v4 v5 => (fun (v4 : forall v4 : (v3 <=? v2) = @false, v2 < v3) (v5 : forall v5 : v2 < v3, (v3 <=? v2) = @false) => v5) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.leb_complete_conv	100	0.043200	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall (v2 v3 : @nat) (v4 : (v3 <=? v2) = @false), v2 < v3 := fun v2 v3 : @nat => match leb_iff_conv v2 v3 as v4 in (_ /\ _) return (forall v5 : (v3 <=? v2) = @false, v2 < v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v3 <=? v2) = @false, v2 < v3) (v5 : forall v5 : v2 < v3, (v3 <=? v2) = @false) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.Compare_dec.leb_compare	100	0.042570	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => (fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) ((v0 ?= v1) <> @Gt) (v0 <= v1) v2) (Nat.compare_le_iff v0 v1) (Nat.leb_le v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.eta	100	0.057945	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : @nat) (v2 : t v0 (S v1)) => caseS (fun (v3 : @nat) (v4 : t v0 (S v3)) => v4 = hd v4 :: tl v4) (fun (v3 : v0) (v4 : @nat) (v5 : t v0 v4) => eq_refl) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.eq_nth_iff	100	0.584146	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : @nat) (v2 v3 : t v0 v1) => conj (rect2 (fun (v4 : @nat) (v5 v6 : t v0 v4) => forall v7 : forall (v7 v8 : Fin.t v4) (v9 : v7 = v8), v5[@v7] = v6[@v8], v5 = v6) (((fun v4 : forall (v4 v5 : Fin.t 0) (v6 : v4 = v5), match v4 as v8 in (Fin.t v7) return (forall v9 : t v0 v7, v0) with | @Fin.F1 v7 => (fun v7 : @nat => caseS (fun (v8 : @nat) (v9 : t v0 (S v8)) => v0) (fun (v8 : v0) (v9 : @nat) (v10 : t v0 v9) => v8)) v7 | @Fin.FS v7 v8 => (fun (v7 : @nat) (v8 : Fin.t v7) (v9 : t v0 (S v7)) => caseS (fun (v10 : @nat) (v11 : t v0 (S v10)) => forall v12 : Fin.t v10, v0) (fun (v10 : v0) (v11 : @nat) (v12 : t v0 v11) (v13 : Fin.t v11) => v12[@v13]) v9 v8) v7 v8 end [] = match v5 as v8 in (Fin.t v7) return (forall v9 : t v0 v7, v0) with | @Fin.F1 v7 => (fun v7 : @nat => caseS (fun (v8 : @nat) (v9 : t v0 (S v8)) => v0) (fun (v8 : v0) (v9 : @nat) (v10 : t v0 v9) => v8)) v7 | @Fin.FS v7 v8 => (fun (v7 : @nat) (v8 : Fin.t v7) (v9 : t v0 (S v7)) => caseS (fun (v10 : @nat) (v11 : t v0 (S v10)) => forall v12 : Fin.t v10, v0) (fun (v10 : v0) (v11 : @nat) (v12 : t v0 v11) (v13 : Fin.t v11) => v12[@v13]) v9 v8) v7 v8 end [] => eq_refl) : forall v4 : forall (v4 v5 : Fin.t 0) (v6 : v4 = v5), [][@v4] = [][@v5], [] = []) : (fun (v4 : @nat) (v5 v6 : t v0 v4) => forall v7 : forall (v7 v8 : Fin.t v4) (v9 : v7 = v8), v5[@v7] = v6[@v8], v5 = v6) 0 [] []) (((fun (v4 : @nat) (v5 v6 : t v0 v4) (v7 : forall v7 : forall (v7 v8 : Fin.t v4) (v9 : v7 = v8), v5[@v7] = v6[@v8], v5 = v6) (v8 v9 : v0) (v10 : forall (v10 v11 : Fin.t (S v4)) (v12 : v10 = v11), match v10 as v14 in (Fin.t v13) return (forall v15 : t v0 v13, v0) with | @Fin.F1 v13 => (fun v13 : @nat => caseS (fun (v14 : @nat) (v15 : t v0 (S v14)) => v0) (fun (v14 : v0) (v15 : @nat) (v16 : t v0 v15) => v14)) v13 | @Fin.FS v13 v14 => (fun (v13 : @nat) (v14 : Fin.t v13) (v15 : t v0 (S v13)) => caseS (fun (v16 : @nat) (v17 : t v0 (S v16)) => forall v18 : Fin.t v16, v0) (fun (v16 : v0) (v17 : @nat) (v18 : t v0 v17) (v19 : Fin.t v17) => v18[@v19]) v15 v14) v13 v14 end (v8 :: v5) = match v11 as v14 in (Fin.t v13) return (forall v15 : t v0 v13, v0) with | @Fin.F1 v13 => (fun v13 : @nat => caseS (fun (v14 : @nat) (v15 : t v0 (S v14)) => v0) (fun (v14 : v0) (v15 : @nat) (v16 : t v0 v15) => v14)) v13 | @Fin.FS v13 v14 => (fun (v13 : @nat) (v14 : Fin.t v13) (v15 : t v0 (S v13)) => caseS (fun (v16 : @nat) (v17 : t v0 (S v16)) => forall v18 : Fin.t v16, v0) (fun (v16 : v0) (v17 : @nat) (v18 : t v0 v17) (v19 : Fin.t v17) => v18[@v19]) v15 v14) v13 v14 end (v9 :: v6)) => let v11 : v5 = v6 := v7 (fun (v11 v12 : Fin.t v4) (v13 : v11 = v12) => v10 (Fin.FS v11) (Fin.FS v12) (f_equal Fin.FS v13)) in (let v12 : v4 = v4 := eq_refl in (let v13 : v8 = v9 := v10 Fin.F1 Fin.F1 eq_refl in (let v14 : v0 = v0 := eq_refl in (fun (v15 : v0 = v0) (v16 : v8 = v9) (v17 : v4 = v4) (v18 : v5 = v6) => eq_trans (f_equal (fun v19 : forall v19 : t v0 v4, t v0 (S v4) => v19 v5) (eq_trans (f_equal (fun v19 : forall (v19 : @nat) (v20 : t v0 v19), t v0 (S v19) => v19 v4) (eq_trans (f_equal (fun v19 : forall (v19 : v0) (v20 : @nat) (v21 : t v0 v20), t v0 (S v20) => v19 v8) eq_refl) (f_equal (cons v0) v16))) eq_refl)) (f_equal (cons v0 v9 v4) v18)) v14) v13) v12) v11) : forall (v4 : @nat) (v5 v6 : t v0 v4) (v7 : forall v7 : forall (v7 v8 : Fin.t v4) (v9 : v7 = v8), v5[@v7] = v6[@v8], v5 = v6) (v8 v9 : v0) (v10 : forall (v10 v11 : Fin.t (S v4)) (v12 : v10 = v11), (v8 :: v5)[@v10] = (v9 :: v6)[@v11]), v8 :: v5 = v9 :: v6) : forall (v4 : @nat) (v5 v6 : t v0 v4) (v7 : (fun (v7 : @nat) (v8 v9 : t v0 v7) => forall v10 : forall (v10 v11 : Fin.t v7) (v12 : v10 = v11), v8[@v10] = v9[@v11], v8 = v9) v4 v5 v6) (v8 v9 : v0), (fun (v10 : @nat) (v11 v12 : t v0 v10) => forall v13 : forall (v13 v14 : Fin.t v10) (v15 : v13 = v14), v11[@v13] = v12[@v14], v11 = v12) (S v4) (v8 :: v5) (v9 :: v6)) v2 v3) (fun (v4 : v2 = v3) (v5 v6 : Fin.t v1) (v7 : v5 = v6) => let v8 : v5 = v6 := v7 in (let v9 : v2 = v3 := v4 in (let v10 : v1 = v1 := eq_refl in (let v11 : v0 = v0 := eq_refl in (fun (v12 : v0 = v0) (v13 : v1 = v1) (v14 : v2 = v3) (v15 : v5 = v6) => eq_trans (f_equal (fun v16 : forall v16 : Fin.t v1, v0 => v16 v5) (eq_trans (f_equal (fun v16 : forall (v16 : t v0 v1) (v17 : Fin.t v1), v0 => v16 v2) eq_refl) (f_equal nth v14))) (f_equal (nth v3) v15)) v11) v10) v9) v8))).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.nth_order_last	100	0.090552	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : Type => @rectS v0 (fun (v1 : @nat) (v2 : t v0 (S v1)) => forall v3 : v1 < S v1, v2[@Fin.of_nat_lt v3] = last v2) (((fun (v1 : v0) (v2 : 0 < 1) => eq_refl) : forall (v1 : v0) (v2 : 0 < 1), [v1][@Fin.of_nat_lt v2] = last [v1]) : forall v1 : v0, (fun (v2 : @nat) (v3 : t v0 (S v2)) => forall v4 : v2 < S v2, v3[@Fin.of_nat_lt v4] = last v3) 0 [v1]) (((fun (v1 : v0) (v2 : @nat) (v3 : t v0 (S v2)) (v4 : forall v4 : v2 < S v2, v3[@Fin.of_nat_lt v4] = last v3) (v5 : S v2 < S (S v2)) => v4 (Lt.lt_S_n v2 (S v2) v5)) : forall (v1 : v0) (v2 : @nat) (v3 : t v0 (S v2)) (v4 : forall v4 : v2 < S v2, v3[@Fin.of_nat_lt v4] = last v3) (v5 : S v2 < S (S v2)), (v1 :: v3)[@Fin.of_nat_lt v5] = last (v1 :: v3)) : forall (v1 : v0) (v2 : @nat) (v3 : t v0 (S v2)) (v4 : (fun (v4 : @nat) (v5 : t v0 (S v4)) => forall v6 : v4 < S v4, v5[@Fin.of_nat_lt v6] = last v5) v2 v3), (fun (v5 : @nat) (v6 : t v0 (S v5)) => forall v7 : v5 < S v5, v6[@Fin.of_nat_lt v7] = last v6) (S v2) (v1 :: v3)) : forall (v1 : @nat) (v2 : t v0 (S v1)) (v3 : v1 < S v1), nth_order v2 v3 = last v2)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.shiftin_nth	100	0.129290	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : @nat) (v3 : t v0 v2) (v4 v5 : Fin.t v2) (v6 : v4 = v5) => eq_ind v4 (fun v7 : Fin.t v2 => (shiftin v1 v3)[@Fin.L_R 1 v4] = v3[@v7]) (Fin.t_ind (fun (v7 : @nat) (v8 : Fin.t v7) => forall v9 : t v0 v7, (shiftin v1 v9)[@Fin.L_R 1 v8] = v9[@v8]) (fun (v7 : @nat) (v8 : t v0 (S v7)) => caseS (fun (v9 : @nat) (v10 : t v0 (S v9)) => (shiftin v1 v10)[@Fin.L_R 1 Fin.F1] = v10[@Fin.F1]) (fun (v9 : v0) (v10 : @nat) (v11 : t v0 v10) => eq_refl : (shiftin v1 (v9 :: v11))[@Fin.L_R 1 Fin.F1] = (v9 :: v11)[@Fin.F1]) v8) (fun (v7 : @nat) (v8 : Fin.t v7) (v9 : forall v9 : t v0 v7, (shiftin v1 v9)[@Fin.L_R 1 v8] = v9[@v8]) (v10 : t v0 (S v7)) => caseS (fun (v11 : @nat) (v12 : t v0 (S v11)) => forall (v13 : Fin.t v11) (v14 : forall v14 : t v0 v11, (shiftin v1 v14)[@Fin.L_R 1 v13] = v14[@v13]), (shiftin v1 v12)[@Fin.L_R 1 (Fin.FS v13)] = v12[@Fin.FS v13]) ((fun (v11 : v0) (v12 : @nat) (v13 : t v0 v12) (v14 : Fin.t v12) (v15 : forall v15 : t v0 v12, (shiftin v1 v15)[@Fin.L_R 1 v14] = v15[@v14]) => v15 v13 : (shiftin v1 (v11 :: v13))[@Fin.L_R 1 (Fin.FS v14)] = (v11 :: v13)[@Fin.FS v14]) : forall (v11 : v0) (v12 : @nat) (v13 : t v0 v12), (fun (v14 : @nat) (v15 : t v0 (S v14)) => forall (v16 : Fin.t v14) (v17 : forall v17 : t v0 v14, (shiftin v1 v17)[@Fin.L_R 1 v16] = v17[@v16]), (shiftin v1 v15)[@Fin.L_R 1 (Fin.FS v16)] = v15[@Fin.FS v16]) v12 (v11 :: v13)) v10 v8 v9) v2 v4 v3) v5 v6)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.shiftin_last	100	0.043530	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : @nat) (v3 : t v0 v2) => t_ind v0 (fun (v4 : @nat) (v5 : t v0 v4) => last (shiftin v1 v5) = v1) (eq_refl : last (shiftin v1 []) = v1) (fun (v4 : v0) (v5 : @nat) (v6 : t v0 v5) (v7 : last (shiftin v1 v6) = v1) => v7 : last (shiftin v1 (v4 :: v6)) = v1) v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.shiftrepeat_nth	100	0.261655	1	2
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.shiftrepeat_last	100	0.088636	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : Type => @rectS v0 (fun (v1 : @nat) (v2 : t v0 (S v1)) => last (shiftrepeat v2) = last v2) (((fun v1 : v0 => eq_refl) : forall v1 : v0, last (shiftrepeat [v1]) = last [v1]) : forall v1 : v0, (fun (v2 : @nat) (v3 : t v0 (S v2)) => last (shiftrepeat v3) = last v3) 0 [v1]) (((fun (v1 : v0) (v2 : @nat) (v3 : t v0 (S v2)) (v4 : last (shiftrepeat v3) = last v3) => v4) : forall (v1 : v0) (v2 : @nat) (v3 : t v0 (S v2)) (v4 : last (shiftrepeat v3) = last v3), last (shiftrepeat (v1 :: v3)) = last (v1 :: v3)) : forall (v1 : v0) (v2 : @nat) (v3 : t v0 (S v2)) (v4 : (fun (v4 : @nat) (v5 : t v0 (S v4)) => last (shiftrepeat v5) = last v5) v2 v3), (fun (v5 : @nat) (v6 : t v0 (S v5)) => last (shiftrepeat v6) = last v6) (S v2) (v1 :: v3)))).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.const_nth	100	0.038160	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : @nat) (v3 : Fin.t v2) => Fin.t_ind (fun (v4 : @nat) (v5 : Fin.t v4) => (const v1 v4)[@v5] = v1) (fun v4 : @nat => eq_refl) (fun (v4 : @nat) (v5 : Fin.t v4) (v6 : (const v1 v4)[@v5] = v1) => v6) v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.nth_map	100	0.139813	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, v1) (v3 : @nat) (v4 : t v0 v3) (v5 v6 : Fin.t v3) (v7 : v5 = v6) => eq_ind v5 (fun v8 : Fin.t v3 => (map v2 v4)[@v5] = v2 v4[@v8]) (Fin.t_ind (fun (v8 : @nat) (v9 : Fin.t v8) => forall v10 : t v0 v8, (map v2 v10)[@v9] = v2 v10[@v9]) (fun (v8 : @nat) (v9 : t v0 (S v8)) => caseS (fun (v10 : @nat) (v11 : t v0 (S v10)) => (map v2 v11)[@Fin.F1] = v2 v11[@Fin.F1]) (((fun (v10 : v0) (v11 : @nat) (v12 : t v0 v11) => eq_refl) : forall (v10 : v0) (v11 : @nat) (v12 : t v0 v11), (map v2 (v10 :: v12))[@Fin.F1] = v2 (v10 :: v12)[@Fin.F1]) : forall (v10 : v0) (v11 : @nat) (v12 : t v0 v11), (fun (v13 : @nat) (v14 : t v0 (S v13)) => (map v2 v14)[@Fin.F1] = v2 v14[@Fin.F1]) v11 (v10 :: v12)) v9) (fun (v8 : @nat) (v9 : Fin.t v8) (v10 : forall v10 : t v0 v8, (map v2 v10)[@v9] = v2 v10[@v9]) (v11 : t v0 (S v8)) => caseS (fun (v12 : @nat) (v13 : t v0 (S v12)) => forall (v14 : Fin.t v12) (v15 : forall v15 : t v0 v12, (map v2 v15)[@v14] = v2 v15[@v14]), (map v2 v13)[@Fin.FS v14] = v2 v13[@Fin.FS v14]) (((fun (v12 : v0) (v13 : @nat) (v14 : t v0 v13) (v15 : Fin.t v13) (v16 : forall v16 : t v0 v13, (map v2 v16)[@v15] = v2 v16[@v15]) => v16 v14) : forall (v12 : v0) (v13 : @nat) (v14 : t v0 v13) (v15 : Fin.t v13) (v16 : forall v16 : t v0 v13, (map v2 v16)[@v15] = v2 v16[@v15]), (map v2 (v12 :: v14))[@Fin.FS v15] = v2 (v12 :: v14)[@Fin.FS v15]) : forall (v12 : v0) (v13 : @nat) (v14 : t v0 v13), (fun (v15 : @nat) (v16 : t v0 (S v15)) => forall (v17 : Fin.t v15) (v18 : forall v18 : t v0 v15, (map v2 v18)[@v17] = v2 v18[@v17]), (map v2 v16)[@Fin.FS v17] = v2 v16[@Fin.FS v17]) v13 (v12 :: v14)) v11 v9 v10) v3 v5 v4) v6 v7)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.nth_map2	100	0.570198	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : Type) (v3 : forall (v3 : v0) (v4 : v1), v2) (v4 : @nat) (v5 : t v0 v4) (v6 : t v1 v4) (v7 v8 v9 : Fin.t v4) (v10 : v7 = v8) (v11 : v8 = v9) => eq_ind v7 (fun v12 : Fin.t v4 => forall v13 : v12 = v9, (map2 v3 v5 v6)[@v7] = v3 v5[@v12] v6[@v9]) (fun v12 : v7 = v9 => eq_ind v7 (fun v13 : Fin.t v4 => (map2 v3 v5 v6)[@v7] = v3 v5[@v7] v6[@v13]) (rect2 (fun (v13 : @nat) (v14 : t v0 v13) (v15 : t v1 v13) => forall v16 : Fin.t v13, (map2 v3 v14 v15)[@v16] = v3 v14[@v16] v15[@v16]) ((Fin.case0 (fun v13 : Fin.t 0 => match v13 as v15 in (Fin.t v14) return (forall v16 : t v2 v14, v2) with | @Fin.F1 v14 => (fun v14 : @nat => caseS (fun (v15 : @nat) (v16 : t v2 (S v15)) => v2) (fun (v15 : v2) (v16 : @nat) (v17 : t v2 v16) => v15)) v14 | @Fin.FS v14 v15 => (fun (v14 : @nat) (v15 : Fin.t v14) (v16 : t v2 (S v14)) => caseS (fun (v17 : @nat) (v18 : t v2 (S v17)) => forall v19 : Fin.t v17, v2) (fun (v17 : v2) (v18 : @nat) (v19 : t v2 v18) (v20 : Fin.t v18) => v19[@v20]) v16 v15) v14 v15 end [] = v3 (match v13 as v15 in (Fin.t v14) return (forall v16 : t v0 v14, v0) with | @Fin.F1 v14 => (fun v14 : @nat => caseS (fun (v15 : @nat) (v16 : t v0 (S v15)) => v0) (fun (v15 : v0) (v16 : @nat) (v17 : t v0 v16) => v15)) v14 | @Fin.FS v14 v15 => (fun (v14 : @nat) (v15 : Fin.t v14) (v16 : t v0 (S v14)) => caseS (fun (v17 : @nat) (v18 : t v0 (S v17)) => forall v19 : Fin.t v17, v0) (fun (v17 : v0) (v18 : @nat) (v19 : t v0 v18) (v20 : Fin.t v18) => v19[@v20]) v16 v15) v14 v15 end []) (match v13 as v15 in (Fin.t v14) return (forall v16 : t v1 v14, v1) with | @Fin.F1 v14 => (fun v14 : @nat => caseS (fun (v15 : @nat) (v16 : t v1 (S v15)) => v1) (fun (v15 : v1) (v16 : @nat) (v17 : t v1 v16) => v15)) v14 | @Fin.FS v14 v15 => (fun (v14 : @nat) (v15 : Fin.t v14) (v16 : t v1 (S v14)) => caseS (fun (v17 : @nat) (v18 : t v1 (S v17)) => forall v19 : Fin.t v17, v1) (fun (v17 : v1) (v18 : @nat) (v19 : t v1 v18) (v20 : Fin.t v18) => v19[@v20]) v16 v15) v14 v15 end [])) : forall v13 : Fin.t 0, (map2 v3 [] [])[@v13] = v3 [][@v13] [][@v13]) : (fun (v13 : @nat) (v14 : t v0 v13) (v15 : t v1 v13) => forall v16 : Fin.t v13, (map2 v3 v14 v15)[@v16] = v3 v14[@v16] v15[@v16]) 0 [] []) (((fun (v13 : @nat) (v14 : t v0 v13) (v15 : t v1 v13) (v16 : forall v16 : Fin.t v13, (map2 v3 v14 v15)[@v16] = v3 v14[@v16] v15[@v16]) (v17 : v0) (v18 : v1) (v19 : Fin.t (S v13)) => Fin.caseS (fun (v20 : @nat) (v21 : Fin.t (S v20)) => forall (v22 : t v0 v20) (v23 : t v1 v20) (v24 : forall v24 : Fin.t v20, (map2 v3 v22 v23)[@v24] = v3 v22[@v24] v23[@v24]), match v21 as v26 in (Fin.t v25) return (forall v27 : t v2 v25, v2) with | @Fin.F1 v25 => (fun v25 : @nat => caseS (fun (v26 : @nat) (v27 : t v2 (S v26)) => v2) (fun (v26 : v2) (v27 : @nat) (v28 : t v2 v27) => v26)) v25 | @Fin.FS v25 v26 => (fun (v25 : @nat) (v26 : Fin.t v25) (v27 : t v2 (S v25)) => caseS (fun (v28 : @nat) (v29 : t v2 (S v28)) => forall v30 : Fin.t v28, v2) (fun (v28 : v2) (v29 : @nat) (v30 : t v2 v29) (v31 : Fin.t v29) => v30[@v31]) v27 v26) v25 v26 end (v3 v17 v18 :: map2 v3 v22 v23) = v3 (match v21 as v26 in (Fin.t v25) return (forall v27 : t v0 v25, v0) with | @Fin.F1 v25 => (fun v25 : @nat => caseS (fun (v26 : @nat) (v27 : t v0 (S v26)) => v0) (fun (v26 : v0) (v27 : @nat) (v28 : t v0 v27) => v26)) v25 | @Fin.FS v25 v26 => (fun (v25 : @nat) (v26 : Fin.t v25) (v27 : t v0 (S v25)) => caseS (fun (v28 : @nat) (v29 : t v0 (S v28)) => forall v30 : Fin.t v28, v0) (fun (v28 : v0) (v29 : @nat) (v30 : t v0 v29) (v31 : Fin.t v29) => v30[@v31]) v27 v26) v25 v26 end (v17 :: v22)) (match v21 as v26 in (Fin.t v25) return (forall v27 : t v1 v25, v1) with | @Fin.F1 v25 => (fun v25 : @nat => caseS (fun (v26 : @nat) (v27 : t v1 (S v26)) => v1) (fun (v26 : v1) (v27 : @nat) (v28 : t v1 v27) => v26)) v25 | @Fin.FS v25 v26 => (fun (v25 : @nat) (v26 : Fin.t v25) (v27 : t v1 (S v25)) => caseS (fun (v28 : @nat) (v29 : t v1 (S v28)) => forall v30 : Fin.t v28, v1) (fun (v28 : v1) (v29 : @nat) (v30 : t v1 v29) (v31 : Fin.t v29) => v30[@v31]) v27 v26) v25 v26 end (v18 :: v23))) (((fun (v20 : @nat) (v21 : t v0 v20) (v22 : t v1 v20) (v23 : forall v23 : Fin.t v20, (map2 v3 v21 v22)[@v23] = v3 v21[@v23] v22[@v23]) => eq_refl) : forall (v20 : @nat) (v21 : t v0 v20) (v22 : t v1 v20) (v23 : forall v23 : Fin.t v20, (map2 v3 v21 v22)[@v23] = v3 v21[@v23] v22[@v23]), caseS (fun (v24 : @nat) (v25 : t v2 (S v24)) => v2) (fun (v24 : v2) (v25 : @nat) (v26 : t v2 v25) => v24) (v3 v17 v18 :: map2 v3 v21 v22) = v3 (caseS (fun (v24 : @nat) (v25 : t v0 (S v24)) => v0) (fun (v24 : v0) (v25 : @nat) (v26 : t v0 v25) => v24) (v17 :: v21)) (caseS (fun (v24 : @nat) (v25 : t v1 (S v24)) => v1) (fun (v24 : v1) (v25 : @nat) (v26 : t v1 v25) => v24) (v18 :: v22))) : forall v20 : @nat, (fun (v21 : @nat) (v22 : Fin.t (S v21)) => forall (v23 : t v0 v21) (v24 : t v1 v21) (v25 : forall v25 : Fin.t v21, (map2 v3 v23 v24)[@v25] = v3 v23[@v25] v24[@v25]), match v22 as v27 in (Fin.t v26) return (forall v28 : t v2 v26, v2) with | @Fin.F1 v26 => (fun v26 : @nat => caseS (fun (v27 : @nat) (v28 : t v2 (S v27)) => v2) (fun (v27 : v2) (v28 : @nat) (v29 : t v2 v28) => v27)) v26 | @Fin.FS v26 v27 => (fun (v26 : @nat) (v27 : Fin.t v26) (v28 : t v2 (S v26)) => caseS (fun (v29 : @nat) (v30 : t v2 (S v29)) => forall v31 : Fin.t v29, v2) (fun (v29 : v2) (v30 : @nat) (v31 : t v2 v30) (v32 : Fin.t v30) => v31[@v32]) v28 v27) v26 v27 end (v3 v17 v18 :: map2 v3 v23 v24) = v3 (match v22 as v27 in (Fin.t v26) return (forall v28 : t v0 v26, v0) with | @Fin.F1 v26 => (fun v26 : @nat => caseS (fun (v27 : @nat) (v28 : t v0 (S v27)) => v0) (fun (v27 : v0) (v28 : @nat) (v29 : t v0 v28) => v27)) v26 | @Fin.FS v26 v27 => (fun (v26 : @nat) (v27 : Fin.t v26) (v28 : t v0 (S v26)) => caseS (fun (v29 : @nat) (v30 : t v0 (S v29)) => forall v31 : Fin.t v29, v0) (fun (v29 : v0) (v30 : @nat) (v31 : t v0 v30) (v32 : Fin.t v30) => v31[@v32]) v28 v27) v26 v27 end (v17 :: v23)) (match v22 as v27 in (Fin.t v26) return (forall v28 : t v1 v26, v1) with | @Fin.F1 v26 => (fun v26 : @nat => caseS (fun (v27 : @nat) (v28 : t v1 (S v27)) => v1) (fun (v27 : v1) (v28 : @nat) (v29 : t v1 v28) => v27)) v26 | @Fin.FS v26 v27 => (fun (v26 : @nat) (v27 : Fin.t v26) (v28 : t v1 (S v26)) => caseS (fun (v29 : @nat) (v30 : t v1 (S v29)) => forall v31 : Fin.t v29, v1) (fun (v29 : v1) (v30 : @nat) (v31 : t v1 v30) (v32 : Fin.t v30) => v31[@v32]) v28 v27) v26 v27 end (v18 :: v24))) v20 Fin.F1) (((fun (v20 : @nat) (v21 : Fin.t v20) (v22 : t v0 v20) (v23 : t v1 v20) (v24 : forall v24 : Fin.t v20, (map2 v3 v22 v23)[@v24] = v3 v22[@v24] v23[@v24]) => v24 v21) : forall (v20 : @nat) (v21 : Fin.t v20) (v22 : t v0 v20) (v23 : t v1 v20) (v24 : forall v24 : Fin.t v20, (map2 v3 v22 v23)[@v24] = v3 v22[@v24] v23[@v24]), caseS (fun (v25 : @nat) (v26 : t v2 (S v25)) => forall v27 : Fin.t v25, v2) (fun (v25 : v2) (v26 : @nat) (v27 : t v2 v26) (v28 : Fin.t v26) => v27[@v28]) (v3 v17 v18 :: map2 v3 v22 v23) v21 = v3 (caseS (fun (v25 : @nat) (v26 : t v0 (S v25)) => forall v27 : Fin.t v25, v0) (fun (v25 : v0) (v26 : @nat) (v27 : t v0 v26) (v28 : Fin.t v26) => v27[@v28]) (v17 :: v22) v21) (caseS (fun (v25 : @nat) (v26 : t v1 (S v25)) => forall v27 : Fin.t v25, v1) (fun (v25 : v1) (v26 : @nat) (v27 : t v1 v26) (v28 : Fin.t v26) => v27[@v28]) (v18 :: v23) v21)) : forall (v20 : @nat) (v21 : Fin.t v20), (fun (v22 : @nat) (v23 : Fin.t (S v22)) => forall (v24 : t v0 v22) (v25 : t v1 v22) (v26 : forall v26 : Fin.t v22, (map2 v3 v24 v25)[@v26] = v3 v24[@v26] v25[@v26]), match v23 as v28 in (Fin.t v27) return (forall v29 : t v2 v27, v2) with | @Fin.F1 v27 => (fun v27 : @nat => caseS (fun (v28 : @nat) (v29 : t v2 (S v28)) => v2) (fun (v28 : v2) (v29 : @nat) (v30 : t v2 v29) => v28)) v27 | @Fin.FS v27 v28 => (fun (v27 : @nat) (v28 : Fin.t v27) (v29 : t v2 (S v27)) => caseS (fun (v30 : @nat) (v31 : t v2 (S v30)) => forall v32 : Fin.t v30, v2) (fun (v30 : v2) (v31 : @nat) (v32 : t v2 v31) (v33 : Fin.t v31) => v32[@v33]) v29 v28) v27 v28 end (v3 v17 v18 :: map2 v3 v24 v25) = v3 (match v23 as v28 in (Fin.t v27) return (forall v29 : t v0 v27, v0) with | @Fin.F1 v27 => (fun v27 : @nat => caseS (fun (v28 : @nat) (v29 : t v0 (S v28)) => v0) (fun (v28 : v0) (v29 : @nat) (v30 : t v0 v29) => v28)) v27 | @Fin.FS v27 v28 => (fun (v27 : @nat) (v28 : Fin.t v27) (v29 : t v0 (S v27)) => caseS (fun (v30 : @nat) (v31 : t v0 (S v30)) => forall v32 : Fin.t v30, v0) (fun (v30 : v0) (v31 : @nat) (v32 : t v0 v31) (v33 : Fin.t v31) => v32[@v33]) v29 v28) v27 v28 end (v17 :: v24)) (match v23 as v28 in (Fin.t v27) return (forall v29 : t v1 v27, v1) with | @Fin.F1 v27 => (fun v27 : @nat => caseS (fun (v28 : @nat) (v29 : t v1 (S v28)) => v1) (fun (v28 : v1) (v29 : @nat) (v30 : t v1 v29) => v28)) v27 | @Fin.FS v27 v28 => (fun (v27 : @nat) (v28 : Fin.t v27) (v29 : t v1 (S v27)) => caseS (fun (v30 : @nat) (v31 : t v1 (S v30)) => forall v32 : Fin.t v30, v1) (fun (v30 : v1) (v31 : @nat) (v32 : t v1 v31) (v33 : Fin.t v31) => v32[@v33]) v29 v28) v27 v28 end (v18 :: v25))) v20 (Fin.FS v21)) v19 v14 v15 v16) : forall (v13 : @nat) (v14 : t v0 v13) (v15 : t v1 v13) (v16 : forall v16 : Fin.t v13, (map2 v3 v14 v15)[@v16] = v3 v14[@v16] v15[@v16]) (v17 : v0) (v18 : v1) (v19 : Fin.t (S v13)), (map2 v3 (v17 :: v14) (v18 :: v15))[@v19] = v3 (v17 :: v14)[@v19] (v18 :: v15)[@v19]) : forall (v13 : @nat) (v14 : t v0 v13) (v15 : t v1 v13) (v16 : (fun (v16 : @nat) (v17 : t v0 v16) (v18 : t v1 v16) => forall v19 : Fin.t v16, (map2 v3 v17 v18)[@v19] = v3 v17[@v19] v18[@v19]) v13 v14 v15) (v17 : v0) (v18 : v1), (fun (v19 : @nat) (v20 : t v0 v19) (v21 : t v1 v19) => forall v22 : Fin.t v19, (map2 v3 v20 v21)[@v22] = v3 v20[@v22] v21[@v22]) (S v13) (v17 :: v14) (v18 :: v15)) v5 v6 v7) v9 v12) v8 v10 v11)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.fold_left_right_assoc_eq	100	0.147996	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall (v2 : v0) (v3 : v1), v0) (v3 : forall (v3 : v0) (v4 v5 : v1), v2 (v2 v3 v4) v5 = v2 (v2 v3 v5) v4) (v4 : @nat) (v5 : t v1 v4) => let v6 : forall (v6 : @nat) (v7 : v1) (v8 : t v1 v6) (v9 : v0), fold_left v2 (v2 v9 v7) v8 = v2 (fold_left v2 v9 v8) v7 := fun (v6 : @nat) (v7 : v1) (v8 : t v1 v6) => t_ind v1 (fun (v9 : @nat) (v10 : t v1 v9) => forall v11 : v0, fold_left v2 (v2 v11 v7) v10 = v2 (fold_left v2 v11 v10) v7) ((fun v9 : v0 => eq_refl) : forall v9 : v0, fold_left v2 (v2 v9 v7) [] = v2 (fold_left v2 v9 []) v7) (fun (v9 : v1) (v10 : @nat) (v11 : t v1 v10) (v12 : forall v12 : v0, fold_left v2 (v2 v12 v7) v11 = v2 (fold_left v2 v12 v11) v7) (v13 : v0) => eq_ind (fold_left v2 (v2 (v2 v13 v9) v7) v11) (fun v14 : v0 => fold_left v2 (v2 (v2 v13 v7) v9) v11 = v14) (eq_ind_r (fun v14 : v0 => fold_left v2 v14 v11 = fold_left v2 (v2 (v2 v13 v9) v7) v11) (let v14 : v11 = v11 := eq_refl in (let v15 : v10 = v10 := eq_refl in (let v16 : v2 (v2 v13 v9) v7 = v2 (v2 v13 v9) v7 := eq_refl in (let v17 : v2 = v2 := eq_refl in (let v18 : v0 = v0 := eq_refl in (let v19 : v1 = v1 := eq_refl in (fun (v20 : v1 = v1) (v21 : v0 = v0) (v22 : v2 = v2) (v23 : v2 (v2 v13 v9) v7 = v2 (v2 v13 v9) v7) (v24 : v10 = v10) (v25 : v11 = v11) => eq_refl) v19) v18) v17) v16) v15) v14) (v3 v13 v7 v9)) (v2 (fold_left v2 (v2 v13 v9) v11) v7) (v12 (v2 v13 v9)) : fold_left v2 (v2 v13 v7) (v9 :: v11) = v2 (fold_left v2 v13 (v9 :: v11)) v7) v6 v8 in t_ind v1 (fun (v7 : @nat) (v8 : t v1 v7) => forall v9 : v0, fold_left v2 v9 v8 = fold_right (fun (v10 : v1) (v11 : v0) => v2 v11 v10) v8 v9) (fun v7 : v0 => eq_refl) (fun (v7 : v1) (v8 : @nat) (v9 : t v1 v8) (v10 : forall v10 : v0, fold_left v2 v10 v9 = fold_right (fun (v11 : v1) (v12 : v0) => v2 v12 v11) v9 v10) => (fun v11 : v0 => eq_ind (fold_left v2 v11 v9) (fun v12 : v0 => fold_left v2 (v2 v11 v7) v9 = v2 v12 v7) (v6 v8 v7 v9 v11) (fold_right (fun (v12 : v1) (v13 : v0) => v2 v13 v12) v9 v11) (v10 v11)) : forall v11 : v0, fold_left v2 v11 (v7 :: v9) = fold_right (fun (v12 : v1) (v13 : v0) => v2 v13 v12) (v7 :: v9) v11) v4 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.to_list_of_list_opp	100	0.125994	1	2
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.take_O	100	0.035888	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : @nat) (v2 : 0 <= v1) (v3 : t v0 v1) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.take_idem	100	0.152100	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : @nat) => nat_ind (fun v2 : @nat => forall (v3 : @nat) (v4 : t v0 v3) (v5 : v2 <= v3) (v6 : v2 <= v2), take v2 v6 (take v2 v5 v4) = take v2 v5 v4) (fun (v2 : @nat) (v3 : t v0 v2) (v4 : 0 <= v2) (v5 : 0 <= 0) => eq_refl) (fun (v2 : @nat) (v3 : forall (v3 : @nat) (v4 : t v0 v3) (v5 : v2 <= v3) (v6 : v2 <= v2), take v2 v6 (take v2 v5 v4) = take v2 v5 v4) (v4 : @nat) (v5 : t v0 v4) (v6 : S v2 <= v4) (v7 : S v2 <= S v2) => match v5 as v9 in (t _ v8) return (forall v10 : S v2 <= v8, take (S v2) v7 (take (S v2) v10 v9) = take (S v2) v10 v9) with | [] => fun v8 : S v2 <= 0 => let v9 : forall v9 : 0 = 0, take (S v2) v7 (take (S v2) v8 []) = take (S v2) v8 [] := match v8 as v10 in (_ <= v9) return (forall v11 : v9 = 0, take (S v2) v7 (take (S v2) v8 []) = take (S v2) v8 []) with | le_n _ => fun v9 : S v2 = 0 => (fun v10 : S v2 = 0 => let v11 : @False := eq_ind (S v2) (fun v11 : @nat => match v11 as v12 in nat return Prop with | 0 => @False | S v12 => (fun v12 : @nat => @True) v12 end) (@I) 0 v10 in False_ind (take (S v2) v7 (take (S v2) v8 []) = take (S v2) v8 []) v11) v9 | le_S _ v9 v10 => (fun (v9 : @nat) (v10 : S v2 <= v9) (v11 : S v9 = 0) => (fun v12 : S v9 = 0 => let v13 : @False := eq_ind (S v9) (fun v13 : @nat => match v13 as v14 in nat return Prop with | 0 => @False | S v14 => (fun v14 : @nat => @True) v14 end) (@I) 0 v12 in False_ind (forall v14 : S v2 <= v9, take (S v2) v7 (take (S v2) v8 []) = take (S v2) v8 []) v13) v11 v10) v9 v10 end in v9 eq_refl | cons _ v8 v9 v10 => (fun (v8 : v0) (v9 : @nat) (v10 : t v0 v9) (v11 : S v2 <= S v9) => f_equal (cons v0 v8 v2) (v3 v9 v10 (Le.le_S_n v2 v9 v11) (Le.le_S_n v2 v2 v7)) : take (S v2) v7 (take (S v2) v11 (v8 :: v10)) = take (S v2) v11 (v8 :: v10)) v8 v9 v10 end v6) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.take_app	100	0.086848	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : @nat) (v2 : t v0 v1) => t_ind v0 (fun (v3 : @nat) (v4 : t v0 v3) => forall (v5 : @nat) (v6 : t v0 v5) (v7 : v3 <= v3 + v5), take v3 v7 (v4 ++ v6) = v4) (fun (v3 : @nat) (v4 : t v0 v3) (v5 : 0 <= 0 + v3) => eq_refl) (fun (v3 : v0) (v4 : @nat) (v5 : t v0 v4) (v6 : forall (v6 : @nat) (v7 : t v0 v6) (v8 : v4 <= v4 + v6), take v4 v8 (v5 ++ v7) = v5) (v7 : @nat) (v8 : t v0 v7) (v9 : S v4 <= S v4 + v7) => f_equal (cons v0 v3 v4) (v6 v7 v8 (Le.le_S_n v4 (v4 + v7) v9)) : take (S v4) v9 ((v3 :: v5) ++ v8) = v3 :: v5) v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.take_prf_irr	100	0.151920	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : @nat) => nat_ind (fun v2 : @nat => forall (v3 : @nat) (v4 : t v0 v3) (v5 v6 : v2 <= v3), take v2 v5 v4 = take v2 v6 v4) (fun (v2 : @nat) (v3 : t v0 v2) (v4 v5 : 0 <= v2) => eq_refl) (fun (v2 : @nat) (v3 : forall (v3 : @nat) (v4 : t v0 v3) (v5 v6 : v2 <= v3), take v2 v5 v4 = take v2 v6 v4) (v4 : @nat) (v5 : t v0 v4) (v6 v7 : S v2 <= v4) => match v5 as v9 in (t _ v8) return (forall v10 v11 : S v2 <= v8, take (S v2) v10 v9 = take (S v2) v11 v9) with | [] => fun v8 v9 : S v2 <= 0 => let v10 : forall v10 : 0 = 0, take (S v2) v8 [] = take (S v2) v9 [] := match v8 as v11 in (_ <= v10) return (forall v12 : v10 = 0, take (S v2) v8 [] = take (S v2) v9 []) with | le_n _ => fun v10 : S v2 = 0 => (fun v11 : S v2 = 0 => let v12 : @False := eq_ind (S v2) (fun v12 : @nat => match v12 as v13 in nat return Prop with | 0 => @False | S v13 => (fun v13 : @nat => @True) v13 end) (@I) 0 v11 in False_ind (take (S v2) v8 [] = take (S v2) v9 []) v12) v10 | le_S _ v10 v11 => (fun (v10 : @nat) (v11 : S v2 <= v10) (v12 : S v10 = 0) => (fun v13 : S v10 = 0 => let v14 : @False := eq_ind (S v10) (fun v14 : @nat => match v14 as v15 in nat return Prop with | 0 => @False | S v15 => (fun v15 : @nat => @True) v15 end) (@I) 0 v13 in False_ind (forall v15 : S v2 <= v10, take (S v2) v8 [] = take (S v2) v9 []) v14) v12 v11) v10 v11 end in v10 eq_refl | cons _ v8 v9 v10 => (fun (v8 : v0) (v9 : @nat) (v10 : t v0 v9) (v11 v12 : S v2 <= S v9) => f_equal (cons v0 v8 v2) (v3 v9 v10 (Le.le_S_n v2 v9 v11) (Le.le_S_n v2 v9 v12)) : take (S v2) v11 (v8 :: v10) = take (S v2) v12 (v8 :: v10)) v8 v9 v10 end v6 v7) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.uncons_cons	100	0.040426	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : @nat) (v2 : v0) (v3 : t v0 v1) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.append_comm_cons	100	0.057813	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 v2 : @nat) (v3 : t v0 v1) (v4 : t v0 v2) (v5 : v0) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.splitat_append	100	0.157622	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 v2 : @nat) (v3 : t v0 v1) => t_ind v0 (fun (v4 : @nat) (v5 : t v0 v4) => forall (v6 : @nat) (v7 : t v0 v6), splitat v4 (v5 ++ v7) = (v5, v7)) (fun (v4 : @nat) (v5 : t v0 v4) => eq_refl : splitat 0 ([] ++ v5) = ([], v5)) (fun (v4 : v0) (v5 : @nat) (v6 : t v0 v5) (v7 : forall (v7 : @nat) (v8 : t v0 v7), splitat v5 (v6 ++ v8) = (v6, v8)) (v8 : @nat) (v9 : t v0 v8) => eq_ind_r (fun v10 : t v0 v5 * t v0 v8 => match v10 as v11 in (_ * _)%type return (t v0 (S v5) * t v0 v8) with | (v11, v12) => (fun (v11 : t v0 v5) (v12 : t v0 v8) => (v4 :: v11, v12)) v11 v12 end = (v4 :: v6, v9)) (eq_refl : (v4 :: v6, v9) = (v4 :: v6, v9)) (v7 v8 v9) : splitat (S v5) ((v4 :: v6) ++ v9) = (v4 :: v6, v9)) v1 v3 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Vectors.VectorSpec.append_splitat	100	1.014274	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.In_eq	100	0.039881	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@O.t)) (v1 v2 : @O.t) (v3 : v1 = v2) (v4 : InA (@O.eq) v1 v0) => eq_ind v1 (fun v5 : @O.t => InA (@O.eq) v5 v0) v4 v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.ListIn_In	100	0.025838	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.Inf_lt	100	0.030742	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.Inf_eq	100	0.032070	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.Sort_Inf_In	100	0.036705	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.ListIn_Inf	100	0.026901	1	1	0	synth with cache (only 1: refine (In_InfA (ltA:=@O.lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.In_Inf	100	0.032120	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.Inf_alt	100	0.039411	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.OrderedTypeLists.Sort_NoDup	100	0.025710	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.ltk_compat	100	0.063631	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : Type => (RelCompFun_compat (@O.lt) fst (@O.lt_compat) : Proper (@O.eq @@1 ==> @O.eq @@1 ==> @iff) ltk) : Proper (eqk ==> eqk ==> @iff) ltk)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.ltk_compat'	100	0.071822	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : Type => subrelation_proper ltk_compat (@tt) (subrelation_respectful eqke_eqk (subrelation_respectful eqke_eqk (subrelation_refl (@iff)))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.pair_compat	100	0.041767	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : Type => pair_compat (@O.eq) eq)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.ltk_not_eqk	100	0.015697	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.ltk_not_eqke	100	0.014547	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Inf_eq	100	0.022571	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Inf_lt	100	0.020743	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Sort_Inf_In	100	0.024478	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Sort_Inf_NotIn	100	0.020044	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Sort_NoDupA	100	0.041749	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Sort_In_cons_1	100	0.024668	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Sort_In_cons_2	100	0.029321	2	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersLists.KeyOrderedType.Elt.Sort_In_cons_3	100	0.022834	2	2
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.empty_1	100	0.091826	1	1	0	synth with cache (only 1: refine (((fun (v0 : @key) (v1 : @elt) => (fun v2 : PX.MapsTo v0 v1 nil => let v3 : forall v3 : nil = nil, @False := match v2 as v4 in (InA _ _ v3) return (forall v5 : v3 = nil, @False) with | @InA_cons_hd _ _ _ v3 v4 v5 => (fun (v3 : @X.t * @elt) (v4 : list (@X.t * @elt)) (v5 : PX.eqke (v0, v1) v3) (v6 : v3 :: v4 = nil) => (fun v7 : v3 :: v4 = nil => let v8 : @False := eq_ind (v3 :: v4) (fun v8 : list (@X.t * @elt) => match v8 as v9 in (list _) return Prop with | nil => @False | v9 :: v10 => (fun (v9 : @X.t * @elt) (v10 : list (@X.t * @elt)) => @True) v9 v10 end) (@I) nil v7 in False_ind (forall v9 : PX.eqke (v0, v1) v3, @False) v8) v6 v5) v3 v4 v5 | @InA_cons_tl _ _ _ v3 v4 v5 => (fun (v3 : @X.t * @elt) (v4 : list (@X.t * @elt)) (v5 : InA (PX.eqke (elt:=@elt)) (v0, v1) v4) (v6 : v3 :: v4 = nil) => (fun v7 : v3 :: v4 = nil => let v8 : @False := eq_ind (v3 :: v4) (fun v8 : list (@X.t * @elt) => match v8 as v9 in (list _) return Prop with | nil => @False | v9 :: v10 => (fun (v9 : @X.t * @elt) (v10 : list (@X.t * @elt)) => @True) v9 v10 end) (@I) nil v7 in False_ind (forall v9 : InA (PX.eqke (elt:=@elt)) (v0, v1) v4, @False) v8) v6 v5) v3 v4 v5 end in v3 eq_refl) : ~ PX.MapsTo v0 v1 nil) : forall (v0 : @key) (v1 : @elt), ~ PX.MapsTo v0 v1 (@empty)) : Empty (@empty))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.empty_sorted	100	0.027173	1	1	0	synth with cache (only 1: refine (Sorted_nil (PX.ltk (elt:=@elt)) : Sorted (PX.ltk (elt:=@elt)) (@empty))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.is_empty_1	100	0.072345	1	1	0	synth with cache (only 1: refine (((fun v0 : list (@X.t * @elt) => match v0 as v1 in (list _) return (forall v2 : forall (v2 : @key) (v3 : @elt), ~ InA (PX.eqke (elt:=@elt)) (v2, v3) v1, is_empty v1 = @true) with | nil => fun v1 : forall (v1 : @key) (v2 : @elt), ~ InA (PX.eqke (elt:=@elt)) (v1, v2) nil => eq_refl | v1 :: v2 => (fun v1 : @X.t * @elt => match v1 as v2 in (_ * _)%type return (forall (v3 : list (@X.t * @elt)) (v4 : forall (v4 : @key) (v5 : @elt), ~ InA (PX.eqke (elt:=@elt)) (v4, v5) (v2 :: v3)), is_empty (v2 :: v3) = @true) with | (v2, v3) => (fun (v2 : @X.t) (v3 : @elt) (v4 : list (@X.t * @elt)) (v5 : forall (v5 : @key) (v6 : @elt), ~ InA (PX.eqke (elt:=@elt)) (v5, v6) ((v2, v3) :: v4)) => False_ind (is_empty ((v2, v3) :: v4) = @true) (v5 v2 v3 (InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v2, v3)) (y:=(v2, v3)) v4 (eqke_refl (v2, v3))))) v2 v3 end) v1 v2 end) : forall (v0 : list (@X.t * @elt)) (v1 : forall (v1 : @key) (v2 : @elt), ~ PX.MapsTo v1 v2 v0), is_empty v0 = @true) : forall (v0 : list (@X.t * @elt)) (v1 : Empty v0), is_empty v0 = @true)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.is_empty_2	100	0.068900	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => match v0 as v1 in (list _) return (forall v2 : is_empty v1 = @true, Empty v1) with | nil => fun v1 : is_empty nil = @true => @empty_1 | v1 :: v2 => (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : is_empty (v1 :: v2) = @true) => let v4 : forall v4 : @true = @true, Empty (v1 :: v2) := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, Empty (v1 :: v2)) with | eq_refl => fun v4 : is_empty (v1 :: v2) = @true => (fun v5 : is_empty (v1 :: v2) = @true => let v6 : @False := eq_ind (is_empty (v1 :: v2)) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (Empty (v1 :: v2)) v6) v4 end in v4 eq_refl) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.mem_1	100	0.330455	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (PX.ltk (elt:=@elt)) v0) (v2 : @X.t) => (let v3 : @bool := mem v2 v0 in mem_ind (P:=fun (v4 : list (@X.t * @elt)) (v5 : @bool) => forall (v6 : Sorted (PX.ltk (elt:=@elt)) v4) (v7 : PX.In v2 v4), v5 = @true) (fun (v4 : t (@elt)) (v5 : v4 = nil) => (fun (v6 : Sorted (PX.ltk (elt:=@elt)) nil) (v7 : PX.In v2 nil) => let v8 : @false = @true := match v7 as v8 in (ex _) return (@false = @true) with | ex_intro _ v8 v9 => (fun (v8 : @elt) (v9 : PX.MapsTo v2 v8 nil) => (fun v10 : PX.MapsTo v2 v8 nil => let v11 : forall v11 : nil = nil, @false = @true := match v10 as v12 in (InA _ _ v11) return (forall v13 : v11 = nil, @false = @true) with | @InA_cons_hd _ _ _ v11 v12 v13 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) (v13 : PX.eqke (v2, v8) v11) (v14 : v11 :: v12 = nil) => (fun v15 : v11 :: v12 = nil => let v16 : @False := eq_ind (v11 :: v12) (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return Prop with | nil => @False | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => @True) v17 v18 end) (@I) nil v15 in False_ind (forall v17 : PX.eqke (v2, v8) v11, @false = @true) v16) v14 v13) v11 v12 v13 | @InA_cons_tl _ _ _ v11 v12 v13 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) (v13 : InA (PX.eqke (elt:=@elt)) (v2, v8) v12) (v14 : v11 :: v12 = nil) => (fun v15 : v11 :: v12 = nil => let v16 : @False := eq_ind (v11 :: v12) (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return Prop with | nil => @False | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => @True) v17 v18 end) (@I) nil v15 in False_ind (forall v17 : InA (PX.eqke (elt:=@elt)) (v2, v8) v12, @false = @true) v16) v14 v13) v11 v12 v13 end in v11 eq_refl) v9) v8 v9 end in v8) : forall (v6 : Sorted (PX.ltk (elt:=@elt)) nil) (v7 : PX.In v2 nil), @false = @true) (fun (v4 : t (@elt)) (v5 : @X.t) (v6 : @elt) (v7 : list (@X.t * @elt)) (v8 : v4 = (v5, v6) :: v7) (v9 : X.lt v2 v5) (v10 : X.compare v2 v5 = LT v9) => (fun (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : PX.In v2 ((v5, v6) :: v7)) => False_ind (@false = @true) (Sort_Inf_NotIn v11 (HdRel_cons (PX.ltk (elt:=@elt)) (v2, v6) (v5, v6) v7 v9) v12)) : forall (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : PX.In v2 ((v5, v6) :: v7)), @false = @true) (fun (v4 : t (@elt)) (v5 : @X.t) (v6 : @elt) (v7 : list (@X.t * @elt)) (v8 : v4 = (v5, v6) :: v7) (v9 : X.eq v2 v5) (v10 : X.compare v2 v5 = EQ v9) => (fun (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : PX.In v2 ((v5, v6) :: v7)) => eq_refl) : forall (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : PX.In v2 ((v5, v6) :: v7)), @true = @true) (fun (v4 : t (@elt)) (v5 : @X.t) (v6 : @elt) (v7 : list (@X.t * @elt)) (v8 : v4 = (v5, v6) :: v7) (v9 : X.lt v5 v2) (v10 : X.compare v2 v5 = GT v9) (v11 : forall (v11 : Sorted (PX.ltk (elt:=@elt)) v7) (v12 : PX.In v2 v7), mem v2 v7 = @true) => (fun (v12 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v13 : PX.In v2 ((v5, v6) :: v7)) => v11 (and_ind (fun (v14 : Sorted (PX.ltk (elt:=@elt)) v7) (v15 : HdRel (PX.ltk (elt:=@elt)) (v5, v6) v7) => v14) (Sorted_inv v12)) (or_ind (fun v14 : X.eq v2 v5 => False_ind (PX.In v2 v7) (MO.gt_not_eq v9 v14)) (fun v14 : PX.In v2 v7 => v14) (In_inv (k:=v2) (k':=v5) (e:=v6) (l:=v7) v13))) : forall (v12 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v13 : PX.In v2 ((v5, v6) :: v7)), mem v2 v7 = @true) v0 : forall (v4 : Sorted (PX.ltk (elt:=@elt)) v0) (v5 : PX.In v2 v0), v3 = @true) v1)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.mem_2	100	0.411693	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (PX.ltk (elt:=@elt)) v0) (v2 : @key) => (((let v3 : @bool := mem v2 v0 in mem_ind (P:=fun (v4 : list (@X.t * @elt)) (v5 : @bool) => forall (v6 : Sorted (PX.ltk (elt:=@elt)) v4) (v7 : v5 = @true), exists v8 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v8) v4) (fun (v4 : t (@elt)) (v5 : v4 = nil) => (fun (v6 : Sorted (PX.ltk (elt:=@elt)) nil) (v7 : @false = @true) => let v8 : forall v8 : @true = @true, exists v9 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v9) nil := match v7 as v9 in (_ = v8) return (forall v10 : v8 = @true, exists v11 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v11) nil) with | eq_refl => fun v8 : @false = @true => (fun v9 : @false = @true => let v10 : @False := eq_ind (@false) (fun v10 : @bool => match v10 as v11 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v9 in False_ind (exists v11 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v11) nil) v10) v8 end in v8 eq_refl) : forall (v6 : Sorted (PX.ltk (elt:=@elt)) nil) (v7 : @false = @true), exists v8 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v8) nil) (fun (v4 : t (@elt)) (v5 : @X.t) (v6 : @elt) (v7 : list (@X.t * @elt)) (v8 : v4 = (v5, v6) :: v7) (v9 : X.lt v2 v5) (v10 : X.compare v2 v5 = LT v9) => (fun (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : @false = @true) => let v13 : forall v13 : @true = @true, exists v14 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v14) ((v5, v6) :: v7) := match v12 as v14 in (_ = v13) return (forall v15 : v13 = @true, exists v16 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v16) ((v5, v6) :: v7)) with | eq_refl => fun v13 : @false = @true => (fun v14 : @false = @true => let v15 : @False := eq_ind (@false) (fun v15 : @bool => match v15 as v16 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v14 in False_ind (exists v16 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v16) ((v5, v6) :: v7)) v15) v13 end in v13 eq_refl) : forall (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : @false = @true), exists v13 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v13) ((v5, v6) :: v7)) (fun (v4 : t (@elt)) (v5 : @X.t) (v6 : @elt) (v7 : list (@X.t * @elt)) (v8 : v4 = (v5, v6) :: v7) (v9 : X.eq v2 v5) (v10 : X.compare v2 v5 = EQ v9) => (fun (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : @true = @true) => ex_intro (fun v13 : @elt => InA (PX.eqke (elt:=@elt)) (v2, v13) ((v5, v6) :: v7)) v6 (InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v2, v6)) (y:=(v5, v6)) v7 (conj v9 eq_refl))) : forall (v11 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v12 : @true = @true), exists v13 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v13) ((v5, v6) :: v7)) (fun (v4 : t (@elt)) (v5 : @X.t) (v6 : @elt) (v7 : list (@X.t * @elt)) (v8 : v4 = (v5, v6) :: v7) (v9 : X.lt v5 v2) (v10 : X.compare v2 v5 = GT v9) (v11 : forall (v11 : Sorted (PX.ltk (elt:=@elt)) v7) (v12 : mem v2 v7 = @true), exists v13 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v13) v7) => (fun (v12 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v13 : mem v2 v7 = @true) => let v14 : exists v14 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v14) v7 := v11 (let v14 : forall v14 : (v5, v6) :: v7 = (v5, v6) :: v7, Sorted (PX.ltk (elt:=@elt)) v7 := match v12 as v15 in (Sorted _ v14) return (forall v16 : v14 = (v5, v6) :: v7, Sorted (PX.ltk (elt:=@elt)) v7) with | Sorted_nil _ => fun v14 : nil = (v5, v6) :: v7 => (fun v15 : nil = (v5, v6) :: v7 => let v16 : @False := eq_ind nil (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return Prop with | nil => @True | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => @False) v17 v18 end) (@I) ((v5, v6) :: v7) v15 in False_ind (Sorted (PX.ltk (elt:=@elt)) v7) v16) v14 | @Sorted_cons _ _ v14 v15 v16 v17 => (fun (v14 : @X.t * @elt) (v15 : list (@X.t * @elt)) (v16 : Sorted (PX.ltk (elt:=@elt)) v15) (v17 : HdRel (PX.ltk (elt:=@elt)) v14 v15) (v18 : v14 :: v15 = (v5, v6) :: v7) => (fun v19 : v14 :: v15 = (v5, v6) :: v7 => let v20 : v15 = v7 := f_equal (fun v20 : list (@X.t * @elt) => match v20 as v21 in (list _) return (list (@X.t * @elt)) with | nil => v15 | v21 :: v22 => (fun (v21 : @X.t * @elt) (v22 : list (@X.t * @elt)) => v22) v21 v22 end) v19 in (let v21 : v14 = (v5, v6) := f_equal (fun v21 : list (@X.t * @elt) => match v21 as v22 in (list _) return (@X.t * @elt) with | nil => v14 | v22 :: v23 => (fun (v22 : @X.t * @elt) (v23 : list (@X.t * @elt)) => v22) v22 v23 end) v19 in (fun v22 : v14 = (v5, v6) => let v23 : v14 = (v5, v6) := v22 in eq_ind_r (fun v24 : @X.t * @elt => forall (v25 : v15 = v7) (v26 : Sorted (PX.ltk (elt:=@elt)) v15) (v27 : HdRel (PX.ltk (elt:=@elt)) v24 v15), Sorted (PX.ltk (elt:=@elt)) v7) (fun v24 : v15 = v7 => let v25 : v15 = v7 := v24 in eq_ind_r (fun v26 : list (@X.t * @elt) => forall (v27 : Sorted (PX.ltk (elt:=@elt)) v26) (v28 : HdRel (PX.ltk (elt:=@elt)) (v5, v6) v26), Sorted (PX.ltk (elt:=@elt)) v7) (fun (v26 : Sorted (PX.ltk (elt:=@elt)) v7) (v27 : HdRel (PX.ltk (elt:=@elt)) (v5, v6) v7) => v26) v25) v23) v21) v20) v18 v16 v17) v14 v15 v16 v17 end in v14 eq_refl) v13 in ex_ind (fun (v15 : @elt) (v16 : InA (PX.eqke (elt:=@elt)) (v2, v15) v7) => ex_intro (fun v17 : @elt => InA (PX.eqke (elt:=@elt)) (v2, v17) ((v5, v6) :: v7)) v15 (InA_cons_tl (v5, v6) v16)) v14) : forall (v12 : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v7)) (v13 : mem v2 v7 = @true), exists v14 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v14) ((v5, v6) :: v7)) v0 : forall (v4 : Sorted (PX.ltk (elt:=@elt)) v0) (v5 : v3 = @true), exists v6 : @elt, InA (PX.eqke (elt:=@elt)) (v2, v6) v0) : forall (v3 : Sorted (PX.ltk (elt:=@elt)) v0) (v4 : mem v2 v0 = @true), exists v5 : @elt, PX.MapsTo v2 v5 v0) : forall (v3 : Sorted (PX.ltk (elt:=@elt)) v0) (v4 : mem v2 v0 = @true), PX.In v2 v0) v1)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.find_2	100	0.664557	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 : @key) => (let v2 : option (@elt) := find v1 v0 in find_ind (P:=fun (v3 : t (@elt)) (v4 : option (@elt)) => forall (v5 : @elt) (v6 : v4 = Some v5), InA (PX.eqke (elt:=@elt)) (v1, v5) v3) (fun (v3 : t (@elt)) (v4 : v3 = nil) => ((fun (v5 : @elt) (v6 : None = Some v5) => let v7 : forall v7 : Some v5 = Some v5, InA (PX.eqke (elt:=@elt)) (v1, v5) nil := match v6 as v8 in (_ = v7) return (forall v9 : v7 = Some v5, InA (PX.eqke (elt:=@elt)) (v1, v5) nil) with | eq_refl => fun v7 : None = Some v5 => (fun v8 : None = Some v5 => let v9 : @False := eq_ind None (fun v9 : option (@elt) => match v9 as v10 in (option _) return Prop with | Some v10 => (fun v10 : @elt => @False) v10 | None => @True end) (@I) (Some v5) v8 in False_ind (InA (PX.eqke (elt:=@elt)) (v1, v5) nil) v9) v7 end in v7 eq_refl) : forall (v5 : @elt) (v6 : None = Some v5), InA (PX.eqke (elt:=@elt)) (v1, v5) nil) : forall (v5 : @elt) (v6 : None = Some v5), InA (PX.eqke (elt:=@elt)) (v1, v5) nil) (fun (v3 : t (@elt)) (v4 : @X.t) (v5 : @elt) (v6 : list (@X.t * @elt)) (v7 : v3 = (v4, v5) :: v6) (v8 : X.lt v1 v4) (v9 : X.compare v1 v4 = LT v8) => ((fun (v10 : @elt) (v11 : None = Some v10) => let v12 : forall v12 : Some v10 = Some v10, InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6) := match v11 as v13 in (_ = v12) return (forall v14 : v12 = Some v10, InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6)) with | eq_refl => fun v12 : None = Some v10 => (fun v13 : None = Some v10 => let v14 : @False := eq_ind None (fun v14 : option (@elt) => match v14 as v15 in (option _) return Prop with | Some v15 => (fun v15 : @elt => @False) v15 | None => @True end) (@I) (Some v10) v13 in False_ind (InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6)) v14) v12 end in v12 eq_refl) : forall (v10 : @elt) (v11 : None = Some v10), InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6)) : forall (v10 : @elt) (v11 : None = Some v10), InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6)) (fun (v3 : t (@elt)) (v4 : @X.t) (v5 : @elt) (v6 : list (@X.t * @elt)) (v7 : v3 = (v4, v5) :: v6) (v8 : X.eq v1 v4) (v9 : X.compare v1 v4 = EQ v8) => ((fun (v10 : @elt) (v11 : Some v5 = Some v10) => let v12 : forall v12 : Some v10 = Some v10, InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6) := match v11 as v13 in (_ = v12) return (forall v14 : v12 = Some v10, InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6)) with | eq_refl => fun v12 : Some v5 = Some v10 => (fun v13 : Some v5 = Some v10 => let v14 : v5 = v10 := f_equal (fun v14 : option (@elt) => match v14 as v15 in (option _) return (@elt) with | Some v15 => (fun v15 : @elt => v15) v15 | None => v5 end) v13 in (fun v15 : v5 = v10 => let v16 : v5 = v10 := v15 in eq_ind_r (fun v17 : @elt => InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v17) :: v6)) (InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v1, v10)) (y:=(v4, v10)) v6 (conj v8 eq_refl)) v16) v14) v12 end in v12 eq_refl) : forall (v10 : @elt) (v11 : Some v5 = Some v10), InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6)) : forall (v10 : @elt) (v11 : Some v5 = Some v10), InA (PX.eqke (elt:=@elt)) (v1, v10) ((v4, v5) :: v6)) (fun (v3 : t (@elt)) (v4 : @X.t) (v5 : @elt) (v6 : list (@X.t * @elt)) (v7 : v3 = (v4, v5) :: v6) (v8 : X.lt v4 v1) (v9 : X.compare v1 v4 = GT v8) (v10 : forall (v10 : @elt) (v11 : find v1 v6 = Some v10), InA (PX.eqke (elt:=@elt)) (v1, v10) v6) => ((fun (v11 : @elt) (v12 : find v1 v6 = Some v11) => let v13 : forall v13 : Some v11 = Some v11, InA (PX.eqke (elt:=@elt)) (v1, v11) ((v4, v5) :: v6) := match v12 as v14 in (_ = v13) return (forall v15 : v13 = Some v11, InA (PX.eqke (elt:=@elt)) (v1, v11) ((v4, v5) :: v6)) with | eq_refl => fun v13 : find v1 v6 = Some v11 => (fun v14 : find v1 v6 = Some v11 => let v15 : find v1 v6 = Some v11 := f_equal (fun v15 : option (@elt) => v15) v14 in (fun v16 : find v1 v6 = Some v11 => let v17 : find v1 v6 = Some v11 := v16 in eq_ind (find v1 v6) (fun v18 : option (@elt) => InA (PX.eqke (elt:=@elt)) (v1, v11) ((v4, v5) :: v6)) (InA_cons_tl (v4, v5) (v10 v11 v16)) (Some v11) v17) v15) v13 end in v13 eq_refl) : forall (v11 : @elt) (v12 : find v1 v6 = Some v11), InA (PX.eqke (elt:=@elt)) (v1, v11) ((v4, v5) :: v6)) : forall (v11 : @elt) (v12 : find v1 v6 = Some v11), InA (PX.eqke (elt:=@elt)) (v1, v11) ((v4, v5) :: v6)) v0 : forall (v3 : @elt) (v4 : v2 = Some v3), InA (PX.eqke (elt:=@elt)) (v1, v3) v0) : forall (v2 : @elt) (v3 : find v1 v0 = Some v2), PX.MapsTo v1 v2 v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.find_1	100	1.219973	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.add_1	100	0.236740	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 v2 : @X.t) (v3 : @elt) => ((let v4 : t (@elt) := add v1 v3 v0 in add_ind (x:=v3) (P:=fun v5 v6 : t (@elt) => forall (v7 : @X.t) (v8 : X.eq v1 v7), InA (PX.eqke (elt:=@elt)) (v7, v3) v6) (fun (v5 : t (@elt)) (v6 : v5 = nil) => ((fun (v7 : @X.t) (v8 : X.eq v1 v7) => InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v7, v3)) (y:=(v1, v3)) nil (conj (X.eq_sym v8) eq_refl)) : forall (v7 : @X.t) (v8 : X.eq v1 v7), InA (PX.eqke (elt:=@elt)) (v7, v3) ((v1, v3) :: nil)) : forall (v7 : @X.t) (v8 : X.eq v1 v7), InA (PX.eqke (elt:=@elt)) (v7, v3) ((v1, v3) :: nil)) (fun (v5 : t (@elt)) (v6 : @X.t) (v7 : @elt) (v8 : list (@X.t * @elt)) (v9 : v5 = (v6, v7) :: v8) (v10 : X.lt v1 v6) (v11 : X.compare v1 v6 = LT v10) => eq_ind_r (fun v12 : t (@elt) => forall (v13 : @X.t) (v14 : X.eq v1 v13), InA (PX.eqke (elt:=@elt)) (v13, v3) ((v1, v3) :: v12)) (((fun (v12 : @X.t) (v13 : X.eq v1 v12) => InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v12, v3)) (y:=(v1, v3)) ((v6, v7) :: v8) (conj (X.eq_sym v13) eq_refl)) : forall (v12 : @X.t) (v13 : X.eq v1 v12), InA (PX.eqke (elt:=@elt)) (v12, v3) ((v1, v3) :: (v6, v7) :: v8)) : forall (v12 : @X.t) (v13 : X.eq v1 v12), InA (PX.eqke (elt:=@elt)) (v12, v3) ((v1, v3) :: (v6, v7) :: v8)) v9) (fun (v5 : t (@elt)) (v6 : @X.t) (v7 : @elt) (v8 : list (@X.t * @elt)) (v9 : v5 = (v6, v7) :: v8) (v10 : X.eq v1 v6) (v11 : X.compare v1 v6 = EQ v10) => ((fun (v12 : @X.t) (v13 : X.eq v1 v12) => InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v12, v3)) (y:=(v1, v3)) v8 (conj (X.eq_sym v13) eq_refl)) : forall (v12 : @X.t) (v13 : X.eq v1 v12), InA (PX.eqke (elt:=@elt)) (v12, v3) ((v1, v3) :: v8)) : forall (v12 : @X.t) (v13 : X.eq v1 v12), InA (PX.eqke (elt:=@elt)) (v12, v3) ((v1, v3) :: v8)) (fun (v5 : t (@elt)) (v6 : @X.t) (v7 : @elt) (v8 : list (@X.t * @elt)) (v9 : v5 = (v6, v7) :: v8) (v10 : X.lt v6 v1) (v11 : X.compare v1 v6 = GT v10) (v12 : forall (v12 : @X.t) (v13 : X.eq v1 v12), InA (PX.eqke (elt:=@elt)) (v12, v3) (add v1 v3 v8)) => ((fun (v13 : @X.t) (v14 : X.eq v1 v13) => InA_cons_tl (v6, v7) (v12 v13 v14)) : forall (v13 : @X.t) (v14 : X.eq v1 v13), InA (PX.eqke (elt:=@elt)) (v13, v3) ((v6, v7) :: add v1 v3 v8)) : forall (v13 : @X.t) (v14 : X.eq v1 v13), InA (PX.eqke (elt:=@elt)) (v13, v3) ((v6, v7) :: add v1 v3 v8)) v0 : forall (v5 : @X.t) (v6 : X.eq v1 v5), InA (PX.eqke (elt:=@elt)) (v5, v3) v4) : forall (v4 : @X.t) (v5 : X.eq v1 v4), PX.MapsTo v4 v3 (add v1 v3 v0)) v2)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.add_2	100	0.722241	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 v2 : @X.t) (v3 v4 : @elt) => ((let v5 : t (@elt) := add v1 v4 v0 in add_ind (x:=v4) (P:=fun (v6 : list (@X.t * @elt)) (v7 : t (@elt)) => forall (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) v6), InA (PX.eqke (elt:=@elt)) (v8, v9) v7) (fun (v6 : t (@elt)) (v7 : v6 = nil) => ((fun (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) nil) => InA_cons_tl (v1, v4) v11) : forall (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) nil), InA (PX.eqke (elt:=@elt)) (v8, v9) ((v1, v4) :: nil)) : forall (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) nil), InA (PX.eqke (elt:=@elt)) (v8, v9) ((v1, v4) :: nil)) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v1 v7) (v12 : X.compare v1 v7 = LT v11) => eq_ind_r (fun v13 : t (@elt) => forall (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v1, v4) :: v13)) (((fun (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)) => InA_cons_tl (v1, v4) v16) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: (v7, v8) :: v9)) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: (v7, v8) :: v9)) v10) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.eq v1 v7) (v12 : X.compare v1 v7 = EQ v11) => ((fun (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)) => let v17 : forall v17 : (v7, v8) :: v9 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9) := match v16 as v18 in (InA _ _ v17) return (forall v19 : v17 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) with | @InA_cons_hd _ _ _ v17 v18 v19 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) (v19 : PX.eqke (v13, v14) v17) (v20 : v17 :: v18 = (v7, v8) :: v9) => (fun v21 : v17 :: v18 = (v7, v8) :: v9 => let v22 : v18 = v9 := f_equal (fun v22 : list (@X.t * @elt) => match v22 as v23 in (list _) return (list (@X.t * @elt)) with | nil => v18 | v23 :: v24 => (fun (v23 : @X.t * @elt) (v24 : list (@X.t * @elt)) => v24) v23 v24 end) v21 in (let v23 : v17 = (v7, v8) := f_equal (fun v23 : list (@X.t * @elt) => match v23 as v24 in (list _) return (@X.t * @elt) with | nil => v17 | v24 :: v25 => (fun (v24 : @X.t * @elt) (v25 : list (@X.t * @elt)) => v24) v24 v25 end) v21 in (fun v24 : v17 = (v7, v8) => let v25 : v17 = (v7, v8) := v24 in eq_ind_r (fun v26 : @X.t * @elt => forall (v27 : v18 = v9) (v28 : PX.eqke (v13, v14) v26), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) (fun v26 : v18 = v9 => let v27 : v18 = v9 := v26 in eq_ind_r (fun v28 : list (@X.t * @elt) => forall v29 : PX.eqke (v13, v14) (v7, v8), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) (fun v28 : PX.eqke (v13, v14) (v7, v8) => match v28 as v29 in (_ /\ _) return (InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) with | conj v29 v30 => (fun (v29 : X.eq (fst (v13, v14)) (fst (v7, v8))) (v30 : snd (v13, v14) = snd (v7, v8)) => False_ind (InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) ((fun v31 : ~ TO.eq v1 v7 => (fun v32 : ~ TO.eq v7 v7 => v32 (OrderTac.eq_refl v7)) (OrderTac.eq_neq (OrderTac.eq_sym v11) v31)) (OrderTac.neq_eq v15 v29)) : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) v29 v30 end) v27) v25) v23) v22) v20 v19) v17 v18 v19 | @InA_cons_tl _ _ _ v17 v18 v19 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) (v19 : InA (PX.eqke (elt:=@elt)) (v13, v14) v18) (v20 : v17 :: v18 = (v7, v8) :: v9) => (fun v21 : v17 :: v18 = (v7, v8) :: v9 => let v22 : v18 = v9 := f_equal (fun v22 : list (@X.t * @elt) => match v22 as v23 in (list _) return (list (@X.t * @elt)) with | nil => v18 | v23 :: v24 => (fun (v23 : @X.t * @elt) (v24 : list (@X.t * @elt)) => v24) v23 v24 end) v21 in (let v23 : v17 = (v7, v8) := f_equal (fun v23 : list (@X.t * @elt) => match v23 as v24 in (list _) return (@X.t * @elt) with | nil => v17 | v24 :: v25 => (fun (v24 : @X.t * @elt) (v25 : list (@X.t * @elt)) => v24) v24 v25 end) v21 in (fun v24 : v17 = (v7, v8) => let v25 : v17 = (v7, v8) := v24 in eq_ind_r (fun v26 : @X.t * @elt => forall (v27 : v18 = v9) (v28 : InA (PX.eqke (elt:=@elt)) (v13, v14) v18), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) (fun v26 : v18 = v9 => let v27 : v18 = v9 := v26 in eq_ind_r (fun v28 : list (@X.t * @elt) => forall v29 : InA (PX.eqke (elt:=@elt)) (v13, v14) v28, InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) (fun v28 : InA (PX.eqke (elt:=@elt)) (v13, v14) v9 => match v28 as v30 in (InA _ _ v29) return (InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v29)) with | @InA_cons_hd _ _ _ v29 v30 v31 => (fun (v29 : @X.t * @elt) (v30 : list (@X.t * @elt)) (v31 : PX.eqke (v13, v14) v29) => InA_cons_tl (v1, v4) (InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v13, v14)) (y:=v29) v30 v31) : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v29 :: v30)) v29 v30 v31 | @InA_cons_tl _ _ _ v29 v30 v31 => (fun (v29 : @X.t * @elt) (v30 : list (@X.t * @elt)) (v31 : InA (PX.eqke (elt:=@elt)) (v13, v14) v30) => InA_cons_tl (v1, v4) (InA_cons_tl v29 v31) : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v29 :: v30)) v29 v30 v31 end) v27) v25) v23) v22) v20 v19) v17 v18 v19 end in v17 eq_refl) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v7 v1) (v12 : X.compare v1 v7 = GT v11) (v13 : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) v9), InA (PX.eqke (elt:=@elt)) (v13, v14) (add v1 v4 v9)) => ((fun (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) => let v18 : forall v18 : (v7, v8) :: v9 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9) := match v17 as v19 in (InA _ _ v18) return (forall v20 : v18 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) with | @InA_cons_hd _ _ _ v18 v19 v20 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) (v20 : PX.eqke (v14, v15) v18) (v21 : v18 :: v19 = (v7, v8) :: v9) => (fun v22 : v18 :: v19 = (v7, v8) :: v9 => let v23 : v19 = v9 := f_equal (fun v23 : list (@X.t * @elt) => match v23 as v24 in (list _) return (list (@X.t * @elt)) with | nil => v19 | v24 :: v25 => (fun (v24 : @X.t * @elt) (v25 : list (@X.t * @elt)) => v25) v24 v25 end) v22 in (let v24 : v18 = (v7, v8) := f_equal (fun v24 : list (@X.t * @elt) => match v24 as v25 in (list _) return (@X.t * @elt) with | nil => v18 | v25 :: v26 => (fun (v25 : @X.t * @elt) (v26 : list (@X.t * @elt)) => v25) v25 v26 end) v22 in (fun v25 : v18 = (v7, v8) => let v26 : v18 = (v7, v8) := v25 in eq_ind_r (fun v27 : @X.t * @elt => forall (v28 : v19 = v9) (v29 : PX.eqke (v14, v15) v27), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) (fun v27 : v19 = v9 => let v28 : v19 = v9 := v27 in eq_ind_r (fun v29 : list (@X.t * @elt) => forall v30 : PX.eqke (v14, v15) (v7, v8), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) (fun v29 : PX.eqke (v14, v15) (v7, v8) => InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v14, v15)) (y:=(v7, v8)) (add v1 v4 v9) v29 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) v28) v26) v24) v23) v21 v20) v18 v19 v20 | @InA_cons_tl _ _ _ v18 v19 v20 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) (v20 : InA (PX.eqke (elt:=@elt)) (v14, v15) v19) (v21 : v18 :: v19 = (v7, v8) :: v9) => (fun v22 : v18 :: v19 = (v7, v8) :: v9 => let v23 : v19 = v9 := f_equal (fun v23 : list (@X.t * @elt) => match v23 as v24 in (list _) return (list (@X.t * @elt)) with | nil => v19 | v24 :: v25 => (fun (v24 : @X.t * @elt) (v25 : list (@X.t * @elt)) => v25) v24 v25 end) v22 in (let v24 : v18 = (v7, v8) := f_equal (fun v24 : list (@X.t * @elt) => match v24 as v25 in (list _) return (@X.t * @elt) with | nil => v18 | v25 :: v26 => (fun (v25 : @X.t * @elt) (v26 : list (@X.t * @elt)) => v25) v25 v26 end) v22 in (fun v25 : v18 = (v7, v8) => let v26 : v18 = (v7, v8) := v25 in eq_ind_r (fun v27 : @X.t * @elt => forall (v28 : v19 = v9) (v29 : InA (PX.eqke (elt:=@elt)) (v14, v15) v19), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) (fun v27 : v19 = v9 => let v28 : v19 = v9 := v27 in eq_ind_r (fun v29 : list (@X.t * @elt) => forall v30 : InA (PX.eqke (elt:=@elt)) (v14, v15) v29, InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) (fun v29 : InA (PX.eqke (elt:=@elt)) (v14, v15) v9 => InA_cons_tl (v7, v8) (v13 v14 v15 v16 v29) : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) v28) v26) v24) v23) v21 v20) v18 v19 v20 end in v18 eq_refl) : forall (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) : forall (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) v0 : forall (v6 : @X.t) (v7 : @elt) (v8 : ~ X.eq v1 v6) (v9 : InA (PX.eqke (elt:=@elt)) (v6, v7) v0), InA (PX.eqke (elt:=@elt)) (v6, v7) v5) : forall (v5 : @X.t) (v6 : @elt) (v7 : ~ X.eq v1 v5) (v8 : PX.MapsTo v5 v6 v0), PX.MapsTo v5 v6 (add v1 v4 v0)) v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.add_3	100	0.513866	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 v2 : @X.t) (v3 v4 : @elt) => ((let v5 : t (@elt) := add v1 v4 v0 in add_ind (x:=v4) (P:=fun v6 v7 : t (@elt) => forall (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) v7), InA (PX.eqke (elt:=@elt)) (v8, v9) v6) (fun (v6 : t (@elt)) (v7 : v6 = nil) => ((fun (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) ((v1, v4) :: nil)) => In_inv_3 v11 ((fun v12 : PX.eqk (v8, v9) (v1, v4) => v10 (X.eq_sym v12)) : ~ PX.eqk (v8, v9) (v1, v4))) : forall (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) ((v1, v4) :: nil)), InA (PX.eqke (elt:=@elt)) (v8, v9) nil) : forall (v8 : @X.t) (v9 : @elt) (v10 : ~ X.eq v1 v8) (v11 : InA (PX.eqke (elt:=@elt)) (v8, v9) ((v1, v4) :: nil)), InA (PX.eqke (elt:=@elt)) (v8, v9) nil) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v1 v7) (v12 : X.compare v1 v7 = LT v11) => eq_ind_r (fun v13 : t (@elt) => forall (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v1, v4) :: v13)), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) (((fun (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: (v7, v8) :: v9)) => In_inv_3 v16 ((fun v17 : PX.eqk (v13, v14) (v1, v4) => v15 (X.eq_sym v17)) : ~ PX.eqk (v13, v14) (v1, v4))) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: (v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: (v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)) v10) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.eq v1 v7) (v12 : X.compare v1 v7 = EQ v11) => ((fun (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)) => InA_cons_tl (v7, v8) (In_inv_3 v16 ((fun v17 : PX.eqk (v13, v14) (v1, v4) => v15 (X.eq_sym v17)) : ~ PX.eqk (v13, v14) (v1, v4)))) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)) : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) ((v1, v4) :: v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) ((v7, v8) :: v9)) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v7 v1) (v12 : X.compare v1 v7 = GT v11) (v13 : forall (v13 : @X.t) (v14 : @elt) (v15 : ~ X.eq v1 v13) (v16 : InA (PX.eqke (elt:=@elt)) (v13, v14) (add v1 v4 v9)), InA (PX.eqke (elt:=@elt)) (v13, v14) v9) => ((fun (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)) => let v18 : forall v18 : (v7, v8) :: add v1 v4 v9 = (v7, v8) :: add v1 v4 v9, InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9) := match v17 as v19 in (InA _ _ v18) return (forall v20 : v18 = (v7, v8) :: add v1 v4 v9, InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) with | @InA_cons_hd _ _ _ v18 v19 v20 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) (v20 : PX.eqke (v14, v15) v18) (v21 : v18 :: v19 = (v7, v8) :: add v1 v4 v9) => (fun v22 : v18 :: v19 = (v7, v8) :: add v1 v4 v9 => let v23 : v19 = add v1 v4 v9 := f_equal (fun v23 : list (@X.t * @elt) => match v23 as v24 in (list _) return (list (@X.t * @elt)) with | nil => v19 | v24 :: v25 => (fun (v24 : @X.t * @elt) (v25 : list (@X.t * @elt)) => v25) v24 v25 end) v22 in (let v24 : v18 = (v7, v8) := f_equal (fun v24 : list (@X.t * @elt) => match v24 as v25 in (list _) return (@X.t * @elt) with | nil => v18 | v25 :: v26 => (fun (v25 : @X.t * @elt) (v26 : list (@X.t * @elt)) => v25) v25 v26 end) v22 in (fun v25 : v18 = (v7, v8) => let v26 : v18 = (v7, v8) := v25 in eq_ind_r (fun v27 : @X.t * @elt => forall (v28 : v19 = add v1 v4 v9) (v29 : PX.eqke (v14, v15) v27), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) (fun v27 : v19 = add v1 v4 v9 => let v28 : v19 = add v1 v4 v9 := v27 in eq_ind_r (fun v29 : list (@X.t * @elt) => forall v30 : PX.eqke (v14, v15) (v7, v8), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) (fun v29 : PX.eqke (v14, v15) (v7, v8) => InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v14, v15)) (y:=(v7, v8)) v9 v29) v28) v26) v24) v23) v21 v20) v18 v19 v20 | @InA_cons_tl _ _ _ v18 v19 v20 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) (v20 : InA (PX.eqke (elt:=@elt)) (v14, v15) v19) (v21 : v18 :: v19 = (v7, v8) :: add v1 v4 v9) => (fun v22 : v18 :: v19 = (v7, v8) :: add v1 v4 v9 => let v23 : v19 = add v1 v4 v9 := f_equal (fun v23 : list (@X.t * @elt) => match v23 as v24 in (list _) return (list (@X.t * @elt)) with | nil => v19 | v24 :: v25 => (fun (v24 : @X.t * @elt) (v25 : list (@X.t * @elt)) => v25) v24 v25 end) v22 in (let v24 : v18 = (v7, v8) := f_equal (fun v24 : list (@X.t * @elt) => match v24 as v25 in (list _) return (@X.t * @elt) with | nil => v18 | v25 :: v26 => (fun (v25 : @X.t * @elt) (v26 : list (@X.t * @elt)) => v25) v25 v26 end) v22 in (fun v25 : v18 = (v7, v8) => let v26 : v18 = (v7, v8) := v25 in eq_ind_r (fun v27 : @X.t * @elt => forall (v28 : v19 = add v1 v4 v9) (v29 : InA (PX.eqke (elt:=@elt)) (v14, v15) v19), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) (fun v27 : v19 = add v1 v4 v9 => let v28 : v19 = add v1 v4 v9 := v27 in eq_ind_r (fun v29 : list (@X.t * @elt) => forall v30 : InA (PX.eqke (elt:=@elt)) (v14, v15) v29, InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) (fun v29 : InA (PX.eqke (elt:=@elt)) (v14, v15) (add v1 v4 v9) => InA_cons_tl (v7, v8) (v13 v14 v15 v16 v29)) v28) v26) v24) v23) v21 v20) v18 v19 v20 end in v18 eq_refl) : forall (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) : forall (v14 : @X.t) (v15 : @elt) (v16 : ~ X.eq v1 v14) (v17 : InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: add v1 v4 v9)), InA (PX.eqke (elt:=@elt)) (v14, v15) ((v7, v8) :: v9)) v0 : forall (v6 : @X.t) (v7 : @elt) (v8 : ~ X.eq v1 v6) (v9 : InA (PX.eqke (elt:=@elt)) (v6, v7) v5), InA (PX.eqke (elt:=@elt)) (v6, v7) v0) : forall (v5 : @X.t) (v6 : @elt) (v7 : ~ X.eq v1 v5) (v8 : PX.MapsTo v5 v6 (add v1 v4 v0)), PX.MapsTo v5 v6 v0) v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.add_Inf	100	0.380436	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 v3 : @key) (v4 v5 : @elt) (v6 : HdRel (PX.ltk (elt:=@elt)) (v3, v5) v1) (v7 : PX.ltk (v3, v5) (v2, v4)), HdRel (PX.ltk (elt:=@elt)) (v3, v5) (add v2 v4 v1)) ((fun (v1 v2 : @key) (v3 v4 : @elt) (v5 : HdRel (PX.ltk (elt:=@elt)) (v2, v4) nil) (v6 : PX.ltk (v2, v4) (v1, v3)) => HdRel_cons (PX.ltk (elt:=@elt)) (v2, v4) (v1, v3) nil v6 : HdRel (PX.ltk (elt:=@elt)) (v2, v4) ((v1, v3) :: nil)) : forall (v1 v2 : @key) (v3 v4 : @elt) (v5 : HdRel (PX.ltk (elt:=@elt)) (v2, v4) nil) (v6 : PX.ltk (v2, v4) (v1, v3)), HdRel (PX.ltk (elt:=@elt)) (v2, v4) (add v1 v3 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 v4 : @key) (v5 v6 : @elt) (v7 : HdRel (PX.ltk (elt:=@elt)) (v4, v6) v2) (v8 : PX.ltk (v4, v6) (v3, v5)), HdRel (PX.ltk (elt:=@elt)) (v4, v6) (add v3 v5 v2)) (v4 v5 : @key) (v6 v7 : @elt) (v8 : HdRel (PX.ltk (elt:=@elt)) (v5, v7) (v1 :: v2)) (v9 : PX.ltk (v5, v7) (v4, v6)) => match v1 as v10 in (_ * _)%type return (forall v11 : HdRel (PX.ltk (elt:=@elt)) (v5, v7) (v10 :: v2), HdRel (PX.ltk (elt:=@elt)) (v5, v7) (add v4 v6 (v10 :: v2))) with | (v10, v11) => (fun (v10 : @X.t) (v11 : @elt) (v12 : HdRel (PX.ltk (elt:=@elt)) (v5, v7) ((v10, v11) :: v2)) => let v13 : forall v13 : (v10, v11) :: v2 = (v10, v11) :: v2, HdRel (PX.ltk (elt:=@elt)) (v5, v7) (add v4 v6 ((v10, v11) :: v2)) := match v12 as v14 in (HdRel _ _ v13) return (forall v15 : v13 = (v10, v11) :: v2, HdRel (PX.ltk (elt:=@elt)) (v5, v7) (add v4 v6 ((v10, v11) :: v2))) with | HdRel_nil _ _ => fun v13 : nil = (v10, v11) :: v2 => (fun v14 : nil = (v10, v11) :: v2 => let v15 : @False := eq_ind nil (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return Prop with | nil => @True | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => @False) v16 v17 end) (@I) ((v10, v11) :: v2) v14 in False_ind (HdRel (PX.ltk (elt:=@elt)) (v5, v7) (add v4 v6 ((v10, v11) :: v2))) v15) v13 | HdRel_cons _ _ v13 v14 v15 => (fun (v13 : @X.t * @elt) (v14 : list (@X.t * @elt)) (v15 : PX.ltk (v5, v7) v13) (v16 : v13 :: v14 = (v10, v11) :: v2) => (fun v17 : v13 :: v14 = (v10, v11) :: v2 => let v18 : v14 = v2 := f_equal (fun v18 : list (@X.t * @elt) => match v18 as v19 in (list _) return (list (@X.t * @elt)) with | nil => v14 | v19 :: v20 => (fun (v19 : @X.t * @elt) (v20 : list (@X.t * @elt)) => v20) v19 v20 end) v17 in (let v19 : v13 = (v10, v11) := f_equal (fun v19 : list (@X.t * @elt) => match v19 as v20 in (list _) return (@X.t * @elt) with | nil => v13 | v20 :: v21 => (fun (v20 : @X.t * @elt) (v21 : list (@X.t * @elt)) => v20) v20 v21 end) v17 in (fun v20 : v13 = (v10, v11) => let v21 : v13 = (v10, v11) := v20 in eq_ind_r (fun v22 : @X.t * @elt => forall (v23 : v14 = v2) (v24 : PX.ltk (v5, v7) v22), HdRel (PX.ltk (elt:=@elt)) (v5, v7) (add v4 v6 ((v10, v11) :: v2))) (fun v22 : v14 = v2 => let v23 : v14 = v2 := v22 in eq_ind_r (fun v24 : list (@X.t * @elt) => forall v25 : PX.ltk (v5, v7) (v10, v11), HdRel (PX.ltk (elt:=@elt)) (v5, v7) (add v4 v6 ((v10, v11) :: v2))) (fun v24 : PX.ltk (v5, v7) (v10, v11) => match X.compare v4 v10 as v25 in (Compare _ _ _ _) return (HdRel (PX.ltk (elt:=@elt)) (v5, v7) match v25 as v26 in (Compare _ _ _ _) return (t (@elt)) with | LT v26 => (fun v26 : X.lt v4 v10 => (v4, v6) :: (v10, v11) :: v2) v26 | EQ v26 => (fun v26 : X.eq v4 v10 => (v4, v6) :: v2) v26 | GT v26 => (fun v26 : X.lt v10 v4 => (v10, v11) :: add v4 v6 v2) v26 end) with | LT v25 => (fun v25 : X.lt v4 v10 => HdRel_cons (PX.ltk (elt:=@elt)) (v5, v7) (v4, v6) ((v10, v11) :: v2) v9 : HdRel (PX.ltk (elt:=@elt)) (v5, v7) ((v4, v6) :: (v10, v11) :: v2)) v25 | EQ v25 => (fun v25 : X.eq v4 v10 => HdRel_cons (PX.ltk (elt:=@elt)) (v5, v7) (v4, v6) v2 v9 : HdRel (PX.ltk (elt:=@elt)) (v5, v7) ((v4, v6) :: v2)) v25 | GT v25 => (fun v25 : X.lt v10 v4 => HdRel_cons (PX.ltk (elt:=@elt)) (v5, v7) (v10, v11) (add v4 v6 v2) v24 : HdRel (PX.ltk (elt:=@elt)) (v5, v7) ((v10, v11) :: add v4 v6 v2)) v25 end : HdRel (PX.ltk (elt:=@elt)) (v5, v7) (add v4 v6 ((v10, v11) :: v2))) v23) v21) v19) v18) v16 v15) v13 v14 v15 end in v13 eq_refl) v10 v11 end v8) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.add_sorted	100	0.674262	1	1	0	synth with cache (only 1: refine (fun v0 : list (@X.t * @elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 : Sorted (PX.ltk (elt:=@elt)) v1) (v3 : @key) (v4 : @elt), Sorted (PX.ltk (elt:=@elt)) (add v3 v4 v1)) ((fun (v1 : Sorted (PX.ltk (elt:=@elt)) nil) (v2 : @key) (v3 : @elt) => Sorted_cons v1 (HdRel_nil (PX.ltk (elt:=@elt)) (v2, v3)) : Sorted (PX.ltk (elt:=@elt)) ((v2, v3) :: nil)) : forall (v1 : Sorted (PX.ltk (elt:=@elt)) nil) (v2 : @key) (v3 : @elt), Sorted (PX.ltk (elt:=@elt)) (add v2 v3 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 : Sorted (PX.ltk (elt:=@elt)) v2) (v4 : @key) (v5 : @elt), Sorted (PX.ltk (elt:=@elt)) (add v4 v5 v2)) (v4 : Sorted (PX.ltk (elt:=@elt)) (v1 :: v2)) (v5 : @key) (v6 : @elt) => match v1 as v7 in (_ * _)%type return (forall v8 : Sorted (PX.ltk (elt:=@elt)) (v7 :: v2), Sorted (PX.ltk (elt:=@elt)) (add v5 v6 (v7 :: v2))) with | (v7, v8) => (fun (v7 : @X.t) (v8 : @elt) (v9 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v2)) => match X.compare v5 v7 as v10 in (Compare _ _ _ _) return (Sorted (PX.ltk (elt:=@elt)) match v10 as v11 in (Compare _ _ _ _) return (t (@elt)) with | LT v11 => (fun v11 : X.lt v5 v7 => (v5, v6) :: (v7, v8) :: v2) v11 | EQ v11 => (fun v11 : X.eq v5 v7 => (v5, v6) :: v2) v11 | GT v11 => (fun v11 : X.lt v7 v5 => (v7, v8) :: add v5 v6 v2) v11 end) with | LT v10 => (fun v10 : X.lt v5 v7 => Sorted_cons v9 (HdRel_cons (PX.ltk (elt:=@elt)) (v5, v6) (v7, v8) v2 v10) : Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: (v7, v8) :: v2)) v10 | EQ v10 => (fun v10 : X.eq v5 v7 => let v11 : forall v11 : (v7, v8) :: v2 = (v7, v8) :: v2, Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v2) := match v9 as v12 in (Sorted _ v11) return (forall v13 : v11 = (v7, v8) :: v2, Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v2)) with | Sorted_nil _ => fun v11 : nil = (v7, v8) :: v2 => (fun v12 : nil = (v7, v8) :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t * @elt) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t * @elt) (v15 : list (@X.t * @elt)) => @False) v14 v15 end) (@I) ((v7, v8) :: v2) v12 in False_ind (Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v2)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) (v13 : Sorted (PX.ltk (elt:=@elt)) v12) (v14 : HdRel (PX.ltk (elt:=@elt)) v11 v12) (v15 : v11 :: v12 = (v7, v8) :: v2) => (fun v16 : v11 :: v12 = (v7, v8) :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return (list (@X.t * @elt)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => v19) v18 v19 end) v16 in (let v18 : v11 = (v7, v8) := f_equal (fun v18 : list (@X.t * @elt) => match v18 as v19 in (list _) return (@X.t * @elt) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t * @elt) (v20 : list (@X.t * @elt)) => v19) v19 v20 end) v16 in (fun v19 : v11 = (v7, v8) => let v20 : v11 = (v7, v8) := v19 in eq_ind_r (fun v21 : @X.t * @elt => forall (v22 : v12 = v2) (v23 : Sorted (PX.ltk (elt:=@elt)) v12) (v24 : HdRel (PX.ltk (elt:=@elt)) v21 v12), Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v2)) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t * @elt) => forall (v24 : Sorted (PX.ltk (elt:=@elt)) v23) (v25 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v23), Sorted (PX.ltk (elt:=@elt)) ((v5, v6) :: v2)) (fun (v23 : Sorted (PX.ltk (elt:=@elt)) v2) (v24 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v2) => Sorted_cons v23 (Inf_eq (x:=(v5, v6)) v10 v24)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 eq_refl) v10 | GT v10 => (fun v10 : X.lt v7 v5 => let v11 : forall v11 : (v7, v8) :: v2 = (v7, v8) :: v2, Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: add v5 v6 v2) := match v9 as v12 in (Sorted _ v11) return (forall v13 : v11 = (v7, v8) :: v2, Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: add v5 v6 v2)) with | Sorted_nil _ => fun v11 : nil = (v7, v8) :: v2 => (fun v12 : nil = (v7, v8) :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t * @elt) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t * @elt) (v15 : list (@X.t * @elt)) => @False) v14 v15 end) (@I) ((v7, v8) :: v2) v12 in False_ind (Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: add v5 v6 v2)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) (v13 : Sorted (PX.ltk (elt:=@elt)) v12) (v14 : HdRel (PX.ltk (elt:=@elt)) v11 v12) (v15 : v11 :: v12 = (v7, v8) :: v2) => (fun v16 : v11 :: v12 = (v7, v8) :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return (list (@X.t * @elt)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => v19) v18 v19 end) v16 in (let v18 : v11 = (v7, v8) := f_equal (fun v18 : list (@X.t * @elt) => match v18 as v19 in (list _) return (@X.t * @elt) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t * @elt) (v20 : list (@X.t * @elt)) => v19) v19 v20 end) v16 in (fun v19 : v11 = (v7, v8) => let v20 : v11 = (v7, v8) := v19 in eq_ind_r (fun v21 : @X.t * @elt => forall (v22 : v12 = v2) (v23 : Sorted (PX.ltk (elt:=@elt)) v12) (v24 : HdRel (PX.ltk (elt:=@elt)) v21 v12), Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: add v5 v6 v2)) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t * @elt) => forall (v24 : Sorted (PX.ltk (elt:=@elt)) v23) (v25 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v23), Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: add v5 v6 v2)) (fun (v23 : Sorted (PX.ltk (elt:=@elt)) v2) (v24 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v2) => Sorted_cons (v3 v23 v5 v6) (add_Inf (x:=v5) (e:=v6) v24 v10)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 eq_refl) v10 end : Sorted (PX.ltk (elt:=@elt)) (add v5 v6 ((v7, v8) :: v2))) v7 v8 end v4) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.remove_1	100	1.104500	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.remove_2	100	0.836798	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (PX.ltk (elt:=@elt)) v0) (v2 v3 : @X.t) (v4 : @elt) => ((let v5 : t (@elt) := remove v2 v0 in remove_ind (P:=fun (v6 : list (@X.t * @elt)) (v7 : t (@elt)) => forall (v8 : Sorted (PX.ltk (elt:=@elt)) v6) (v9 : ~ X.eq v2 v3) (v10 : InA (PX.eqke (elt:=@elt)) (v3, v4) v6), InA (PX.eqke (elt:=@elt)) (v3, v4) v7) (fun (v6 : t (@elt)) (v7 : v6 = nil) => (fun (v8 : Sorted (PX.ltk (elt:=@elt)) nil) (v9 : ~ X.eq v2 v3) (v10 : InA (PX.eqke (elt:=@elt)) (v3, v4) nil) => v10) : forall (v8 : Sorted (PX.ltk (elt:=@elt)) nil) (v9 : ~ X.eq v2 v3) (v10 : InA (PX.eqke (elt:=@elt)) (v3, v4) nil), InA (PX.eqke (elt:=@elt)) (v3, v4) nil) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v2 v7) (v12 : X.compare v2 v7 = LT v11) => eq_ind_r (fun v13 : t (@elt) => forall (v14 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v15 : ~ X.eq v2 v3) (v16 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) v13) ((fun (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : ~ X.eq v2 v3) (v15 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) => v15) : forall (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : ~ X.eq v2 v3) (v15 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) v10) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.eq v2 v7) (v12 : X.compare v2 v7 = EQ v11) => (fun (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : ~ X.eq v2 v3) (v15 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) => let v16 : forall v16 : (v7, v8) :: v9 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v3, v4) v9 := match v15 as v17 in (InA _ _ v16) return (forall v18 : v16 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v3, v4) v9) with | @InA_cons_hd _ _ _ v16 v17 v18 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) (v18 : PX.eqke (v3, v4) v16) (v19 : v16 :: v17 = (v7, v8) :: v9) => (fun v20 : v16 :: v17 = (v7, v8) :: v9 => let v21 : v17 = v9 := f_equal (fun v21 : list (@X.t * @elt) => match v21 as v22 in (list _) return (list (@X.t * @elt)) with | nil => v17 | v22 :: v23 => (fun (v22 : @X.t * @elt) (v23 : list (@X.t * @elt)) => v23) v22 v23 end) v20 in (let v22 : v16 = (v7, v8) := f_equal (fun v22 : list (@X.t * @elt) => match v22 as v23 in (list _) return (@X.t * @elt) with | nil => v16 | v23 :: v24 => (fun (v23 : @X.t * @elt) (v24 : list (@X.t * @elt)) => v23) v23 v24 end) v20 in (fun v23 : v16 = (v7, v8) => let v24 : v16 = (v7, v8) := v23 in eq_ind_r (fun v25 : @X.t * @elt => forall (v26 : v17 = v9) (v27 : PX.eqke (v3, v4) v25), InA (PX.eqke (elt:=@elt)) (v3, v4) v9) (fun v25 : v17 = v9 => let v26 : v17 = v9 := v25 in eq_ind_r (fun v27 : list (@X.t * @elt) => forall v28 : PX.eqke (v3, v4) (v7, v8), InA (PX.eqke (elt:=@elt)) (v3, v4) v9) (fun v27 : PX.eqke (v3, v4) (v7, v8) => match v27 as v28 in (_ /\ _) return (InA (PX.eqke (elt:=@elt)) (v3, v4) v9) with | conj v28 v29 => (fun (v28 : X.eq v3 v7) (v29 : v4 = v8) => False_ind (InA (PX.eqke (elt:=@elt)) (v3, v4) v9) ((fun v30 : ~ TO.eq v2 v7 => (fun v31 : ~ TO.eq v7 v7 => v31 (OrderTac.eq_refl v7)) (OrderTac.eq_neq (OrderTac.eq_sym v11) v30)) (OrderTac.neq_eq v14 v28))) v28 v29 end) v26) v24) v22) v21) v19 v18) v16 v17 v18 | @InA_cons_tl _ _ _ v16 v17 v18 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) (v18 : InA (PX.eqke (elt:=@elt)) (v3, v4) v17) (v19 : v16 :: v17 = (v7, v8) :: v9) => (fun v20 : v16 :: v17 = (v7, v8) :: v9 => let v21 : v17 = v9 := f_equal (fun v21 : list (@X.t * @elt) => match v21 as v22 in (list _) return (list (@X.t * @elt)) with | nil => v17 | v22 :: v23 => (fun (v22 : @X.t * @elt) (v23 : list (@X.t * @elt)) => v23) v22 v23 end) v20 in (let v22 : v16 = (v7, v8) := f_equal (fun v22 : list (@X.t * @elt) => match v22 as v23 in (list _) return (@X.t * @elt) with | nil => v16 | v23 :: v24 => (fun (v23 : @X.t * @elt) (v24 : list (@X.t * @elt)) => v23) v23 v24 end) v20 in (fun v23 : v16 = (v7, v8) => let v24 : v16 = (v7, v8) := v23 in eq_ind_r (fun v25 : @X.t * @elt => forall (v26 : v17 = v9) (v27 : InA (PX.eqke (elt:=@elt)) (v3, v4) v17), InA (PX.eqke (elt:=@elt)) (v3, v4) v9) (fun v25 : v17 = v9 => let v26 : v17 = v9 := v25 in eq_ind_r (fun v27 : list (@X.t * @elt) => forall v28 : InA (PX.eqke (elt:=@elt)) (v3, v4) v27, InA (PX.eqke (elt:=@elt)) (v3, v4) v9) (fun v27 : InA (PX.eqke (elt:=@elt)) (v3, v4) v9 => v27) v26) v24) v22) v21) v19 v18) v16 v17 v18 end in v16 eq_refl) : forall (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : ~ X.eq v2 v3) (v15 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) v9) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v7 v2) (v12 : X.compare v2 v7 = GT v11) (v13 : forall (v13 : Sorted (PX.ltk (elt:=@elt)) v9) (v14 : ~ X.eq v2 v3) (v15 : InA (PX.eqke (elt:=@elt)) (v3, v4) v9), InA (PX.eqke (elt:=@elt)) (v3, v4) (remove v2 v9)) => (fun v14 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9) => let v15 : forall (v15 : (v7, v8) :: v9 = (v7, v8) :: v9) (v16 : ~ X.eq v2 v3) (v17 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9) := match v14 as v16 in (Sorted _ v15) return (forall (v17 : v15 = (v7, v8) :: v9) (v18 : ~ X.eq v2 v3) (v19 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) with | Sorted_nil _ => fun v15 : nil = (v7, v8) :: v9 => (fun v16 : nil = (v7, v8) :: v9 => let v17 : @False := eq_ind nil (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return Prop with | nil => @True | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => @False) v18 v19 end) (@I) ((v7, v8) :: v9) v16 in False_ind (forall (v18 : ~ X.eq v2 v3) (v19 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) v17) v15 | @Sorted_cons _ _ v15 v16 v17 v18 => (fun (v15 : @X.t * @elt) (v16 : list (@X.t * @elt)) (v17 : Sorted (PX.ltk (elt:=@elt)) v16) (v18 : HdRel (PX.ltk (elt:=@elt)) v15 v16) (v19 : v15 :: v16 = (v7, v8) :: v9) => (fun v20 : v15 :: v16 = (v7, v8) :: v9 => let v21 : v16 = v9 := f_equal (fun v21 : list (@X.t * @elt) => match v21 as v22 in (list _) return (list (@X.t * @elt)) with | nil => v16 | v22 :: v23 => (fun (v22 : @X.t * @elt) (v23 : list (@X.t * @elt)) => v23) v22 v23 end) v20 in (let v22 : v15 = (v7, v8) := f_equal (fun v22 : list (@X.t * @elt) => match v22 as v23 in (list _) return (@X.t * @elt) with | nil => v15 | v23 :: v24 => (fun (v23 : @X.t * @elt) (v24 : list (@X.t * @elt)) => v23) v23 v24 end) v20 in (fun v23 : v15 = (v7, v8) => let v24 : v15 = (v7, v8) := v23 in eq_ind_r (fun v25 : @X.t * @elt => forall (v26 : v16 = v9) (v27 : Sorted (PX.ltk (elt:=@elt)) v16) (v28 : HdRel (PX.ltk (elt:=@elt)) v25 v16) (v29 : ~ X.eq v2 v3) (v30 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) (fun v25 : v16 = v9 => let v26 : v16 = v9 := v25 in eq_ind_r (fun v27 : list (@X.t * @elt) => forall (v28 : Sorted (PX.ltk (elt:=@elt)) v27) (v29 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v27) (v30 : ~ X.eq v2 v3) (v31 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) (fun (v27 : Sorted (PX.ltk (elt:=@elt)) v9) (v28 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v9) (v29 : ~ X.eq v2 v3) (v30 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) => let v31 : forall v31 : (v7, v8) :: v9 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9) := match v30 as v32 in (InA _ _ v31) return (forall v33 : v31 = (v7, v8) :: v9, InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) with | @InA_cons_hd _ _ _ v31 v32 v33 => (fun (v31 : @X.t * @elt) (v32 : list (@X.t * @elt)) (v33 : PX.eqke (v3, v4) v31) (v34 : v31 :: v32 = (v7, v8) :: v9) => (fun v35 : v31 :: v32 = (v7, v8) :: v9 => let v36 : v32 = v9 := f_equal (fun v36 : list (@X.t * @elt) => match v36 as v37 in (list _) return (list (@X.t * @elt)) with | nil => v32 | v37 :: v38 => (fun (v37 : @X.t * @elt) (v38 : list (@X.t * @elt)) => v38) v37 v38 end) v35 in (let v37 : v31 = (v7, v8) := f_equal (fun v37 : list (@X.t * @elt) => match v37 as v38 in (list _) return (@X.t * @elt) with | nil => v31 | v38 :: v39 => (fun (v38 : @X.t * @elt) (v39 : list (@X.t * @elt)) => v38) v38 v39 end) v35 in (fun v38 : v31 = (v7, v8) => let v39 : v31 = (v7, v8) := v38 in eq_ind_r (fun v40 : @X.t * @elt => forall (v41 : v32 = v9) (v42 : PX.eqke (v3, v4) v40), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) (fun v40 : v32 = v9 => let v41 : v32 = v9 := v40 in eq_ind_r (fun v42 : list (@X.t * @elt) => forall v43 : PX.eqke (v3, v4) (v7, v8), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) (fun v42 : PX.eqke (v3, v4) (v7, v8) => InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v3, v4)) (y:=(v7, v8)) (remove v2 v9) v42) v41) v39) v37) v36) v34 v33) v31 v32 v33 | @InA_cons_tl _ _ _ v31 v32 v33 => (fun (v31 : @X.t * @elt) (v32 : list (@X.t * @elt)) (v33 : InA (PX.eqke (elt:=@elt)) (v3, v4) v32) (v34 : v31 :: v32 = (v7, v8) :: v9) => (fun v35 : v31 :: v32 = (v7, v8) :: v9 => let v36 : v32 = v9 := f_equal (fun v36 : list (@X.t * @elt) => match v36 as v37 in (list _) return (list (@X.t * @elt)) with | nil => v32 | v37 :: v38 => (fun (v37 : @X.t * @elt) (v38 : list (@X.t * @elt)) => v38) v37 v38 end) v35 in (let v37 : v31 = (v7, v8) := f_equal (fun v37 : list (@X.t * @elt) => match v37 as v38 in (list _) return (@X.t * @elt) with | nil => v31 | v38 :: v39 => (fun (v38 : @X.t * @elt) (v39 : list (@X.t * @elt)) => v38) v38 v39 end) v35 in (fun v38 : v31 = (v7, v8) => let v39 : v31 = (v7, v8) := v38 in eq_ind_r (fun v40 : @X.t * @elt => forall (v41 : v32 = v9) (v42 : InA (PX.eqke (elt:=@elt)) (v3, v4) v32), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) (fun v40 : v32 = v9 => let v41 : v32 = v9 := v40 in eq_ind_r (fun v42 : list (@X.t * @elt) => forall v43 : InA (PX.eqke (elt:=@elt)) (v3, v4) v42, InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) (fun v42 : InA (PX.eqke (elt:=@elt)) (v3, v4) v9 => InA_cons_tl (v7, v8) (v13 v27 v29 v42)) v41) v39) v37) v36) v34 v33) v31 v32 v33 end in v31 eq_refl) v26) v24) v22) v21) v19 v17 v18) v15 v16 v17 v18 end in v15 eq_refl) : forall (v14 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v15 : ~ X.eq v2 v3) (v16 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) v0 : forall (v6 : Sorted (PX.ltk (elt:=@elt)) v0) (v7 : ~ X.eq v2 v3) (v8 : InA (PX.eqke (elt:=@elt)) (v3, v4) v0), InA (PX.eqke (elt:=@elt)) (v3, v4) v5) : forall (v5 : Sorted (PX.ltk (elt:=@elt)) v0) (v6 : ~ X.eq v2 v3) (v7 : PX.MapsTo v3 v4 v0), PX.MapsTo v3 v4 (remove v2 v0)) v1)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.remove_3	100	0.641107	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (PX.ltk (elt:=@elt)) v0) (v2 : @key) (v3 : @X.t) (v4 : @elt) => ((let v5 : t (@elt) := remove v2 v0 in remove_ind (P:=fun (v6 : list (@X.t * @elt)) (v7 : t (@elt)) => forall (v8 : Sorted (PX.ltk (elt:=@elt)) v6) (v9 : InA (PX.eqke (elt:=@elt)) (v3, v4) v7), InA (PX.eqke (elt:=@elt)) (v3, v4) v6) (fun (v6 : t (@elt)) (v7 : v6 = nil) => (fun (v8 : Sorted (PX.ltk (elt:=@elt)) nil) (v9 : InA (PX.eqke (elt:=@elt)) (v3, v4) nil) => v9) : forall (v8 : Sorted (PX.ltk (elt:=@elt)) nil) (v9 : InA (PX.eqke (elt:=@elt)) (v3, v4) nil), InA (PX.eqke (elt:=@elt)) (v3, v4) nil) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v2 v7) (v12 : X.compare v2 v7 = LT v11) => eq_ind_r (fun v13 : t (@elt) => forall (v14 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v15 : InA (PX.eqke (elt:=@elt)) (v3, v4) v13), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) ((fun (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) => v14) : forall (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) v10) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.eq v2 v7) (v12 : X.compare v2 v7 = EQ v11) => (fun (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : InA (PX.eqke (elt:=@elt)) (v3, v4) v9) => InA_cons_tl (v7, v8) v14) : forall (v13 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v14 : InA (PX.eqke (elt:=@elt)) (v3, v4) v9), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) (fun (v6 : t (@elt)) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v6 = (v7, v8) :: v9) (v11 : X.lt v7 v2) (v12 : X.compare v2 v7 = GT v11) (v13 : forall (v13 : Sorted (PX.ltk (elt:=@elt)) v9) (v14 : InA (PX.eqke (elt:=@elt)) (v3, v4) (remove v2 v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) v9) => (fun v14 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9) => let v15 : forall (v15 : (v7, v8) :: v9 = (v7, v8) :: v9) (v16 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9) := match v14 as v16 in (Sorted _ v15) return (forall (v17 : v15 = (v7, v8) :: v9) (v18 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) with | Sorted_nil _ => fun v15 : nil = (v7, v8) :: v9 => (fun v16 : nil = (v7, v8) :: v9 => let v17 : @False := eq_ind nil (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return Prop with | nil => @True | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => @False) v18 v19 end) (@I) ((v7, v8) :: v9) v16 in False_ind (forall v18 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) v17) v15 | @Sorted_cons _ _ v15 v16 v17 v18 => (fun (v15 : @X.t * @elt) (v16 : list (@X.t * @elt)) (v17 : Sorted (PX.ltk (elt:=@elt)) v16) (v18 : HdRel (PX.ltk (elt:=@elt)) v15 v16) (v19 : v15 :: v16 = (v7, v8) :: v9) => (fun v20 : v15 :: v16 = (v7, v8) :: v9 => let v21 : v16 = v9 := f_equal (fun v21 : list (@X.t * @elt) => match v21 as v22 in (list _) return (list (@X.t * @elt)) with | nil => v16 | v22 :: v23 => (fun (v22 : @X.t * @elt) (v23 : list (@X.t * @elt)) => v23) v22 v23 end) v20 in (let v22 : v15 = (v7, v8) := f_equal (fun v22 : list (@X.t * @elt) => match v22 as v23 in (list _) return (@X.t * @elt) with | nil => v15 | v23 :: v24 => (fun (v23 : @X.t * @elt) (v24 : list (@X.t * @elt)) => v23) v23 v24 end) v20 in (fun v23 : v15 = (v7, v8) => let v24 : v15 = (v7, v8) := v23 in eq_ind_r (fun v25 : @X.t * @elt => forall (v26 : v16 = v9) (v27 : Sorted (PX.ltk (elt:=@elt)) v16) (v28 : HdRel (PX.ltk (elt:=@elt)) v25 v16) (v29 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) (fun v25 : v16 = v9 => let v26 : v16 = v9 := v25 in eq_ind_r (fun v27 : list (@X.t * @elt) => forall (v28 : Sorted (PX.ltk (elt:=@elt)) v27) (v29 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v27) (v30 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) (fun (v27 : Sorted (PX.ltk (elt:=@elt)) v9) (v28 : HdRel (PX.ltk (elt:=@elt)) (v7, v8) v9) (v29 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)) => let v30 : forall v30 : (v7, v8) :: remove v2 v9 = (v7, v8) :: remove v2 v9, InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9) := match v29 as v31 in (InA _ _ v30) return (forall v32 : v30 = (v7, v8) :: remove v2 v9, InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) with | @InA_cons_hd _ _ _ v30 v31 v32 => (fun (v30 : @X.t * @elt) (v31 : list (@X.t * @elt)) (v32 : PX.eqke (v3, v4) v30) (v33 : v30 :: v31 = (v7, v8) :: remove v2 v9) => (fun v34 : v30 :: v31 = (v7, v8) :: remove v2 v9 => let v35 : v31 = remove v2 v9 := f_equal (fun v35 : list (@X.t * @elt) => match v35 as v36 in (list _) return (list (@X.t * @elt)) with | nil => v31 | v36 :: v37 => (fun (v36 : @X.t * @elt) (v37 : list (@X.t * @elt)) => v37) v36 v37 end) v34 in (let v36 : v30 = (v7, v8) := f_equal (fun v36 : list (@X.t * @elt) => match v36 as v37 in (list _) return (@X.t * @elt) with | nil => v30 | v37 :: v38 => (fun (v37 : @X.t * @elt) (v38 : list (@X.t * @elt)) => v37) v37 v38 end) v34 in (fun v37 : v30 = (v7, v8) => let v38 : v30 = (v7, v8) := v37 in eq_ind_r (fun v39 : @X.t * @elt => forall (v40 : v31 = remove v2 v9) (v41 : PX.eqke (v3, v4) v39), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) (fun v39 : v31 = remove v2 v9 => let v40 : v31 = remove v2 v9 := v39 in eq_ind_r (fun v41 : list (@X.t * @elt) => forall v42 : PX.eqke (v3, v4) (v7, v8), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) (fun v41 : PX.eqke (v3, v4) (v7, v8) => InA_cons_hd (eqA:=PX.eqke (elt:=@elt)) (x:=(v3, v4)) (y:=(v7, v8)) v9 v41) v40) v38) v36) v35) v33 v32) v30 v31 v32 | @InA_cons_tl _ _ _ v30 v31 v32 => (fun (v30 : @X.t * @elt) (v31 : list (@X.t * @elt)) (v32 : InA (PX.eqke (elt:=@elt)) (v3, v4) v31) (v33 : v30 :: v31 = (v7, v8) :: remove v2 v9) => (fun v34 : v30 :: v31 = (v7, v8) :: remove v2 v9 => let v35 : v31 = remove v2 v9 := f_equal (fun v35 : list (@X.t * @elt) => match v35 as v36 in (list _) return (list (@X.t * @elt)) with | nil => v31 | v36 :: v37 => (fun (v36 : @X.t * @elt) (v37 : list (@X.t * @elt)) => v37) v36 v37 end) v34 in (let v36 : v30 = (v7, v8) := f_equal (fun v36 : list (@X.t * @elt) => match v36 as v37 in (list _) return (@X.t * @elt) with | nil => v30 | v37 :: v38 => (fun (v37 : @X.t * @elt) (v38 : list (@X.t * @elt)) => v37) v37 v38 end) v34 in (fun v37 : v30 = (v7, v8) => let v38 : v30 = (v7, v8) := v37 in eq_ind_r (fun v39 : @X.t * @elt => forall (v40 : v31 = remove v2 v9) (v41 : InA (PX.eqke (elt:=@elt)) (v3, v4) v31), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) (fun v39 : v31 = remove v2 v9 => let v40 : v31 = remove v2 v9 := v39 in eq_ind_r (fun v41 : list (@X.t * @elt) => forall v42 : InA (PX.eqke (elt:=@elt)) (v3, v4) v41, InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) (fun v41 : InA (PX.eqke (elt:=@elt)) (v3, v4) (remove v2 v9) => InA_cons_tl (v7, v8) (v13 v27 v41)) v40) v38) v36) v35) v33 v32) v30 v31 v32 end in v30 eq_refl) v26) v24) v22) v21) v19 v17 v18) v15 v16 v17 v18 end in v15 eq_refl) : forall (v14 : Sorted (PX.ltk (elt:=@elt)) ((v7, v8) :: v9)) (v15 : InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: remove v2 v9)), InA (PX.eqke (elt:=@elt)) (v3, v4) ((v7, v8) :: v9)) v0 : forall (v6 : Sorted (PX.ltk (elt:=@elt)) v0) (v7 : InA (PX.eqke (elt:=@elt)) (v3, v4) v5), InA (PX.eqke (elt:=@elt)) (v3, v4) v0) : forall (v5 : Sorted (PX.ltk (elt:=@elt)) v0) (v6 : PX.MapsTo v3 v4 (remove v2 v0)), PX.MapsTo v3 v4 v0) v1)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.remove_Inf	100	0.669085	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 : Sorted (PX.ltk (elt:=@elt)) v1) (v3 v4 : @key) (v5 : @elt) (v6 : HdRel (PX.ltk (elt:=@elt)) (v4, v5) v1), HdRel (PX.ltk (elt:=@elt)) (v4, v5) (remove v3 v1)) ((fun (v1 : Sorted (PX.ltk (elt:=@elt)) nil) (v2 v3 : @key) (v4 : @elt) (v5 : HdRel (PX.ltk (elt:=@elt)) (v3, v4) nil) => v5) : forall (v1 : Sorted (PX.ltk (elt:=@elt)) nil) (v2 v3 : @key) (v4 : @elt) (v5 : HdRel (PX.ltk (elt:=@elt)) (v3, v4) nil), HdRel (PX.ltk (elt:=@elt)) (v3, v4) (remove v2 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 : Sorted (PX.ltk (elt:=@elt)) v2) (v4 v5 : @key) (v6 : @elt) (v7 : HdRel (PX.ltk (elt:=@elt)) (v5, v6) v2), HdRel (PX.ltk (elt:=@elt)) (v5, v6) (remove v4 v2)) (v4 : Sorted (PX.ltk (elt:=@elt)) (v1 :: v2)) (v5 v6 : @key) (v7 : @elt) (v8 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) (v1 :: v2)) => match v1 as v9 in (_ * _)%type return (forall (v10 : Sorted (PX.ltk (elt:=@elt)) (v9 :: v2)) (v11 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) (v9 :: v2)), HdRel (PX.ltk (elt:=@elt)) (v6, v7) (remove v5 (v9 :: v2))) with | (v9, v10) => (fun (v9 : @X.t) (v10 : @elt) (v11 : Sorted (PX.ltk (elt:=@elt)) ((v9, v10) :: v2)) (v12 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) ((v9, v10) :: v2)) => let v13 : forall v13 : (v9, v10) :: v2 = (v9, v10) :: v2, HdRel (PX.ltk (elt:=@elt)) (v6, v7) (remove v5 ((v9, v10) :: v2)) := match v12 as v14 in (HdRel _ _ v13) return (forall v15 : v13 = (v9, v10) :: v2, HdRel (PX.ltk (elt:=@elt)) (v6, v7) (remove v5 ((v9, v10) :: v2))) with | HdRel_nil _ _ => fun v13 : nil = (v9, v10) :: v2 => (fun v14 : nil = (v9, v10) :: v2 => let v15 : @False := eq_ind nil (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return Prop with | nil => @True | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => @False) v16 v17 end) (@I) ((v9, v10) :: v2) v14 in False_ind (HdRel (PX.ltk (elt:=@elt)) (v6, v7) (remove v5 ((v9, v10) :: v2))) v15) v13 | HdRel_cons _ _ v13 v14 v15 => (fun (v13 : @X.t * @elt) (v14 : list (@X.t * @elt)) (v15 : PX.ltk (v6, v7) v13) (v16 : v13 :: v14 = (v9, v10) :: v2) => (fun v17 : v13 :: v14 = (v9, v10) :: v2 => let v18 : v14 = v2 := f_equal (fun v18 : list (@X.t * @elt) => match v18 as v19 in (list _) return (list (@X.t * @elt)) with | nil => v14 | v19 :: v20 => (fun (v19 : @X.t * @elt) (v20 : list (@X.t * @elt)) => v20) v19 v20 end) v17 in (let v19 : v13 = (v9, v10) := f_equal (fun v19 : list (@X.t * @elt) => match v19 as v20 in (list _) return (@X.t * @elt) with | nil => v13 | v20 :: v21 => (fun (v20 : @X.t * @elt) (v21 : list (@X.t * @elt)) => v20) v20 v21 end) v17 in (fun v20 : v13 = (v9, v10) => let v21 : v13 = (v9, v10) := v20 in eq_ind_r (fun v22 : @X.t * @elt => forall (v23 : v14 = v2) (v24 : PX.ltk (v6, v7) v22), HdRel (PX.ltk (elt:=@elt)) (v6, v7) (remove v5 ((v9, v10) :: v2))) (fun v22 : v14 = v2 => let v23 : v14 = v2 := v22 in eq_ind_r (fun v24 : list (@X.t * @elt) => forall v25 : PX.ltk (v6, v7) (v9, v10), HdRel (PX.ltk (elt:=@elt)) (v6, v7) (remove v5 ((v9, v10) :: v2))) (fun v24 : PX.ltk (v6, v7) (v9, v10) => match X.compare v5 v9 as v25 in (Compare _ _ _ _) return (HdRel (PX.ltk (elt:=@elt)) (v6, v7) match v25 as v26 in (Compare _ _ _ _) return (t (@elt)) with | LT v26 => (fun v26 : X.lt v5 v9 => (v9, v10) :: v2) v26 | EQ v26 => (fun v26 : X.eq v5 v9 => v2) v26 | GT v26 => (fun v26 : X.lt v9 v5 => (v9, v10) :: remove v5 v2) v26 end) with | LT v25 => (fun v25 : X.lt v5 v9 => HdRel_cons (PX.ltk (elt:=@elt)) (v6, v7) (v9, v10) v2 v24 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) ((v9, v10) :: v2)) v25 | EQ v25 => (fun v25 : X.eq v5 v9 => let v26 : forall v26 : (v9, v10) :: v2 = (v9, v10) :: v2, HdRel (PX.ltk (elt:=@elt)) (v6, v7) v2 := match v11 as v27 in (Sorted _ v26) return (forall v28 : v26 = (v9, v10) :: v2, HdRel (PX.ltk (elt:=@elt)) (v6, v7) v2) with | Sorted_nil _ => fun v26 : nil = (v9, v10) :: v2 => (fun v27 : nil = (v9, v10) :: v2 => let v28 : @False := eq_ind nil (fun v28 : list (@X.t * @elt) => match v28 as v29 in (list _) return Prop with | nil => @True | v29 :: v30 => (fun (v29 : @X.t * @elt) (v30 : list (@X.t * @elt)) => @False) v29 v30 end) (@I) ((v9, v10) :: v2) v27 in False_ind (HdRel (PX.ltk (elt:=@elt)) (v6, v7) v2) v28) v26 | @Sorted_cons _ _ v26 v27 v28 v29 => (fun (v26 : @X.t * @elt) (v27 : list (@X.t * @elt)) (v28 : Sorted (PX.ltk (elt:=@elt)) v27) (v29 : HdRel (PX.ltk (elt:=@elt)) v26 v27) (v30 : v26 :: v27 = (v9, v10) :: v2) => (fun v31 : v26 :: v27 = (v9, v10) :: v2 => let v32 : v27 = v2 := f_equal (fun v32 : list (@X.t * @elt) => match v32 as v33 in (list _) return (list (@X.t * @elt)) with | nil => v27 | v33 :: v34 => (fun (v33 : @X.t * @elt) (v34 : list (@X.t * @elt)) => v34) v33 v34 end) v31 in (let v33 : v26 = (v9, v10) := f_equal (fun v33 : list (@X.t * @elt) => match v33 as v34 in (list _) return (@X.t * @elt) with | nil => v26 | v34 :: v35 => (fun (v34 : @X.t * @elt) (v35 : list (@X.t * @elt)) => v34) v34 v35 end) v31 in (fun v34 : v26 = (v9, v10) => let v35 : v26 = (v9, v10) := v34 in eq_ind_r (fun v36 : @X.t * @elt => forall (v37 : v27 = v2) (v38 : Sorted (PX.ltk (elt:=@elt)) v27) (v39 : HdRel (PX.ltk (elt:=@elt)) v36 v27), HdRel (PX.ltk (elt:=@elt)) (v6, v7) v2) (fun v36 : v27 = v2 => let v37 : v27 = v2 := v36 in eq_ind_r (fun v38 : list (@X.t * @elt) => forall (v39 : Sorted (PX.ltk (elt:=@elt)) v38) (v40 : HdRel (PX.ltk (elt:=@elt)) (v9, v10) v38), HdRel (PX.ltk (elt:=@elt)) (v6, v7) v2) (fun (v38 : Sorted (PX.ltk (elt:=@elt)) v2) (v39 : HdRel (PX.ltk (elt:=@elt)) (v9, v10) v2) => Inf_lt (x:=(v6, v7)) v24 v39) v37) v35) v33) v32) v30 v28 v29) v26 v27 v28 v29 end in v26 eq_refl) v25 | GT v25 => (fun v25 : X.lt v9 v5 => HdRel_cons (PX.ltk (elt:=@elt)) (v6, v7) (v9, v10) (remove v5 v2) v24 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) ((v9, v10) :: remove v5 v2)) v25 end : HdRel (PX.ltk (elt:=@elt)) (v6, v7) (remove v5 ((v9, v10) :: v2))) v23) v21) v19) v18) v16 v15) v13 v14 v15 end in v13 eq_refl) v9 v10 end v4 v8) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.remove_sorted	100	0.483753	1	1	0	synth with cache (only 1: refine (fun v0 : list (@X.t * @elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 : Sorted (PX.ltk (elt:=@elt)) v1) (v3 : @key), Sorted (PX.ltk (elt:=@elt)) (remove v3 v1)) ((fun (v1 : Sorted (PX.ltk (elt:=@elt)) nil) (v2 : @key) => v1) : forall (v1 : Sorted (PX.ltk (elt:=@elt)) nil) (v2 : @key), Sorted (PX.ltk (elt:=@elt)) (remove v2 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 : Sorted (PX.ltk (elt:=@elt)) v2) (v4 : @key), Sorted (PX.ltk (elt:=@elt)) (remove v4 v2)) (v4 : Sorted (PX.ltk (elt:=@elt)) (v1 :: v2)) (v5 : @key) => match v1 as v6 in (_ * _)%type return (forall v7 : Sorted (PX.ltk (elt:=@elt)) (v6 :: v2), Sorted (PX.ltk (elt:=@elt)) (remove v5 (v6 :: v2))) with | (v6, v7) => (fun (v6 : @X.t) (v7 : @elt) (v8 : Sorted (PX.ltk (elt:=@elt)) ((v6, v7) :: v2)) => match X.compare v5 v6 as v9 in (Compare _ _ _ _) return (Sorted (PX.ltk (elt:=@elt)) match v9 as v10 in (Compare _ _ _ _) return (t (@elt)) with | LT v10 => (fun v10 : X.lt v5 v6 => (v6, v7) :: v2) v10 | EQ v10 => (fun v10 : X.eq v5 v6 => v2) v10 | GT v10 => (fun v10 : X.lt v6 v5 => (v6, v7) :: remove v5 v2) v10 end) with | LT v9 => (fun v9 : X.lt v5 v6 => v8) v9 | EQ v9 => (fun v9 : X.eq v5 v6 => let v10 : forall v10 : (v6, v7) :: v2 = (v6, v7) :: v2, Sorted (PX.ltk (elt:=@elt)) v2 := match v8 as v11 in (Sorted _ v10) return (forall v12 : v10 = (v6, v7) :: v2, Sorted (PX.ltk (elt:=@elt)) v2) with | Sorted_nil _ => fun v10 : nil = (v6, v7) :: v2 => (fun v11 : nil = (v6, v7) :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t * @elt) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t * @elt) (v14 : list (@X.t * @elt)) => @False) v13 v14 end) (@I) ((v6, v7) :: v2) v11 in False_ind (Sorted (PX.ltk (elt:=@elt)) v2) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t * @elt) (v11 : list (@X.t * @elt)) (v12 : Sorted (PX.ltk (elt:=@elt)) v11) (v13 : HdRel (PX.ltk (elt:=@elt)) v10 v11) (v14 : v10 :: v11 = (v6, v7) :: v2) => (fun v15 : v10 :: v11 = (v6, v7) :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (list (@X.t * @elt)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v18) v17 v18 end) v15 in (let v17 : v10 = (v6, v7) := f_equal (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return (@X.t * @elt) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => v18) v18 v19 end) v15 in (fun v18 : v10 = (v6, v7) => let v19 : v10 = (v6, v7) := v18 in eq_ind_r (fun v20 : @X.t * @elt => forall (v21 : v11 = v2) (v22 : Sorted (PX.ltk (elt:=@elt)) v11) (v23 : HdRel (PX.ltk (elt:=@elt)) v20 v11), Sorted (PX.ltk (elt:=@elt)) v2) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t * @elt) => forall (v23 : Sorted (PX.ltk (elt:=@elt)) v22) (v24 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) v22), Sorted (PX.ltk (elt:=@elt)) v2) (fun (v22 : Sorted (PX.ltk (elt:=@elt)) v2) (v23 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) v2) => v22) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 eq_refl) v9 | GT v9 => (fun v9 : X.lt v6 v5 => let v10 : forall v10 : (v6, v7) :: v2 = (v6, v7) :: v2, Sorted (PX.ltk (elt:=@elt)) ((v6, v7) :: remove v5 v2) := match v8 as v11 in (Sorted _ v10) return (forall v12 : v10 = (v6, v7) :: v2, Sorted (PX.ltk (elt:=@elt)) ((v6, v7) :: remove v5 v2)) with | Sorted_nil _ => fun v10 : nil = (v6, v7) :: v2 => (fun v11 : nil = (v6, v7) :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t * @elt) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t * @elt) (v14 : list (@X.t * @elt)) => @False) v13 v14 end) (@I) ((v6, v7) :: v2) v11 in False_ind (Sorted (PX.ltk (elt:=@elt)) ((v6, v7) :: remove v5 v2)) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t * @elt) (v11 : list (@X.t * @elt)) (v12 : Sorted (PX.ltk (elt:=@elt)) v11) (v13 : HdRel (PX.ltk (elt:=@elt)) v10 v11) (v14 : v10 :: v11 = (v6, v7) :: v2) => (fun v15 : v10 :: v11 = (v6, v7) :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (list (@X.t * @elt)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v18) v17 v18 end) v15 in (let v17 : v10 = (v6, v7) := f_equal (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return (@X.t * @elt) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => v18) v18 v19 end) v15 in (fun v18 : v10 = (v6, v7) => let v19 : v10 = (v6, v7) := v18 in eq_ind_r (fun v20 : @X.t * @elt => forall (v21 : v11 = v2) (v22 : Sorted (PX.ltk (elt:=@elt)) v11) (v23 : HdRel (PX.ltk (elt:=@elt)) v20 v11), Sorted (PX.ltk (elt:=@elt)) ((v6, v7) :: remove v5 v2)) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t * @elt) => forall (v23 : Sorted (PX.ltk (elt:=@elt)) v22) (v24 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) v22), Sorted (PX.ltk (elt:=@elt)) ((v6, v7) :: remove v5 v2)) (fun (v22 : Sorted (PX.ltk (elt:=@elt)) v2) (v23 : HdRel (PX.ltk (elt:=@elt)) (v6, v7) v2) => Sorted_cons (v3 v22 v5) (remove_Inf v22 v5 v23)) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 eq_refl) v9 end : Sorted (PX.ltk (elt:=@elt)) (remove v5 ((v6, v7) :: v2))) v6 v7 end v4) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.elements_1	100	0.043774	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : @X.t) (v2 : @elt) (v3 : PX.MapsTo v1 v2 v0) => v3)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.elements_2	100	0.043596	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 : @X.t) (v2 : @elt) (v3 : InA (PX.eqke (elt:=@elt)) (v1, v2) (elements v0)) => v3)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.elements_3	100	0.042444	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (PX.ltk (elt:=@elt)) v0) => v1)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.elements_3w	100	0.042788	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (PX.ltk (elt:=@elt)) v0) => Sort_NoDupA (elements_3 v1))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.fold_1	100	0.096191	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 : Type) (v2 : v1) (v3 : forall (v3 : @key) (v4 : @elt) (v5 : v1), v1) => let v4 : v1 := fold v3 v0 v2 in fold_ind (f:=v3) (P:=fun (v5 : t (@elt)) (v6 v7 : v1) => v7 = fold_left (fun (v8 : v1) (v9 : @key * @elt) => v3 (fst v9) (snd v9) v8) (elements v5) v6) (fun (v5 : t (@elt)) (v6 : v1) (v7 : v5 = nil) => eq_refl : v6 = fold_left (fun (v8 : v1) (v9 : @key * @elt) => v3 (fst v9) (snd v9) v8) (elements nil) v6) (fun (v5 : t (@elt)) (v6 : v1) (v7 : @X.t) (v8 : @elt) (v9 : list (@X.t * @elt)) (v10 : v5 = (v7, v8) :: v9) (v11 : fold v3 v9 (v3 v7 v8 v6) = fold_left (fun (v11 : v1) (v12 : @key * @elt) => v3 (fst v12) (snd v12) v11) (elements v9) (v3 v7 v8 v6)) => v11 : fold v3 v9 (v3 v7 v8 v6) = fold_left (fun (v12 : v1) (v13 : @key * @elt) => v3 (fst v13) (snd v13) v12) (elements ((v7, v8) :: v9)) v6) v0 v2 : v4 = fold_left (fun (v5 : v1) (v6 : @key * @elt) => v3 (fst v6) (snd v6) v5) (elements v0) v2)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.equal_1	100	2.958000	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.equal_2	100	2.502346	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt.equal_cons	100	0.602031	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 v1 : @elt, @bool) (v1 v2 : list (@X.t * @elt)) (v3 v4 : @X.t * @elt) (v5 : Sorted (PX.ltk (elt:=@elt)) (v3 :: v1)) (v6 : Sorted (PX.ltk (elt:=@elt)) (v4 :: v2)) (v7 : PX.eqk v3 v4) (v8 : v0 (snd v3) (snd v4) = @true) => let v9 : forall v9 : v3 :: v1 = v3 :: v1, Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2) := match v5 as v10 in (Sorted _ v9) return (forall v11 : v9 = v3 :: v1, Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) with | Sorted_nil _ => fun v9 : nil = v3 :: v1 => (fun v10 : nil = v3 :: v1 => let v11 : @False := eq_ind nil (fun v11 : list (@X.t * @elt) => match v11 as v12 in (list _) return Prop with | nil => @True | v12 :: v13 => (fun (v12 : @X.t * @elt) (v13 : list (@X.t * @elt)) => @False) v12 v13 end) (@I) (v3 :: v1) v10 in False_ind (Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) v11) v9 | @Sorted_cons _ _ v9 v10 v11 v12 => (fun (v9 : @X.t * @elt) (v10 : list (@X.t * @elt)) (v11 : Sorted (PX.ltk (elt:=@elt)) v10) (v12 : HdRel (PX.ltk (elt:=@elt)) v9 v10) (v13 : v9 :: v10 = v3 :: v1) => (fun v14 : v9 :: v10 = v3 :: v1 => let v15 : v10 = v1 := f_equal (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return (list (@X.t * @elt)) with | nil => v10 | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => v17) v16 v17 end) v14 in (let v16 : v9 = v3 := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (@X.t * @elt) with | nil => v9 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v17) v17 v18 end) v14 in (fun v17 : v9 = v3 => let v18 : v9 = v3 := v17 in eq_ind_r (fun v19 : @X.t * @elt => forall (v20 : v10 = v1) (v21 : Sorted (PX.ltk (elt:=@elt)) v10) (v22 : HdRel (PX.ltk (elt:=@elt)) v19 v10), Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) (fun v19 : v10 = v1 => let v20 : v10 = v1 := v19 in eq_ind_r (fun v21 : list (@X.t * @elt) => forall (v22 : Sorted (PX.ltk (elt:=@elt)) v21) (v23 : HdRel (PX.ltk (elt:=@elt)) v3 v21), Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) (fun (v21 : Sorted (PX.ltk (elt:=@elt)) v1) (v22 : HdRel (PX.ltk (elt:=@elt)) v3 v1) => let v23 : forall v23 : v4 :: v2 = v4 :: v2, Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2) := match v6 as v24 in (Sorted _ v23) return (forall v25 : v23 = v4 :: v2, Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) with | Sorted_nil _ => fun v23 : nil = v4 :: v2 => (fun v24 : nil = v4 :: v2 => let v25 : @False := eq_ind nil (fun v25 : list (@X.t * @elt) => match v25 as v26 in (list _) return Prop with | nil => @True | v26 :: v27 => (fun (v26 : @X.t * @elt) (v27 : list (@X.t * @elt)) => @False) v26 v27 end) (@I) (v4 :: v2) v24 in False_ind (Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) v25) v23 | @Sorted_cons _ _ v23 v24 v25 v26 => (fun (v23 : @X.t * @elt) (v24 : list (@X.t * @elt)) (v25 : Sorted (PX.ltk (elt:=@elt)) v24) (v26 : HdRel (PX.ltk (elt:=@elt)) v23 v24) (v27 : v23 :: v24 = v4 :: v2) => (fun v28 : v23 :: v24 = v4 :: v2 => let v29 : v24 = v2 := f_equal (fun v29 : list (@X.t * @elt) => match v29 as v30 in (list _) return (list (@X.t * @elt)) with | nil => v24 | v30 :: v31 => (fun (v30 : @X.t * @elt) (v31 : list (@X.t * @elt)) => v31) v30 v31 end) v28 in (let v30 : v23 = v4 := f_equal (fun v30 : list (@X.t * @elt) => match v30 as v31 in (list _) return (@X.t * @elt) with | nil => v23 | v31 :: v32 => (fun (v31 : @X.t * @elt) (v32 : list (@X.t * @elt)) => v31) v31 v32 end) v28 in (fun v31 : v23 = v4 => let v32 : v23 = v4 := v31 in eq_ind_r (fun v33 : @X.t * @elt => forall (v34 : v24 = v2) (v35 : Sorted (PX.ltk (elt:=@elt)) v24) (v36 : HdRel (PX.ltk (elt:=@elt)) v33 v24), Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) (fun v33 : v24 = v2 => let v34 : v24 = v2 := v33 in eq_ind_r (fun v35 : list (@X.t * @elt) => forall (v36 : Sorted (PX.ltk (elt:=@elt)) v35) (v37 : HdRel (PX.ltk (elt:=@elt)) v4 v35), Equivb v0 v1 v2 <-> Equivb v0 (v3 :: v1) (v4 :: v2)) (fun (v35 : Sorted (PX.ltk (elt:=@elt)) v2) (v36 : HdRel (PX.ltk (elt:=@elt)) v4 v2) => match v3 as v37 in (_ * _)%type return (forall (v38 : Sorted (PX.ltk (elt:=@elt)) (v37 :: v1)) (v39 : PX.eqk v37 v4) (v40 : v0 (snd v37) (snd v4) = @true) (v41 : HdRel (PX.ltk (elt:=@elt)) v37 v1), Equivb v0 v1 v2 <-> Equivb v0 (v37 :: v1) (v4 :: v2)) with | (v37, v38) => (fun (v37 : @X.t) (v38 : @elt) (v39 : Sorted (PX.ltk (elt:=@elt)) ((v37, v38) :: v1)) (v40 : PX.eqk (v37, v38) v4) (v41 : v0 (snd (v37, v38)) (snd v4) = @true) (v42 : HdRel (PX.ltk (elt:=@elt)) (v37, v38) v1) => match v4 as v43 in (_ * _)%type return (forall (v44 : Sorted (PX.ltk (elt:=@elt)) (v43 :: v2)) (v45 : PX.eqk (v37, v38) v43) (v46 : v0 (snd (v37, v38)) (snd v43) = @true) (v47 : HdRel (PX.ltk (elt:=@elt)) v43 v2), Equivb v0 v1 v2 <-> Equivb v0 ((v37, v38) :: v1) (v43 :: v2)) with | (v43, v44) => (fun (v43 : @X.t) (v44 : @elt) (v45 : Sorted (PX.ltk (elt:=@elt)) ((v43, v44) :: v2)) (v46 : PX.eqk (v37, v38) (v43, v44)) (v47 : v0 (snd (v37, v38)) (snd (v43, v44)) = @true) (v48 : HdRel (PX.ltk (elt:=@elt)) (v43, v44) v2) => conj (fun v49 : Equivb v0 v1 v2 => equal_2 v39 v45 (cmp:=v0) ((let v50 : Compare (@X.lt) (@X.eq) v37 v43 := X.compare v37 v43 in match v50 as v51 in (Compare _ _ _ _) return (match v51 as v52 in (Compare _ _ _ _) return (@bool) with | LT v52 => (fun v52 : X.lt v37 v43 => @false) v52 | EQ v52 => (fun v52 : X.eq v37 v43 => v0 v38 v44 && equal v0 v1 v2) v52 | GT v52 => (fun v52 : X.lt v43 v37 => @false) v52 end = @true) with | LT v51 => (fun v51 : X.lt v37 v43 => False_ind (@false = @true) ((fun v52 : TO.lt v43 v43 => OrderTac.lt_irrefl v52) (OrderTac.eq_lt (OrderTac.eq_sym v46) v51))) v51 | EQ v51 => (fun v51 : X.eq v37 v43 => eq_ind_r (fun v52 : @bool => v52 && equal v0 v1 v2 = @true) (equal_1 v21 v35 (cmp:=v0) v49 : @true && equal v0 v1 v2 = @true) v47) v51 | GT v51 => (fun v51 : X.lt v43 v37 => False_ind (@false = @true) ((fun v52 : TO.lt v43 v43 => OrderTac.lt_irrefl v52) (OrderTac.lt_eq v51 v46))) v51 end) : equal v0 ((v37, v38) :: v1) ((v43, v44) :: v2) = @true)) (fun v49 : Equivb v0 ((v37, v38) :: v1) ((v43, v44) :: v2) => equal_2 v21 v35 (cmp:=v0) (((let v50 : Compare (@X.lt) (@X.eq) v37 v43 := X.compare v37 v43 in match v50 as v51 in (Compare _ _ _ _) return (forall v52 : match v51 as v52 in (Compare _ _ _ _) return (@bool) with | LT v52 => (fun v52 : X.lt v37 v43 => @false) v52 | EQ v52 => (fun v52 : X.eq v37 v43 => v0 v38 v44 && equal v0 v1 v2) v52 | GT v52 => (fun v52 : X.lt v43 v37 => @false) v52 end = @true, equal v0 v1 v2 = @true) with | LT v51 => (fun (v51 : X.lt v37 v43) (v52 : @false = @true) => False_ind (equal v0 v1 v2 = @true) ((fun v53 : TO.lt v43 v43 => OrderTac.lt_irrefl v53) (OrderTac.eq_lt (OrderTac.eq_sym v46) v51))) v51 | EQ v51 => (fun v51 : X.eq v37 v43 => eq_ind_r (fun v52 : @bool => forall v53 : v52 && equal v0 v1 v2 = @true, equal v0 v1 v2 = @true) ((fun v52 : equal v0 v1 v2 = @true => v52) : forall v52 : @true && equal v0 v1 v2 = @true, equal v0 v1 v2 = @true) v47) v51 | GT v51 => (fun (v51 : X.lt v43 v37) (v52 : @false = @true) => False_ind (equal v0 v1 v2 = @true) ((fun v53 : TO.lt v43 v43 => OrderTac.lt_irrefl v53) (OrderTac.lt_eq v51 v46))) v51 end) : forall v50 : equal v0 ((v37, v38) :: v1) ((v43, v44) :: v2) = @true, equal v0 v1 v2 = @true) (equal_1 v39 v45 (cmp:=v0) v49)))) v43 v44 end v6 v40 v41 v36) v37 v38 end v5 v7 v8 v22) v34) v32) v30) v29) v27 v25 v26) v23 v24 v25 v26 end in v23 eq_refl) v20) v18) v16) v15) v13 v11 v12) v9 v10 v11 v12 end in v9 eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.map_1	100	0.429766	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 : @key) (v2 : @elt) (v3 : forall v3 : @elt, @elt') => list_ind (fun v4 : list (@X.t * @elt) => forall v5 : MapsTo v1 v2 v4, MapsTo v1 (v3 v2) (map v3 v4)) (fun v4 : MapsTo v1 v2 nil => let v5 : forall v5 : nil = nil, MapsTo v1 (v3 v2) (map v3 nil) := match v4 as v6 in (InA _ _ v5) return (forall v7 : v5 = nil, MapsTo v1 (v3 v2) (map v3 nil)) with | @InA_cons_hd _ _ _ v5 v6 v7 => (fun (v5 : @X.t * @elt) (v6 : list (@X.t * @elt)) (v7 : eqke (v1, v2) v5) (v8 : v5 :: v6 = nil) => (fun v9 : v5 :: v6 = nil => let v10 : @False := eq_ind (v5 :: v6) (fun v10 : list (@X.t * @elt) => match v10 as v11 in (list _) return Prop with | nil => @False | v11 :: v12 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) => @True) v11 v12 end) (@I) nil v9 in False_ind (forall v11 : eqke (v1, v2) v5, MapsTo v1 (v3 v2) (map v3 nil)) v10) v8 v7) v5 v6 v7 | @InA_cons_tl _ _ _ v5 v6 v7 => (fun (v5 : @X.t * @elt) (v6 : list (@X.t * @elt)) (v7 : InA (eqke (elt:=@elt)) (v1, v2) v6) (v8 : v5 :: v6 = nil) => (fun v9 : v5 :: v6 = nil => let v10 : @False := eq_ind (v5 :: v6) (fun v10 : list (@X.t * @elt) => match v10 as v11 in (list _) return Prop with | nil => @False | v11 :: v12 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) => @True) v11 v12 end) (@I) nil v9 in False_ind (forall v11 : InA (eqke (elt:=@elt)) (v1, v2) v6, MapsTo v1 (v3 v2) (map v3 nil)) v10) v8 v7) v5 v6 v7 end in v5 eq_refl) (fun (v4 : @X.t * @elt) (v5 : list (@X.t * @elt)) (v6 : forall v6 : MapsTo v1 v2 v5, MapsTo v1 (v3 v2) (map v3 v5)) => match v4 as v7 in (_ * _)%type return (forall v8 : MapsTo v1 v2 (v7 :: v5), MapsTo v1 (v3 v2) (map v3 (v7 :: v5))) with | (v7, v8) => (fun (v7 : @X.t) (v8 : @elt) => (fun v9 : MapsTo v1 v2 ((v7, v8) :: v5) => let v10 : forall v10 : (v7, v8) :: v5 = (v7, v8) :: v5, MapsTo v1 (v3 v2) ((v7, v3 v8) :: map v3 v5) := match v9 as v11 in (InA _ _ v10) return (forall v12 : v10 = (v7, v8) :: v5, MapsTo v1 (v3 v2) ((v7, v3 v8) :: map v3 v5)) with | @InA_cons_hd _ _ _ v10 v11 v12 => (fun (v10 : @X.t * @elt) (v11 : list (@X.t * @elt)) (v12 : eqke (v1, v2) v10) (v13 : v10 :: v11 = (v7, v8) :: v5) => (fun v14 : v10 :: v11 = (v7, v8) :: v5 => let v15 : v11 = v5 := f_equal (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return (list (@X.t * @elt)) with | nil => v11 | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => v17) v16 v17 end) v14 in (let v16 : v10 = (v7, v8) := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (@X.t * @elt) with | nil => v10 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v17) v17 v18 end) v14 in (fun v17 : v10 = (v7, v8) => let v18 : v10 = (v7, v8) := v17 in eq_ind_r (fun v19 : @X.t * @elt => forall (v20 : v11 = v5) (v21 : eqke (v1, v2) v19), MapsTo v1 (v3 v2) ((v7, v3 v8) :: map v3 v5)) (fun v19 : v11 = v5 => let v20 : v11 = v5 := v19 in eq_ind_r (fun v21 : list (@X.t * @elt) => forall v22 : eqke (v1, v2) (v7, v8), MapsTo v1 (v3 v2) ((v7, v3 v8) :: map v3 v5)) (fun v21 : eqke (v1, v2) (v7, v8) => InA_cons_hd (eqA:=eqke (elt:=@elt')) (x:=(v1, v3 v2)) (y:=(v7, v3 v8)) (map v3 v5) ((and_ind (fun (v22 : X.eq v1 v7) (v23 : v2 = v8) => conj v22 (eq_trans (f_equal (fun v24 : forall v24 : @elt, @elt' => v24 v2) eq_refl) (f_equal v3 v23) : v3 v2 = v3 v8)) v21 : X.eq (fst (v1, v3 v2)) (fst (v7, v3 v8)) /\ snd (v1, v3 v2) = snd (v7, v3 v8)) : eqke (v1, v3 v2) (v7, v3 v8))) v20) v18) v16) v15) v13 v12) v10 v11 v12 | @InA_cons_tl _ _ _ v10 v11 v12 => (fun (v10 : @X.t * @elt) (v11 : list (@X.t * @elt)) (v12 : InA (eqke (elt:=@elt)) (v1, v2) v11) (v13 : v10 :: v11 = (v7, v8) :: v5) => (fun v14 : v10 :: v11 = (v7, v8) :: v5 => let v15 : v11 = v5 := f_equal (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return (list (@X.t * @elt)) with | nil => v11 | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => v17) v16 v17 end) v14 in (let v16 : v10 = (v7, v8) := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (@X.t * @elt) with | nil => v10 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v17) v17 v18 end) v14 in (fun v17 : v10 = (v7, v8) => let v18 : v10 = (v7, v8) := v17 in eq_ind_r (fun v19 : @X.t * @elt => forall (v20 : v11 = v5) (v21 : InA (eqke (elt:=@elt)) (v1, v2) v11), MapsTo v1 (v3 v2) ((v7, v3 v8) :: map v3 v5)) (fun v19 : v11 = v5 => let v20 : v11 = v5 := v19 in eq_ind_r (fun v21 : list (@X.t * @elt) => forall v22 : InA (eqke (elt:=@elt)) (v1, v2) v21, MapsTo v1 (v3 v2) ((v7, v3 v8) :: map v3 v5)) (fun v21 : InA (eqke (elt:=@elt)) (v1, v2) v5 => InA_cons_tl (v7, v3 v8) (v6 v21) : MapsTo v1 (v3 v2) ((v7, v3 v8) :: map v3 v5)) v20) v18) v16) v15) v13 v12) v10 v11 v12 end in v10 eq_refl) : forall v9 : MapsTo v1 v2 ((v7, v8) :: v5), MapsTo v1 (v3 v2) (map v3 ((v7, v8) :: v5))) v7 v8 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.map_2	100	0.800805	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 : @key) (v2 : forall v2 : @elt, @elt') => list_ind (fun v3 : list (@X.t * @elt) => forall v4 : In v1 (map v2 v3), In v1 v3) ((fun v3 : In v1 nil => match v3 as v4 in (ex _) return (In v1 nil) with | ex_intro _ v4 v5 => (fun (v4 : @elt') (v5 : MapsTo v1 v4 nil) => let v6 : forall v6 : nil = nil, In v1 nil := match v5 as v7 in (InA _ _ v6) return (forall v8 : v6 = nil, In v1 nil) with | @InA_cons_hd _ _ _ v6 v7 v8 => (fun (v6 : @X.t * @elt') (v7 : list (@X.t * @elt')) (v8 : eqke (v1, v4) v6) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t * @elt') => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : eqke (v1, v4) v6, In v1 nil) v11) v9 v8) v6 v7 v8 | @InA_cons_tl _ _ _ v6 v7 v8 => (fun (v6 : @X.t * @elt') (v7 : list (@X.t * @elt')) (v8 : InA (eqke (elt:=@elt')) (v1, v4) v7) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t * @elt') => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : InA (eqke (elt:=@elt')) (v1, v4) v7, In v1 nil) v11) v9 v8) v6 v7 v8 end in v6 eq_refl) v4 v5 end) : forall v3 : In v1 (map v2 nil), In v1 nil) (fun (v3 : @X.t * @elt) (v4 : list (@X.t * @elt)) (v5 : forall v5 : In v1 (map v2 v4), In v1 v4) => match v3 as v6 in (_ * _)%type return (forall v7 : In v1 match v6 as v7 in (_ * _)%type return (t (@elt')) with | (v7, v8) => (fun (v7 : @X.t) (v8 : @elt) => (v7, v2 v8) :: map v2 v4) v7 v8 end, In v1 (v6 :: v4)) with | (v6, v7) => (fun (v6 : @X.t) (v7 : @elt) (v8 : In v1 ((v6, v2 v7) :: map v2 v4)) => let v9 : In v1 ((v6, v7) :: v4) := match v8 as v9 in (ex _) return (In v1 ((v6, v7) :: v4)) with | ex_intro _ v9 v10 => (fun (v9 : @elt') (v10 : MapsTo v1 v9 ((v6, v2 v7) :: map v2 v4)) => (fun v11 : MapsTo v1 v9 ((v6, v2 v7) :: map v2 v4) => let v12 : forall v12 : (v6, v2 v7) :: map v2 v4 = (v6, v2 v7) :: map v2 v4, In v1 ((v6, v7) :: v4) := match v11 as v13 in (InA _ _ v12) return (forall v14 : v12 = (v6, v2 v7) :: map v2 v4, In v1 ((v6, v7) :: v4)) with | @InA_cons_hd _ _ _ v12 v13 v14 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) (v14 : eqke (v1, v9) v12) (v15 : v12 :: v13 = (v6, v2 v7) :: map v2 v4) => (fun v16 : v12 :: v13 = (v6, v2 v7) :: map v2 v4 => let v17 : v13 = map v2 v4 := f_equal (fun v17 : list (@X.t * @elt') => match v17 as v18 in (list _) return (list (@X.t * @elt')) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t * @elt') (v19 : list (@X.t * @elt')) => v19) v18 v19 end) v16 in (let v18 : v12 = (v6, v2 v7) := f_equal (fun v18 : list (@X.t * @elt') => match v18 as v19 in (list _) return (@X.t * @elt') with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t * @elt') (v20 : list (@X.t * @elt')) => v19) v19 v20 end) v16 in (fun v19 : v12 = (v6, v2 v7) => let v20 : v12 = (v6, v2 v7) := v19 in eq_ind_r (fun v21 : @X.t * @elt' => forall (v22 : v13 = map v2 v4) (v23 : eqke (v1, v9) v21), In v1 ((v6, v7) :: v4)) (fun v21 : v13 = map v2 v4 => let v22 : v13 = map v2 v4 := v21 in eq_ind_r (fun v23 : list (@X.t * @elt') => forall v24 : eqke (v1, v9) (v6, v2 v7), In v1 ((v6, v7) :: v4)) (fun v23 : eqke (v1, v9) (v6, v2 v7) => ex_intro (fun v24 : @elt => MapsTo v1 v24 ((v6, v7) :: v4)) v7 (InA_cons_hd (eqA:=eqke (elt:=@elt)) (x:=(v1, v7)) (y:=(v6, v7)) v4 ((and_ind (fun (v24 : X.eq v1 v6) (v25 : v9 = v2 v7) => conj v24 eq_refl) v23 : X.eq (fst (v1, v7)) (fst (v6, v7)) /\ snd (v1, v7) = snd (v6, v7)) : eqke (v1, v7) (v6, v7)))) v22) v20) v18) v17) v15 v14) v12 v13 v14 | @InA_cons_tl _ _ _ v12 v13 v14 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) (v14 : InA (eqke (elt:=@elt')) (v1, v9) v13) (v15 : v12 :: v13 = (v6, v2 v7) :: map v2 v4) => (fun v16 : v12 :: v13 = (v6, v2 v7) :: map v2 v4 => let v17 : v13 = map v2 v4 := f_equal (fun v17 : list (@X.t * @elt') => match v17 as v18 in (list _) return (list (@X.t * @elt')) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t * @elt') (v19 : list (@X.t * @elt')) => v19) v18 v19 end) v16 in (let v18 : v12 = (v6, v2 v7) := f_equal (fun v18 : list (@X.t * @elt') => match v18 as v19 in (list _) return (@X.t * @elt') with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t * @elt') (v20 : list (@X.t * @elt')) => v19) v19 v20 end) v16 in (fun v19 : v12 = (v6, v2 v7) => let v20 : v12 = (v6, v2 v7) := v19 in eq_ind_r (fun v21 : @X.t * @elt' => forall (v22 : v13 = map v2 v4) (v23 : InA (eqke (elt:=@elt')) (v1, v9) v13), In v1 ((v6, v7) :: v4)) (fun v21 : v13 = map v2 v4 => let v22 : v13 = map v2 v4 := v21 in eq_ind_r (fun v23 : list (@X.t * @elt') => forall v24 : InA (eqke (elt:=@elt')) (v1, v9) v23, In v1 ((v6, v7) :: v4)) (fun v23 : InA (eqke (elt:=@elt')) (v1, v9) (map v2 v4) => let v24 : exists v24 : @elt, MapsTo v1 v24 v4 := v5 (ex_intro (fun v24 : @elt' => MapsTo v1 v24 (map v2 v4)) v9 v23) in match v24 as v25 in (ex _) return (In v1 ((v6, v7) :: v4)) with | ex_intro _ v25 v26 => (fun (v25 : @elt) (v26 : MapsTo v1 v25 v4) => ex_intro (fun v27 : @elt => MapsTo v1 v27 ((v6, v7) :: v4)) v25 (InA_cons_tl (v6, v7) v26)) v25 v26 end) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 eq_refl) v10) v9 v10 end in v9) v6 v7 end : forall v6 : In v1 (map v2 (v3 :: v4)), In v1 (v3 :: v4)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.map_lelistA	100	0.289268	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 : @key) (v3 : @elt) (v4 : @elt') (v5 : forall v5 : @elt, @elt') (v6 : HdRel (ltk (elt:=@elt)) (v2, v3) v1), HdRel (ltk (elt:=@elt')) (v2, v4) (map v5 v1)) ((fun (v1 : @key) (v2 : @elt) (v3 : @elt') (v4 : forall v4 : @elt, @elt') (v5 : HdRel (ltk (elt:=@elt)) (v1, v2) nil) => HdRel_nil (ltk (elt:=@elt')) (v1, v3)) : forall (v1 : @key) (v2 : @elt) (v3 : @elt') (v4 : forall v4 : @elt, @elt') (v5 : HdRel (ltk (elt:=@elt)) (v1, v2) nil), HdRel (ltk (elt:=@elt')) (v1, v3) (map v4 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 : @key) (v4 : @elt) (v5 : @elt') (v6 : forall v6 : @elt, @elt') (v7 : HdRel (ltk (elt:=@elt)) (v3, v4) v2), HdRel (ltk (elt:=@elt')) (v3, v5) (map v6 v2)) => (fun (v4 : @key) (v5 : @elt) (v6 : @elt') (v7 : forall v7 : @elt, @elt') (v8 : HdRel (ltk (elt:=@elt)) (v4, v5) (v1 :: v2)) => match v1 as v9 in (_ * _)%type return (forall v10 : HdRel (ltk (elt:=@elt)) (v4, v5) (v9 :: v2), HdRel (ltk (elt:=@elt')) (v4, v6) match v9 as v11 in (_ * _)%type return (t (@elt')) with | (v11, v12) => (fun (v11 : @X.t) (v12 : @elt) => (v11, v7 v12) :: map v7 v2) v11 v12 end) with | (v9, v10) => (fun (v9 : @X.t) (v10 : @elt) (v11 : HdRel (ltk (elt:=@elt)) (v4, v5) ((v9, v10) :: v2)) => let v12 : forall v12 : (v9, v10) :: v2 = (v9, v10) :: v2, HdRel (ltk (elt:=@elt')) (v4, v6) ((v9, v7 v10) :: map v7 v2) := match v11 as v13 in (HdRel _ _ v12) return (forall v14 : v12 = (v9, v10) :: v2, HdRel (ltk (elt:=@elt')) (v4, v6) ((v9, v7 v10) :: map v7 v2)) with | HdRel_nil _ _ => fun v12 : nil = (v9, v10) :: v2 => (fun v13 : nil = (v9, v10) :: v2 => let v14 : @False := eq_ind nil (fun v14 : list (@X.t * @elt) => match v14 as v15 in (list _) return Prop with | nil => @True | v15 :: v16 => (fun (v15 : @X.t * @elt) (v16 : list (@X.t * @elt)) => @False) v15 v16 end) (@I) ((v9, v10) :: v2) v13 in False_ind (HdRel (ltk (elt:=@elt')) (v4, v6) ((v9, v7 v10) :: map v7 v2)) v14) v12 | HdRel_cons _ _ v12 v13 v14 => (fun (v12 : @X.t * @elt) (v13 : list (@X.t * @elt)) (v14 : ltk (v4, v5) v12) (v15 : v12 :: v13 = (v9, v10) :: v2) => (fun v16 : v12 :: v13 = (v9, v10) :: v2 => let v17 : v13 = v2 := f_equal (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return (list (@X.t * @elt)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => v19) v18 v19 end) v16 in (let v18 : v12 = (v9, v10) := f_equal (fun v18 : list (@X.t * @elt) => match v18 as v19 in (list _) return (@X.t * @elt) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t * @elt) (v20 : list (@X.t * @elt)) => v19) v19 v20 end) v16 in (fun v19 : v12 = (v9, v10) => let v20 : v12 = (v9, v10) := v19 in eq_ind_r (fun v21 : @X.t * @elt => forall (v22 : v13 = v2) (v23 : ltk (v4, v5) v21), HdRel (ltk (elt:=@elt')) (v4, v6) ((v9, v7 v10) :: map v7 v2)) (fun v21 : v13 = v2 => let v22 : v13 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t * @elt) => forall v24 : ltk (v4, v5) (v9, v10), HdRel (ltk (elt:=@elt')) (v4, v6) ((v9, v7 v10) :: map v7 v2)) (fun v23 : ltk (v4, v5) (v9, v10) => HdRel_cons (ltk (elt:=@elt')) (v4, v6) (v9, v7 v10) (map v7 v2) v23) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 eq_refl) v9 v10 end v8) : forall (v4 : @key) (v5 : @elt) (v6 : @elt') (v7 : forall v7 : @elt, @elt') (v8 : HdRel (ltk (elt:=@elt)) (v4, v5) (v1 :: v2)), HdRel (ltk (elt:=@elt')) (v4, v6) (map v7 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.map_sorted	100	0.257051	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 : Sorted (ltk (elt:=@elt)) v1) (v3 : forall v3 : @elt, @elt'), Sorted (ltk (elt:=@elt')) (map v3 v1)) ((fun (v1 : Sorted (ltk (elt:=@elt)) nil) (v2 : forall v2 : @elt, @elt') => Sorted_nil (ltk (elt:=@elt'))) : forall (v1 : Sorted (ltk (elt:=@elt)) nil) (v2 : forall v2 : @elt, @elt'), Sorted (ltk (elt:=@elt')) (map v2 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 : Sorted (ltk (elt:=@elt)) v2) (v4 : forall v4 : @elt, @elt'), Sorted (ltk (elt:=@elt')) (map v4 v2)) => (fun (v4 : Sorted (ltk (elt:=@elt)) (v1 :: v2)) (v5 : forall v5 : @elt, @elt') => match v1 as v6 in (_ * _)%type return (forall v7 : Sorted (ltk (elt:=@elt)) (v6 :: v2), Sorted (ltk (elt:=@elt')) match v6 as v8 in (_ * _)%type return (t (@elt')) with | (v8, v9) => (fun (v8 : @X.t) (v9 : @elt) => (v8, v5 v9) :: map v5 v2) v8 v9 end) with | (v6, v7) => (fun (v6 : @X.t) (v7 : @elt) (v8 : Sorted (ltk (elt:=@elt)) ((v6, v7) :: v2)) => let v9 : forall v9 : (v6, v7) :: v2 = (v6, v7) :: v2, Sorted (ltk (elt:=@elt')) ((v6, v5 v7) :: map v5 v2) := match v8 as v10 in (Sorted _ v9) return (forall v11 : v9 = (v6, v7) :: v2, Sorted (ltk (elt:=@elt')) ((v6, v5 v7) :: map v5 v2)) with | Sorted_nil _ => fun v9 : nil = (v6, v7) :: v2 => (fun v10 : nil = (v6, v7) :: v2 => let v11 : @False := eq_ind nil (fun v11 : list (@X.t * @elt) => match v11 as v12 in (list _) return Prop with | nil => @True | v12 :: v13 => (fun (v12 : @X.t * @elt) (v13 : list (@X.t * @elt)) => @False) v12 v13 end) (@I) ((v6, v7) :: v2) v10 in False_ind (Sorted (ltk (elt:=@elt')) ((v6, v5 v7) :: map v5 v2)) v11) v9 | @Sorted_cons _ _ v9 v10 v11 v12 => (fun (v9 : @X.t * @elt) (v10 : list (@X.t * @elt)) (v11 : Sorted (ltk (elt:=@elt)) v10) (v12 : HdRel (ltk (elt:=@elt)) v9 v10) (v13 : v9 :: v10 = (v6, v7) :: v2) => (fun v14 : v9 :: v10 = (v6, v7) :: v2 => let v15 : v10 = v2 := f_equal (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return (list (@X.t * @elt)) with | nil => v10 | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => v17) v16 v17 end) v14 in (let v16 : v9 = (v6, v7) := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (@X.t * @elt) with | nil => v9 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v17) v17 v18 end) v14 in (fun v17 : v9 = (v6, v7) => let v18 : v9 = (v6, v7) := v17 in eq_ind_r (fun v19 : @X.t * @elt => forall (v20 : v10 = v2) (v21 : Sorted (ltk (elt:=@elt)) v10) (v22 : HdRel (ltk (elt:=@elt)) v19 v10), Sorted (ltk (elt:=@elt')) ((v6, v5 v7) :: map v5 v2)) (fun v19 : v10 = v2 => let v20 : v10 = v2 := v19 in eq_ind_r (fun v21 : list (@X.t * @elt) => forall (v22 : Sorted (ltk (elt:=@elt)) v21) (v23 : HdRel (ltk (elt:=@elt)) (v6, v7) v21), Sorted (ltk (elt:=@elt')) ((v6, v5 v7) :: map v5 v2)) (fun (v21 : Sorted (ltk (elt:=@elt)) v2) (v22 : HdRel (ltk (elt:=@elt)) (v6, v7) v2) => Sorted_cons (v3 v21 v5) (map_lelistA (v5 v7) v5 v22)) v20) v18) v16) v15) v13 v11 v12) v9 v10 v11 v12 end in v9 eq_refl) v6 v7 end v4) : forall (v4 : Sorted (ltk (elt:=@elt)) (v1 :: v2)) (v5 : forall v5 : @elt, @elt'), Sorted (ltk (elt:=@elt')) (map v5 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.mapi_1	100	0.509555	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 : @key) (v2 : @elt) (v3 : forall (v3 : @key) (v4 : @elt), @elt') => list_ind (fun v4 : list (@X.t * @elt) => forall v5 : MapsTo v1 v2 v4, exists v6 : @X.t, X.eq v6 v1 /\ MapsTo v1 (v3 v6 v2) (mapi v3 v4)) (fun v4 : MapsTo v1 v2 nil => let v5 : forall v5 : nil = nil, exists v6 : @X.t, X.eq v6 v1 /\ MapsTo v1 (v3 v6 v2) (mapi v3 nil) := match v4 as v6 in (InA _ _ v5) return (forall v7 : v5 = nil, exists v8 : @X.t, X.eq v8 v1 /\ MapsTo v1 (v3 v8 v2) (mapi v3 nil)) with | @InA_cons_hd _ _ _ v5 v6 v7 => (fun (v5 : @X.t * @elt) (v6 : list (@X.t * @elt)) (v7 : eqke (v1, v2) v5) (v8 : v5 :: v6 = nil) => (fun v9 : v5 :: v6 = nil => let v10 : @False := eq_ind (v5 :: v6) (fun v10 : list (@X.t * @elt) => match v10 as v11 in (list _) return Prop with | nil => @False | v11 :: v12 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) => @True) v11 v12 end) (@I) nil v9 in False_ind (forall v11 : eqke (v1, v2) v5, exists v12 : @X.t, X.eq v12 v1 /\ MapsTo v1 (v3 v12 v2) (mapi v3 nil)) v10) v8 v7) v5 v6 v7 | @InA_cons_tl _ _ _ v5 v6 v7 => (fun (v5 : @X.t * @elt) (v6 : list (@X.t * @elt)) (v7 : InA (eqke (elt:=@elt)) (v1, v2) v6) (v8 : v5 :: v6 = nil) => (fun v9 : v5 :: v6 = nil => let v10 : @False := eq_ind (v5 :: v6) (fun v10 : list (@X.t * @elt) => match v10 as v11 in (list _) return Prop with | nil => @False | v11 :: v12 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) => @True) v11 v12 end) (@I) nil v9 in False_ind (forall v11 : InA (eqke (elt:=@elt)) (v1, v2) v6, exists v12 : @X.t, X.eq v12 v1 /\ MapsTo v1 (v3 v12 v2) (mapi v3 nil)) v10) v8 v7) v5 v6 v7 end in v5 eq_refl) (fun (v4 : @X.t * @elt) (v5 : list (@X.t * @elt)) (v6 : forall v6 : MapsTo v1 v2 v5, exists v7 : @X.t, X.eq v7 v1 /\ MapsTo v1 (v3 v7 v2) (mapi v3 v5)) => match v4 as v7 in (_ * _)%type return (forall v8 : MapsTo v1 v2 (v7 :: v5), exists v9 : @X.t, X.eq v9 v1 /\ MapsTo v1 (v3 v9 v2) (mapi v3 (v7 :: v5))) with | (v7, v8) => (fun (v7 : @X.t) (v8 : @elt) => (fun v9 : MapsTo v1 v2 ((v7, v8) :: v5) => let v10 : forall v10 : (v7, v8) :: v5 = (v7, v8) :: v5, exists v11 : @X.t, X.eq v11 v1 /\ MapsTo v1 (v3 v11 v2) ((v7, v3 v7 v8) :: mapi v3 v5) := match v9 as v11 in (InA _ _ v10) return (forall v12 : v10 = (v7, v8) :: v5, exists v13 : @X.t, X.eq v13 v1 /\ MapsTo v1 (v3 v13 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) with | @InA_cons_hd _ _ _ v10 v11 v12 => (fun (v10 : @X.t * @elt) (v11 : list (@X.t * @elt)) (v12 : eqke (v1, v2) v10) (v13 : v10 :: v11 = (v7, v8) :: v5) => (fun v14 : v10 :: v11 = (v7, v8) :: v5 => let v15 : v11 = v5 := f_equal (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return (list (@X.t * @elt)) with | nil => v11 | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => v17) v16 v17 end) v14 in (let v16 : v10 = (v7, v8) := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (@X.t * @elt) with | nil => v10 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v17) v17 v18 end) v14 in (fun v17 : v10 = (v7, v8) => let v18 : v10 = (v7, v8) := v17 in eq_ind_r (fun v19 : @X.t * @elt => forall (v20 : v11 = v5) (v21 : eqke (v1, v2) v19), exists v22 : @X.t, X.eq v22 v1 /\ MapsTo v1 (v3 v22 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) (fun v19 : v11 = v5 => let v20 : v11 = v5 := v19 in eq_ind_r (fun v21 : list (@X.t * @elt) => forall v22 : eqke (v1, v2) (v7, v8), exists v23 : @X.t, X.eq v23 v1 /\ MapsTo v1 (v3 v23 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) (fun v21 : eqke (v1, v2) (v7, v8) => ex_intro (fun v22 : @X.t => X.eq v22 v1 /\ MapsTo v1 (v3 v22 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) v7 match v21 as v22 in (_ /\ _) return (X.eq v7 v1 /\ MapsTo v1 (v3 v7 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) with | conj v22 v23 => (fun (v22 : X.eq (fst (v1, v2)) (fst (v7, v8))) (v23 : snd (v1, v2) = snd (v7, v8)) => conj (X.eq_sym v22) (InA_cons_hd (eqA:=eqke (elt:=@elt')) (x:=(v1, v3 v7 v2)) (y:=(v7, v3 v7 v8)) (mapi v3 v5) ((conj v22 (eq_trans (f_equal (fun v24 : forall v24 : @elt, @elt' => v24 v2) eq_refl) (f_equal (v3 v7) v23) : v3 v7 v2 = v3 v7 v8) : X.eq (fst (v1, v3 v7 v2)) (fst (v7, v3 v7 v8)) /\ snd (v1, v3 v7 v2) = snd (v7, v3 v7 v8)) : eqke (v1, v3 v7 v2) (v7, v3 v7 v8))) : X.eq v7 v1 /\ MapsTo v1 (v3 v7 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) v22 v23 end) v20) v18) v16) v15) v13 v12) v10 v11 v12 | @InA_cons_tl _ _ _ v10 v11 v12 => (fun (v10 : @X.t * @elt) (v11 : list (@X.t * @elt)) (v12 : InA (eqke (elt:=@elt)) (v1, v2) v11) (v13 : v10 :: v11 = (v7, v8) :: v5) => (fun v14 : v10 :: v11 = (v7, v8) :: v5 => let v15 : v11 = v5 := f_equal (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return (list (@X.t * @elt)) with | nil => v11 | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => v17) v16 v17 end) v14 in (let v16 : v10 = (v7, v8) := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (@X.t * @elt) with | nil => v10 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v17) v17 v18 end) v14 in (fun v17 : v10 = (v7, v8) => let v18 : v10 = (v7, v8) := v17 in eq_ind_r (fun v19 : @X.t * @elt => forall (v20 : v11 = v5) (v21 : InA (eqke (elt:=@elt)) (v1, v2) v11), exists v22 : @X.t, X.eq v22 v1 /\ MapsTo v1 (v3 v22 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) (fun v19 : v11 = v5 => let v20 : v11 = v5 := v19 in eq_ind_r (fun v21 : list (@X.t * @elt) => forall v22 : InA (eqke (elt:=@elt)) (v1, v2) v21, exists v23 : @X.t, X.eq v23 v1 /\ MapsTo v1 (v3 v23 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) (fun v21 : InA (eqke (elt:=@elt)) (v1, v2) v5 => let v22 : exists v22 : @X.t, X.eq v22 v1 /\ MapsTo v1 (v3 v22 v2) (mapi v3 v5) := v6 v21 in match v22 as v23 in (ex _) return (exists v24 : @X.t, X.eq v24 v1 /\ MapsTo v1 (v3 v24 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) with | ex_intro _ v23 v24 => (fun (v23 : @X.t) (v24 : X.eq v23 v1 /\ MapsTo v1 (v3 v23 v2) (mapi v3 v5)) => ex_intro (fun v25 : @X.t => X.eq v25 v1 /\ MapsTo v1 (v3 v25 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) v23 (and_ind (fun (v25 : X.eq v23 v1) (v26 : MapsTo v1 (v3 v23 v2) (mapi v3 v5)) => conj v25 ((InA_cons_tl (v7, v3 v7 v8) v26 : MapsTo v1 (v3 v23 v2) ((v7, v3 v7 v8) :: mapi v3 v5)) : MapsTo v1 (v3 v23 v2) ((v7, v3 v7 v8) :: mapi v3 v5))) v24)) v23 v24 end) v20) v18) v16) v15) v13 v12) v10 v11 v12 end in v10 eq_refl) : forall v9 : MapsTo v1 v2 ((v7, v8) :: v5), exists v10 : @X.t, X.eq v10 v1 /\ MapsTo v1 (v3 v10 v2) (mapi v3 ((v7, v8) :: v5))) v7 v8 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.mapi_2	100	0.430968	1	1	0	synth with cache (only 1: refine (fun (v0 : t (@elt)) (v1 : @key) (v2 : forall (v2 : @key) (v3 : @elt), @elt') => list_ind (fun v3 : list (@X.t * @elt) => forall v4 : In v1 (mapi v2 v3), In v1 v3) ((fun v3 : In v1 nil => match v3 as v4 in (ex _) return (In v1 nil) with | ex_intro _ v4 v5 => (fun (v4 : @elt') (v5 : MapsTo v1 v4 nil) => let v6 : forall v6 : nil = nil, In v1 nil := match v5 as v7 in (InA _ _ v6) return (forall v8 : v6 = nil, In v1 nil) with | @InA_cons_hd _ _ _ v6 v7 v8 => (fun (v6 : @X.t * @elt') (v7 : list (@X.t * @elt')) (v8 : eqke (v1, v4) v6) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t * @elt') => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : eqke (v1, v4) v6, In v1 nil) v11) v9 v8) v6 v7 v8 | @InA_cons_tl _ _ _ v6 v7 v8 => (fun (v6 : @X.t * @elt') (v7 : list (@X.t * @elt')) (v8 : InA (eqke (elt:=@elt')) (v1, v4) v7) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t * @elt') => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : InA (eqke (elt:=@elt')) (v1, v4) v7, In v1 nil) v11) v9 v8) v6 v7 v8 end in v6 eq_refl) v4 v5 end) : forall v3 : In v1 (mapi v2 nil), In v1 nil) (fun (v3 : @X.t * @elt) (v4 : list (@X.t * @elt)) (v5 : forall v5 : In v1 (mapi v2 v4), In v1 v4) => match v3 as v6 in (_ * _)%type return (forall v7 : In v1 match v6 as v7 in (_ * _)%type return (t (@elt')) with | (v7, v8) => (fun (v7 : @X.t) (v8 : @elt) => (v7, v2 v7 v8) :: mapi v2 v4) v7 v8 end, In v1 (v6 :: v4)) with | (v6, v7) => (fun (v6 : @X.t) (v7 : @elt) (v8 : In v1 ((v6, v2 v6 v7) :: mapi v2 v4)) => let v9 : In v1 ((v6, v7) :: v4) := match v8 as v9 in (ex _) return (In v1 ((v6, v7) :: v4)) with | ex_intro _ v9 v10 => (fun (v9 : @elt') (v10 : MapsTo v1 v9 ((v6, v2 v6 v7) :: mapi v2 v4)) => (fun v11 : MapsTo v1 v9 ((v6, v2 v6 v7) :: mapi v2 v4) => let v12 : forall v12 : (v6, v2 v6 v7) :: mapi v2 v4 = (v6, v2 v6 v7) :: mapi v2 v4, In v1 ((v6, v7) :: v4) := match v11 as v13 in (InA _ _ v12) return (forall v14 : v12 = (v6, v2 v6 v7) :: mapi v2 v4, In v1 ((v6, v7) :: v4)) with | @InA_cons_hd _ _ _ v12 v13 v14 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) (v14 : eqke (v1, v9) v12) (v15 : v12 :: v13 = (v6, v2 v6 v7) :: mapi v2 v4) => (fun v16 : v12 :: v13 = (v6, v2 v6 v7) :: mapi v2 v4 => let v17 : v13 = mapi v2 v4 := f_equal (fun v17 : list (@X.t * @elt') => match v17 as v18 in (list _) return (list (@X.t * @elt')) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t * @elt') (v19 : list (@X.t * @elt')) => v19) v18 v19 end) v16 in (let v18 : v12 = (v6, v2 v6 v7) := f_equal (fun v18 : list (@X.t * @elt') => match v18 as v19 in (list _) return (@X.t * @elt') with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t * @elt') (v20 : list (@X.t * @elt')) => v19) v19 v20 end) v16 in (fun v19 : v12 = (v6, v2 v6 v7) => let v20 : v12 = (v6, v2 v6 v7) := v19 in eq_ind_r (fun v21 : @X.t * @elt' => forall (v22 : v13 = mapi v2 v4) (v23 : eqke (v1, v9) v21), In v1 ((v6, v7) :: v4)) (fun v21 : v13 = mapi v2 v4 => let v22 : v13 = mapi v2 v4 := v21 in eq_ind_r (fun v23 : list (@X.t * @elt') => forall v24 : eqke (v1, v9) (v6, v2 v6 v7), In v1 ((v6, v7) :: v4)) (fun v23 : eqke (v1, v9) (v6, v2 v6 v7) => ex_intro (fun v24 : @elt => MapsTo v1 v24 ((v6, v7) :: v4)) v7 (InA_cons_hd (eqA:=eqke (elt:=@elt)) (x:=(v1, v7)) (y:=(v6, v7)) v4 ((and_ind (fun (v24 : X.eq v1 v6) (v25 : v9 = v2 v6 v7) => conj v24 eq_refl) v23 : X.eq (fst (v1, v7)) (fst (v6, v7)) /\ snd (v1, v7) = snd (v6, v7)) : eqke (v1, v7) (v6, v7)))) v22) v20) v18) v17) v15 v14) v12 v13 v14 | @InA_cons_tl _ _ _ v12 v13 v14 => (fun (v12 : @X.t * @elt') (v13 : list (@X.t * @elt')) (v14 : InA (eqke (elt:=@elt')) (v1, v9) v13) (v15 : v12 :: v13 = (v6, v2 v6 v7) :: mapi v2 v4) => (fun v16 : v12 :: v13 = (v6, v2 v6 v7) :: mapi v2 v4 => let v17 : v13 = mapi v2 v4 := f_equal (fun v17 : list (@X.t * @elt') => match v17 as v18 in (list _) return (list (@X.t * @elt')) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t * @elt') (v19 : list (@X.t * @elt')) => v19) v18 v19 end) v16 in (let v18 : v12 = (v6, v2 v6 v7) := f_equal (fun v18 : list (@X.t * @elt') => match v18 as v19 in (list _) return (@X.t * @elt') with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t * @elt') (v20 : list (@X.t * @elt')) => v19) v19 v20 end) v16 in (fun v19 : v12 = (v6, v2 v6 v7) => let v20 : v12 = (v6, v2 v6 v7) := v19 in eq_ind_r (fun v21 : @X.t * @elt' => forall (v22 : v13 = mapi v2 v4) (v23 : InA (eqke (elt:=@elt')) (v1, v9) v13), In v1 ((v6, v7) :: v4)) (fun v21 : v13 = mapi v2 v4 => let v22 : v13 = mapi v2 v4 := v21 in eq_ind_r (fun v23 : list (@X.t * @elt') => forall v24 : InA (eqke (elt:=@elt')) (v1, v9) v23, In v1 ((v6, v7) :: v4)) (fun v23 : InA (eqke (elt:=@elt')) (v1, v9) (mapi v2 v4) => let v24 : exists v24 : @elt, MapsTo v1 v24 v4 := v5 (ex_intro (fun v24 : @elt' => MapsTo v1 v24 (mapi v2 v4)) v9 v23) in match v24 as v25 in (ex _) return (In v1 ((v6, v7) :: v4)) with | ex_intro _ v25 v26 => (fun (v25 : @elt) (v26 : MapsTo v1 v25 v4) => ex_intro (fun v27 : @elt => MapsTo v1 v27 ((v6, v7) :: v4)) v25 (InA_cons_tl (v6, v7) v26)) v25 v26 end) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 eq_refl) v10) v9 v10 end in v9) v6 v7 end : forall v6 : In v1 (mapi v2 (v3 :: v4)), In v1 (v3 :: v4)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.mapi_lelistA	100	0.302035	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 : @key) (v3 : @elt) (v4 : forall (v4 : @key) (v5 : @elt), @elt') (v5 : HdRel (ltk (elt:=@elt)) (v2, v3) v1), HdRel (ltk (elt:=@elt')) (v2, v4 v2 v3) (mapi v4 v1)) ((fun (v1 : @key) (v2 : @elt) (v3 : forall (v3 : @key) (v4 : @elt), @elt') (v4 : HdRel (ltk (elt:=@elt)) (v1, v2) nil) => HdRel_nil (ltk (elt:=@elt')) (v1, v3 v1 v2)) : forall (v1 : @key) (v2 : @elt) (v3 : forall (v3 : @key) (v4 : @elt), @elt') (v4 : HdRel (ltk (elt:=@elt)) (v1, v2) nil), HdRel (ltk (elt:=@elt')) (v1, v3 v1 v2) (mapi v3 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 : @key) (v4 : @elt) (v5 : forall (v5 : @key) (v6 : @elt), @elt') (v6 : HdRel (ltk (elt:=@elt)) (v3, v4) v2), HdRel (ltk (elt:=@elt')) (v3, v5 v3 v4) (mapi v5 v2)) => (fun (v4 : @key) (v5 : @elt) (v6 : forall (v6 : @key) (v7 : @elt), @elt') (v7 : HdRel (ltk (elt:=@elt)) (v4, v5) (v1 :: v2)) => match v1 as v8 in (_ * _)%type return (forall v9 : HdRel (ltk (elt:=@elt)) (v4, v5) (v8 :: v2), HdRel (ltk (elt:=@elt')) (v4, v6 v4 v5) match v8 as v10 in (_ * _)%type return (t (@elt')) with | (v10, v11) => (fun (v10 : @X.t) (v11 : @elt) => (v10, v6 v10 v11) :: mapi v6 v2) v10 v11 end) with | (v8, v9) => (fun (v8 : @X.t) (v9 : @elt) (v10 : HdRel (ltk (elt:=@elt)) (v4, v5) ((v8, v9) :: v2)) => let v11 : forall v11 : (v8, v9) :: v2 = (v8, v9) :: v2, HdRel (ltk (elt:=@elt')) (v4, v6 v4 v5) ((v8, v6 v8 v9) :: mapi v6 v2) := match v10 as v12 in (HdRel _ _ v11) return (forall v13 : v11 = (v8, v9) :: v2, HdRel (ltk (elt:=@elt')) (v4, v6 v4 v5) ((v8, v6 v8 v9) :: mapi v6 v2)) with | HdRel_nil _ _ => fun v11 : nil = (v8, v9) :: v2 => (fun v12 : nil = (v8, v9) :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t * @elt) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t * @elt) (v15 : list (@X.t * @elt)) => @False) v14 v15 end) (@I) ((v8, v9) :: v2) v12 in False_ind (HdRel (ltk (elt:=@elt')) (v4, v6 v4 v5) ((v8, v6 v8 v9) :: mapi v6 v2)) v13) v11 | HdRel_cons _ _ v11 v12 v13 => (fun (v11 : @X.t * @elt) (v12 : list (@X.t * @elt)) (v13 : ltk (v4, v5) v11) (v14 : v11 :: v12 = (v8, v9) :: v2) => (fun v15 : v11 :: v12 = (v8, v9) :: v2 => let v16 : v12 = v2 := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (list (@X.t * @elt)) with | nil => v12 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v18) v17 v18 end) v15 in (let v17 : v11 = (v8, v9) := f_equal (fun v17 : list (@X.t * @elt) => match v17 as v18 in (list _) return (@X.t * @elt) with | nil => v11 | v18 :: v19 => (fun (v18 : @X.t * @elt) (v19 : list (@X.t * @elt)) => v18) v18 v19 end) v15 in (fun v18 : v11 = (v8, v9) => let v19 : v11 = (v8, v9) := v18 in eq_ind_r (fun v20 : @X.t * @elt => forall (v21 : v12 = v2) (v22 : ltk (v4, v5) v20), HdRel (ltk (elt:=@elt')) (v4, v6 v4 v5) ((v8, v6 v8 v9) :: mapi v6 v2)) (fun v20 : v12 = v2 => let v21 : v12 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t * @elt) => forall v23 : ltk (v4, v5) (v8, v9), HdRel (ltk (elt:=@elt')) (v4, v6 v4 v5) ((v8, v6 v8 v9) :: mapi v6 v2)) (fun v22 : ltk (v4, v5) (v8, v9) => HdRel_cons (ltk (elt:=@elt')) (v4, v6 v4 v5) (v8, v6 v8 v9) (mapi v6 v2) v22) v21) v19) v17) v16) v14 v13) v11 v12 v13 end in v11 eq_refl) v8 v9 end v7) : forall (v4 : @key) (v5 : @elt) (v6 : forall (v6 : @key) (v7 : @elt), @elt') (v7 : HdRel (ltk (elt:=@elt)) (v4, v5) (v1 :: v2)), HdRel (ltk (elt:=@elt')) (v4, v6 v4 v5) (mapi v6 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt2.mapi_sorted	100	0.271180	1	1	0	synth with cache (only 1: refine (fun v0 : list (@X.t * @elt) => list_ind (fun v1 : list (@X.t * @elt) => forall (v2 : Sorted (ltk (elt:=@elt)) v1) (v3 : forall (v3 : @key) (v4 : @elt), @elt'), Sorted (ltk (elt:=@elt')) (mapi v3 v1)) ((fun (v1 : Sorted (ltk (elt:=@elt)) nil) (v2 : forall (v2 : @key) (v3 : @elt), @elt') => Sorted_nil (ltk (elt:=@elt'))) : forall (v1 : Sorted (ltk (elt:=@elt)) nil) (v2 : forall (v2 : @key) (v3 : @elt), @elt'), Sorted (ltk (elt:=@elt')) (mapi v2 nil)) (fun (v1 : @X.t * @elt) (v2 : list (@X.t * @elt)) (v3 : forall (v3 : Sorted (ltk (elt:=@elt)) v2) (v4 : forall (v4 : @key) (v5 : @elt), @elt'), Sorted (ltk (elt:=@elt')) (mapi v4 v2)) => (fun (v4 : Sorted (ltk (elt:=@elt)) (v1 :: v2)) (v5 : forall (v5 : @key) (v6 : @elt), @elt') => match v1 as v6 in (_ * _)%type return (forall v7 : Sorted (ltk (elt:=@elt)) (v6 :: v2), Sorted (ltk (elt:=@elt')) match v6 as v8 in (_ * _)%type return (t (@elt')) with | (v8, v9) => (fun (v8 : @X.t) (v9 : @elt) => (v8, v5 v8 v9) :: mapi v5 v2) v8 v9 end) with | (v6, v7) => (fun (v6 : @X.t) (v7 : @elt) (v8 : Sorted (ltk (elt:=@elt)) ((v6, v7) :: v2)) => let v9 : forall v9 : (v6, v7) :: v2 = (v6, v7) :: v2, Sorted (ltk (elt:=@elt')) ((v6, v5 v6 v7) :: mapi v5 v2) := match v8 as v10 in (Sorted _ v9) return (forall v11 : v9 = (v6, v7) :: v2, Sorted (ltk (elt:=@elt')) ((v6, v5 v6 v7) :: mapi v5 v2)) with | Sorted_nil _ => fun v9 : nil = (v6, v7) :: v2 => (fun v10 : nil = (v6, v7) :: v2 => let v11 : @False := eq_ind nil (fun v11 : list (@X.t * @elt) => match v11 as v12 in (list _) return Prop with | nil => @True | v12 :: v13 => (fun (v12 : @X.t * @elt) (v13 : list (@X.t * @elt)) => @False) v12 v13 end) (@I) ((v6, v7) :: v2) v10 in False_ind (Sorted (ltk (elt:=@elt')) ((v6, v5 v6 v7) :: mapi v5 v2)) v11) v9 | @Sorted_cons _ _ v9 v10 v11 v12 => (fun (v9 : @X.t * @elt) (v10 : list (@X.t * @elt)) (v11 : Sorted (ltk (elt:=@elt)) v10) (v12 : HdRel (ltk (elt:=@elt)) v9 v10) (v13 : v9 :: v10 = (v6, v7) :: v2) => (fun v14 : v9 :: v10 = (v6, v7) :: v2 => let v15 : v10 = v2 := f_equal (fun v15 : list (@X.t * @elt) => match v15 as v16 in (list _) return (list (@X.t * @elt)) with | nil => v10 | v16 :: v17 => (fun (v16 : @X.t * @elt) (v17 : list (@X.t * @elt)) => v17) v16 v17 end) v14 in (let v16 : v9 = (v6, v7) := f_equal (fun v16 : list (@X.t * @elt) => match v16 as v17 in (list _) return (@X.t * @elt) with | nil => v9 | v17 :: v18 => (fun (v17 : @X.t * @elt) (v18 : list (@X.t * @elt)) => v17) v17 v18 end) v14 in (fun v17 : v9 = (v6, v7) => let v18 : v9 = (v6, v7) := v17 in eq_ind_r (fun v19 : @X.t * @elt => forall (v20 : v10 = v2) (v21 : Sorted (ltk (elt:=@elt)) v10) (v22 : HdRel (ltk (elt:=@elt)) v19 v10), Sorted (ltk (elt:=@elt')) ((v6, v5 v6 v7) :: mapi v5 v2)) (fun v19 : v10 = v2 => let v20 : v10 = v2 := v19 in eq_ind_r (fun v21 : list (@X.t * @elt) => forall (v22 : Sorted (ltk (elt:=@elt)) v21) (v23 : HdRel (ltk (elt:=@elt)) (v6, v7) v21), Sorted (ltk (elt:=@elt')) ((v6, v5 v6 v7) :: mapi v5 v2)) (fun (v21 : Sorted (ltk (elt:=@elt)) v2) (v22 : HdRel (ltk (elt:=@elt)) (v6, v7) v2) => Sorted_cons (v3 v21 v5) (mapi_lelistA v5 v22)) v20) v18) v16) v15) v13 v11 v12) v9 v10 v11 v12 end in v9 eq_refl) v6 v7 end v4) : forall (v4 : Sorted (ltk (elt:=@elt)) (v1 :: v2)) (v5 : forall (v5 : @key) (v6 : @elt), @elt'), Sorted (ltk (elt:=@elt')) (mapi v5 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.map2_alt_equiv	100	1.292815	0	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.combine_lelistA	100	1.326362	0	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.combine_sorted	100	1.466324	0	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.map2_sorted	100	1.161909	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (ltk (elt:=@elt)) v0) (v2 : list (@X.t * @elt')) (v3 : Sorted (ltk (elt:=@elt')) v2) => eq_ind (map2_alt v0 v2) (fun v4 : list (@key * @elt'') => Sorted (ltk (elt:=@elt'')) v4) ((let v4 : Sorted (ltk (elt:=option (@elt) * option (@elt'))) (combine v0 v2) := combine_sorted v1 v3 in let v5 : t (option (@elt) * option (@elt')) := combine v0 v2 in let v6 : forall v6 : option (@elt) * option (@elt'), option (@elt'') := fun v6 : option (@elt) * option (@elt') => f (fst v6) (snd v6) in let v7 : Sorted (ltk (elt:=option (@elt''))) (map v6 v5) := map_sorted v4 v6 in let v8 : t (option (@elt'')) := map v6 v5 in list_ind (fun v9 : list (@X.t * option (@elt'')) => forall v10 : Sorted (ltk (elt:=option (@elt''))) v9, Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) v9 nil)) (fun v9 : Sorted (ltk (elt:=option (@elt''))) nil => Sorted_nil (ltk (elt:=@elt'')) : Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) nil nil)) (fun (v9 : @X.t * option (@elt'')) (v10 : list (@X.t * option (@elt''))) (v11 : forall v11 : Sorted (ltk (elt:=option (@elt''))) v10, Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) v10 nil)) (v12 : Sorted (ltk (elt:=option (@elt''))) (v9 :: v10)) => let v13 : forall v13 : v9 :: v10 = v9 :: v10, Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) (v9 :: v10) nil) := match v12 as v14 in (Sorted _ v13) return (forall v15 : v13 = v9 :: v10, Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) (v9 :: v10) nil)) with | Sorted_nil _ => fun v13 : nil = v9 :: v10 => (fun v14 : nil = v9 :: v10 => let v15 : @False := eq_ind nil (fun v15 : list (@X.t * option (@elt'')) => match v15 as v16 in (list _) return Prop with | nil => @True | v16 :: v17 => (fun (v16 : @X.t * option (@elt'')) (v17 : list (@X.t * option (@elt''))) => @False) v16 v17 end) (@I) (v9 :: v10) v14 in False_ind (Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) (v9 :: v10) nil)) v15) v13 | @Sorted_cons _ _ v13 v14 v15 v16 => (fun (v13 : @X.t * option (@elt'')) (v14 : list (@X.t * option (@elt''))) (v15 : Sorted (ltk (elt:=option (@elt''))) v14) (v16 : HdRel (ltk (elt:=option (@elt''))) v13 v14) (v17 : v13 :: v14 = v9 :: v10) => (fun v18 : v13 :: v14 = v9 :: v10 => let v19 : v14 = v10 := f_equal (fun v19 : list (@X.t * option (@elt'')) => match v19 as v20 in (list _) return (list (@X.t * option (@elt''))) with | nil => v14 | v20 :: v21 => (fun (v20 : @X.t * option (@elt'')) (v21 : list (@X.t * option (@elt''))) => v21) v20 v21 end) v18 in (let v20 : v13 = v9 := f_equal (fun v20 : list (@X.t * option (@elt'')) => match v20 as v21 in (list _) return (@X.t * option (@elt'')) with | nil => v13 | v21 :: v22 => (fun (v21 : @X.t * option (@elt'')) (v22 : list (@X.t * option (@elt''))) => v21) v21 v22 end) v18 in (fun v21 : v13 = v9 => let v22 : v13 = v9 := v21 in eq_ind_r (fun v23 : @X.t * option (@elt'') => forall (v24 : v14 = v10) (v25 : Sorted (ltk (elt:=option (@elt''))) v14) (v26 : HdRel (ltk (elt:=option (@elt''))) v23 v14), Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) (v9 :: v10) nil)) (fun v23 : v14 = v10 => let v24 : v14 = v10 := v23 in eq_ind_r (fun v25 : list (@X.t * option (@elt'')) => forall (v26 : Sorted (ltk (elt:=option (@elt''))) v25) (v27 : HdRel (ltk (elt:=option (@elt''))) v9 v25), Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) (v9 :: v10) nil)) (fun (v25 : Sorted (ltk (elt:=option (@elt''))) v10) (v26 : HdRel (ltk (elt:=option (@elt''))) v9 v10) => match v9 as v27 in (_ * _)%type return (forall v28 : HdRel (ltk (elt:=option (@elt''))) v27 v10, Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) (v27 :: v10) nil)) with | (v27, v28) => (fun (v27 : @X.t) (v28 : option (@elt'')) (v29 : HdRel (ltk (elt:=option (@elt''))) (v27, v28) v10) => match v28 as v30 in (option _) return (forall v31 : HdRel (ltk (elt:=option (@elt''))) (v27, v30) v10, Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) ((v27, v30) :: v10) nil)) with | Some v30 => (fun (v30 : @elt'') (v31 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) v10) => Sorted_cons (v11 v25) (list_ind (fun v32 : list (@X.t * option (@elt'')) => forall (v33 : Sorted (ltk (elt:=option (@elt''))) v32) (v34 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) v32), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v32 nil)) (fun (v32 : Sorted (ltk (elt:=option (@elt''))) nil) (v33 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) nil) => HdRel_nil (ltk (elt:=@elt'')) (v27, v30) : HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) nil nil)) (fun (v32 : @X.t * option (@elt'')) (v33 : list (@X.t * option (@elt''))) (v34 : forall (v34 : Sorted (ltk (elt:=option (@elt''))) v33) (v35 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) v33), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) (v35 : Sorted (ltk (elt:=option (@elt''))) (v32 :: v33)) (v36 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) (v32 :: v33)) => match v32 as v37 in (_ * _)%type return (forall (v38 : Sorted (ltk (elt:=option (@elt''))) (v37 :: v33)) (v39 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) (v37 :: v33)), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) (v37 :: v33) nil)) with | (v37, v38) => (fun (v37 : @X.t) (v38 : option (@elt'')) (v39 : Sorted (ltk (elt:=option (@elt''))) ((v37, v38) :: v33)) (v40 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) ((v37, v38) :: v33)) => match v38 as v41 in (option _) return (forall (v42 : Sorted (ltk (elt:=option (@elt''))) ((v37, v41) :: v33)) (v43 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) ((v37, v41) :: v33)), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) ((v37, v41) :: v33) nil)) with | Some v41 => (fun (v41 : @elt'') (v42 : Sorted (ltk (elt:=option (@elt''))) ((v37, Some v41) :: v33)) (v43 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) ((v37, Some v41) :: v33)) => (let v44 : forall v44 : (v37, Some v41) :: v33 = (v37, Some v41) :: v33, HdRel (ltk (elt:=@elt'')) (v27, v30) ((v37, v41) :: fold_right_pair (option_cons (A:=@elt'')) v33 nil) := match v43 as v45 in (HdRel _ _ v44) return (forall v46 : v44 = (v37, Some v41) :: v33, HdRel (ltk (elt:=@elt'')) (v27, v30) ((v37, v41) :: fold_right_pair (option_cons (A:=@elt'')) v33 nil)) with | HdRel_nil _ _ => fun v44 : nil = (v37, Some v41) :: v33 => (fun v45 : nil = (v37, Some v41) :: v33 => let v46 : @False := eq_ind nil (fun v46 : list (@X.t * option (@elt'')) => match v46 as v47 in (list _) return Prop with | nil => @True | v47 :: v48 => (fun (v47 : @X.t * option (@elt'')) (v48 : list (@X.t * option (@elt''))) => @False) v47 v48 end) (@I) ((v37, Some v41) :: v33) v45 in False_ind (HdRel (ltk (elt:=@elt'')) (v27, v30) ((v37, v41) :: fold_right_pair (option_cons (A:=@elt'')) v33 nil)) v46) v44 | HdRel_cons _ _ v44 v45 v46 => (fun (v44 : @X.t * option (@elt'')) (v45 : list (@X.t * option (@elt''))) (v46 : ltk (v27, Some v30) v44) (v47 : v44 :: v45 = (v37, Some v41) :: v33) => (fun v48 : v44 :: v45 = (v37, Some v41) :: v33 => let v49 : v45 = v33 := f_equal (fun v49 : list (@X.t * option (@elt'')) => match v49 as v50 in (list _) return (list (@X.t * option (@elt''))) with | nil => v45 | v50 :: v51 => (fun (v50 : @X.t * option (@elt'')) (v51 : list (@X.t * option (@elt''))) => v51) v50 v51 end) v48 in (let v50 : v44 = (v37, Some v41) := f_equal (fun v50 : list (@X.t * option (@elt'')) => match v50 as v51 in (list _) return (@X.t * option (@elt'')) with | nil => v44 | v51 :: v52 => (fun (v51 : @X.t * option (@elt'')) (v52 : list (@X.t * option (@elt''))) => v51) v51 v52 end) v48 in (fun v51 : v44 = (v37, Some v41) => let v52 : v44 = (v37, Some v41) := v51 in eq_ind_r (fun v53 : @X.t * option (@elt'') => forall (v54 : v45 = v33) (v55 : ltk (v27, Some v30) v53), HdRel (ltk (elt:=@elt'')) (v27, v30) ((v37, v41) :: fold_right_pair (option_cons (A:=@elt'')) v33 nil)) (fun v53 : v45 = v33 => let v54 : v45 = v33 := v53 in eq_ind_r (fun v55 : list (@X.t * option (@elt'')) => forall v56 : ltk (v27, Some v30) (v37, Some v41), HdRel (ltk (elt:=@elt'')) (v27, v30) ((v37, v41) :: fold_right_pair (option_cons (A:=@elt'')) v33 nil)) (fun v55 : ltk (v27, Some v30) (v37, Some v41) => HdRel_cons (ltk (elt:=@elt'')) (v27, v30) (v37, v41) (fold_right_pair (option_cons (A:=@elt'')) v33 nil) v55) v54) v52) v50) v49) v47 v46) v44 v45 v46 end in v44 eq_refl) : HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) ((v37, Some v41) :: v33) nil)) v41 | None => fun (v41 : Sorted (ltk (elt:=option (@elt''))) ((v37, None) :: v33)) (v42 : HdRel (ltk (elt:=option (@elt''))) (v27, Some v30) ((v37, None) :: v33)) => (let v43 : forall v43 : (v37, None) :: v33 = (v37, None) :: v33, HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil) := match v42 as v44 in (HdRel _ _ v43) return (forall v45 : v43 = (v37, None) :: v33, HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) with | HdRel_nil _ _ => fun v43 : nil = (v37, None) :: v33 => (fun v44 : nil = (v37, None) :: v33 => let v45 : @False := eq_ind nil (fun v45 : list (@X.t * option (@elt'')) => match v45 as v46 in (list _) return Prop with | nil => @True | v46 :: v47 => (fun (v46 : @X.t * option (@elt'')) (v47 : list (@X.t * option (@elt''))) => @False) v46 v47 end) (@I) ((v37, None) :: v33) v44 in False_ind (HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) v45) v43 | HdRel_cons _ _ v43 v44 v45 => (fun (v43 : @X.t * option (@elt'')) (v44 : list (@X.t * option (@elt''))) (v45 : ltk (v27, Some v30) v43) (v46 : v43 :: v44 = (v37, None) :: v33) => (fun v47 : v43 :: v44 = (v37, None) :: v33 => let v48 : v44 = v33 := f_equal (fun v48 : list (@X.t * option (@elt'')) => match v48 as v49 in (list _) return (list (@X.t * option (@elt''))) with | nil => v44 | v49 :: v50 => (fun (v49 : @X.t * option (@elt'')) (v50 : list (@X.t * option (@elt''))) => v50) v49 v50 end) v47 in (let v49 : v43 = (v37, None) := f_equal (fun v49 : list (@X.t * option (@elt'')) => match v49 as v50 in (list _) return (@X.t * option (@elt'')) with | nil => v43 | v50 :: v51 => (fun (v50 : @X.t * option (@elt'')) (v51 : list (@X.t * option (@elt''))) => v50) v50 v51 end) v47 in (fun v50 : v43 = (v37, None) => let v51 : v43 = (v37, None) := v50 in eq_ind_r (fun v52 : @X.t * option (@elt'') => forall (v53 : v44 = v33) (v54 : ltk (v27, Some v30) v52), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) (fun v52 : v44 = v33 => let v53 : v44 = v33 := v52 in eq_ind_r (fun v54 : list (@X.t * option (@elt'')) => forall v55 : ltk (v27, Some v30) (v37, None), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) (fun v54 : ltk (v27, Some v30) (v37, None) => let v55 : forall v55 : (v37, None) :: v33 = (v37, None) :: v33, HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil) := match v41 as v56 in (Sorted _ v55) return (forall v57 : v55 = (v37, None) :: v33, HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) with | Sorted_nil _ => fun v55 : nil = (v37, None) :: v33 => (fun v56 : nil = (v37, None) :: v33 => let v57 : @False := eq_ind nil (fun v57 : list (@X.t * option (@elt'')) => match v57 as v58 in (list _) return Prop with | nil => @True | v58 :: v59 => (fun (v58 : @X.t * option (@elt'')) (v59 : list (@X.t * option (@elt''))) => @False) v58 v59 end) (@I) ((v37, None) :: v33) v56 in False_ind (HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) v57) v55 | @Sorted_cons _ _ v55 v56 v57 v58 => (fun (v55 : @X.t * option (@elt'')) (v56 : list (@X.t * option (@elt''))) (v57 : Sorted (ltk (elt:=option (@elt''))) v56) (v58 : HdRel (ltk (elt:=option (@elt''))) v55 v56) (v59 : v55 :: v56 = (v37, None) :: v33) => (fun v60 : v55 :: v56 = (v37, None) :: v33 => let v61 : v56 = v33 := f_equal (fun v61 : list (@X.t * option (@elt'')) => match v61 as v62 in (list _) return (list (@X.t * option (@elt''))) with | nil => v56 | v62 :: v63 => (fun (v62 : @X.t * option (@elt'')) (v63 : list (@X.t * option (@elt''))) => v63) v62 v63 end) v60 in (let v62 : v55 = (v37, None) := f_equal (fun v62 : list (@X.t * option (@elt'')) => match v62 as v63 in (list _) return (@X.t * option (@elt'')) with | nil => v55 | v63 :: v64 => (fun (v63 : @X.t * option (@elt'')) (v64 : list (@X.t * option (@elt''))) => v63) v63 v64 end) v60 in (fun v63 : v55 = (v37, None) => let v64 : v55 = (v37, None) := v63 in eq_ind_r (fun v65 : @X.t * option (@elt'') => forall (v66 : v56 = v33) (v67 : Sorted (ltk (elt:=option (@elt''))) v56) (v68 : HdRel (ltk (elt:=option (@elt''))) v65 v56), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) (fun v65 : v56 = v33 => let v66 : v56 = v33 := v65 in eq_ind_r (fun v67 : list (@X.t * option (@elt'')) => forall (v68 : Sorted (ltk (elt:=option (@elt''))) v67) (v69 : HdRel (ltk (elt:=option (@elt''))) (v37, None) v67), HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) v33 nil)) (fun (v67 : Sorted (ltk (elt:=option (@elt''))) v33) (v68 : HdRel (ltk (elt:=option (@elt''))) (v37, None) v33) => v34 v67 (Inf_lt (x:=(v27, Some v30)) v54 v68)) v66) v64) v62) v61) v59 v57 v58) v55 v56 v57 v58 end in v55 eq_refl) v53) v51) v49) v48) v46 v45) v43 v44 v45 end in v43 eq_refl) : HdRel (ltk (elt:=@elt'')) (v27, v30) (fold_right_pair (option_cons (A:=@elt'')) ((v37, None) :: v33) nil) end v39 v40) v37 v38 end v35 v36) v10 v25 v31) : Sorted (ltk (elt:=@elt'')) (fold_right_pair (option_cons (A:=@elt'')) ((v27, Some v30) :: v10) nil)) v30 | None => fun v30 : HdRel (ltk (elt:=option (@elt''))) (v27, None) v10 => v11 v25 end v29) v27 v28 end v26) v24) v22) v20) v19) v17 v15 v16) v13 v14 v15 v16 end in v13 eq_refl) v8 v7) : Sorted (ltk (elt:=@elt'')) (map2_alt v0 v2)) (map2 v0 v2) (map2_alt_equiv v0 v2))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.combine_1	100	3.887237	0	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.map2_0	100	4.150314	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.map2_1	100	0.205939	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (ltk (elt:=@elt)) v0) (v2 : list (@X.t * @elt')) (v3 : Sorted (ltk (elt:=@elt')) v2) (v4 : @key) (v5 : In v4 v0 \/ In v4 v2) => eq_ind_r (fun v6 : option (@elt'') => v6 = f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2)) match v5 as v6 in (_ \/ _) return (at_least_one_then_f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2) = f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2)) with | or_introl v6 => (fun v6 : In v4 v0 => match v6 as v7 in (ex _) return (at_least_one_then_f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2) = f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2)) with | ex_intro _ v7 v8 => (fun (v7 : @elt) (v8 : MapsTo v4 v7 v0) => eq_ind_r (fun v9 : option (@elt) => at_least_one_then_f v9 (find (elt:=@elt') v4 v2) = f v9 (find (elt:=@elt') v4 v2)) (let v9 : option (@elt') := find (elt:=@elt') v4 v2 in match v9 as v10 in (option _) return (at_least_one_then_f (Some v7) v10 = f (Some v7) v10) with | Some v10 => (fun v10 : @elt' => eq_refl : at_least_one_then_f (Some v7) (Some v10) = f (Some v7) (Some v10)) v10 | None => eq_refl : at_least_one_then_f (Some v7) None = f (Some v7) None end) (find_1 v1 (x:=v4) (e:=v7) v8)) v7 v8 end) v6 | or_intror v6 => (fun v6 : In v4 v2 => match v6 as v7 in (ex _) return (at_least_one_then_f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2) = f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2)) with | ex_intro _ v7 v8 => (fun (v7 : @elt') (v8 : MapsTo v4 v7 v2) => eq_ind_r (fun v9 : option (@elt') => at_least_one_then_f (find (elt:=@elt) v4 v0) v9 = f (find (elt:=@elt) v4 v0) v9) (let v9 : option (@elt) := find (elt:=@elt) v4 v0 in match v9 as v10 in (option _) return (at_least_one_then_f v10 (Some v7) = f v10 (Some v7)) with | Some v10 => (fun v10 : @elt => eq_refl : at_least_one_then_f (Some v10) (Some v7) = f (Some v10) (Some v7)) v10 | None => eq_refl : at_least_one_then_f None (Some v7) = f None (Some v7) end) (find_1 v3 (x:=v4) (e:=v7) v8)) v7 v8 end) v6 end (map2_0 v1 v3 v4))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Raw.Elt3.map2_2	100	0.485148	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@X.t * @elt)) (v1 : Sorted (ltk (elt:=@elt)) v0) (v2 : list (@X.t * @elt')) (v3 : Sorted (ltk (elt:=@elt')) v2) (v4 : @key) (v5 : In v4 (map2 v0 v2)) => match v5 as v6 in (ex _) return (In v4 v0 \/ In v4 v2) with | ex_intro _ v6 v7 => (fun (v6 : @elt'') (v7 : MapsTo v4 v6 (map2 v0 v2)) => eq_ind_r (fun v8 : option (@elt'') => forall v9 : v8 = at_least_one_then_f (find (elt:=@elt) v4 v0) (find (elt:=@elt') v4 v2), In v4 v0 \/ In v4 v2) ((let v8 : option (@elt) := find (elt:=@elt) v4 v0 in match v8 as v9 in (option _) return (forall (v10 : forall (v10 : @elt') (v11 : find (elt:=@elt') v4 v2 = Some v10), MapsTo v4 v10 v2) (v11 : forall (v11 : @elt) (v12 : v9 = Some v11), MapsTo v4 v11 v0) (v12 : Some v6 = at_least_one_then_f v9 (find (elt:=@elt') v4 v2)), In v4 v0 \/ In v4 v2) with | Some v9 => (fun v9 : @elt => let v10 : option (@elt') := find (elt:=@elt') v4 v2 in match v10 as v11 in (option _) return (forall (v12 : forall (v12 : @elt') (v13 : v11 = Some v12), MapsTo v4 v12 v2) (v13 : forall (v13 : @elt) (v14 : Some v9 = Some v13), MapsTo v4 v13 v0) (v14 : Some v6 = at_least_one_then_f (Some v9) v11), In v4 v0 \/ In v4 v2) with | Some v11 => (fun v11 : @elt' => (fun (v12 : forall (v12 : @elt') (v13 : Some v11 = Some v12), MapsTo v4 v12 v2) (v13 : forall (v13 : @elt) (v14 : Some v9 = Some v13), MapsTo v4 v13 v0) (v14 : Some v6 = f (Some v9) (Some v11)) => or_introl (ex_intro (fun v15 : @elt => MapsTo v4 v15 v0) v9 (v13 v9 eq_refl))) : forall (v12 : forall (v12 : @elt') (v13 : Some v11 = Some v12), MapsTo v4 v12 v2) (v13 : forall (v13 : @elt) (v14 : Some v9 = Some v13), MapsTo v4 v13 v0) (v14 : Some v6 = at_least_one_then_f (Some v9) (Some v11)), In v4 v0 \/ In v4 v2) v11 | None => (fun (v11 : forall (v11 : @elt') (v12 : None = Some v11), MapsTo v4 v11 v2) (v12 : forall (v12 : @elt) (v13 : Some v9 = Some v12), MapsTo v4 v12 v0) (v13 : Some v6 = f (Some v9) None) => or_introl (ex_intro (fun v14 : @elt => MapsTo v4 v14 v0) v9 (v12 v9 eq_refl))) : forall (v11 : forall (v11 : @elt') (v12 : None = Some v11), MapsTo v4 v11 v2) (v12 : forall (v12 : @elt) (v13 : Some v9 = Some v12), MapsTo v4 v12 v0) (v13 : Some v6 = at_least_one_then_f (Some v9) None), In v4 v0 \/ In v4 v2 end) v9 | None => let v9 : option (@elt') := find (elt:=@elt') v4 v2 in match v9 as v10 in (option _) return (forall (v11 : forall (v11 : @elt') (v12 : v10 = Some v11), MapsTo v4 v11 v2) (v12 : forall (v12 : @elt) (v13 : None = Some v12), MapsTo v4 v12 v0) (v13 : Some v6 = at_least_one_then_f None v10), In v4 v0 \/ In v4 v2) with | Some v10 => (fun v10 : @elt' => (fun (v11 : forall (v11 : @elt') (v12 : Some v10 = Some v11), MapsTo v4 v11 v2) (v12 : forall (v12 : @elt) (v13 : None = Some v12), MapsTo v4 v12 v0) (v13 : Some v6 = f None (Some v10)) => or_intror (ex_intro (fun v14 : @elt' => MapsTo v4 v14 v2) v10 (v11 v10 eq_refl))) : forall (v11 : forall (v11 : @elt') (v12 : Some v10 = Some v11), MapsTo v4 v11 v2) (v12 : forall (v12 : @elt) (v13 : None = Some v12), MapsTo v4 v12 v0) (v13 : Some v6 = at_least_one_then_f None (Some v10)), In v4 v0 \/ In v4 v2) v10 | None => (fun (v10 : forall (v10 : @elt') (v11 : None = Some v10), MapsTo v4 v10 v2) (v11 : forall (v11 : @elt) (v12 : None = Some v11), MapsTo v4 v11 v0) (v12 : Some v6 = None) => let v13 : @False := eq_ind (Some v6) (fun v13 : option (@elt'') => match v13 as v14 in (option _) return Prop with | Some v14 => (fun v14 : @elt'' => @True) v14 | None => @False end) (@I) None v12 in False_ind (In v4 v0 \/ In v4 v2) v13) : forall (v10 : forall (v10 : @elt') (v11 : None = Some v10), MapsTo v4 v10 v2) (v11 : forall (v11 : @elt) (v12 : None = Some v11), MapsTo v4 v11 v0) (v12 : Some v6 = at_least_one_then_f None None), In v4 v0 \/ In v4 v2 end end) (find_2 (m:=v2) (x:=v4)) (find_2 (m:=v0) (x:=v4))) (find_1 (map2_sorted v1 v3) (x:=v4) (e:=v6) v7) (map2_0 v1 v3 v4)) v6 v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.MapsTo_1	100	0.028282	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.PX.MapsTo_eq (l:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.mem_1	100	0.030170	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.mem_1 (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.mem_2	100	0.032273	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.mem_2 (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.empty_1	100	0.015086	1	1	0	synth with cache (only 1: refine (Raw.empty_1 (elt:=@elt))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.is_empty_1	100	0.027299	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.is_empty_1 (m:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.is_empty_2	100	0.023170	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.is_empty_2 (elt:=@elt) (m:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.add_1	100	0.027346	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.add_1 (elt:=@elt) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.add_2	100	0.033309	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.add_2 (m:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.add_3	100	0.035622	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.add_3 (elt:=@elt) (m:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.remove_1	100	0.029818	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.remove_1 (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.remove_2	100	0.039734	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.remove_2 (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.remove_3	100	0.033583	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.remove_3 (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.find_1	100	0.034770	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.find_1 (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.find_2	100	0.036044	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.find_2 (elt:=@elt) (m:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.elements_1	100	0.039134	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.elements_1 (m:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.elements_2	100	0.041973	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.elements_2 (elt:=@elt) (m:=v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.elements_3	100	0.032068	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.elements_3 (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.elements_3w	100	0.030257	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.elements_3w (sorted v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.cardinal_1	100	0.032714	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.fold_1	100	0.053425	1	1	0	synth with cache (only 1: refine (fun v0 : t (@elt) => Raw.fold_1 (elt:=@elt) v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.equal_1	100	0.042706	1	1	0	synth with cache (only 1: refine (fun v0 v1 : t (@elt) => Raw.equal_1 (sorted v0) (sorted v1))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.Elt.equal_2	100	0.091986	1	1	0	synth with cache (only 1: refine (fun v0 v1 : t (@elt) => Raw.equal_2 (sorted v0) (sorted v1))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.map_1	100	0.035846	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : t v0) => Raw.map_1 (elt:=v0) (elt':=v1) (m:=v2))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.map_2	100	0.034686	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : t v0) => Raw.map_2 (elt:=v0) (elt':=v1) (m:=v2))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.mapi_1	100	0.041270	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : t v0) => Raw.mapi_1 (elt:=v0) (elt':=v1) (m:=v2))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.mapi_2	100	0.032034	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : t v0) => Raw.mapi_2 (elt:=v0) (elt':=v1) (m:=v2))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.map2_1	100	0.054580	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 : t v0) (v4 : t v1) (v5 : @key) (v6 : forall (v6 : option v0) (v7 : option v1), option v2) => Raw.map2_1 v6 (sorted v3) (sorted v4) (x:=v5))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make.map2_2	100	0.046203	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 : t v0) (v4 : t v1) (v5 : @key) (v6 : forall (v6 : option v0) (v7 : option v1), option v2) => Raw.map2_2 (f:=v6) (sorted v3) (sorted v4) (x:=v5))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.eq_equal	100	1.219186	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.eq_1	100	0.051517	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : MapS.t (@D.t)) (v2 : Equivb (@cmp) v0 v1) => (fun (v3 : eq v0 v1 <-> equal (@cmp) v0 v1 = @true) (v4 : forall v4 : Equivb (@cmp) v0 v1, equal (@cmp) v0 v1 = @true) => and_ind (fun (v5 : forall v5 : eq v0 v1, equal (@cmp) v0 v1 = @true) (v6 : forall v6 : equal (@cmp) v0 v1 = @true, eq v0 v1) => let v7 : equal (@cmp) v0 v1 = @true := v4 v2 in let v8 : eq v0 v1 := v6 v7 in let v9 : equal (@cmp) v0 v1 = @true := v5 v8 in v8) v3) (eq_equal v0 v1) (equal_1 (m:=v0) (m':=v1) (cmp:=@cmp)))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.eq_2	100	0.052981	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : slist (@D.t)) (v2 : eq v0 v1) => (fun (v3 : eq v0 v1 <-> equal (@cmp) v0 v1 = @true) (v4 : forall v4 : equal (@cmp) v0 v1 = @true, Equivb (@cmp) v0 v1) => and_ind (fun (v5 : forall v5 : eq v0 v1, equal (@cmp) v0 v1 = @true) (v6 : forall v6 : equal (@cmp) v0 v1 = @true, eq v0 v1) => let v7 : equal (@cmp) v0 v1 = @true := v5 v2 in let v8 : Equivb (@cmp) v0 v1 := v4 v7 in let v9 : eq v0 v1 := v6 v7 in v8) v3) (eq_equal v0 v1) (equal_2 (m:=v0) (m':=v1) (cmp:=@cmp)))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.eq_refl	100	0.277164	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match v0 as v1 in (slist _) return (eq v1 v1) with | {| this := v1; sorted := v2 |} => (fun (v1 : Raw.t (@D.t)) (v2 : Sorted (Raw.PX.ltk (elt:=@D.t)) v1) => list_ind (fun v3 : list (@X.t * @D.t) => forall v4 : Sorted (Raw.PX.ltk (elt:=@D.t)) v3, eq {| this := v3; sorted := v4 |} {| this := v3; sorted := v4 |}) (fun v3 : Sorted (Raw.PX.ltk (elt:=@D.t)) nil => (@I : eq_list {| this := nil; sorted := v3 |} {| this := nil; sorted := v3 |}) : eq {| this := nil; sorted := v3 |} {| this := nil; sorted := v3 |}) (fun (v3 : @X.t * @D.t) (v4 : list (@X.t * @D.t)) (v5 : forall v5 : Sorted (Raw.PX.ltk (elt:=@D.t)) v4, eq {| this := v4; sorted := v5 |} {| this := v4; sorted := v5 |}) (v6 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v3 :: v4)) => (match v3 as v7 in (_ * _)%type return (forall v8 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v7 :: v4), match v7 as v9 in (_ * _) return Prop with | (v9, v10) => (fun (v9 : @X.t) (v10 : @D.t) => match v7 as v11 in (_ * _)%type return Prop with | (v11, v12) => (fun (v11 : @X.t) (v12 : @D.t) => match X.compare v9 v11 as v13 in (Compare _ _ _ _) return Prop with | LT v13 => (fun v13 : X.lt v9 v11 => @False) v13 | EQ v13 => (fun v13 : X.eq v9 v11 => D.eq v10 v12 /\ eq_list v4 v4) v13 | GT v13 => (fun v13 : X.lt v11 v9 => @False) v13 end) v11 v12 end) v9 v10 end) with | (v7, v8) => (fun (v7 : @X.t) (v8 : @D.t) (v9 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v7, v8) :: v4)) => let v10 : Compare (@X.lt) (@X.eq) v7 v7 := X.compare v7 v7 in match v10 as v11 in (Compare _ _ _ _) return match v11 as v12 in (Compare _ _ _ _) return Prop with | EQ v12 => (fun v12 : X.eq v7 v7 => D.eq v8 v8 /\ eq_list v4 v4) v12 | LT v12 | GT v12 => (fun v12 : X.lt v7 v7 => @False) v12 end with | EQ v11 => (fun v11 : X.eq v7 v7 => conj (D.eq_refl v8) (let v12 : forall v12 : (v7, v8) :: v4 = (v7, v8) :: v4, eq_list v4 v4 := match v9 as v13 in (Sorted _ v12) return (forall v14 : v12 = (v7, v8) :: v4, eq_list v4 v4) with | Sorted_nil _ => fun v12 : nil = (v7, v8) :: v4 => (fun v13 : nil = (v7, v8) :: v4 => let v14 : @False := eq_ind nil (fun v14 : list (@X.t * @D.t) => match v14 as v15 in (list _) return Prop with | nil => @True | v15 :: v16 => (fun (v15 : @X.t * @D.t) (v16 : list (@X.t * @D.t)) => @False) v15 v16 end) (@I) ((v7, v8) :: v4) v13 in False_ind (eq_list v4 v4) v14) v12 | @Sorted_cons _ _ v12 v13 v14 v15 => (fun (v12 : @X.t * @D.t) (v13 : list (@X.t * @D.t)) (v14 : Sorted (Raw.PX.ltk (elt:=@D.t)) v13) (v15 : HdRel (Raw.PX.ltk (elt:=@D.t)) v12 v13) (v16 : v12 :: v13 = (v7, v8) :: v4) => (fun v17 : v12 :: v13 = (v7, v8) :: v4 => let v18 : v13 = v4 := f_equal (fun v18 : list (@X.t * @D.t) => match v18 as v19 in (list _) return (list (@X.t * @D.t)) with | nil => v13 | v19 :: v20 => (fun (v19 : @X.t * @D.t) (v20 : list (@X.t * @D.t)) => v20) v19 v20 end) v17 in (let v19 : v12 = (v7, v8) := f_equal (fun v19 : list (@X.t * @D.t) => match v19 as v20 in (list _) return (@X.t * @D.t) with | nil => v12 | v20 :: v21 => (fun (v20 : @X.t * @D.t) (v21 : list (@X.t * @D.t)) => v20) v20 v21 end) v17 in (fun v20 : v12 = (v7, v8) => let v21 : v12 = (v7, v8) := v20 in eq_ind_r (fun v22 : @X.t * @D.t => forall (v23 : v13 = v4) (v24 : Sorted (Raw.PX.ltk (elt:=@D.t)) v13) (v25 : HdRel (Raw.PX.ltk (elt:=@D.t)) v22 v13), eq_list v4 v4) (fun v22 : v13 = v4 => let v23 : v13 = v4 := v22 in eq_ind_r (fun v24 : list (@X.t * @D.t) => forall (v25 : Sorted (Raw.PX.ltk (elt:=@D.t)) v24) (v26 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v7, v8) v24), eq_list v4 v4) (fun (v24 : Sorted (Raw.PX.ltk (elt:=@D.t)) v4) (v25 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v7, v8) v4) => v5 v24) v23) v21) v19) v18) v16 v14 v15) v12 v13 v14 v15 end in v12 eq_refl)) v11 | LT v11 | GT v11 => (fun v11 : X.lt v7 v7 => Raw.MX.lt_antirefl v11) v11 end) v7 v8 end v6 : eq_list {| this := v3 :: v4; sorted := v6 |} {| this := v3 :: v4; sorted := v6 |}) : eq {| this := v3 :: v4; sorted := v6 |} {| this := v3 :: v4; sorted := v6 |}) v1 v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.eq_sym	100	0.779547	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match v0 as v1 in (slist _) return (forall (v2 : @t) (v3 : eq v1 v2), eq v2 v1) with | {| this := v1; sorted := v2 |} => (fun (v1 : Raw.t (@D.t)) (v2 : Sorted (Raw.PX.ltk (elt:=@D.t)) v1) => list_ind (fun v3 : list (@X.t * @D.t) => forall (v4 : Sorted (Raw.PX.ltk (elt:=@D.t)) v3) (v5 : @t) (v6 : eq {| this := v3; sorted := v4 |} v5), eq v5 {| this := v3; sorted := v4 |}) (fun (v3 : Sorted (Raw.PX.ltk (elt:=@D.t)) nil) (v4 : @t) => match v4 as v5 in (slist _) return (forall v6 : eq {| this := nil; sorted := v3 |} v5, eq v5 {| this := nil; sorted := v3 |}) with | {| this := v5; sorted := v6 |} => (fun (v5 : Raw.t (@D.t)) (v6 : Sorted (Raw.PX.ltk (elt:=@D.t)) v5) => match v5 as v7 in (list _) return (forall (v8 : Sorted (Raw.PX.ltk (elt:=@D.t)) v7) (v9 : eq {| this := nil; sorted := v3 |} {| this := v7; sorted := v8 |}), eq {| this := v7; sorted := v8 |} {| this := nil; sorted := v3 |}) with | nil => fun v7 : Sorted (Raw.PX.ltk (elt:=@D.t)) nil => ((fun v8 : @True => v8) : forall v8 : eq_list {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |}, eq_list {| this := nil; sorted := v7 |} {| this := nil; sorted := v3 |}) : forall v8 : eq {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |}, eq {| this := nil; sorted := v7 |} {| this := nil; sorted := v3 |} | v7 :: v8 => (fun (v7 : @X.t * @D.t) (v8 : list (@X.t * @D.t)) (v9 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v7 :: v8)) => (match v7 as v10 in (_ * _)%type return (forall (v11 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v10 :: v8)) (v12 : @False), match v10 as v13 in (_ * _) return Prop with | (v13, v14) => (fun (v13 : @X.t) (v14 : @D.t) => @False) v13 v14 end) with | (v10, v11) => (fun (v10 : @X.t) (v11 : @D.t) (v12 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v10, v11) :: v8)) (v13 : @False) => v13) v10 v11 end v9 : forall v10 : eq_list {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}, eq_list {| this := v7 :: v8; sorted := v9 |} {| this := nil; sorted := v3 |}) : forall v10 : eq {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}, eq {| this := v7 :: v8; sorted := v9 |} {| this := nil; sorted := v3 |}) v7 v8 end v6) v5 v6 end) (fun (v3 : @X.t * @D.t) (v4 : list (@X.t * @D.t)) (v5 : forall (v5 : Sorted (Raw.PX.ltk (elt:=@D.t)) v4) (v6 : @t) (v7 : eq {| this := v4; sorted := v5 |} v6), eq v6 {| this := v4; sorted := v5 |}) (v6 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v3 :: v4)) (v7 : @t) => match v7 as v8 in (slist _) return (forall v9 : eq {| this := v3 :: v4; sorted := v6 |} v8, eq v8 {| this := v3 :: v4; sorted := v6 |}) with | {| this := v8; sorted := v9 |} => (fun (v8 : Raw.t (@D.t)) (v9 : Sorted (Raw.PX.ltk (elt:=@D.t)) v8) => match v8 as v10 in (list _) return (forall (v11 : Sorted (Raw.PX.ltk (elt:=@D.t)) v10) (v12 : eq {| this := v3 :: v4; sorted := v6 |} {| this := v10; sorted := v11 |}), eq {| this := v10; sorted := v11 |} {| this := v3 :: v4; sorted := v6 |}) with | nil => fun v10 : Sorted (Raw.PX.ltk (elt:=@D.t)) nil => (match v3 as v11 in (_ * _)%type return (forall (v12 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v11 :: v4)) (v13 : match v11 as v13 in (_ * _) return Prop with | (v13, v14) => (fun (v13 : @X.t) (v14 : @D.t) => @False) v13 v14 end), @False) with | (v11, v12) => (fun (v11 : @X.t) (v12 : @D.t) (v13 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v11, v12) :: v4)) (v14 : @False) => v14) v11 v12 end v6 : forall v11 : eq_list {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |}, eq_list {| this := nil; sorted := v10 |} {| this := v3 :: v4; sorted := v6 |}) : forall v11 : eq {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |}, eq {| this := nil; sorted := v10 |} {| this := v3 :: v4; sorted := v6 |} | v10 :: v11 => (fun (v10 : @X.t * @D.t) (v11 : list (@X.t * @D.t)) (v12 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v10 :: v11)) => (match v3 as v13 in (_ * _)%type return (forall (v14 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v13 :: v4)) (v15 : match v13 as v15 in (_ * _) return Prop with | (v15, v16) => (fun (v15 : @X.t) (v16 : @D.t) => match v10 as v17 in (_ * _)%type return Prop with | (v17, v18) => (fun (v17 : @X.t) (v18 : @D.t) => match X.compare v15 v17 as v19 in (Compare _ _ _ _) return Prop with | LT v19 => (fun v19 : X.lt v15 v17 => @False) v19 | EQ v19 => (fun v19 : X.eq v15 v17 => D.eq v16 v18 /\ eq_list v4 v11) v19 | GT v19 => (fun v19 : X.lt v17 v15 => @False) v19 end) v17 v18 end) v15 v16 end), match v10 as v16 in (_ * _) return Prop with | (v16, v17) => (fun (v16 : @X.t) (v17 : @D.t) => match v13 as v18 in (_ * _)%type return Prop with | (v18, v19) => (fun (v18 : @X.t) (v19 : @D.t) => match X.compare v16 v18 as v20 in (Compare _ _ _ _) return Prop with | LT v20 => (fun v20 : X.lt v16 v18 => @False) v20 | EQ v20 => (fun v20 : X.eq v16 v18 => D.eq v17 v19 /\ eq_list v11 v4) v20 | GT v20 => (fun v20 : X.lt v18 v16 => @False) v20 end) v18 v19 end) v16 v17 end) with | (v13, v14) => (fun (v13 : @X.t) (v14 : @D.t) (v15 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v13, v14) :: v4)) => match v10 as v16 in (_ * _)%type return (forall (v17 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v16 :: v11)) (v18 : match v16 as v18 in (_ * _) return Prop with | (v18, v19) => (fun (v18 : @X.t) (v19 : @D.t) => match X.compare v13 v18 as v20 in (Compare _ _ _ _) return Prop with | LT v20 => (fun v20 : X.lt v13 v18 => @False) v20 | EQ v20 => (fun v20 : X.eq v13 v18 => D.eq v14 v19 /\ eq_list v4 v11) v20 | GT v20 => (fun v20 : X.lt v18 v13 => @False) v20 end) v18 v19 end), match v16 as v19 in (_ * _) return Prop with | (v19, v20) => (fun (v19 : @X.t) (v20 : @D.t) => match X.compare v19 v13 as v21 in (Compare _ _ _ _) return Prop with | LT v21 => (fun v21 : X.lt v19 v13 => @False) v21 | EQ v21 => (fun v21 : X.eq v19 v13 => D.eq v20 v14 /\ eq_list v11 v4) v21 | GT v21 => (fun v21 : X.lt v13 v19 => @False) v21 end) v19 v20 end) with | (v16, v17) => (fun (v16 : @X.t) (v17 : @D.t) (v18 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v16, v17) :: v11)) => let v19 : Compare (@X.lt) (@X.eq) v13 v16 := X.compare v13 v16 in match v19 as v20 in (Compare _ _ _ _) return (forall v21 : match v20 as v21 in (Compare _ _ _ _) return Prop with | LT v21 => (fun v21 : X.lt v13 v16 => @False) v21 | EQ v21 => (fun v21 : X.eq v13 v16 => D.eq v14 v17 /\ eq_list v4 v11) v21 | GT v21 => (fun v21 : X.lt v16 v13 => @False) v21 end, match X.compare v16 v13 as v22 in (Compare _ _ _ _) return Prop with | LT v22 => (fun v22 : X.lt v16 v13 => @False) v22 | EQ v22 => (fun v22 : X.eq v16 v13 => D.eq v17 v14 /\ eq_list v11 v4) v22 | GT v22 => (fun v22 : X.lt v13 v16 => @False) v22 end) with | LT v20 => (fun v20 : X.lt v13 v16 => let v21 : Compare (@X.lt) (@X.eq) v16 v13 := X.compare v16 v13 in match v21 as v22 in (Compare _ _ _ _) return (forall v23 : @False, match v22 as v24 in (Compare _ _ _ _) return Prop with | LT v24 => (fun v24 : X.lt v16 v13 => @False) v24 | EQ v24 => (fun v24 : X.eq v16 v13 => D.eq v17 v14 /\ eq_list v11 v4) v24 | GT v24 => (fun v24 : X.lt v13 v16 => @False) v24 end) with | LT v22 => (fun (v22 : X.lt v16 v13) (v23 : @False) => False_ind (@False) ((fun v24 : Raw.MX.TO.lt v13 v13 => Raw.MX.OrderTac.lt_irrefl v24) (Raw.MX.OrderTac.lt_trans v20 v22))) v22 | EQ v22 => (fun (v22 : X.eq v16 v13) (v23 : @False) => False_ind (D.eq v17 v14 /\ eq_list v11 v4) ((fun v24 : Raw.MX.TO.lt v13 v13 => Raw.MX.OrderTac.lt_irrefl v24) (Raw.MX.OrderTac.lt_eq v20 v22))) v22 | GT v22 => (fun (v22 : X.lt v13 v16) (v23 : @False) => False_ind (@False) v23) v22 end) v20 | EQ v20 => (fun v20 : X.eq v13 v16 => let v21 : Compare (@X.lt) (@X.eq) v16 v13 := X.compare v16 v13 in match v21 as v22 in (Compare _ _ _ _) return (forall v23 : D.eq v14 v17 /\ eq_list v4 v11, match v22 as v24 in (Compare _ _ _ _) return Prop with | LT v24 => (fun v24 : X.lt v16 v13 => @False) v24 | EQ v24 => (fun v24 : X.eq v16 v13 => D.eq v17 v14 /\ eq_list v11 v4) v24 | GT v24 => (fun v24 : X.lt v13 v16 => @False) v24 end) with | LT v22 => (fun (v22 : X.lt v16 v13) (v23 : D.eq v14 v17 /\ eq_list v4 v11) => False_ind (@False) ((fun v24 : Raw.MX.TO.lt v16 v16 => Raw.MX.OrderTac.lt_irrefl v24) (Raw.MX.OrderTac.lt_eq v22 v20))) v22 | EQ v22 => (fun (v22 : X.eq v16 v13) (v23 : D.eq v14 v17 /\ eq_list v4 v11) => and_ind (fun (v24 : D.eq v14 v17) (v25 : eq_list v4 v11) => conj (symmetry v24 : D.eq v17 v14) (let v26 : forall v26 : (v13, v14) :: v4 = (v13, v14) :: v4, eq_list v11 v4 := match v15 as v27 in (Sorted _ v26) return (forall v28 : v26 = (v13, v14) :: v4, eq_list v11 v4) with | Sorted_nil _ => fun v26 : nil = (v13, v14) :: v4 => (fun v27 : nil = (v13, v14) :: v4 => let v28 : @False := eq_ind nil (fun v28 : list (@X.t * @D.t) => match v28 as v29 in (list _) return Prop with | nil => @True | v29 :: v30 => (fun (v29 : @X.t * @D.t) (v30 : list (@X.t * @D.t)) => @False) v29 v30 end) (@I) ((v13, v14) :: v4) v27 in False_ind (eq_list v11 v4) v28) v26 | @Sorted_cons _ _ v26 v27 v28 v29 => (fun (v26 : @X.t * @D.t) (v27 : list (@X.t * @D.t)) (v28 : Sorted (Raw.PX.ltk (elt:=@D.t)) v27) (v29 : HdRel (Raw.PX.ltk (elt:=@D.t)) v26 v27) (v30 : v26 :: v27 = (v13, v14) :: v4) => (fun v31 : v26 :: v27 = (v13, v14) :: v4 => let v32 : v27 = v4 := f_equal (fun v32 : list (@X.t * @D.t) => match v32 as v33 in (list _) return (list (@X.t * @D.t)) with | nil => v27 | v33 :: v34 => (fun (v33 : @X.t * @D.t) (v34 : list (@X.t * @D.t)) => v34) v33 v34 end) v31 in (let v33 : v26 = (v13, v14) := f_equal (fun v33 : list (@X.t * @D.t) => match v33 as v34 in (list _) return (@X.t * @D.t) with | nil => v26 | v34 :: v35 => (fun (v34 : @X.t * @D.t) (v35 : list (@X.t * @D.t)) => v34) v34 v35 end) v31 in (fun v34 : v26 = (v13, v14) => let v35 : v26 = (v13, v14) := v34 in eq_ind_r (fun v36 : @X.t * @D.t => forall (v37 : v27 = v4) (v38 : Sorted (Raw.PX.ltk (elt:=@D.t)) v27) (v39 : HdRel (Raw.PX.ltk (elt:=@D.t)) v36 v27), eq_list v11 v4) (fun v36 : v27 = v4 => let v37 : v27 = v4 := v36 in eq_ind_r (fun v38 : list (@X.t * @D.t) => forall (v39 : Sorted (Raw.PX.ltk (elt:=@D.t)) v38) (v40 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v13, v14) v38), eq_list v11 v4) (fun (v38 : Sorted (Raw.PX.ltk (elt:=@D.t)) v4) (v39 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v13, v14) v4) => let v40 : forall v40 : (v16, v17) :: v11 = (v16, v17) :: v11, eq_list v11 v4 := match v18 as v41 in (Sorted _ v40) return (forall v42 : v40 = (v16, v17) :: v11, eq_list v11 v4) with | Sorted_nil _ => fun v40 : nil = (v16, v17) :: v11 => (fun v41 : nil = (v16, v17) :: v11 => let v42 : @False := eq_ind nil (fun v42 : list (@X.t * @D.t) => match v42 as v43 in (list _) return Prop with | nil => @True | v43 :: v44 => (fun (v43 : @X.t * @D.t) (v44 : list (@X.t * @D.t)) => @False) v43 v44 end) (@I) ((v16, v17) :: v11) v41 in False_ind (eq_list v11 v4) v42) v40 | @Sorted_cons _ _ v40 v41 v42 v43 => (fun (v40 : @X.t * @D.t) (v41 : list (@X.t * @D.t)) (v42 : Sorted (Raw.PX.ltk (elt:=@D.t)) v41) (v43 : HdRel (Raw.PX.ltk (elt:=@D.t)) v40 v41) (v44 : v40 :: v41 = (v16, v17) :: v11) => (fun v45 : v40 :: v41 = (v16, v17) :: v11 => let v46 : v41 = v11 := f_equal (fun v46 : list (@X.t * @D.t) => match v46 as v47 in (list _) return (list (@X.t * @D.t)) with | nil => v41 | v47 :: v48 => (fun (v47 : @X.t * @D.t) (v48 : list (@X.t * @D.t)) => v48) v47 v48 end) v45 in (let v47 : v40 = (v16, v17) := f_equal (fun v47 : list (@X.t * @D.t) => match v47 as v48 in (list _) return (@X.t * @D.t) with | nil => v40 | v48 :: v49 => (fun (v48 : @X.t * @D.t) (v49 : list (@X.t * @D.t)) => v48) v48 v49 end) v45 in (fun v48 : v40 = (v16, v17) => let v49 : v40 = (v16, v17) := v48 in eq_ind_r (fun v50 : @X.t * @D.t => forall (v51 : v41 = v11) (v52 : Sorted (Raw.PX.ltk (elt:=@D.t)) v41) (v53 : HdRel (Raw.PX.ltk (elt:=@D.t)) v50 v41), eq_list v11 v4) (fun v50 : v41 = v11 => let v51 : v41 = v11 := v50 in eq_ind_r (fun v52 : list (@X.t * @D.t) => forall (v53 : Sorted (Raw.PX.ltk (elt:=@D.t)) v52) (v54 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v16, v17) v52), eq_list v11 v4) (fun (v52 : Sorted (Raw.PX.ltk (elt:=@D.t)) v11) (v53 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v16, v17) v11) => v5 v38 {| this := v11; sorted := v52 |} v25) v51) v49) v47) v46) v44 v42 v43) v40 v41 v42 v43 end in v40 Logic.eq_refl) v37) v35) v33) v32) v30 v28 v29) v26 v27 v28 v29 end in v26 Logic.eq_refl)) v23) v22 | GT v22 => (fun (v22 : X.lt v13 v16) (v23 : D.eq v14 v17 /\ eq_list v4 v11) => False_ind (@False) ((fun v24 : Raw.MX.TO.lt v16 v16 => Raw.MX.OrderTac.lt_irrefl v24) (Raw.MX.OrderTac.eq_lt (Raw.MX.OrderTac.eq_sym v20) v22))) v22 end) v20 | GT v20 => (fun v20 : X.lt v16 v13 => let v21 : Compare (@X.lt) (@X.eq) v16 v13 := X.compare v16 v13 in match v21 as v22 in (Compare _ _ _ _) return (forall v23 : @False, match v22 as v24 in (Compare _ _ _ _) return Prop with | LT v24 => (fun v24 : X.lt v16 v13 => @False) v24 | EQ v24 => (fun v24 : X.eq v16 v13 => D.eq v17 v14 /\ eq_list v11 v4) v24 | GT v24 => (fun v24 : X.lt v13 v16 => @False) v24 end) with | LT v22 => (fun (v22 : X.lt v16 v13) (v23 : @False) => False_ind (@False) v23) v22 | EQ v22 => (fun (v22 : X.eq v16 v13) (v23 : @False) => False_ind (D.eq v17 v14 /\ eq_list v11 v4) ((fun v24 : Raw.MX.TO.lt v13 v13 => Raw.MX.OrderTac.lt_irrefl v24) (Raw.MX.OrderTac.eq_lt (Raw.MX.OrderTac.eq_sym v22) v20))) v22 | GT v22 => (fun (v22 : X.lt v13 v16) (v23 : @False) => False_ind (@False) ((fun v24 : Raw.MX.TO.lt v16 v16 => Raw.MX.OrderTac.lt_irrefl v24) (Raw.MX.OrderTac.lt_trans v20 v22))) v22 end) v20 end) v16 v17 end v12) v13 v14 end v6 : forall v13 : eq_list {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}, eq_list {| this := v10 :: v11; sorted := v12 |} {| this := v3 :: v4; sorted := v6 |}) : forall v13 : eq {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}, eq {| this := v10 :: v11; sorted := v12 |} {| this := v3 :: v4; sorted := v6 |}) v10 v11 end v9) v8 v9 end) v1 v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.eq_trans	100	2.430497	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.lt_trans	100	2.359663	1	1
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.lt_not_eq	100	0.716915	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match v0 as v1 in (slist _) return (forall (v2 : @t) (v3 : lt v1 v2), ~ eq v1 v2) with | {| this := v1; sorted := v2 |} => (fun (v1 : Raw.t (@D.t)) (v2 : Sorted (Raw.PX.ltk (elt:=@D.t)) v1) => list_ind (fun v3 : list (@X.t * @D.t) => forall (v4 : Sorted (Raw.PX.ltk (elt:=@D.t)) v3) (v5 : @t) (v6 : lt {| this := v3; sorted := v4 |} v5), ~ eq {| this := v3; sorted := v4 |} v5) (fun (v3 : Sorted (Raw.PX.ltk (elt:=@D.t)) nil) (v4 : @t) => match v4 as v5 in (slist _) return (forall v6 : lt {| this := nil; sorted := v3 |} v5, ~ eq {| this := nil; sorted := v3 |} v5) with | {| this := v5; sorted := v6 |} => (fun (v5 : Raw.t (@D.t)) (v6 : Sorted (Raw.PX.ltk (elt:=@D.t)) v5) => match v5 as v7 in (list _) return (forall (v8 : Sorted (Raw.PX.ltk (elt:=@D.t)) v7) (v9 : lt {| this := nil; sorted := v3 |} {| this := v7; sorted := v8 |}), ~ eq {| this := nil; sorted := v3 |} {| this := v7; sorted := v8 |}) with | nil => fun v7 : Sorted (Raw.PX.ltk (elt:=@D.t)) nil => (((fun v8 : @False => False_ind (~ @True) v8) : forall v8 : lt_list {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |}, ~ eq_list {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |}) : forall v8 : lt {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |}, ~ eq_list {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |}) : forall v8 : lt {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |}, ~ eq {| this := nil; sorted := v3 |} {| this := nil; sorted := v7 |} | v7 :: v8 => (fun (v7 : @X.t * @D.t) (v8 : list (@X.t * @D.t)) (v9 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v7 :: v8)) => ((match v7 as v10 in (_ * _)%type return (forall (v11 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v10 :: v8)) (v12 : @True), ~ @False) with | (v10, v11) => (fun (v10 : @X.t) (v11 : @D.t) (v12 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v10, v11) :: v8)) (v13 : @True) => (fun v14 : @False => v14) : ~ @False) v10 v11 end v9 : forall v10 : lt_list {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}, ~ eq_list {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}) : forall v10 : lt {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}, ~ eq_list {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}) : forall v10 : lt {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}, ~ eq {| this := nil; sorted := v3 |} {| this := v7 :: v8; sorted := v9 |}) v7 v8 end v6) v5 v6 end) (fun (v3 : @X.t * @D.t) (v4 : list (@X.t * @D.t)) (v5 : forall (v5 : Sorted (Raw.PX.ltk (elt:=@D.t)) v4) (v6 : @t) (v7 : lt {| this := v4; sorted := v5 |} v6), ~ eq {| this := v4; sorted := v5 |} v6) (v6 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v3 :: v4)) (v7 : @t) => match v7 as v8 in (slist _) return (forall v9 : lt {| this := v3 :: v4; sorted := v6 |} v8, ~ eq {| this := v3 :: v4; sorted := v6 |} v8) with | {| this := v8; sorted := v9 |} => (fun (v8 : Raw.t (@D.t)) (v9 : Sorted (Raw.PX.ltk (elt:=@D.t)) v8) => match v8 as v10 in (list _) return (forall (v11 : Sorted (Raw.PX.ltk (elt:=@D.t)) v10) (v12 : lt {| this := v3 :: v4; sorted := v6 |} {| this := v10; sorted := v11 |}), ~ eq {| this := v3 :: v4; sorted := v6 |} {| this := v10; sorted := v11 |}) with | nil => fun v10 : Sorted (Raw.PX.ltk (elt:=@D.t)) nil => ((match v3 as v11 in (_ * _)%type return (forall (v12 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v11 :: v4)) (v13 : match v11 as v13 in (_ * _) return Prop with | (v13, v14) => (fun (v13 : @X.t) (v14 : @D.t) => @False) v13 v14 end), ~ match v11 as v14 in (_ * _) return Prop with | (v14, v15) => (fun (v14 : @X.t) (v15 : @D.t) => @False) v14 v15 end) with | (v11, v12) => (fun (v11 : @X.t) (v12 : @D.t) (v13 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v11, v12) :: v4)) (v14 : @False) => False_ind (~ @False) v14) v11 v12 end v6 : forall v11 : lt_list {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |}, ~ eq_list {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |}) : forall v11 : lt {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |}, ~ eq_list {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |}) : forall v11 : lt {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |}, ~ eq {| this := v3 :: v4; sorted := v6 |} {| this := nil; sorted := v10 |} | v10 :: v11 => (fun (v10 : @X.t * @D.t) (v11 : list (@X.t * @D.t)) (v12 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v10 :: v11)) => ((match v3 as v13 in (_ * _)%type return (forall (v14 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v13 :: v4)) (v15 : match v13 as v15 in (_ * _) return Prop with | (v15, v16) => (fun (v15 : @X.t) (v16 : @D.t) => match v10 as v17 in (_ * _)%type return Prop with | (v17, v18) => (fun (v17 : @X.t) (v18 : @D.t) => match X.compare v15 v17 as v19 in (Compare _ _ _ _) return Prop with | LT v19 => (fun v19 : X.lt v15 v17 => @True) v19 | EQ v19 => (fun v19 : X.eq v15 v17 => D.lt v16 v18 \/ D.eq v16 v18 /\ lt_list v4 v11) v19 | GT v19 => (fun v19 : X.lt v17 v15 => @False) v19 end) v17 v18 end) v15 v16 end), ~ match v13 as v16 in (_ * _) return Prop with | (v16, v17) => (fun (v16 : @X.t) (v17 : @D.t) => match v10 as v18 in (_ * _)%type return Prop with | (v18, v19) => (fun (v18 : @X.t) (v19 : @D.t) => match X.compare v16 v18 as v20 in (Compare _ _ _ _) return Prop with | LT v20 => (fun v20 : X.lt v16 v18 => @False) v20 | EQ v20 => (fun v20 : X.eq v16 v18 => D.eq v17 v19 /\ eq_list v4 v11) v20 | GT v20 => (fun v20 : X.lt v18 v16 => @False) v20 end) v18 v19 end) v16 v17 end) with | (v13, v14) => (fun (v13 : @X.t) (v14 : @D.t) (v15 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v13, v14) :: v4)) => match v10 as v16 in (_ * _)%type return (forall (v17 : Sorted (Raw.PX.ltk (elt:=@D.t)) (v16 :: v11)) (v18 : match v16 as v18 in (_ * _) return Prop with | (v18, v19) => (fun (v18 : @X.t) (v19 : @D.t) => match X.compare v13 v18 as v20 in (Compare _ _ _ _) return Prop with | LT v20 => (fun v20 : X.lt v13 v18 => @True) v20 | EQ v20 => (fun v20 : X.eq v13 v18 => D.lt v14 v19 \/ D.eq v14 v19 /\ lt_list v4 v11) v20 | GT v20 => (fun v20 : X.lt v18 v13 => @False) v20 end) v18 v19 end), ~ match v16 as v19 in (_ * _) return Prop with | (v19, v20) => (fun (v19 : @X.t) (v20 : @D.t) => match X.compare v13 v19 as v21 in (Compare _ _ _ _) return Prop with | LT v21 => (fun v21 : X.lt v13 v19 => @False) v21 | EQ v21 => (fun v21 : X.eq v13 v19 => D.eq v14 v20 /\ eq_list v4 v11) v21 | GT v21 => (fun v21 : X.lt v19 v13 => @False) v21 end) v19 v20 end) with | (v16, v17) => (fun (v16 : @X.t) (v17 : @D.t) (v18 : Sorted (Raw.PX.ltk (elt:=@D.t)) ((v16, v17) :: v11)) => let v19 : Compare (@X.lt) (@X.eq) v13 v16 := X.compare v13 v16 in match v19 as v20 in (Compare _ _ _ _) return (forall v21 : match v20 as v21 in (Compare _ _ _ _) return Prop with | LT v21 => (fun v21 : X.lt v13 v16 => @True) v21 | EQ v21 => (fun v21 : X.eq v13 v16 => D.lt v14 v17 \/ D.eq v14 v17 /\ lt_list v4 v11) v21 | GT v21 => (fun v21 : X.lt v16 v13 => @False) v21 end, ~ match v20 as v22 in (Compare _ _ _ _) return Prop with | LT v22 => (fun v22 : X.lt v13 v16 => @False) v22 | EQ v22 => (fun v22 : X.eq v13 v16 => D.eq v14 v17 /\ eq_list v4 v11) v22 | GT v22 => (fun v22 : X.lt v16 v13 => @False) v22 end) with | LT v20 => (fun (v20 : X.lt v13 v16) (v21 : @True) => (fun v22 : @False => v22) : ~ @False) v20 | EQ v20 => (fun (v20 : X.eq v13 v16) (v21 : D.lt v14 v17 \/ D.eq v14 v17 /\ lt_list v4 v11) => (fun v22 : D.eq v14 v17 /\ eq_list v4 v11 => and_ind (fun (v23 : D.eq v14 v17) (v24 : eq_list v4 v11) => or_ind (fun v25 : D.lt v14 v17 => D.lt_not_eq v25 v23 : @False) (fun v25 : D.eq v14 v17 /\ lt_list v4 v11 => and_ind (fun (v26 : D.eq v14 v17) (v27 : lt_list v4 v11) => (let v28 : forall v28 : (v13, v14) :: v4 = (v13, v14) :: v4, @False := match v15 as v29 in (Sorted _ v28) return (forall v30 : v28 = (v13, v14) :: v4, @False) with | Sorted_nil _ => fun v28 : nil = (v13, v14) :: v4 => (fun v29 : nil = (v13, v14) :: v4 => let v30 : @False := eq_ind nil (fun v30 : list (@X.t * @D.t) => match v30 as v31 in (list _) return Prop with | nil => @True | v31 :: v32 => (fun (v31 : @X.t * @D.t) (v32 : list (@X.t * @D.t)) => @False) v31 v32 end) (@I) ((v13, v14) :: v4) v29 in False_ind (@False) v30) v28 | @Sorted_cons _ _ v28 v29 v30 v31 => (fun (v28 : @X.t * @D.t) (v29 : list (@X.t * @D.t)) (v30 : Sorted (Raw.PX.ltk (elt:=@D.t)) v29) (v31 : HdRel (Raw.PX.ltk (elt:=@D.t)) v28 v29) (v32 : v28 :: v29 = (v13, v14) :: v4) => (fun v33 : v28 :: v29 = (v13, v14) :: v4 => let v34 : v29 = v4 := f_equal (fun v34 : list (@X.t * @D.t) => match v34 as v35 in (list _) return (list (@X.t * @D.t)) with | nil => v29 | v35 :: v36 => (fun (v35 : @X.t * @D.t) (v36 : list (@X.t * @D.t)) => v36) v35 v36 end) v33 in (let v35 : v28 = (v13, v14) := f_equal (fun v35 : list (@X.t * @D.t) => match v35 as v36 in (list _) return (@X.t * @D.t) with | nil => v28 | v36 :: v37 => (fun (v36 : @X.t * @D.t) (v37 : list (@X.t * @D.t)) => v36) v36 v37 end) v33 in (fun v36 : v28 = (v13, v14) => let v37 : v28 = (v13, v14) := v36 in eq_ind_r (fun v38 : @X.t * @D.t => forall (v39 : v29 = v4) (v40 : Sorted (Raw.PX.ltk (elt:=@D.t)) v29) (v41 : HdRel (Raw.PX.ltk (elt:=@D.t)) v38 v29), @False) (fun v38 : v29 = v4 => let v39 : v29 = v4 := v38 in eq_ind_r (fun v40 : list (@X.t * @D.t) => forall (v41 : Sorted (Raw.PX.ltk (elt:=@D.t)) v40) (v42 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v13, v14) v40), @False) (fun (v40 : Sorted (Raw.PX.ltk (elt:=@D.t)) v4) (v41 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v13, v14) v4) => let v42 : forall v42 : (v16, v17) :: v11 = (v16, v17) :: v11, @False := match v18 as v43 in (Sorted _ v42) return (forall v44 : v42 = (v16, v17) :: v11, @False) with | Sorted_nil _ => fun v42 : nil = (v16, v17) :: v11 => (fun v43 : nil = (v16, v17) :: v11 => let v44 : @False := eq_ind nil (fun v44 : list (@X.t * @D.t) => match v44 as v45 in (list _) return Prop with | nil => @True | v45 :: v46 => (fun (v45 : @X.t * @D.t) (v46 : list (@X.t * @D.t)) => @False) v45 v46 end) (@I) ((v16, v17) :: v11) v43 in False_ind (@False) v44) v42 | @Sorted_cons _ _ v42 v43 v44 v45 => (fun (v42 : @X.t * @D.t) (v43 : list (@X.t * @D.t)) (v44 : Sorted (Raw.PX.ltk (elt:=@D.t)) v43) (v45 : HdRel (Raw.PX.ltk (elt:=@D.t)) v42 v43) (v46 : v42 :: v43 = (v16, v17) :: v11) => (fun v47 : v42 :: v43 = (v16, v17) :: v11 => let v48 : v43 = v11 := f_equal (fun v48 : list (@X.t * @D.t) => match v48 as v49 in (list _) return (list (@X.t * @D.t)) with | nil => v43 | v49 :: v50 => (fun (v49 : @X.t * @D.t) (v50 : list (@X.t * @D.t)) => v50) v49 v50 end) v47 in (let v49 : v42 = (v16, v17) := f_equal (fun v49 : list (@X.t * @D.t) => match v49 as v50 in (list _) return (@X.t * @D.t) with | nil => v42 | v50 :: v51 => (fun (v50 : @X.t * @D.t) (v51 : list (@X.t * @D.t)) => v50) v50 v51 end) v47 in (fun v50 : v42 = (v16, v17) => let v51 : v42 = (v16, v17) := v50 in eq_ind_r (fun v52 : @X.t * @D.t => forall (v53 : v43 = v11) (v54 : Sorted (Raw.PX.ltk (elt:=@D.t)) v43) (v55 : HdRel (Raw.PX.ltk (elt:=@D.t)) v52 v43), @False) (fun v52 : v43 = v11 => let v53 : v43 = v11 := v52 in eq_ind_r (fun v54 : list (@X.t * @D.t) => forall (v55 : Sorted (Raw.PX.ltk (elt:=@D.t)) v54) (v56 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v16, v17) v54), @False) (fun (v54 : Sorted (Raw.PX.ltk (elt:=@D.t)) v11) (v55 : HdRel (Raw.PX.ltk (elt:=@D.t)) (v16, v17) v11) => v5 v40 {| this := v11; sorted := v54 |} v27 v24) v53) v51) v49) v48) v46 v44 v45) v42 v43 v44 v45 end in v42 Logic.eq_refl) v39) v37) v35) v34) v32 v30 v31) v28 v29 v30 v31 end in v28 Logic.eq_refl) : @False) v25) v21) v22) : ~ (D.eq v14 v17 /\ eq_list v4 v11)) v20 | GT v20 => (fun (v20 : X.lt v16 v13) (v21 : @False) => (fun v22 : @False => v22) : ~ @False) v20 end) v16 v17 end v12) v13 v14 end v6 : forall v13 : lt_list {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}, ~ eq_list {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}) : forall v13 : lt {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}, ~ eq_list {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}) : forall v13 : lt {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}, ~ eq {| this := v3 :: v4; sorted := v6 |} {| this := v10 :: v11; sorted := v12 |}) v10 v11 end v9) v8 v9 end) v1 v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FMapList.Make_ord.compare	100	1.580426	1	1
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.functional_rel_reification_and_rel_choice_imp_fun_choice	100	0.099368	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : FunctionalRelReification_on v0 v1) (v3 : RelationalChoice_on v0 v1) => (fun (v4 : forall (v4 : v0) (v5 : v1), Prop) (v5 : forall v5 : v0, exists v6 : v1, v4 v5 v6) => let v6 : exists v6 : forall (v6 : v0) (v7 : v1), Prop, subrelation v6 v4 /\ (forall v7 : v0, exists ! v8 : v1, v6 v7 v8) := v3 v4 v5 in match v6 as v7 in (ex _) return (exists v8 : forall v8 : v0, v1, forall v9 : v0, v4 v9 (v8 v9)) with | ex_intro _ v7 v8 => (fun (v7 : forall (v7 : v0) (v8 : v1), Prop) (v8 : subrelation v7 v4 /\ (forall v8 : v0, exists ! v9 : v1, v7 v8 v9)) => match v8 as v9 in (_ /\ _) return (exists v10 : forall v10 : v0, v1, forall v11 : v0, v4 v11 (v10 v11)) with | conj v9 v10 => (fun (v9 : subrelation v7 v4) (v10 : forall v10 : v0, exists ! v11 : v1, v7 v10 v11) => let v11 : exists v11 : forall v11 : v0, v1, forall v12 : v0, v7 v12 (v11 v12) := v2 v7 v10 in match v11 as v12 in (ex _) return (exists v13 : forall v13 : v0, v1, forall v14 : v0, v4 v14 (v13 v14)) with | ex_intro _ v12 v13 => (fun (v12 : forall v12 : v0, v1) (v13 : forall v13 : v0, v7 v13 (v12 v13)) => ex_intro (fun v14 : forall v14 : v0, v1 => forall v15 : v0, v4 v15 (v14 v15)) v12 (fun v14 : v0 => let v15 : exists ! v15 : v1, v7 v14 v15 := v10 v14 in match v15 as v16 in (ex _) return (v4 v14 (v12 v14)) with | ex_intro _ v16 v17 => (fun (v16 : v1) (v17 : unique (fun v17 : v1 => v7 v14 v17) v16) => match v17 as v18 in (_ /\ _) return (v4 v14 (v12 v14)) with | conj v18 v19 => (fun (v18 : v7 v14 v16) (v19 : forall (v19 : v1) (v20 : v7 v14 v19), v16 = v19) => eq_ind v16 (fun v20 : v1 => v4 v14 v20) (v9 v14 v16 v18) (v12 v14) (v19 (v12 v14) (v13 v14))) v18 v19 end) v16 v17 end)) v12 v13 end) v9 v10 end) v7 v8 end) : FunctionalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_imp_rel_choice	100	0.057068	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : FunctionalChoice_on v0 v1) => (fun (v3 : forall (v3 : v0) (v4 : v1), Prop) (v4 : forall v4 : v0, exists v5 : v1, v3 v4 v5) => let v5 : exists v5 : forall v5 : v0, v1, forall v6 : v0, v3 v6 (v5 v6) := v2 v3 v4 in match v5 as v6 in (ex _) return (exists v7 : forall (v7 : v0) (v8 : v1), Prop, subrelation v7 v3 /\ (forall v8 : v0, exists ! v9 : v1, v7 v8 v9)) with | ex_intro _ v6 v7 => (fun (v6 : forall v6 : v0, v1) (v7 : forall v7 : v0, v3 v7 (v6 v7)) => ex_intro (fun v8 : forall (v8 : v0) (v9 : v1), Prop => subrelation v8 v3 /\ (forall v9 : v0, exists ! v10 : v1, v8 v9 v10)) (fun (v8 : v0) (v9 : v1) => v6 v8 = v9) (conj ((fun (v8 : v0) (v9 : v1) (v10 : v6 v8 = v9) => eq_ind (v6 v8) (fun v11 : v1 => v3 v8 v11) (v7 v8) v9 v10) : subrelation (fun (v8 : v0) (v9 : v1) => v6 v8 = v9) v3) (fun v8 : v0 => ex_intro (unique (fun v9 : v1 => v6 v8 = v9)) (v6 v8) (conj eq_refl (fun (v9 : v1) (v10 : v6 v8 = v9) => v10))))) v6 v7 end) : RelationalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_imp_functional_rel_reification	100	0.053059	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : FunctionalChoice_on v0 v1) => (fun (v3 : forall (v3 : v0) (v4 : v1), Prop) (v4 : forall v4 : v0, exists ! v5 : v1, v3 v4 v5) => let v5 : exists v5 : forall v5 : v0, v1, forall v6 : v0, v3 v6 (v5 v6) := v2 v3 (fun v5 : v0 => let v6 : exists ! v6 : v1, v3 v5 v6 := v4 v5 in match v6 as v7 in (ex _) return (exists v8 : v1, v3 v5 v8) with | ex_intro _ v7 v8 => (fun (v7 : v1) (v8 : unique (fun v8 : v1 => v3 v5 v8) v7) => match v8 as v9 in (_ /\ _) return (exists v10 : v1, v3 v5 v10) with | conj v9 v10 => (fun (v9 : v3 v5 v7) (v10 : forall (v10 : v1) (v11 : v3 v5 v10), v7 = v10) => ex_intro (fun v11 : v1 => v3 v5 v11) v7 v9) v9 v10 end) v7 v8 end) in match v5 as v6 in (ex _) return (exists v7 : forall v7 : v0, v1, forall v8 : v0, v3 v8 (v7 v8)) with | ex_intro _ v6 v7 => (fun (v6 : forall v6 : v0, v1) (v7 : forall v7 : v0, v3 v7 (v6 v7)) => ex_intro (fun v8 : forall v8 : v0, v1 => forall v9 : v0, v3 v9 (v8 v9)) v6 v7) v6 v7 end) : FunctionalRelReification_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_iff_rel_choice_and_functional_rel_reification	100	0.041449	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Type => conj (fun v2 : FunctionalChoice_on v0 v1 => conj (fun_choice_imp_rel_choice v2) (fun_choice_imp_functional_rel_reification v2)) (fun v2 : RelationalChoice_on v0 v1 /\ FunctionalRelReification_on v0 v1 => match v2 as v3 in (_ /\ _) return (FunctionalChoice_on v0 v1) with | conj v3 v4 => (fun (v3 : RelationalChoice_on v0 v1) (v4 : FunctionalRelReification_on v0 v1) => functional_rel_reification_and_rel_choice_imp_fun_choice v4 v3) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.rel_choice_and_proof_irrel_imp_guarded_rel_choice	100	0.167191	1	1	0	synth with cache (only 1: refine (fun (v0 : RelationalChoice) (v1 : @ProofIrrelevance) => (fun (v2 v3 : Type) (v4 : forall v4 : v2, Prop) (v5 : forall (v5 : v2) (v6 : v3), Prop) (v6 : forall (v6 : v2) (v7 : v4 v6), exists v8 : v3, v5 v6 v8) => let v7 : exists v7 : forall (v7 : {x : v2 & v4 x}) (v8 : v3), Prop, subrelation v7 (fun (v8 : {x : v2 & v4 x}) (v9 : v3) => v5 (projT1 v8) v9) /\ (forall v8 : {x : v2 & v4 x}, exists ! v9 : v3, v7 v8 v9) := v0 {x : v2 & v4 x} v3 (fun (v7 : {x : v2 & v4 x}) (v8 : v3) => v5 (projT1 v7) v8) (fun v7 : {x : v2 & v4 x} => match v7 as v8 in (sigT _) return (exists v9 : v3, v5 (projT1 v8) v9) with | existT _ v8 v9 => (fun (v8 : v2) (v9 : v4 v8) => let v10 : exists v10 : v3, v5 v8 v10 := v6 v8 v9 in match v10 as v11 in (ex _) return (exists v12 : v3, v5 (projT1 (existT v4 v8 v9)) v12) with | ex_intro _ v11 v12 => (fun (v11 : v3) (v12 : v5 v8 v11) => ex_intro (fun v13 : v3 => v5 (projT1 (existT v4 v8 v9)) v13) v11 v12) v11 v12 end) v8 v9 end) in match v7 as v8 in (ex _) return (exists v9 : forall (v9 : v2) (v10 : v3), Prop, subrelation v9 v5 /\ (forall (v10 : v2) (v11 : v4 v10), exists ! v12 : v3, v9 v10 v12)) with | ex_intro _ v8 v9 => (fun (v8 : forall (v8 : {x : v2 & v4 x}) (v9 : v3), Prop) (v9 : subrelation v8 (fun (v9 : {x : v2 & v4 x}) (v10 : v3) => v5 (projT1 v9) v10) /\ (forall v9 : {x : v2 & v4 x}, exists ! v10 : v3, v8 v9 v10)) => match v9 as v10 in (_ /\ _) return (exists v11 : forall (v11 : v2) (v12 : v3), Prop, subrelation v11 v5 /\ (forall (v12 : v2) (v13 : v4 v12), exists ! v14 : v3, v11 v12 v14)) with | conj v10 v11 => (fun (v10 : subrelation v8 (fun (v10 : {x : v2 & v4 x}) (v11 : v3) => v5 (projT1 v10) v11)) (v11 : forall v11 : {x : v2 & v4 x}, exists ! v12 : v3, v8 v11 v12) => let v12 : forall (v12 : v2) (v13 : v3), Prop := fun (v12 : v2) (v13 : v3) => exists v14 : v4 v12, v8 (existT v4 v12 v14) v13 in ex_intro (fun v13 : forall (v13 : v2) (v14 : v3), Prop => subrelation v13 v5 /\ (forall (v14 : v2) (v15 : v4 v14), exists ! v16 : v3, v13 v14 v16)) v12 (conj ((fun (v13 : v2) (v14 : v3) (v15 : v12 v13 v14) => match v15 as v16 in (ex _) return (v5 v13 v14) with | ex_intro _ v16 v17 => (fun (v16 : v4 v13) (v17 : v8 (existT v4 v13 v16) v14) => v10 (existT v4 v13 v16) v14 v17) v16 v17 end) : subrelation v12 v5) (fun (v13 : v2) (v14 : v4 v13) => let v15 : exists ! v15 : v3, v8 (existT v4 v13 v14) v15 := v11 (existT v4 v13 v14) in match v15 as v16 in (ex _) return (exists ! v17 : v3, v12 v13 v17) with | ex_intro _ v16 v17 => (fun (v16 : v3) (v17 : unique (fun v17 : v3 => v8 (existT v4 v13 v14) v17) v16) => match v17 as v18 in (_ /\ _) return (exists ! v19 : v3, v12 v13 v19) with | conj v18 v19 => (fun (v18 : v8 (existT v4 v13 v14) v16) (v19 : forall (v19 : v3) (v20 : v8 (existT v4 v13 v14) v19), v16 = v19) => ex_intro (unique (fun v20 : v3 => v12 v13 v20)) v16 (conj (ex_intro (fun v20 : v4 v13 => v8 (existT v4 v13 v20) v16) v14 v18) (fun (v20 : v3) (v21 : v12 v13 v20) => match v21 as v22 in (ex _) return (v16 = v20) with | ex_intro _ v22 v23 => (fun (v22 : v4 v13) (v23 : v8 (existT v4 v13 v22) v20) => v19 v20 (eq_ind_r (fun v24 : v4 v13 => v8 (existT v4 v13 v24) v20) v23 (v1 (v4 v13) v14 v22))) v22 v23 end))) v18 v19 end) v16 v17 end))) v10 v11 end) v8 v9 end) : GuardedRelationalChoice)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.rel_choice_indep_of_general_premises_imp_guarded_rel_choice	100	0.134955	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : inhabited v1) (v3 : RelationalChoice_on v0 v1) (v4 : @IndependenceOfGeneralPremises) => (fun (v5 : forall v5 : v0, Prop) (v6 : forall (v6 : v0) (v7 : v1), Prop) (v7 : forall (v7 : v0) (v8 : v5 v7), exists v9 : v1, v6 v7 v9) => let v8 : exists v8 : forall (v8 : v0) (v9 : v1), Prop, subrelation v8 (fun (v9 : v0) (v10 : v1) => forall v11 : v5 v9, v6 v9 v10) /\ (forall v9 : v0, exists ! v10 : v1, v8 v9 v10) := v3 (fun (v8 : v0) (v9 : v1) => forall v10 : v5 v8, v6 v8 v9) (fun v8 : v0 => v4 v1 (v6 v8) (v5 v8) v2 (fun v9 : v5 v8 => v7 v8 v9)) in match v8 as v9 in (ex _) return (exists v10 : forall (v10 : v0) (v11 : v1), Prop, subrelation v10 v6 /\ (forall (v11 : v0) (v12 : v5 v11), exists ! v13 : v1, v10 v11 v13)) with | ex_intro _ v9 v10 => (fun (v9 : forall (v9 : v0) (v10 : v1), Prop) (v10 : subrelation v9 (fun (v10 : v0) (v11 : v1) => forall v12 : v5 v10, v6 v10 v11) /\ (forall v10 : v0, exists ! v11 : v1, v9 v10 v11)) => match v10 as v11 in (_ /\ _) return (exists v12 : forall (v12 : v0) (v13 : v1), Prop, subrelation v12 v6 /\ (forall (v13 : v0) (v14 : v5 v13), exists ! v15 : v1, v12 v13 v15)) with | conj v11 v12 => (fun (v11 : subrelation v9 (fun (v11 : v0) (v12 : v1) => forall v13 : v5 v11, v6 v11 v12)) (v12 : forall v12 : v0, exists ! v13 : v1, v9 v12 v13) => ex_intro (fun v13 : forall (v13 : v0) (v14 : v1), Prop => subrelation v13 v6 /\ (forall (v14 : v0) (v15 : v5 v14), exists ! v16 : v1, v13 v14 v16)) (fun (v13 : v0) (v14 : v1) => v5 v13 /\ v9 v13 v14) (inhabited_ind (fun v13 : v1 => conj ((fun (v14 : v0) (v15 : v1) (v16 : v5 v14 /\ v9 v14 v15) => and_ind (fun (v17 : v5 v14) (v18 : v9 v14 v15) => (fun v19 : forall (v19 : v1) (v20 : v9 v14 v19), (fun (v21 : v0) (v22 : v1) => forall v23 : v5 v21, v6 v21 v22) v14 v19 => (fun v20 : forall v20 : v9 v14 v15, (fun (v21 : v0) (v22 : v1) => forall v23 : v5 v21, v6 v21 v22) v14 v15 => (fun v21 : (fun (v21 : v0) (v22 : v1) => forall v23 : v5 v21, v6 v21 v22) v14 v15 => (fun v22 : v6 v14 v15 => v22) (v21 v17)) (v20 v18)) (v19 v15)) (v11 v14)) v16) : subrelation (fun (v14 : v0) (v15 : v1) => v5 v14 /\ v9 v14 v15) v6) (fun (v14 : v0) (v15 : v5 v14) => (fun v16 : forall (v16 : v1) (v17 : v9 v14 v16), (fun (v18 : v0) (v19 : v1) => forall v20 : v5 v18, v6 v18 v19) v14 v16 => (fun v17 : exists ! v17 : v1, v9 v14 v17 => ex_ind (fun (v18 : v1) (v19 : unique (fun v19 : v1 => v9 v14 v19) v18) => and_ind (fun (v20 : v9 v14 v18) (v21 : forall (v21 : v1) (v22 : v9 v14 v21), v18 = v21) => ex_intro (unique (fun v22 : v1 => v5 v14 /\ v9 v14 v22)) v18 (conj (conj v15 v20) (fun (v22 : v1) (v23 : v5 v14 /\ v9 v14 v22) => and_ind (fun (v24 : v5 v14) (v25 : v9 v14 v22) => v21 v22 v25) v23))) v19) v17) (v12 v14)) (v11 v14))) v2)) v11 v12 end) v9 v10 end) : GuardedRelationalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.guarded_rel_choice_imp_rel_choice	100	0.074645	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : GuardedRelationalChoice_on v0 v1) => (fun (v3 : forall (v3 : v0) (v4 : v1), Prop) (v4 : forall v4 : v0, exists v5 : v1, v3 v4 v5) => let v5 : exists v5 : forall (v5 : v0) (v6 : v1), Prop, subrelation v5 v3 /\ (forall (v6 : v0) (v7 : (fun v7 : v0 => @True) v6), exists ! v8 : v1, v5 v6 v8) := v2 (fun v5 : v0 => @True) v3 (fun (v5 : v0) (v6 : @True) => (fun v7 : exists v7 : v1, v3 v5 v7 => v7) (v4 v5)) in match v5 as v6 in (ex _) return (exists v7 : forall (v7 : v0) (v8 : v1), Prop, subrelation v7 v3 /\ (forall v8 : v0, exists ! v9 : v1, v7 v8 v9)) with | ex_intro _ v6 v7 => (fun (v6 : forall (v6 : v0) (v7 : v1), Prop) (v7 : subrelation v6 v3 /\ (forall (v7 : v0) (v8 : @True), exists ! v9 : v1, v6 v7 v9)) => match v7 as v8 in (_ /\ _) return (exists v9 : forall (v9 : v0) (v10 : v1), Prop, subrelation v9 v3 /\ (forall v10 : v0, exists ! v11 : v1, v9 v10 v11)) with | conj v8 v9 => (fun (v8 : subrelation v6 v3) (v9 : forall (v9 : v0) (v10 : @True), exists ! v11 : v1, v6 v9 v11) => ex_intro (fun v10 : forall (v10 : v0) (v11 : v1), Prop => subrelation v10 v3 /\ (forall v11 : v0, exists ! v12 : v1, v10 v11 v12)) v6 (conj v8 (fun v10 : v0 => (fun v11 : forall (v11 : v1) (v12 : v6 v10 v11), v3 v10 v11 => (fun v12 : forall v12 : @True, exists ! v13 : v1, v6 v10 v13 => (fun v13 : exists ! v13 : v1, v6 v10 v13 => v13) (v12 (@I))) (v9 v10)) (v8 v10)))) v8 v9 end) v6 v7 end) : RelationalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.subset_types_imp_guarded_rel_choice_iff_rel_choice	100	0.029991	1	1	0	synth with cache (only 1: refine (fun v0 : @ProofIrrelevance => conj (fun (v1 : GuardedRelationalChoice) (v2 v3 : Type) => guarded_rel_choice_imp_rel_choice (v1 v2 v3)) (fun (v1 : RelationalChoice) (v2 v3 : Type) => rel_choice_and_proof_irrel_imp_guarded_rel_choice v1 v0 (B:=v3)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.guarded_iff_omniscient_rel_choice	100	0.153231	1	1	0	synth with cache (only 1: refine (conj (fun (v0 : GuardedRelationalChoice) (v1 v2 : Type) => (fun v3 : forall (v3 : v1) (v4 : v2), Prop => v0 v1 v2 (fun v4 : v1 => exists v5 : v2, v3 v4 v5) v3 (fun (v4 : v1) (v5 : exists v5 : v2, v3 v4 v5) => v5)) : OmniscientRelationalChoice_on v1 v2) (fun (v0 : OmniscientRelationalChoice) (v1 v2 : Type) => (fun (v3 : forall v3 : v1, Prop) (v4 : forall (v4 : v1) (v5 : v2), Prop) (v5 : forall (v5 : v1) (v6 : v3 v5), exists v7 : v2, v4 v5 v7) => let v6 : exists v6 : forall (v6 : v1) (v7 : v2), Prop, subrelation v6 v4 /\ (forall (v7 : v1) (v8 : exists v8 : v2, v4 v7 v8), exists ! v9 : v2, v6 v7 v9) := v0 v1 v2 v4 in match v6 as v7 in (ex _) return (exists v8 : forall (v8 : v1) (v9 : v2), Prop, subrelation v8 v4 /\ (forall (v9 : v1) (v10 : v3 v9), exists ! v11 : v2, v8 v9 v11)) with | ex_intro _ v7 v8 => (fun (v7 : forall (v7 : v1) (v8 : v2), Prop) (v8 : subrelation v7 v4 /\ (forall (v8 : v1) (v9 : exists v9 : v2, v4 v8 v9), exists ! v10 : v2, v7 v8 v10)) => ex_intro (fun v9 : forall (v9 : v1) (v10 : v2), Prop => subrelation v9 v4 /\ (forall (v10 : v1) (v11 : v3 v10), exists ! v12 : v2, v9 v10 v12)) v7 (and_ind (fun (v9 : subrelation v7 v4) (v10 : forall (v10 : v1) (v11 : exists v11 : v2, v4 v10 v11), exists ! v12 : v2, v7 v10 v12) => conj v9 (fun (v11 : v1) (v12 : v3 v11) => (fun v13 : forall v13 : exists v13 : v2, v4 v11 v13, exists ! v14 : v2, v7 v11 v14 => (fun v14 : forall (v14 : v2) (v15 : (fun v15 : v2 => v4 v11 v15) v14), exists ! v16 : v2, v7 v11 v16 => (fun v15 : forall (v15 : v2) (v16 : v7 v11 v15), v4 v11 v15 => (fun v16 : forall v16 : v3 v11, exists v17 : v2, v4 v11 v17 => (fun v17 : exists v17 : v2, v4 v11 v17 => ex_ind (fun (v18 : v2) (v19 : v4 v11 v18) => v10 v11 (v5 v11 v12)) v17) (v16 v12)) (v5 v11)) (v9 v11)) (fun (v14 : v2) (v15 : (fun v15 : v2 => v4 v11 v15) v14) => v13 (ex_intro (fun v16 : v2 => v4 v11 v16) v14 v15))) (v10 v11))) v8)) v7 v8 end) : GuardedRelationalChoice_on v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.guarded_fun_choice_imp_indep_of_general_premises	100	0.037301	1	1	0	synth with cache (only 1: refine (fun v0 : GuardedFunctionalChoice => (fun (v1 : Type) (v2 : forall v2 : v1, Prop) (v3 : Prop) (v4 : inhabited v1) (v5 : forall v5 : v3, exists v6 : v1, v2 v6) => let v6 : exists v6 : forall v6 : @unit, v1, forall (v7 : @unit) (v8 : (fun v8 : @unit => v3) v7), (fun v9 : @unit => v2) v7 (v6 v7) := v0 (@unit) v1 (fun v6 : @unit => v3) (fun v6 : @unit => v2) v4 (fun (v6 : @unit) (v7 : v3) => let v8 : exists v8 : v1, v2 v8 := v5 v7 in v8) in match v6 as v7 in (ex _) return (exists v8 : v1, forall v9 : v3, v2 v8) with | ex_intro _ v7 v8 => (fun (v7 : forall v7 : @unit, v1) (v8 : forall (v8 : @unit) (v9 : v3), v2 (v7 v8)) => ex_intro (fun v9 : v1 => forall v10 : v3, v2 v9) (v7 (@tt)) (fun v9 : v3 => v8 (@tt) v9)) v7 v8 end) : @IndependenceOfGeneralPremises)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.guarded_fun_choice_imp_fun_choice	100	0.046001	1	1	0	synth with cache (only 1: refine (fun (v0 : GuardedFunctionalChoice) (v1 v2 : Type) (v3 : inhabited v2) => (fun (v4 : forall (v4 : v1) (v5 : v2), Prop) (v5 : forall v5 : v1, exists v6 : v2, v4 v5 v6) => let v6 : exists v6 : forall v6 : v1, v2, forall (v7 : v1) (v8 : (fun v8 : v1 => @True) v7), v4 v7 (v6 v7) := v0 v1 v2 (fun v6 : v1 => @True) v4 v3 (fun (v6 : v1) (v7 : @True) => inhabited_ind (fun v8 : v2 => (fun v9 : exists v9 : v2, v4 v6 v9 => v9) (v5 v6)) v3) in match v6 as v7 in (ex _) return (exists v8 : forall v8 : v1, v2, forall v9 : v1, v4 v9 (v8 v9)) with | ex_intro _ v7 v8 => (fun (v7 : forall v7 : v1, v2) (v8 : forall (v8 : v1) (v9 : @True), v4 v8 (v7 v8)) => ex_intro (fun v9 : forall v9 : v1, v2 => forall v10 : v1, v4 v10 (v9 v10)) v7 (fun v9 : v1 => v8 v9 (@I))) v7 v8 end) : FunctionalChoice_on v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_and_indep_general_prem_imp_guarded_fun_choice	100	0.032108	1	1	0	synth with cache (only 1: refine (fun (v0 : forall (v0 v1 : Type) (v2 : inhabited v1), FunctionalChoice_on v0 v1) (v1 : @IndependenceOfGeneralPremises) (v2 v3 : Type) => (fun (v4 : forall v4 : v2, Prop) (v5 : forall (v5 : v2) (v6 : v3), Prop) (v6 : inhabited v3) (v7 : forall (v7 : v2) (v8 : v4 v7), exists v9 : v3, v5 v7 v9) => v0 v2 v3 v6 (fun (v8 : v2) (v9 : v3) => forall v10 : v4 v8, v5 v8 v9) (fun v8 : v2 => v1 v3 (v5 v8) (v4 v8) v6 (fun v9 : v4 v8 => v7 v8 v9))) : GuardedFunctionalChoice_on v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_and_indep_general_prem_iff_guarded_fun_choice	100	0.043569	1	1	0	synth with cache (only 1: refine (conj (fun v0 : (forall (v0 v1 : Type) (v2 : inhabited v1), FunctionalChoice_on v0 v1) /\ @IndependenceOfGeneralPremises => and_ind (fun (v1 : forall (v1 v2 : Type) (v3 : inhabited v2), FunctionalChoice_on v1 v2) (v2 : @IndependenceOfGeneralPremises) (v3 v4 : Type) => fun_choice_and_indep_general_prem_imp_guarded_fun_choice v1 v2 (B:=v4)) v0) (fun v0 : GuardedFunctionalChoice => conj (fun (v1 v2 : Type) (v3 : inhabited v2) => guarded_fun_choice_imp_fun_choice v0 v3) (guarded_fun_choice_imp_indep_of_general_premises v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.omniscient_fun_choice_imp_small_drinker	100	0.055770	1	1	0	synth with cache (only 1: refine (fun v0 : OmniscientFunctionalChoice => (fun (v1 : Type) (v2 : forall v2 : v1, Prop) (v3 : inhabited v1) => let v4 : exists v4 : forall v4 : @unit, v1, forall (v5 : @unit) (v6 : exists v6 : v1, (fun v7 : @unit => v2) v5 v6), (fun v7 : @unit => v2) v5 (v4 v5) := v0 (@unit) v1 (fun v4 : @unit => v2) v3 in match v4 as v5 in (ex _) return (exists v6 : v1, forall v7 : exists v7 : v1, v2 v7, v2 v6) with | ex_intro _ v5 v6 => (fun (v5 : forall v5 : @unit, v1) (v6 : forall (v6 : @unit) (v7 : exists v7 : v1, v2 v7), v2 (v5 v6)) => ex_intro (fun v7 : v1 => forall v8 : exists v8 : v1, v2 v8, v2 v7) (v5 (@tt)) (fun v7 : exists v7 : v1, v2 v7 => inhabited_ind (fun v8 : v1 => ex_ind (fun (v9 : v1) (v10 : v2 v9) => (fun v11 : forall v11 : exists v11 : v1, v2 v11, v2 (v5 (@tt)) => (fun v12 : forall (v12 : v1) (v13 : (fun v13 : v1 => v2 v13) v12), v2 (v5 (@tt)) => (fun v13 : forall v13 : (fun v13 : v1 => v2 v13) (v5 (@tt)), v2 (v5 (@tt)) => (fun v14 : forall v14 : (fun v14 : v1 => v2 v14) v9, v2 (v5 (@tt)) => (fun v15 : v2 (v5 (@tt)) => v15) (v14 v10)) (v12 v9)) (v12 (v5 (@tt)))) (fun (v12 : v1) (v13 : (fun v13 : v1 => v2 v13) v12) => v11 (ex_intro (fun v14 : v1 => v2 v14) v12 v13))) (v6 (@tt))) v7) v3)) v5 v6 end) : @SmallDrinker'sParadox)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.omniscient_fun_choice_imp_fun_choice	100	0.061698	1	1	0	synth with cache (only 1: refine (fun (v0 : OmniscientFunctionalChoice) (v1 v2 : Type) (v3 : inhabited v2) => (fun (v4 : forall (v4 : v1) (v5 : v2), Prop) (v5 : forall v5 : v1, exists v6 : v2, v4 v5 v6) => let v6 : exists v6 : forall v6 : v1, v2, forall (v7 : v1) (v8 : exists v8 : v2, v4 v7 v8), v4 v7 (v6 v7) := v0 v1 v2 v4 v3 in match v6 as v7 in (ex _) return (exists v8 : forall v8 : v1, v2, forall v9 : v1, v4 v9 (v8 v9)) with | ex_intro _ v7 v8 => (fun (v7 : forall v7 : v1, v2) (v8 : forall (v8 : v1) (v9 : exists v9 : v2, v4 v8 v9), v4 v8 (v7 v8)) => ex_intro (fun v9 : forall v9 : v1, v2 => forall v10 : v1, v4 v10 (v9 v10)) v7 (fun v9 : v1 => inhabited_ind (fun v10 : v2 => (fun v11 : forall v11 : exists v11 : v2, v4 v9 v11, v4 v9 (v7 v9) => (fun v12 : forall (v12 : v2) (v13 : (fun v13 : v2 => v4 v9 v13) v12), v4 v9 (v7 v9) => (fun v13 : forall v13 : (fun v13 : v2 => v4 v9 v13) (v7 v9), v4 v9 (v7 v9) => (fun v14 : exists v14 : v2, v4 v9 v14 => ex_ind (fun (v15 : v2) (v16 : v4 v9 v15) => v8 v9 (v5 v9)) v14) (v5 v9)) (v12 (v7 v9))) (fun (v12 : v2) (v13 : (fun v13 : v2 => v4 v9 v13) v12) => v11 (ex_intro (fun v14 : v2 => v4 v9 v14) v12 v13))) (v8 v9)) v3)) v7 v8 end) : FunctionalChoice_on v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_and_small_drinker_imp_omniscient_fun_choice	100	0.052723	1	1	0	synth with cache (only 1: refine (fun (v0 : forall (v0 v1 : Type) (v2 : inhabited v1), FunctionalChoice_on v0 v1) (v1 : @SmallDrinker'sParadox) (v2 v3 : Type) => (fun (v4 : forall (v4 : v2) (v5 : v3), Prop) (v5 : inhabited v3) => let v6 : exists v6 : forall v6 : v2, v3, forall v7 : v2, (fun (v8 : v2) (v9 : v3) => forall v10 : exists v10 : v3, v4 v8 v10, v4 v8 v9) v7 (v6 v7) := v0 v2 v3 v5 (fun (v6 : v2) (v7 : v3) => forall v8 : exists v8 : v3, v4 v6 v8, v4 v6 v7) (fun v6 : v2 => v1 v3 (v4 v6) v5) in match v6 as v7 in (ex _) return (exists v8 : forall v8 : v2, v3, forall (v9 : v2) (v10 : exists v10 : v3, v4 v9 v10), v4 v9 (v8 v9)) with | ex_intro _ v7 v8 => (fun (v7 : forall v7 : v2, v3) (v8 : forall (v8 : v2) (v9 : exists v9 : v3, v4 v8 v9), v4 v8 (v7 v8)) => ex_intro (fun v9 : forall v9 : v2, v3 => forall (v10 : v2) (v11 : exists v11 : v3, v4 v10 v11), v4 v10 (v9 v10)) v7 v8) v7 v8 end) : OmniscientFunctionalChoice_on v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_and_small_drinker_iff_omniscient_fun_choice	100	0.049818	1	1	0	synth with cache (only 1: refine (conj (fun v0 : (forall (v0 v1 : Type) (v2 : inhabited v1), FunctionalChoice_on v0 v1) /\ @SmallDrinker'sParadox => and_ind (fun (v1 : forall (v1 v2 : Type) (v3 : inhabited v2), FunctionalChoice_on v1 v2) (v2 : @SmallDrinker'sParadox) (v3 v4 : Type) => fun_choice_and_small_drinker_imp_omniscient_fun_choice v1 v2 (B:=v4)) v0) (fun v0 : OmniscientFunctionalChoice => conj (fun (v1 v2 : Type) (v3 : inhabited v2) => omniscient_fun_choice_imp_fun_choice v0 v3) (omniscient_fun_choice_imp_small_drinker v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.guarded_iff_omniscient_fun_choice	100	0.076694	1	1	0	synth with cache (only 1: refine (conj (fun (v0 : GuardedFunctionalChoice) (v1 v2 : Type) => (fun (v3 : forall (v3 : v1) (v4 : v2), Prop) (v4 : inhabited v2) => v0 v1 v2 (fun v5 : v1 => exists v6 : v2, v3 v5 v6) v3 v4 (fun (v5 : v1) (v6 : exists v6 : v2, v3 v5 v6) => v6)) : OmniscientFunctionalChoice_on v1 v2) (fun (v0 : OmniscientFunctionalChoice) (v1 v2 : Type) => (fun (v3 : forall v3 : v1, Prop) (v4 : forall (v4 : v1) (v5 : v2), Prop) (v5 : inhabited v2) (v6 : forall (v6 : v1) (v7 : v3 v6), exists v8 : v2, v4 v6 v8) => let v7 : exists v7 : forall v7 : v1, v2, forall (v8 : v1) (v9 : exists v9 : v2, v4 v8 v9), v4 v8 (v7 v8) := v0 v1 v2 v4 v5 in match v7 as v8 in (ex _) return (exists v9 : forall v9 : v1, v2, forall (v10 : v1) (v11 : v3 v10), v4 v10 (v9 v10)) with | ex_intro _ v8 v9 => (fun (v8 : forall v8 : v1, v2) (v9 : forall (v9 : v1) (v10 : exists v10 : v2, v4 v9 v10), v4 v9 (v8 v9)) => ex_intro (fun v10 : forall v10 : v1, v2 => forall (v11 : v1) (v12 : v3 v11), v4 v11 (v10 v11)) v8 (fun (v10 : v1) (v11 : v3 v10) => inhabited_ind (fun v12 : v2 => (fun v13 : forall v13 : exists v13 : v2, v4 v10 v13, v4 v10 (v8 v10) => (fun v14 : forall (v14 : v2) (v15 : (fun v15 : v2 => v4 v10 v15) v14), v4 v10 (v8 v10) => (fun v15 : forall v15 : (fun v15 : v2 => v4 v10 v15) (v8 v10), v4 v10 (v8 v10) => (fun v16 : forall v16 : v3 v10, exists v17 : v2, v4 v10 v17 => (fun v17 : exists v17 : v2, v4 v10 v17 => ex_ind (fun (v18 : v2) (v19 : v4 v10 v18) => v9 v10 (v6 v10 v11)) v17) (v16 v11)) (v6 v10)) (v14 (v8 v10))) (fun (v14 : v2) (v15 : (fun v15 : v2 => v4 v10 v15) v14) => v13 (ex_intro (fun v16 : v2 => v4 v10 v16) v14 v15))) (v9 v10)) v5)) v8 v9 end) : GuardedFunctionalChoice_on v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.iota_imp_constructive_definite_description	100	0.042701	1	1	0	synth with cache (only 1: refine (fun (v0 : IotaStatement) (v1 : Type) => (fun (v2 : forall v2 : v1, Prop) (v3 : exists ! v3 : v1, v2 v3) => let v4 : {v4 : v1 | forall v5 : exists ! v5 : v1, v2 v5, v2 v4} := v0 v1 v2 match v3 as v4 in (ex _) return (inhabited v1) with | ex_intro _ v4 v5 => (fun (v4 : v1) (v5 : unique (fun v5 : v1 => v2 v5) v4) => inhabits v4) v4 v5 end in match v4 as v5 in (sig _) return {v6 : v1 | v2 v6} with | exist _ v5 v6 => (fun (v5 : v1) (v6 : forall v6 : exists ! v6 : v1, v2 v6, v2 v5) => exist (fun v7 : v1 => v2 v7) v5 (v6 v3)) v5 v6 end) : ConstructiveDefiniteDescription_on v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.epsilon_imp_constructive_indefinite_description	100	0.044436	1	1	0	synth with cache (only 1: refine (fun (v0 : EpsilonStatement) (v1 : Type) => (fun (v2 : forall v2 : v1, Prop) (v3 : exists v3 : v1, v2 v3) => let v4 : {v4 : v1 | forall v5 : exists v5 : v1, v2 v5, v2 v4} := v0 v1 v2 match v3 as v4 in (ex _) return (inhabited v1) with | ex_intro _ v4 v5 => (fun (v4 : v1) (v5 : v2 v4) => inhabits v4) v4 v5 end in match v4 as v5 in (sig _) return {v6 : v1 | v2 v6} with | exist _ v5 v6 => (fun (v5 : v1) (v6 : forall v6 : exists v6 : v1, v2 v6, v2 v5) => exist (fun v7 : v1 => v2 v7) v5 (v6 v3)) v5 v6 end) : ConstructiveIndefiniteDescription_on v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.constructive_indefinite_description_and_small_drinker_imp_epsilon	100	0.031943	1	1	0	synth with cache (only 1: refine (fun (v0 : @SmallDrinker'sParadox) (v1 : ConstructiveIndefiniteDescription) (v2 : Type) => (fun (v3 : forall v3 : v2, Prop) (v4 : inhabited v2) => v1 v2 (fun v5 : v2 => forall v6 : exists v6 : v2, v3 v6, v3 v5) (v0 v2 v3 v4)) : EpsilonStatement_on v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.epsilon_imp_small_drinker	100	0.033367	1	1	0	synth with cache (only 1: refine (fun v0 : EpsilonStatement => (fun (v1 : Type) (v2 : forall v2 : v1, Prop) (v3 : inhabited v1) => let v4 : {v4 : v1 | forall v5 : exists v5 : v1, v2 v5, v2 v4} := v0 v1 v2 v3 in match v4 as v5 in (sig _) return (exists v6 : v1, forall v7 : exists v7 : v1, v2 v7, v2 v6) with | exist _ v5 v6 => (fun (v5 : v1) (v6 : forall v6 : exists v6 : v1, v2 v6, v2 v5) => ex_intro (fun v7 : v1 => forall v8 : exists v8 : v1, v2 v8, v2 v7) v5 v6) v5 v6 end) : @SmallDrinker'sParadox)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.constructive_indefinite_description_and_small_drinker_iff_epsilon	100	0.050747	1	1	0	synth with cache (only 1: refine (fun v0 : @SmallDrinker'sParadox * ConstructiveIndefiniteDescription => prod_rect (fun v1 : @SmallDrinker'sParadox * ConstructiveIndefiniteDescription => EpsilonStatement) (fun (v1 : @SmallDrinker'sParadox) (v2 : ConstructiveIndefiniteDescription) (v3 : Type) => constructive_indefinite_description_and_small_drinker_imp_epsilon v1 v2 (A:=v3)) v0, fun v0 : EpsilonStatement => (epsilon_imp_small_drinker v0, fun v1 : Type => epsilon_imp_constructive_indefinite_description v0 (A:=v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.classical_denumerable_description_imp_fun_choice	100	0.076008	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : FunctionalRelReification_on v0 (@nat)) => (fun (v2 : forall (v2 : v0) (v3 : @nat), Prop) (v3 : forall (v3 : v0) (v4 : @nat), decidable (v2 v3 v4)) (v4 : forall v4 : v0, exists v5 : @nat, v2 v4 v5) => let v5 : forall (v5 : v0) (v6 : @nat), Prop := fun (v5 : v0) (v6 : @nat) => v2 v5 v6 /\ (forall (v7 : @nat) (v8 : v2 v5 v7), v6 <= v7) in let v6 : exists v6 : forall v6 : v0, @nat, forall v7 : v0, v5 v7 (v6 v7) := v1 v5 (fun v6 : v0 => dec_inh_nat_subset_has_unique_least_element (v2 v6) (v3 v6) (v4 v6)) in match v6 as v7 in (ex _) return (exists v8 : forall v8 : v0, @nat, forall v9 : v0, v2 v9 (v8 v9)) with | ex_intro _ v7 v8 => (fun (v7 : forall v7 : v0, @nat) (v8 : forall v8 : v0, v5 v8 (v7 v8)) => ex_intro (fun v9 : forall v9 : v0, @nat => forall v10 : v0, v2 v10 (v9 v10)) v7 (fun v9 : v0 => let v10 : v2 v9 (v7 v9) /\ (forall (v10 : @nat) (v11 : v2 v9 v10), v7 v9 <= v10) := v8 v9 in match v10 as v11 in (_ /\ _) return (v2 v9 (v7 v9)) with | conj v11 v12 => (fun (v11 : v2 v9 (v7 v9)) (v12 : forall (v12 : @nat) (v13 : v2 v9 v12), v7 v9 <= v12) => v11) v11 v12 end)) v7 v8 end) : forall (v2 : forall (v2 : v0) (v3 : @nat), Prop) (v3 : forall (v3 : v0) (v4 : @nat), decidable (v2 v3 v4)), FunctionalChoice_on_rel v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.dep_non_dep_functional_choice	100	0.040747	1	1	0	synth with cache (only 1: refine (fun (v0 : forall (v0 : Type) (v1 : forall v1 : v0, Type), DependentFunctionalChoice_on v1) (v1 v2 : Type) => (fun (v3 : forall (v3 : v1) (v4 : v2), Prop) (v4 : forall v4 : v1, exists v5 : v2, v3 v4 v5) => let v5 : exists v5 : forall v5 : v1, (fun v6 : v1 => v2) v5, forall v6 : v1, v3 v6 (v5 v6) := v0 v1 (fun v5 : v1 => v2) v3 v4 in match v5 as v6 in (ex _) return (exists v7 : forall v7 : v1, v2, forall v8 : v1, v3 v8 (v7 v8)) with | ex_intro _ v6 v7 => (fun (v6 : forall v6 : v1, v2) (v7 : forall v7 : v1, v3 v7 (v6 v7)) => ex_intro (fun v8 : forall v8 : v1, v2 => forall v9 : v1, v3 v9 (v8 v9)) v6 v7) v6 v7 end) : FunctionalChoice_on v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.non_dep_dep_functional_choice	100	0.252577	1	1	0	synth with cache (only 1: refine (fun (v0 : FunctionalChoice) (v1 : Type) (v2 : forall v2 : v1, Type) => (fun (v3 : forall (v3 : v1) (v4 : v2 v3), Prop) (v4 : forall v4 : v1, exists v5 : v2 v4, v3 v4 v5) => let v5 : Type := {v5 : v1 & v2 v5} in let v6 : forall (v6 : v1) (v7 : v5), Prop := fun (v6 : v1) (v7 : v5) => projT1 v7 = v6 /\ v3 (projT1 v7) (projT2 v7) in let v7 : exists v7 : forall v7 : v1, v5, forall v8 : v1, v6 v8 (v7 v8) := v0 v1 v5 v6 (fun v7 : v1 => let v8 : exists v8 : v2 v7, v3 v7 v8 := v4 v7 in match v8 as v9 in (ex _) return (exists v10 : v5, v6 v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v2 v7) (v10 : v3 v7 v9) => ex_intro (fun v11 : v5 => v6 v7 v11) (existT (fun v11 : v1 => v2 v11) v7 v9) (conj eq_refl v10)) v9 v10 end) in match v7 as v8 in (ex _) return (exists v9 : forall v9 : v1, v2 v9, forall v10 : v1, v3 v10 (v9 v10)) with | ex_intro _ v8 v9 => (fun (v8 : forall v8 : v1, v5) (v9 : forall v9 : v1, v6 v9 (v8 v9)) => ex_intro (fun v10 : forall v10 : v1, v2 v10 => forall v11 : v1, v3 v11 (v10 v11)) (fun v10 : v1 => eq_rect (projT1 (v8 v10)) (fun v11 : v1 => v2 v11) (projT2 (v8 v10)) v10 (proj1_inf (v9 v10))) (fun v10 : v1 => let v11 : v6 v10 (v8 v10) := v9 v10 in and_indd (fun v12 : projT1 (v8 v10) = v10 /\ v3 (projT1 (v8 v10)) (projT2 (v8 v10)) => v3 v10 (eq_rect (projT1 (v8 v10)) (fun v13 : v1 => v2 v13) (projT2 (v8 v10)) v10 (proj1_inf v12))) (fun (v12 : projT1 (v8 v10) = v10) (v13 : v3 (projT1 (v8 v10)) (projT2 (v8 v10))) => let v14 : v5 := v8 v10 in match v14 as v15 in (sigT _) return (forall (v16 : projT1 v15 = v10) (v17 : v3 (projT1 v15) (projT2 v15)), v3 v10 (eq_rect (projT1 v15) (fun v18 : v1 => v2 v18) (projT2 v15) v10 (proj1_inf (conj v16 v17)))) with | existT _ v15 v16 => (fun (v15 : v1) (v16 : v2 v15) (v17 : projT1 (existT (fun v17 : v1 => v2 v17) v15 v16) = v10) (v18 : v3 (projT1 (existT (fun v18 : v1 => v2 v18) v15 v16)) (projT2 (existT (fun v18 : v1 => v2 v18) v15 v16))) => eq_indd (fun (v19 : v1) (v20 : v15 = v19) => v3 v19 (eq_rect v15 (fun v21 : v1 => v2 v21) v16 v19 v20)) v18 v17 : v3 v10 (eq_rect (projT1 (existT (fun v19 : v1 => v2 v19) v15 v16)) (fun v19 : v1 => v2 v19) (projT2 (existT (fun v19 : v1 => v2 v19) v15 v16)) v10 (proj1_inf (conj v17 v18)))) v15 v16 end v12 v13) v11)) v8 v9 end) : DependentFunctionalChoice_on v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.functional_choice_to_inhabited_forall_commute	100	0.047089	1	1	0	synth with cache (only 1: refine (fun (v0 : FunctionalChoice) (v1 : Type) (v2 : forall v2 : v1, Type) => (fun v3 : forall v3 : v1, inhabited (v2 v3) => let v4 : forall (v4 : Type) (v5 : forall v5 : v4, Type), DependentFunctionalChoice_on v5 := non_dep_dep_functional_choice v0 in let v5 : forall v5 : v1, exists v6 : v2 v5, @True := fun v5 : v1 => inhabited_sig_to_exists (inhabited_covariant ((fun v6 : v2 v5 => exist (fun v7 : v2 v5 => @True) v6 (@I)) : forall v6 : v2 v5, {v7 : v2 v5 | @True}) (v3 v5)) in let v6 : exists v6 : forall v6 : v1, v2 v6, forall v7 : v1, @True := v4 v1 v2 (fun (v6 : v1) (v7 : v2 v6) => @True) v5 in match v6 as v7 in (ex _) return (inhabited (forall v8 : v1, v2 v8)) with | ex_intro _ v7 v8 => (fun (v7 : forall v7 : v1, v2 v7) (v8 : forall v8 : v1, @True) => inhabits v7) v7 v8 end) : InhabitedForallCommute_on v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.inhabited_forall_commute_to_functional_choice	100	0.048686	1	1	0	synth with cache (only 1: refine (fun (v0 : forall (v0 : Type) (v1 : forall v1 : v0, Type), InhabitedForallCommute_on v1) (v1 v2 : Type) => (fun (v3 : forall (v3 : v1) (v4 : v2), Prop) (v4 : forall v4 : v1, exists v5 : v2, v3 v4 v5) => let v5 : forall v5 : v1, inhabited {v6 : v2 | v3 v5 v6} := fun v5 : v1 => exists_to_inhabited_sig (v4 v5) in let v6 : inhabited (forall v6 : v1, {v7 : v2 | v3 v6 v7}) := v0 v1 (fun v6 : v1 => {v7 : v2 | v3 v6 v7}) v5 in match v6 as v7 in (inhabited _) return (exists v8 : forall v8 : v1, v2, forall v9 : v1, v3 v9 (v8 v9)) with | inhabits v7 => (fun v7 : forall v7 : v1, {v8 : v2 | v3 v7 v8} => ex_intro (fun v8 : forall v8 : v1, v2 => forall v9 : v1, v3 v9 (v8 v9)) (fun v8 : v1 => proj1_sig (v7 v8)) (fun v8 : v1 => proj2_sig (v7 v8))) v7 end) : FunctionalChoice_on v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.dep_non_dep_functional_rel_reification	100	0.041702	1	1	0	synth with cache (only 1: refine (fun (v0 : forall (v0 : Type) (v1 : forall v1 : v0, Type), DependentFunctionalRelReification_on v1) (v1 v2 : Type) => (fun (v3 : forall (v3 : v1) (v4 : v2), Prop) (v4 : forall v4 : v1, exists ! v5 : v2, v3 v4 v5) => let v5 : exists v5 : forall v5 : v1, (fun v6 : v1 => v2) v5, forall v6 : v1, v3 v6 (v5 v6) := v0 v1 (fun v5 : v1 => v2) v3 v4 in match v5 as v6 in (ex _) return (exists v7 : forall v7 : v1, v2, forall v8 : v1, v3 v8 (v7 v8)) with | ex_intro _ v6 v7 => (fun (v6 : forall v6 : v1, v2) (v7 : forall v7 : v1, v3 v7 (v6 v7)) => ex_intro (fun v8 : forall v8 : v1, v2 => forall v9 : v1, v3 v9 (v8 v9)) v6 v7) v6 v7 end) : FunctionalRelReification_on v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.non_dep_dep_functional_rel_reification	100	0.292923	1	1	0	synth with cache (only 1: refine (fun (v0 : FunctionalRelReification) (v1 : Type) (v2 : forall v2 : v1, Type) => (fun (v3 : forall (v3 : v1) (v4 : v2 v3), Prop) (v4 : forall v4 : v1, exists ! v5 : v2 v4, v3 v4 v5) => let v5 : Type := {v5 : v1 & v2 v5} in let v6 : forall (v6 : v1) (v7 : v5), Prop := fun (v6 : v1) (v7 : v5) => projT1 v7 = v6 /\ v3 (projT1 v7) (projT2 v7) in let v7 : exists v7 : forall v7 : v1, v5, forall v8 : v1, v6 v8 (v7 v8) := v0 v1 v5 v6 (fun v7 : v1 => let v8 : exists ! v8 : v2 v7, v3 v7 v8 := v4 v7 in match v8 as v9 in (ex _) return (exists ! v10 : v5, v6 v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v2 v7) (v10 : unique (fun v10 : v2 v7 => v3 v7 v10) v9) => match v10 as v11 in (_ /\ _) return (exists ! v12 : v5, v6 v7 v12) with | conj v11 v12 => (fun (v11 : v3 v7 v9) (v12 : forall (v12 : v2 v7) (v13 : v3 v7 v12), v9 = v12) => ex_intro (unique (fun v13 : v5 => v6 v7 v13)) (existT (fun v13 : v1 => v2 v13) v7 v9) (conj (conj eq_refl v11) (fun v13 : v5 => match v13 as v14 in (sigT _) return (forall v15 : v6 v7 v14, existT (fun v16 : v1 => v2 v16) v7 v9 = v14) with | existT _ v14 v15 => (fun (v14 : v1) (v15 : v2 v14) (v16 : v6 v7 (existT (fun v16 : v1 => v2 v16) v14 v15)) => match v16 as v17 in (_ /\ _) return (existT (fun v18 : v1 => v2 v18) v7 v9 = existT (fun v18 : v1 => v2 v18) v14 v15) with | conj v17 v18 => (fun (v17 : projT1 (existT (fun v17 : v1 => v2 v17) v14 v15) = v7) (v18 : v3 (projT1 (existT (fun v18 : v1 => v2 v18) v14 v15)) (projT2 (existT (fun v18 : v1 => v2 v18) v14 v15))) => match v17 as v20 in (_ = v19) return (forall (v21 : v2 v19) (v22 : v3 v19 v21) (v23 : forall (v23 : v2 v19) (v24 : v3 v19 v23), v21 = v23), existT (fun v24 : v1 => v2 v24) v19 v21 = existT (fun v24 : v1 => v2 v24) v14 v15) with | eq_refl => fun (v19 : v2 v14) (v20 : v3 v14 v19) (v21 : forall (v21 : v2 v14) (v22 : v3 v14 v21), v19 = v21) => eq_ind_r (fun v22 : v2 v14 => existT (fun v23 : v1 => v2 v23) v14 v22 = existT (fun v23 : v1 => v2 v23) v14 v15) eq_refl (v21 v15 v18) end v9 v11 v12 : existT (fun v19 : v1 => v2 v19) v7 v9 = existT (fun v19 : v1 => v2 v19) v14 v15) v17 v18 end) v14 v15 end))) v11 v12 end) v9 v10 end) in match v7 as v8 in (ex _) return (exists v9 : forall v9 : v1, v2 v9, forall v10 : v1, v3 v10 (v9 v10)) with | ex_intro _ v8 v9 => (fun (v8 : forall v8 : v1, v5) (v9 : forall v9 : v1, v6 v9 (v8 v9)) => ex_intro (fun v10 : forall v10 : v1, v2 v10 => forall v11 : v1, v3 v11 (v10 v11)) (fun v10 : v1 => eq_rect (projT1 (v8 v10)) (fun v11 : v1 => v2 v11) (projT2 (v8 v10)) v10 (proj1_inf (v9 v10))) (fun v10 : v1 => let v11 : v6 v10 (v8 v10) := v9 v10 in and_indd (fun v12 : projT1 (v8 v10) = v10 /\ v3 (projT1 (v8 v10)) (projT2 (v8 v10)) => v3 v10 (eq_rect (projT1 (v8 v10)) (fun v13 : v1 => v2 v13) (projT2 (v8 v10)) v10 (proj1_inf v12))) (fun (v12 : projT1 (v8 v10) = v10) (v13 : v3 (projT1 (v8 v10)) (projT2 (v8 v10))) => let v14 : v5 := v8 v10 in match v14 as v15 in (sigT _) return (forall (v16 : projT1 v15 = v10) (v17 : v3 (projT1 v15) (projT2 v15)), v3 v10 (eq_rect (projT1 v15) (fun v18 : v1 => v2 v18) (projT2 v15) v10 (proj1_inf (conj v16 v17)))) with | existT _ v15 v16 => (fun (v15 : v1) (v16 : v2 v15) (v17 : projT1 (existT (fun v17 : v1 => v2 v17) v15 v16) = v10) (v18 : v3 (projT1 (existT (fun v18 : v1 => v2 v18) v15 v16)) (projT2 (existT (fun v18 : v1 => v2 v18) v15 v16))) => eq_indd (fun (v19 : v1) (v20 : v15 = v19) => v3 v19 (eq_rect v15 (fun v21 : v1 => v2 v21) v16 v19 v20)) v18 v17 : v3 v10 (eq_rect (projT1 (existT (fun v19 : v1 => v2 v19) v15 v16)) (fun v19 : v1 => v2 v19) (projT2 (existT (fun v19 : v1 => v2 v19) v15 v16)) v10 (proj1_inf (conj v17 v18)))) v15 v16 end v12 v13) v11)) v8 v9 end) : DependentFunctionalRelReification_on v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.dep_iff_non_dep_functional_rel_reification	100	0.033383	1	1	0	synth with cache (only 1: refine (conj (fun (v0 : FunctionalRelReification) (v1 : Type) (v2 : forall v2 : v1, Type) => non_dep_dep_functional_rel_reification v0 v2) (fun (v0 : forall (v0 : Type) (v1 : forall v1 : v0, Type), DependentFunctionalRelReification_on v1) (v1 v2 : Type) => dep_non_dep_functional_rel_reification v0 (B:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.relative_non_contradiction_of_indefinite_descr	100	0.187760	1	1	0	synth with cache (only 1: refine (fun (v0 : Prop) (v1 : forall v1 : ConstructiveIndefiniteDescription, v0) (v2 : FunctionalChoice) => let v3 : forall (v3 : Type) (v4 : forall v4 : v3, Type), DependentFunctionalChoice_on v4 := non_dep_dep_functional_choice v2 in let v4 : Type := {v4 : Type & {v5 : forall v5 : v4, Prop & exists v6 : v4, v5 v6}} in let v5 : forall v5 : v4, Type := fun v5 : v4 => projT1 v5 in let v6 : forall (v6 : v4) (v7 : v5 v6), Prop := fun (v6 : v4) (v7 : v5 v6) => projT1 (projT2 v6) v7 in let v7 : forall v7 : v4, (fun v8 : forall v8 : projT1 v7, Prop => exists v9 : projT1 v7, v8 v9) (projT1 (projT2 v7)) := fun v7 : v4 => projT2 (projT2 v7) in let v8 : exists v8 : forall v8 : v4, v5 v8, forall v9 : v4, v6 v9 (v8 v9) := v3 v4 v5 v6 v7 in match v8 as v9 in (ex _) return v0 with | ex_intro _ v9 v10 => (fun (v9 : forall v9 : v4, v5 v9) (v10 : forall v10 : v4, v6 v10 (v9 v10)) => v1 (fun v11 : Type => (fun (v12 : forall v12 : v11, Prop) (v13 : exists v13 : v11, v12 v13) => exist (fun v14 : v11 => v12 v14) (v9 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists v15 : v11, v14 v15) v12 v13))) (let v14 : v6 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists v15 : v11, v14 v15) v12 v13)) (v9 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists v15 : v11, v14 v15) v12 v13))) := v10 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists v15 : v11, v14 v15) v12 v13)) in v14)) : ConstructiveIndefiniteDescription_on v11)) v9 v10 end)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.constructive_indefinite_descr_fun_choice	100	0.030571	1	1	0	synth with cache (only 1: refine (fun (v0 : ConstructiveIndefiniteDescription) (v1 v2 : Type) => (fun (v3 : forall (v3 : v1) (v4 : v2), Prop) (v4 : forall v4 : v1, exists v5 : v2, v3 v4 v5) => ex_intro (fun v5 : forall v5 : v1, v2 => forall v6 : v1, v3 v6 (v5 v6)) (fun v5 : v1 => proj1_sig (v0 v2 (v3 v5) (v4 v5))) (fun v5 : v1 => proj2_sig (v0 v2 (v3 v5) (v4 v5)))) : FunctionalChoice_on v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.relative_non_contradiction_of_definite_descr	100	0.385094	1	1	0	synth with cache (only 1: refine (fun (v0 : Prop) (v1 : forall v1 : ConstructiveDefiniteDescription, v0) (v2 : FunctionalRelReification) => let v3 : forall (v3 : Type) (v4 : forall v4 : v3, Type), DependentFunctionalRelReification_on v4 := non_dep_dep_functional_rel_reification v2 in let v4 : Type := {v4 : Type & {v5 : forall v5 : v4, Prop & exists ! v6 : v4, v5 v6}} in let v5 : forall v5 : v4, Type := fun v5 : v4 => projT1 v5 in let v6 : forall (v6 : v4) (v7 : v5 v6), Prop := fun (v6 : v4) (v7 : v5 v6) => projT1 (projT2 v6) v7 in let v7 : forall v7 : v4, (fun v8 : forall v8 : projT1 v7, Prop => exists ! v9 : projT1 v7, v8 v9) (projT1 (projT2 v7)) := fun v7 : v4 => projT2 (projT2 v7) in let v8 : exists v8 : forall v8 : v4, v5 v8, forall v9 : v4, v6 v9 (v8 v9) := v3 v4 v5 v6 v7 in match v8 as v9 in (ex _) return v0 with | ex_intro _ v9 v10 => (fun (v9 : forall v9 : v4, v5 v9) (v10 : forall v10 : v4, v6 v10 (v9 v10)) => v1 (fun v11 : Type => (fun (v12 : forall v12 : v11, Prop) (v13 : exists ! v13 : v11, v12 v13) => exist (fun v14 : v11 => v12 v14) (v9 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists ! v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists ! v15 : v11, v14 v15) v12 v13))) (let v14 : v6 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists ! v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists ! v15 : v11, v14 v15) v12 v13)) (v9 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists ! v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists ! v15 : v11, v14 v15) v12 v13))) := v10 (existT (fun v14 : Type => {v15 : forall v15 : v14, Prop & exists ! v16 : v14, v15 v16}) v11 (existT (fun v14 : forall v14 : v11, Prop => exists ! v15 : v11, v14 v15) v12 v13)) in v14)) : ConstructiveDefiniteDescription_on v11)) v9 v10 end)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.constructive_definite_descr_fun_reification	100	0.032348	1	1	0	synth with cache (only 1: refine (fun (v0 : ConstructiveDefiniteDescription) (v1 v2 : Type) => (fun (v3 : forall (v3 : v1) (v4 : v2), Prop) (v4 : forall v4 : v1, exists ! v5 : v2, v3 v4 v5) => ex_intro (fun v5 : forall v5 : v1, v2 => forall v6 : v1, v3 v6 (v5 v6)) (fun v5 : v1 => proj1_sig (v0 v2 (v3 v5) (v4 v5))) (fun v5 : v1 => proj2_sig (v0 v2 (v3 v5) (v4 v5)))) : FunctionalRelReification_on v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.constructive_definite_descr_excluded_middle	100	0.147474	1	1	0	synth with cache (only 1: refine (fun (v0 : ConstructiveDefiniteDescription) (v1 : forall v1 : Prop, v1 \/ ~ v1) (v2 : Prop) => let v3 : forall v3 : @bool, Prop := fun v3 : @bool => match v3 as v4 in bool return Prop with | true => v2 | false => ~ v2 end in let v4 : {v4 : @bool | v3 v4} := v0 (@bool) v3 ((fun v4 : (exists v4 : @bool, v3 v4) /\ uniqueness v3 <-> (exists ! v4 : @bool, v3 v4) => Morphisms.iff_flip_impl_subrelation (exists ! v5 : @bool, v3 v5) ((exists v5 : @bool, v3 v5) /\ uniqueness v3) (symmetry v4)) (unique_existence v3) (conj (let v4 : v2 \/ ~ v2 := v1 v2 in match v4 as v5 in (_ \/ _) return (exists v6 : @bool, v3 v6) with | or_introl v5 => (fun v5 : v2 => ex_intro (fun v6 : @bool => v3 v6) (@true) v5) v5 | or_intror v5 => (fun v5 : ~ v2 => ex_intro (fun v6 : @bool => v3 v6) (@false) v5) v5 end) ((fun v4 : @bool => match v4 as v5 in bool return (forall (v6 : @bool) (v7 : v3 v5) (v8 : v3 v6), v5 = v6) with | true => fun v5 : @bool => match v5 as v6 in bool return (forall (v7 : v3 (@true)) (v8 : v3 v6), @true = v6) with | true => fun v6 v7 : v3 (@true) => eq_refl : @true = @true | false => fun (v6 : v3 (@true)) (v7 : v3 (@false)) => False_ind (@true = @false) (v7 v6) : @true = @false end | false => fun v5 : @bool => match v5 as v6 in bool return (forall (v7 : v3 (@false)) (v8 : v3 v6), @false = v6) with | true => fun (v6 : v3 (@false)) (v7 : v3 (@true)) => False_ind (@false = @true) (v6 v7) : @false = @true | false => fun v6 v7 : v3 (@false) => eq_refl : @false = @false end end) : uniqueness v3))) in match v4 as v5 in (sig _) return ({v2} + {~ v2}) with | exist _ v5 v6 => (fun (v5 : @bool) (v6 : v3 v5) => match v5 as v7 in bool return (forall v8 : v3 v7, {v2} + {~ v2}) with | true => fun v7 : v3 (@true) => left v7 | false => fun v7 : v3 (@false) => right v7 end v6) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_reification_descr_computational_excluded_middle_in_prop_context	100	0.033390	1	1	0	synth with cache (only 1: refine (fun (v0 : FunctionalRelReification) (v1 : forall v1 : Prop, v1 \/ ~ v1) (v2 : Prop) (v3 : forall v3 : forall v3 : Prop, {v3} + {~ v3}, v2) => relative_non_contradiction_of_definite_descr (fun v4 : ConstructiveDefiniteDescription => v3 (fun v5 : Prop => constructive_definite_descr_excluded_middle v4 v1 v5)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.functional_choice_imp_functional_dependent_choice	100	0.211587	0	1
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.functional_dependent_choice_imp_functional_countable_choice	100	0.242280	1	1	0	synth with cache (only 1: refine (fun (v0 : FunctionalDependentChoice) (v1 : Type) => (fun (v2 : forall (v2 : @nat) (v3 : v1), Prop) (v3 : forall v3 : @nat, exists v4 : v1, v2 v3 v4) => let v4 : forall v4 v5 : @nat * v1, Prop := fun v4 v5 : @nat * v1 => fst v5 = S (fst v4) /\ v2 (fst v4) (snd v5) in let v5 : exists v5 : v1, v2 0 v5 := v3 0 in match v5 as v6 in (ex _) return (exists v7 : forall v7 : @nat, v1, forall v8 : @nat, v2 v8 (v7 v8)) with | ex_intro _ v6 v7 => (fun (v6 : v1) (v7 : v2 0 v6) => let v8 : exists v8 : forall v8 : @nat, @nat * v1, v8 0 = (0, v6) /\ (forall v9 : @nat, v4 (v8 v9) (v8 (S v9))) := v0 (@nat * v1) v4 (fun v8 : @nat * v1 => let v9 : exists v9 : v1, v2 (fst v8) v9 := v3 (fst v8) in match v9 as v10 in (ex _) return (exists v11 : @nat * v1, v4 v8 v11) with | ex_intro _ v10 v11 => (fun (v10 : v1) (v11 : v2 (fst v8) v10) => ex_intro (fun v12 : @nat * v1 => v4 v8 v12) (S (fst v8), v10) (conj eq_refl v11 : v4 v8 (S (fst v8), v10))) v10 v11 end) (0, v6) in match v8 as v9 in (ex _) return (exists v10 : forall v10 : @nat, v1, forall v11 : @nat, v2 v11 (v10 v11)) with | ex_intro _ v9 v10 => (fun (v9 : forall v9 : @nat, @nat * v1) (v10 : v9 0 = (0, v6) /\ (forall v10 : @nat, v4 (v9 v10) (v9 (S v10)))) => match v10 as v11 in (_ /\ _) return (exists v12 : forall v12 : @nat, v1, forall v13 : @nat, v2 v13 (v12 v13)) with | conj v11 v12 => (fun (v11 : v9 0 = (0, v6)) (v12 : forall v12 : @nat, v4 (v9 v12) (v9 (S v12))) => let v13 : forall v13 : @nat, fst (v9 v13) = v13 := fun v13 : @nat => nat_ind (fun v14 : @nat => fst (v9 v14) = v14) (eq_ind_r (fun v14 : @nat * v1 => fst v14 = 0) eq_refl v11) (fun (v14 : @nat) (v15 : fst (v9 v14) = v14) => let v16 : v4 (v9 v14) (v9 (S v14)) := v12 v14 in match v16 as v17 in (_ /\ _) return (fst (v9 (S v14)) = S v14) with | conj v17 v18 => (fun (v17 : fst (v9 (S v14)) = S (fst (v9 v14))) (v18 : v2 (fst (v9 v14)) (snd (v9 (S v14)))) => eq_ind_r (fun v19 : @nat => v19 = S v14) (eq_trans (f_equal (fun v19 : forall v19 : @nat, @nat => v19 (fst (v9 v14))) eq_refl) (f_equal (@S) v15)) v17) v17 v18 end) v13 in ex_intro (fun v14 : forall v14 : @nat, v1 => forall v15 : @nat, v2 v15 (v14 v15)) (fun v14 : @nat => snd (v9 (S v14))) (fun v14 : @nat => let v15 : v4 (v9 v14) (v9 (S v14)) := v12 v14 in match v15 as v16 in (_ /\ _) return (v2 v14 (snd (v9 (S v14)))) with | conj v16 v17 => (fun (v16 : fst (v9 (S v14)) = S (fst (v9 v14))) (v17 : v2 (fst (v9 v14)) (snd (v9 (S v14)))) => let v18 : v2 v14 (snd (v9 (S v14))) := eq_ind (fst (v9 v14)) (fun v18 : @nat => v2 v18 (snd (v9 (S v14)))) v17 v14 (v13 v14) in v18) v16 v17 end)) v11 v12 end) v9 v10 end) v6 v7 end) : FunctionalCountableChoice_on v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.repr_fun_choice_imp_ext_prop_repr	100	0.088413	1	1	0	synth with cache (only 1: refine (fun (v0 : RepresentativeFunctionalChoice) (v1 : Type) => let v2 : forall v2 v3 : Prop, Prop := fun v2 v3 : Prop => v2 <-> v3 in let v3 : Equivalence v2 := {| Equivalence_Reflexive := (fun v3 : Prop => conj (fun v4 : v3 => v4) (fun v4 : v3 => v4)) : Reflexive v2; Equivalence_Symmetric := (fun (v3 v4 : Prop) (v5 : v2 v3 v4) => and_ind (fun (v6 : forall v6 : v3, v4) (v7 : forall v7 : v4, v3) => conj v7 v6) v5) : Symmetric v2; Equivalence_Transitive := (fun (v3 v4 v5 : Prop) (v6 : v2 v3 v4) (v7 : v2 v4 v5) => and_ind (fun (v8 : forall v8 : v4, v5) (v9 : forall v9 : v5, v4) => and_ind (fun (v10 : forall v10 : v3, v4) (v11 : forall v11 : v4, v3) => conj (fun v12 : v3 => (fun v13 : v4 => (fun v14 : v3 => (fun v15 : v5 => v15) (v8 v13)) (v11 v13)) (v10 v12)) (fun v12 : v5 => (fun v13 : v4 => (fun v14 : v5 => (fun v15 : v3 => v15) (v11 v13)) (v8 v13)) (v9 v12))) v6) v7) : Transitive v2 |} in v0 Prop v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.repr_fun_choice_imp_ext_pred_repr	100	0.111683	1	1	0	synth with cache (only 1: refine (fun (v0 : RepresentativeFunctionalChoice) (v1 : Type) => let v2 : forall (v2 : forall v2 : v1, Prop) (v3 : forall v3 : v1, Prop), Prop := fun (v2 : forall v2 : v1, Prop) (v3 : forall v3 : v1, Prop) => forall v4 : v1, v2 v4 <-> v3 v4 in let v3 : Equivalence v2 := {| Equivalence_Reflexive := (fun v3 : forall v3 : v1, Prop => (fun v4 : v1 => conj (fun v5 : v3 v4 => v5) (fun v5 : v3 v4 => v5)) : v2 v3 v3) : Reflexive v2; Equivalence_Symmetric := (fun (v3 : forall v3 : v1, Prop) (v4 : forall v4 : v1, Prop) (v5 : v2 v3 v4) => (fun v6 : v1 => conj (fun v7 : v4 v6 => (fun v8 : v3 v6 <-> v4 v6 => and_ind (fun (v9 : forall v9 : v3 v6, v4 v6) (v10 : forall v10 : v4 v6, v3 v6) => (fun v11 : v3 v6 => v11) (v10 v7)) v8) (v5 v6)) (fun v7 : v3 v6 => (fun v8 : v3 v6 <-> v4 v6 => and_ind (fun (v9 : forall v9 : v3 v6, v4 v6) (v10 : forall v10 : v4 v6, v3 v6) => (fun v11 : v4 v6 => v11) (v9 v7)) v8) (v5 v6))) : v2 v4 v3) : Symmetric v2; Equivalence_Transitive := (fun (v3 : forall v3 : v1, Prop) (v4 : forall v4 : v1, Prop) (v5 : forall v5 : v1, Prop) (v6 : v2 v3 v4) (v7 : v2 v4 v5) => (fun v8 : v1 => conj (fun v9 : v3 v8 => (fun v10 : v4 v8 <-> v5 v8 => and_ind (fun (v11 : forall v11 : v4 v8, v5 v8) (v12 : forall v12 : v5 v8, v4 v8) => (fun v13 : v3 v8 <-> v4 v8 => and_ind (fun (v14 : forall v14 : v3 v8, v4 v8) (v15 : forall v15 : v4 v8, v3 v8) => (fun v16 : v4 v8 => (fun v17 : v3 v8 => (fun v18 : v5 v8 => v18) (v11 v16)) (v15 v16)) (v14 v9)) v13) (v6 v8)) v10) (v7 v8)) (fun v9 : v5 v8 => (fun v10 : v4 v8 <-> v5 v8 => and_ind (fun (v11 : forall v11 : v4 v8, v5 v8) (v12 : forall v12 : v5 v8, v4 v8) => (fun v13 : v4 v8 => (fun v14 : v5 v8 => (fun v15 : v3 v8 <-> v4 v8 => and_ind (fun (v16 : forall v16 : v3 v8, v4 v8) (v17 : forall v17 : v4 v8, v3 v8) => (fun v18 : v3 v8 => v18) (v17 v13)) v15) (v6 v8)) (v11 v13)) (v12 v9)) v10) (v7 v8))) : v2 v3 v5) : Transitive v2 |} in v0 (forall v4 : v1, Prop) v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.repr_fun_choice_imp_ext_function_repr	100	0.075020	1	1	0	synth with cache (only 1: refine (fun (v0 : RepresentativeFunctionalChoice) (v1 v2 : Type) => let v3 : forall (v3 : forall v3 : v1, v2) (v4 : forall v4 : v1, v2), Prop := fun (v3 : forall v3 : v1, v2) (v4 : forall v4 : v1, v2) => forall v5 : v1, v3 v5 = v4 v5 in let v4 : Equivalence v3 := {| Equivalence_Reflexive := (fun v4 : forall v4 : v1, v2 => (fun v5 : v1 => eq_refl) : v3 v4 v4) : Reflexive v3; Equivalence_Symmetric := (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v1, v2) (v6 : v3 v4 v5) => (fun v7 : v1 => eq_sym (v6 v7)) : v3 v5 v4) : Symmetric v3; Equivalence_Transitive := (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v1, v2) (v6 : forall v6 : v1, v2) (v7 : v3 v4 v5) (v8 : v3 v5 v6) => (fun v9 : v1 => (fun v10 : forall (v10 v11 v12 : v2) (v13 : v10 = v11) (v14 : v11 = v12), v10 = v12 => (fun v11 : forall (v11 v12 : v2) (v13 : v4 v9 = v11) (v14 : v11 = v12), v4 v9 = v12 => (fun v12 : forall (v12 : v2) (v13 : v4 v9 = v5 v9) (v14 : v5 v9 = v12), v4 v9 = v12 => v12 (v6 v9) (v7 v9) (v8 v9)) (v11 (v5 v9))) (v10 (v4 v9))) (eq_trans (A:=v2))) : v3 v4 v6) : Transitive v3 |} in v0 (forall v5 : v1, v2) v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.repr_fun_choice_imp_excluded_middle	100	0.026969	1	1	0	synth with cache (only 1: refine (fun v0 : RepresentativeFunctionalChoice => representative_boolean_partition_imp_excluded_middle (v0 (@bool)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.repr_fun_choice_imp_relational_choice	100	3.078534	1	1
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.gen_setoid_fun_choice_imp_setoid_fun_choice	100	0.076576	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : GeneralizedSetoidFunctionalChoice_on v0 v1) => (fun (v3 : forall v3 v4 : v0, Prop) (v4 : forall (v4 : v0) (v5 : v1), Prop) (v5 : Equivalence v3) (v6 : forall (v6 v7 : v0) (v8 : v1) (v9 : v3 v6 v7) (v10 : v4 v6 v8), v4 v7 v8) (v7 : forall v7 : v0, exists v8 : v1, v4 v7 v8) => v2 v3 eq v4 v5 eq_equivalence (fun (v8 v9 : v0) (v10 v11 : v1) (v12 : v3 v8 v9) (v13 : v10 = v11) => eq_ind v10 (fun v14 : v1 => forall v15 : v4 v8 v10, v4 v9 v14) (fun v14 : v4 v8 v10 => match v5 as v15 in (Equivalence _) return (v4 v9 v10) with | {| Equivalence_Reflexive := v15; Equivalence_Symmetric := v16; Equivalence_Transitive := v17 |} => (fun (v15 : Reflexive v3) (v16 : Symmetric v3) (v17 : Transitive v3) => (fun v18 : exists v18 : v1, v4 v9 v18 => ex_ind (fun (v19 : v1) (v20 : v4 v9 v19) => (fun v21 : forall (v21 : v0) (v22 : v1) (v23 : v3 v9 v21) (v24 : v4 v9 v22), v4 v21 v22 => (fun v22 : forall (v22 : v0) (v23 : v1) (v24 : v3 v8 v22) (v25 : v4 v8 v23), v4 v22 v23 => v21 v9 v10 (v15 v9) (v21 v9 v10 (v15 v9) (v21 v9 v10 (v15 v9) (v22 v9 v10 v12 v14)))) (v6 v8)) (v6 v9)) v18) (v7 v9)) v15 v16 v17 end) v11 v13) v7) : SetoidFunctionalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_fun_choice_imp_gen_setoid_fun_choice	100	0.088029	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : SetoidFunctionalChoice_on v0 v1) => (fun (v3 : forall v3 v4 : v0, Prop) (v4 : forall v4 v5 : v1, Prop) (v5 : forall (v5 : v0) (v6 : v1), Prop) (v6 : Equivalence v3) (v7 : Equivalence v4) (v8 : forall (v8 v9 : v0) (v10 v11 : v1) (v12 : v3 v8 v9) (v13 : v4 v10 v11) (v14 : v5 v8 v10), v5 v9 v11) (v9 : forall v9 : v0, exists v10 : v1, v5 v9 v10) => let v10 : exists v10 : forall v10 : v0, v1, forall v11 : v0, v5 v11 (v10 v11) /\ (forall (v12 : v0) (v13 : v3 v11 v12), v10 v11 = v10 v12) := v2 v3 v5 v6 (fun (v10 v11 : v0) (v12 : v1) (v13 : v3 v10 v11) (v14 : v5 v10 v12) => v8 v10 v11 v12 v12 v13 (reflexivity v12) v14) v9 in match v10 as v11 in (ex _) return (exists v12 : forall v12 : v0, v1, forall v13 : v0, v5 v13 (v12 v13) /\ (forall (v14 : v0) (v15 : v3 v13 v14), v4 (v12 v13) (v12 v14))) with | ex_intro _ v11 v12 => (fun (v11 : forall v11 : v0, v1) (v12 : forall v12 : v0, v5 v12 (v11 v12) /\ (forall (v13 : v0) (v14 : v3 v12 v13), v11 v12 = v11 v13)) => ex_intro (fun v13 : forall v13 : v0, v1 => forall v14 : v0, v5 v14 (v13 v14) /\ (forall (v15 : v0) (v16 : v3 v14 v15), v4 (v13 v14) (v13 v15))) v11 (fun v13 : v0 => let v14 : v5 v13 (v11 v13) /\ (forall (v14 : v0) (v15 : v3 v13 v14), v11 v13 = v11 v14) := v12 v13 in match v14 as v15 in (_ /\ _) return (v5 v13 (v11 v13) /\ (forall (v16 : v0) (v17 : v3 v13 v16), v4 (v11 v13) (v11 v16))) with | conj v15 v16 => (fun (v15 : v5 v13 (v11 v13)) (v16 : forall (v16 : v0) (v17 : v3 v13 v16), v11 v13 = v11 v16) => conj v15 (fun (v17 : v0) (v18 : v3 v13 v17) => eq_ind_r (fun v19 : v1 => v4 v19 (v11 v17)) (reflexivity (v11 v17)) (v16 v17 v18))) v15 v16 end)) v11 v12 end) : GeneralizedSetoidFunctionalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_fun_choice_iff_gen_setoid_fun_choice	100	0.037661	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Type => conj (fun v2 : SetoidFunctionalChoice_on v0 v1 => setoid_fun_choice_imp_gen_setoid_fun_choice v2) (fun v2 : GeneralizedSetoidFunctionalChoice_on v0 v1 => gen_setoid_fun_choice_imp_setoid_fun_choice v2))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_fun_choice_imp_simple_setoid_fun_choice	100	0.133426	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : SetoidFunctionalChoice_on v0 v1) => (fun (v3 : forall v3 v4 : v0, Prop) (v4 : forall (v4 : v0) (v5 : v1), Prop) (v5 : Equivalence v3) (v6 : forall v6 : v0, exists v7 : v1, forall (v8 : v0) (v9 : v3 v6 v8), v4 v8 v7) => let v7 : forall (v7 : v0) (v8 : v1), Prop := fun (v7 : v0) (v8 : v1) => forall (v9 : v0) (v10 : v3 v7 v9), v4 v9 v8 in let v8 : forall (v8 v9 : v0) (v10 : v1) (v11 : v3 v8 v9) (v12 : v7 v8 v10), v7 v9 v10 := fun (v8 v9 : v0) (v10 : v1) (v11 : v3 v8 v9) (v12 : v7 v8 v10) => (fun (v13 : v0) (v14 : v3 v9 v13) => match v5 as v15 in (Equivalence _) return (v4 v13 v10) with | {| Equivalence_Reflexive := v15; Equivalence_Symmetric := v16; Equivalence_Transitive := v17 |} => (fun (v15 : Reflexive v3) (v16 : Symmetric v3) (v17 : Transitive v3) => (fun v18 : forall v18 : v3 v8 v13, v4 v13 v10 => (fun v19 : forall (v19 v20 : v0) (v21 : v3 v8 v19) (v22 : v3 v19 v20), v3 v8 v20 => (fun v20 : forall (v20 : v0) (v21 : v3 v8 v9) (v22 : v3 v9 v20), v3 v8 v20 => v12 v13 (v16 v13 v8 (v16 v8 v13 (v20 v13 v11 v14)))) (v19 v9)) (v17 v8)) (v12 v13)) v15 v16 v17 end) : v7 v9 v10 in let v9 : exists v9 : forall v9 : v0, v1, forall v10 : v0, v7 v10 (v9 v10) /\ (forall (v11 : v0) (v12 : v3 v10 v11), v9 v10 = v9 v11) := v2 v3 v7 v5 v8 v6 in match v9 as v10 in (ex _) return (exists v11 : forall v11 : v0, v1, forall v12 : v0, v4 v12 (v11 v12) /\ (forall (v13 : v0) (v14 : v3 v12 v13), v11 v12 = v11 v13)) with | ex_intro _ v10 v11 => (fun (v10 : forall v10 : v0, v1) (v11 : forall v11 : v0, v7 v11 (v10 v11) /\ (forall (v12 : v0) (v13 : v3 v11 v12), v10 v11 = v10 v12)) => ex_intro (fun v12 : forall v12 : v0, v1 => forall v13 : v0, v4 v13 (v12 v13) /\ (forall (v14 : v0) (v15 : v3 v13 v14), v12 v13 = v12 v14)) v10 (fun v12 : v0 => match v5 as v13 in (Equivalence _) return (v4 v12 (v10 v12) /\ (forall (v14 : v0) (v15 : v3 v12 v14), v10 v12 = v10 v14)) with | {| Equivalence_Reflexive := v13; Equivalence_Symmetric := v14; Equivalence_Transitive := v15 |} => (fun (v13 : Reflexive v3) (v14 : Symmetric v3) (v15 : Transitive v3) => conj ((fun v16 : v7 v12 (v10 v12) /\ (forall (v16 : v0) (v17 : v3 v12 v16), v10 v12 = v10 v16) => and_ind (fun (v17 : v7 v12 (v10 v12)) (v18 : forall (v18 : v0) (v19 : v3 v12 v18), v10 v12 = v10 v18) => (fun v19 : forall (v19 : v0) (v20 : v1) (v21 : v3 v12 v19) (v22 : v7 v12 v20), v7 v19 v20 => (fun v20 : exists v20 : v1, forall (v21 : v0) (v22 : v3 v12 v21), v4 v21 v20 => ex_ind (fun (v21 : v1) (v22 : forall (v22 : v0) (v23 : v3 v12 v22), v4 v22 v21) => v17 v12 (v13 v12)) v20) (v6 v12)) (v8 v12)) v16) (v11 v12)) (fun (v16 : v0) (v17 : v3 v12 v16) => (fun v18 : v7 v12 (v10 v12) /\ (forall (v18 : v0) (v19 : v3 v12 v18), v10 v12 = v10 v18) => and_ind (fun (v19 : v7 v12 (v10 v12)) (v20 : forall (v20 : v0) (v21 : v3 v12 v20), v10 v12 = v10 v20) => (fun v21 : forall v21 : v3 v12 v16, v10 v12 = v10 v16 => (fun v22 : v10 v12 = v10 v16 => v22) (v21 v17)) (v20 v16)) v18) (v11 v12))) v13 v14 v15 end)) v10 v11 end) : SimpleSetoidFunctionalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.simple_setoid_fun_choice_imp_setoid_fun_choice	100	0.102131	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : SimpleSetoidFunctionalChoice_on v0 v1) => (fun (v3 : forall v3 v4 : v0, Prop) (v4 : forall (v4 : v0) (v5 : v1), Prop) (v5 : Equivalence v3) (v6 : forall (v6 v7 : v0) (v8 : v1) (v9 : v3 v6 v7) (v10 : v4 v6 v8), v4 v7 v8) (v7 : forall v7 : v0, exists v8 : v1, v4 v7 v8) => let v8 : exists v8 : forall v8 : v0, v1, forall v9 : v0, v4 v9 (v8 v9) /\ (forall (v10 : v0) (v11 : v3 v9 v10), v8 v9 = v8 v10) := v2 v3 v4 v5 (fun v8 : v0 => match v5 as v9 in (Equivalence _) return (exists v10 : v1, forall (v11 : v0) (v12 : v3 v8 v11), v4 v11 v10) with | {| Equivalence_Reflexive := v9; Equivalence_Symmetric := v10; Equivalence_Transitive := v11 |} => (fun (v9 : Reflexive v3) (v10 : Symmetric v3) (v11 : Transitive v3) => (fun v12 : forall (v12 : v0) (v13 : v1) (v14 : v3 v8 v12) (v15 : v4 v8 v13), v4 v12 v13 => (fun v13 : exists v13 : v1, v4 v8 v13 => ex_ind (fun (v14 : v1) (v15 : v4 v8 v14) => ex_intro (fun v16 : v1 => forall (v17 : v0) (v18 : v3 v8 v17), v4 v17 v16) v14 (fun (v16 : v0) (v17 : v3 v8 v16) => v12 v16 v14 v17 v15)) v13) (v7 v8)) (v6 v8)) v9 v10 v11 end) in match v8 as v9 in (ex _) return (exists v10 : forall v10 : v0, v1, forall v11 : v0, v4 v11 (v10 v11) /\ (forall (v12 : v0) (v13 : v3 v11 v12), v10 v11 = v10 v12)) with | ex_intro _ v9 v10 => (fun (v9 : forall v9 : v0, v1) (v10 : forall v10 : v0, v4 v10 (v9 v10) /\ (forall (v11 : v0) (v12 : v3 v10 v11), v9 v10 = v9 v11)) => match v5 as v11 in (Equivalence _) return (exists v12 : forall v12 : v0, v1, forall v13 : v0, v4 v13 (v12 v13) /\ (forall (v14 : v0) (v15 : v3 v13 v14), v12 v13 = v12 v14)) with | {| Equivalence_Reflexive := v11; Equivalence_Symmetric := v12; Equivalence_Transitive := v13 |} => (fun (v11 : Reflexive v3) (v12 : Symmetric v3) (v13 : Transitive v3) => ex_intro (fun v14 : forall v14 : v0, v1 => forall v15 : v0, v4 v15 (v14 v15) /\ (forall (v16 : v0) (v17 : v3 v15 v16), v14 v15 = v14 v16)) v9 v10) v11 v12 v13 end) v9 v10 end) : SetoidFunctionalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_fun_choice_iff_simple_setoid_fun_choice	100	0.043770	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Type => conj (fun v2 : SetoidFunctionalChoice_on v0 v1 => setoid_fun_choice_imp_simple_setoid_fun_choice v2) (fun v2 : SimpleSetoidFunctionalChoice_on v0 v1 => simple_setoid_fun_choice_imp_setoid_fun_choice v2))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_fun_choice_imp_fun_choice	100	0.068191	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : SetoidFunctionalChoice_on v0 v1) => (fun (v3 : forall (v3 : v0) (v4 : v1), Prop) (v4 : forall v4 : v0, exists v5 : v1, v3 v4 v5) => let v5 : exists v5 : forall v5 : v0, v1, forall v6 : v0, v3 v6 (v5 v6) /\ (forall (v7 : v0) (v8 : v6 = v7), v5 v6 = v5 v7) := v2 eq v3 eq_equivalence (fun (v5 v6 : v0) (v7 : v1) (v8 : v5 = v6) => eq_ind_r (fun v9 : v0 => forall v10 : v3 v9 v7, v3 v6 v7) (fun v9 : v3 v6 v7 => v9) v8) v4 in match v5 as v6 in (ex _) return (exists v7 : forall v7 : v0, v1, forall v8 : v0, v3 v8 (v7 v8)) with | ex_intro _ v6 v7 => (fun (v6 : forall v6 : v0, v1) (v7 : forall v7 : v0, v3 v7 (v6 v7) /\ (forall (v8 : v0) (v9 : v7 = v8), v6 v7 = v6 v8)) => ex_intro (fun v8 : forall v8 : v0, v1 => forall v9 : v0, v3 v9 (v8 v9)) v6 (fun v8 : v0 => (fun v9 : v3 v8 (v6 v8) /\ (forall (v9 : v0) (v10 : v8 = v9), v6 v8 = v6 v9) => and_ind (fun (v10 : v3 v8 (v6 v8)) (v11 : forall (v11 : v0) (v12 : v8 = v11), v6 v8 = v6 v11) => v10) v9) (v7 v8))) v6 v7 end) : FunctionalChoice_on v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_fun_choice_imp_functional_rel_reification	100	0.028870	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : SetoidFunctionalChoice_on v0 v1) => fun_choice_imp_functional_rel_reification (setoid_fun_choice_imp_fun_choice v2))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_fun_choice_imp_repr_fun_choice	100	0.062081	1	1	0	synth with cache (only 1: refine (fun (v0 : SetoidFunctionalChoice) (v1 : Type) => (fun (v2 : forall v2 v3 : v1, Prop) (v3 : Equivalence v2) => v0 v1 v1 v2 v2 v3 (fun (v4 v5 v6 : v1) (v7 : v2 v4 v5) (v8 : v2 v4 v6) => match v3 as v9 in (Equivalence _) return (v2 v5 v6) with | {| Equivalence_Reflexive := v9; Equivalence_Symmetric := v10; Equivalence_Transitive := v11 |} => (fun (v9 : Reflexive v2) (v10 : Symmetric v2) (v11 : Transitive v2) => (fun v12 : forall (v12 : v1) (v13 : v2 v6 v12), v2 v12 v6 => (fun v13 : forall (v13 v14 : v1) (v15 : v2 v6 v13) (v16 : v2 v13 v14), v2 v6 v14 => (fun v14 : forall (v14 : v1) (v15 : v2 v6 v4) (v16 : v2 v4 v14), v2 v6 v14 => v10 v6 v5 (v10 v5 v6 (v10 v6 v5 (v14 v5 (symmetry v8) v7)))) (v13 v4)) (v11 v6)) (v10 v6)) v9 v10 v11 end) (fun v4 : v1 => match v3 as v5 in (Equivalence _) return (exists v6 : v1, v2 v4 v6) with | {| Equivalence_Reflexive := v5; Equivalence_Symmetric := v6; Equivalence_Transitive := v7 |} => (fun (v5 : Reflexive v2) (v6 : Symmetric v2) (v7 : Transitive v2) => ex_intro (fun v8 : v1 => v2 v4 v8) v4 ((fun v8 : forall (v8 v9 : v1) (v10 : v2 v4 v8) (v11 : v2 v8 v9), v2 v4 v9 => (fun v9 : forall (v9 : v1) (v10 : v2 v4 v4) (v11 : v2 v4 v9), v2 v4 v9 => v5 v4) (v8 v4)) (v7 v4))) v5 v6 v7 end)) : RepresentativeFunctionalChoice_on v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.functional_rel_reification_and_repr_fun_choice_imp_setoid_fun_choice	100	0.278096	1	1	0	synth with cache (only 1: refine (fun (v0 : FunctionalRelReification) (v1 : RepresentativeFunctionalChoice) (v2 v3 : Type) => (fun (v4 : forall v4 v5 : v2, Prop) (v5 : forall (v5 : v2) (v6 : v3), Prop) (v6 : Equivalence v4) (v7 : forall (v7 v8 : v2) (v9 : v3) (v10 : v4 v7 v8) (v11 : v5 v7 v9), v5 v8 v9) (v8 : forall v8 : v2, exists v9 : v3, v5 v8 v9) => let v9 : FunctionalChoice := fun v9 v10 : Type => functional_rel_reification_and_rel_choice_imp_fun_choice (v0 v9 v10) (repr_fun_choice_imp_relational_choice v1 (B:=v10)) in let v10 : exists v10 : forall v10 : v2, v3, forall v11 : v2, v5 v11 (v10 v11) := v9 v2 v3 v5 v8 in match v10 as v11 in (ex _) return (exists v12 : forall v12 : v2, v3, forall v13 : v2, v5 v13 (v12 v13) /\ (forall (v14 : v2) (v15 : v4 v13 v14), v12 v13 = v12 v14)) with | ex_intro _ v11 v12 => (fun (v11 : forall v11 : v2, v3) (v12 : forall v12 : v2, v5 v12 (v11 v12)) => let v13 : exists v13 : forall v13 : v2, v2, forall v14 : v2, v4 v14 (v13 v14) /\ (forall (v15 : v2) (v16 : v4 v14 v15), v13 v14 = v13 v15) := v1 v2 v4 v6 in match v13 as v14 in (ex _) return (exists v15 : forall v15 : v2, v3, forall v16 : v2, v5 v16 (v15 v16) /\ (forall (v17 : v2) (v18 : v4 v16 v17), v15 v16 = v15 v17)) with | ex_intro _ v14 v15 => (fun (v14 : forall v14 : v2, v2) (v15 : forall v15 : v2, v4 v15 (v14 v15) /\ (forall (v16 : v2) (v17 : v4 v15 v16), v14 v15 = v14 v16)) => ex_intro (fun v16 : forall v16 : v2, v3 => forall v17 : v2, v5 v17 (v16 v17) /\ (forall (v18 : v2) (v19 : v4 v17 v18), v16 v17 = v16 v18)) (fun v16 : v2 => v11 (v14 v16)) (fun v16 : v2 => let v17 : v4 v16 (v14 v16) /\ (forall (v17 : v2) (v18 : v4 v16 v17), v14 v16 = v14 v17) := v15 v16 in match v17 as v18 in (_ /\ _) return (v5 v16 (v11 (v14 v16)) /\ (forall (v19 : v2) (v20 : v4 v16 v19), v11 (v14 v16) = v11 (v14 v19))) with | conj v18 v19 => (fun (v18 : v4 v16 (v14 v16)) (v19 : forall (v19 : v2) (v20 : v4 v16 v19), v14 v16 = v14 v19) => conj (v7 (v14 v16) v16 (v11 (v14 v16)) (symmetry v18) (v12 (v14 v16))) (fun (v20 : v2) (v21 : v4 v16 v20) => let v22 : v14 v16 = v14 v20 := v19 v20 v21 in (fun v23 : v14 v16 = v14 v20 => eq_trans (f_equal (fun v24 : forall v24 : v2, v3 => v24 (v14 v16)) eq_refl) (f_equal v11 v23)) v22)) v18 v19 end)) v14 v15 end) v11 v12 end) : SetoidFunctionalChoice_on v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.functional_rel_reification_and_repr_fun_choice_iff_setoid_fun_choice	100	0.065143	1	1	0	synth with cache (only 1: refine (conj (fun (v0 : FunctionalRelReification /\ RepresentativeFunctionalChoice) (v1 v2 : Type) => functional_rel_reification_and_repr_fun_choice_imp_setoid_fun_choice match v0 as v3 in (_ /\ _) return FunctionalRelReification with | conj v3 v4 => (fun (v3 : FunctionalRelReification) (v4 : RepresentativeFunctionalChoice) => v3) v3 v4 end match v0 as v3 in (_ /\ _) return RepresentativeFunctionalChoice with | conj v3 v4 => (fun (v3 : FunctionalRelReification) (v4 : RepresentativeFunctionalChoice) => v4) v3 v4 end (B:=v2)) (fun v0 : SetoidFunctionalChoice => conj (fun v1 v2 : Type => setoid_fun_choice_imp_functional_rel_reification (v0 v1 v2)) (setoid_fun_choice_imp_repr_fun_choice v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_and_ext_functions_repr_and_excluded_middle_imp_setoid_fun_choice	100	0.535434	1	1	0	synth with cache (only 1: refine (let v0 : forall (v0 : Type) (v1 : v0) (v2 : forall (v2 : v0) (v3 : v1 = v2), Type) (v3 : v2 v1 eq_refl) (v4 : v0) (v5 : v1 = v4), v2 v4 v5 := fun (v0 : Type) (v1 : v0) (v2 : forall (v2 : v0) (v3 : v1 = v2), Type) (v3 : v2 v1 eq_refl) (v4 : v0) (v5 : v1 = v4) => match v5 as v7 in (_ = v6) return (v2 v6 v7) with | eq_refl => v3 end in fun (v1 : FunctionalChoice) (v2 : forall v2 v3 : Type, exists v4 : forall (v4 : forall v4 : v2, v3) (v5 : v2), v3, forall v5 : forall v5 : v2, v3, (forall v6 : v2, v5 v6 = v4 v5 v6) /\ (forall (v6 : forall v6 : v2, v3) (v7 : forall v7 : v2, v5 v7 = v6 v7), v4 v5 = v4 v6)) (v3 : @ExcludedMiddle) (v4 : Type) => (fun (v5 : forall v5 v6 : v4, Prop) (v6 : Equivalence v5) => match v6 as v7 in (Equivalence _) return (exists v8 : forall v8 : v4, v4, forall v9 : v4, v5 v9 (v8 v9) /\ (forall (v10 : v4) (v11 : v5 v9 v10), v8 v9 = v8 v10)) with | {| Equivalence_Reflexive := v7; Equivalence_Symmetric := v8; Equivalence_Transitive := v9 |} => (fun (v7 : Reflexive v5) (v8 : Symmetric v5) (v9 : Transitive v5) => let v10 : forall v10 : Prop, exists v11 : @bool, v11 = @true <-> v10 := fun v10 : Prop => let v11 : v10 \/ ~ v10 := v3 v10 in match v11 as v12 in (_ \/ _) return (exists v13 : @bool, v13 = @true <-> v10) with | or_introl v12 => (fun v12 : v10 => ex_intro (fun v13 : @bool => v13 = @true <-> v10) (@true) (conj (fun v13 : @true = @true => v12) (fun v13 : v10 => eq_refl))) v12 | or_intror v12 => (fun v12 : ~ v10 => ex_intro (fun v13 : @bool => v13 = @true <-> v10) (@false) (conj (fun v13 : @false = @true => let v14 : forall v14 : @true = @true, v10 := match v13 as v15 in (_ = v14) return (forall v16 : v14 = @true, v10) with | eq_refl => fun v14 : @false = @true => (fun v15 : @false = @true => let v16 : @False := eq_ind (@false) (fun v16 : @bool => match v16 as v17 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v15 in False_ind v10 v16) v14 end in v14 eq_refl) (fun v13 : v10 => False_ind (@false = @true) (v12 v13)))) v12 end in let v11 : exists v11 : forall v11 : Prop, @bool, forall v12 : Prop, (fun (v13 : Prop) (v14 : @bool) => v14 = @true <-> v13) v12 (v11 v12) := v1 Prop (@bool) (fun (v11 : Prop) (v12 : @bool) => v12 = @true <-> v11) v10 in match v11 as v12 in (ex _) return (exists v13 : forall v13 : v4, v4, forall v14 : v4, v5 v14 (v13 v14) /\ (forall (v15 : v4) (v16 : v5 v14 v15), v13 v14 = v13 v15)) with | ex_intro _ v12 v13 => (fun (v12 : forall v12 : Prop, @bool) (v13 : forall v13 : Prop, v12 v13 = @true <-> v13) => let v14 : forall v14 v15 : v4, @bool := fun v14 v15 : v4 => v12 (v5 v14 v15) in let v15 : forall v15 : forall v15 : v4, @bool, Prop := fun v15 : forall v15 : v4, @bool => exists v16 : v4, v15 v16 = @true in let v16 : Type := {v16 : forall v16 : v4, @bool | v15 v16} in let v17 : forall (v17 : v16) (v18 : v4), Prop := fun (v17 : v16) (v18 : v4) => proj1_sig v17 v18 = @true in let v18 : exists v18 : forall v18 : v16, v4, forall v19 : v16, v17 v19 (v18 v19) := v1 v16 v4 v17 (fun v18 : v16 => let v19 : exists v19 : v4, proj1_sig v18 v19 = @true := proj2_sig v18 in match v19 as v20 in (ex _) return (exists v21 : v4, v17 v18 v21) with | ex_intro _ v20 v21 => (fun (v20 : v4) (v21 : proj1_sig v18 v20 = @true) => ex_intro (fun v22 : v4 => v17 v18 v22) v20 v21) v20 v21 end) in match v18 as v19 in (ex _) return (exists v20 : forall v20 : v4, v4, forall v21 : v4, v5 v21 (v20 v21) /\ (forall (v22 : v4) (v23 : v5 v21 v22), v20 v21 = v20 v22)) with | ex_intro _ v19 v20 => (fun (v19 : forall v19 : v16, v4) (v20 : forall v20 : v16, v17 v20 (v19 v20)) => let v21 : exists v21 : forall (v21 : forall v21 : v4, @bool) (v22 : v4), @bool, forall v22 : forall v22 : v4, @bool, (forall v23 : v4, v22 v23 = v21 v22 v23) /\ (forall (v23 : forall v23 : v4, @bool) (v24 : forall v24 : v4, v22 v24 = v23 v24), v21 v22 = v21 v23) := v2 v4 (@bool) in match v21 as v22 in (ex _) return (exists v23 : forall v23 : v4, v4, forall v24 : v4, v5 v24 (v23 v24) /\ (forall (v25 : v4) (v26 : v5 v24 v25), v23 v24 = v23 v25)) with | ex_intro _ v22 v23 => (fun (v22 : forall (v22 : forall v22 : v4, @bool) (v23 : v4), @bool) (v23 : forall v23 : forall v23 : v4, @bool, (forall v24 : v4, v23 v24 = v22 v23 v24) /\ (forall (v24 : forall v24 : v4, @bool) (v25 : forall v25 : v4, v23 v25 = v24 v25), v22 v23 = v22 v24)) => let v24 : forall v24 : v4, v15 (v22 (v14 v24)) := fun v24 : v4 => ex_intro (fun v25 : v4 => v22 (v14 v24) v25 = @true) v24 (let v25 : (forall v25 : v4, v14 v24 v25 = v22 (v14 v24) v25) /\ (forall (v25 : forall v25 : v4, @bool) (v26 : forall v26 : v4, v14 v24 v26 = v25 v26), v22 (v14 v24) = v22 v25) := v23 (v14 v24) in match v25 as v26 in (_ /\ _) return (v22 (v14 v24) v24 = @true) with | conj v26 v27 => (fun (v26 : forall v26 : v4, v14 v24 v26 = v22 (v14 v24) v26) (v27 : forall (v27 : forall v27 : v4, @bool) (v28 : forall v28 : v4, v14 v24 v28 = v27 v28), v22 (v14 v24) = v22 v27) => eq_ind (v14 v24 v24) (fun v28 : @bool => v28 = @true) (let v28 : forall (v28 : Prop) (v29 : v28), v12 v28 = @true := fun v28 : Prop => match v13 v28 as v29 in (_ /\ _) return (forall v30 : v28, v12 v28 = @true) with | conj v29 v30 => (fun (v29 : forall v29 : v12 v28 = @true, v28) (v30 : forall v30 : v28, v12 v28 = @true) => v30) v29 v30 end in v28 (v5 v24 v24) (v7 v24)) (v22 (v14 v24) v24) (v26 v24)) v26 v27 end) in let v25 : forall v25 : v4, v16 := fun v25 : v4 => exist v15 (v22 (v14 v25)) (v24 v25) : v16 in ex_intro (fun v26 : forall v26 : v4, v4 => forall v27 : v4, v5 v27 (v26 v27) /\ (forall (v28 : v4) (v29 : v5 v27 v28), v26 v27 = v26 v28)) (fun v26 : v4 => v19 (v25 v26)) (fun v26 : v4 => let v27 : (forall v27 : v4, v14 v26 v27 = v22 (v14 v26) v27) /\ (forall (v27 : forall v27 : v4, @bool) (v28 : forall v28 : v4, v14 v26 v28 = v27 v28), v22 (v14 v26) = v22 v27) := v23 (v14 v26) in match v27 as v28 in (_ /\ _) return (v5 v26 (v19 (v25 v26)) /\ (forall (v29 : v4) (v30 : v5 v26 v29), v19 (v25 v26) = v19 (v25 v29))) with | conj v28 v29 => (fun (v28 : forall v28 : v4, v14 v26 v28 = v22 (v14 v26) v28) (v29 : forall (v29 : forall v29 : v4, @bool) (v30 : forall v30 : v4, v14 v26 v30 = v29 v30), v22 (v14 v26) = v22 v29) => conj (let v30 : v17 (v25 v26) (v19 (v25 v26)) := v20 (v25 v26) in let v31 : v14 v26 (v19 (v25 v26)) = @true := eq_ind_r (fun v31 : @bool => v31 = @true) v30 (v28 (v19 (v25 v26))) in let v32 : forall (v32 : Prop) (v33 : v12 v32 = @true), v32 := fun v32 : Prop => match v13 v32 as v33 in (_ /\ _) return (forall v34 : v12 v32 = @true, v32) with | conj v33 v34 => (fun (v33 : forall v33 : v12 v32 = @true, v32) (v34 : forall v34 : v32, v12 v32 = @true) => v33) v33 v34 end in v32 (v5 v26 (v19 (v25 v26))) v31) (fun (v30 : v4) (v31 : v5 v26 v30) => let v32 : v25 v26 = v25 v30 := let v32 : v22 (v14 v26) = v22 (v14 v30) := v29 (v14 v30) (fun v32 : v4 => (let v33 : @bool := v12 (v5 v26 v32) in let v34 : v12 (v5 v26 v32) = v33 := eq_refl in match v33 as v35 in bool return (forall v36 : v12 (v5 v26 v32) = v35, v35 = v12 (v5 v30 v32)) with | true => fun v35 : v12 (v5 v26 v32) = @true => eq_sym (let v36 : forall (v36 : Prop) (v37 : v36), v12 v36 = @true := fun v36 : Prop => match v13 v36 as v37 in (_ /\ _) return (forall v38 : v36, v12 v36 = @true) with | conj v37 v38 => (fun (v37 : forall v37 : v12 v36 = @true, v36) (v38 : forall v38 : v36, v12 v36 = @true) => v38) v37 v38 end in v36 (v5 v30 v32) (let v37 : forall v37 : Prop, v12 v37 = @true <-> v37 := v13 in let v38 : Prop := v5 v26 v32 in let v39 : v12 v38 = @true <-> v38 := v37 v38 in match v39 as v40 in (_ /\ _) return (v5 v30 v32) with | conj v40 v41 => (fun (v40 : forall v40 : v12 (v5 v26 v32) = @true, v5 v26 v32) (v41 : forall v41 : v5 v26 v32, v12 (v5 v26 v32) = @true) => let v42 : v5 v26 v32 := v40 v35 in (fun v43 : forall v43 : forall v43 : v4, v14 v26 v43 = (fun v44 : v4 => v12 (v5 v26 v44)) v43, v22 (v14 v26) = v22 (fun v44 : v4 => v12 (v5 v26 v44)) => (fun v44 : forall (v44 v45 : v4) (v46 : v5 v30 v44) (v47 : v5 v44 v45), v5 v30 v45 => (fun v45 : forall (v45 : v4) (v46 : v5 v30 v26) (v47 : v5 v26 v45), v5 v30 v45 => v8 v32 v30 (v8 v30 v32 (v45 v32 (v8 v26 v30 v31) v42))) (v44 v26)) (v9 v30)) (v29 (fun v43 : v4 => v12 (v5 v26 v43)))) v40 v41 end)) | false => fun v35 : v12 (v5 v26 v32) = @false => let v36 : @bool := v12 (v5 v30 v32) in let v37 : v12 (v5 v30 v32) = v36 := eq_refl in match v36 as v38 in bool return (forall v39 : v12 (v5 v30 v32) = v38, @false = v38) with | true => fun v38 : v12 (v5 v30 v32) = @true => let v39 : forall v39 : Prop, v12 v39 = @true <-> v39 := v13 in let v40 : Prop := v5 v30 v32 in let v41 : v12 v40 = @true <-> v40 := v39 v40 in match v41 as v42 in (_ /\ _) return (@false = @true) with | conj v42 v43 => (fun (v42 : forall v42 : v12 (v5 v30 v32) = @true, v5 v30 v32) (v43 : forall v43 : v5 v30 v32, v12 (v5 v30 v32) = @true) => let v44 : v5 v30 v32 := v42 v38 in eq_ind (v12 (v5 v26 v32)) (fun v45 : @bool => v45 = @true) (let v45 : forall (v45 : Prop) (v46 : v45), v12 v45 = @true := fun v45 : Prop => match v13 v45 as v46 in (_ /\ _) return (forall v47 : v45, v12 v45 = @true) with | conj v46 v47 => (fun (v46 : forall v46 : v12 v45 = @true, v45) (v47 : forall v47 : v45, v12 v45 = @true) => v47) v46 v47 end in v45 (v5 v26 v32) ((fun v46 : forall v46 : forall v46 : v4, v14 v26 v46 = (fun v47 : v4 => v12 (v5 v26 v47)) v46, v22 (v14 v26) = v22 (fun v47 : v4 => v12 (v5 v26 v47)) => (fun v47 : forall (v47 v48 : v4) (v49 : v5 v26 v47) (v50 : v5 v47 v48), v5 v26 v48 => (fun v48 : forall (v48 : v4) (v49 : v5 v26 v30) (v50 : v5 v30 v48), v5 v26 v48 => v8 v32 v26 (v8 v26 v32 (v48 v32 v31 v44))) (v47 v30)) (v9 v26)) (v29 (fun v46 : v4 => v12 (v5 v26 v46))))) (@false) v35) v42 v43 end | false => fun v38 : v12 (v5 v30 v32) = @false => eq_refl end v37 end v34) : v14 v26 v32 = v14 v30 v32) in let v33 : rew [v15] v32 in v24 v26 = v24 v30 := proof_irrelevance_cci v3 (v15 (v22 (v14 v30))) (rew [v15] v32 in v24 v26) (v24 v30) in eq_ind (rew [v15] v32 in v24 v26) (fun v34 : v15 (v22 (v14 v30)) => exist v15 (v22 (v14 v26)) (v24 v26) = exist v15 (v22 (v14 v30)) v34) (v0 (forall v34 : v4, @bool) (v22 (v14 v26)) (fun (v34 : forall v34 : v4, @bool) (v35 : v22 (v14 v26) = v34) => exist v15 (v22 (v14 v26)) (v24 v26) = exist v15 v34 (rew [v15] v35 in v24 v26)) eq_refl (v22 (v14 v30)) v32) (v24 v30) v33 : v25 v26 = v25 v30 in (fun v33 : v25 v26 = v25 v30 => eq_trans (f_equal (fun v34 : forall v34 : v16, v4 => v34 (v25 v26)) eq_refl) (f_equal v19 v33)) v32)) v28 v29 end)) v22 v23 end) v19 v20 end) v12 v13 end) v7 v8 v9 end) : RepresentativeFunctionalChoice_on v4)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_functional_choice_first_characterization	100	0.167350	1	1	0	synth with cache (only 1: refine (conj (fun v0 : FunctionalChoice /\ (forall v0 v1 : Type, exists v2 : forall (v2 : forall v2 : v0, v1) (v3 : v0), v1, forall v3 : forall v3 : v0, v1, (forall v4 : v0, v3 v4 = v2 v3 v4) /\ (forall (v4 : forall v4 : v0, v1) (v5 : forall v5 : v0, v3 v5 = v4 v5), v2 v3 = v2 v4)) /\ @ExcludedMiddle => match v0 as v1 in (_ /\ _) return SetoidFunctionalChoice with | conj v1 v2 => (fun (v1 : FunctionalChoice) (v2 : (forall v2 v3 : Type, exists v4 : forall (v4 : forall v4 : v2, v3) (v5 : v2), v3, forall v5 : forall v5 : v2, v3, (forall v6 : v2, v5 v6 = v4 v5 v6) /\ (forall (v6 : forall v6 : v2, v3) (v7 : forall v7 : v2, v5 v7 = v6 v7), v4 v5 = v4 v6)) /\ @ExcludedMiddle) => match v2 as v3 in (_ /\ _) return SetoidFunctionalChoice with | conj v3 v4 => (fun (v3 : forall v3 v4 : Type, exists v5 : forall (v5 : forall v5 : v3, v4) (v6 : v3), v4, forall v6 : forall v6 : v3, v4, (forall v7 : v3, v6 v7 = v5 v6 v7) /\ (forall (v7 : forall v7 : v3, v4) (v8 : forall v8 : v3, v6 v8 = v7 v8), v5 v6 = v5 v7)) (v4 : @ExcludedMiddle) => functional_rel_reification_and_repr_fun_choice_imp_setoid_fun_choice (fun v5 v6 : Type => fun_choice_imp_functional_rel_reification (v1 v5 v6)) (fun_choice_and_ext_functions_repr_and_excluded_middle_imp_setoid_fun_choice v1 v3 v4)) v3 v4 end) v1 v2 end) (fun v0 : SetoidFunctionalChoice => conj (fun v1 v2 : Type => setoid_fun_choice_imp_fun_choice (v0 v1 v2)) (conj (repr_fun_choice_imp_ext_function_repr (setoid_fun_choice_imp_repr_fun_choice v0)) (repr_fun_choice_imp_excluded_middle (setoid_fun_choice_imp_repr_fun_choice v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.fun_choice_and_ext_pred_ext_and_proof_irrel_imp_setoid_fun_choice	100	0.349837	1	1	0	synth with cache (only 1: refine (let v0 : forall (v0 : Type) (v1 : v0) (v2 : forall (v2 : v0) (v3 : v1 = v2), Type) (v3 : v2 v1 eq_refl) (v4 : v0) (v5 : v1 = v4), v2 v4 v5 := fun (v0 : Type) (v1 : v0) (v2 : forall (v2 : v0) (v3 : v1 = v2), Type) (v3 : v2 v1 eq_refl) (v4 : v0) (v5 : v1 = v4) => match v5 as v7 in (_ = v6) return (v2 v6 v7) with | eq_refl => v3 end in fun (v1 : FunctionalChoice) (v2 : forall v2 : Type, exists v3 : forall (v3 : forall v3 : v2, Prop) (v4 : v2), Prop, forall v4 : forall v4 : v2, Prop, (forall v5 : v2, v4 v5 <-> v3 v4 v5) /\ (forall (v5 : forall v5 : v2, Prop) (v6 : forall v6 : v2, v4 v6 <-> v5 v6), v3 v4 = v3 v5)) (v3 : @ProofIrrelevance) (v4 : Type) => (fun (v5 : forall v5 v6 : v4, Prop) (v6 : Equivalence v5) => match v6 as v7 in (Equivalence _) return (exists v8 : forall v8 : v4, v4, forall v9 : v4, v5 v9 (v8 v9) /\ (forall (v10 : v4) (v11 : v5 v9 v10), v8 v9 = v8 v10)) with | {| Equivalence_Reflexive := v7; Equivalence_Symmetric := v8; Equivalence_Transitive := v9 |} => (fun (v7 : Reflexive v5) (v8 : Symmetric v5) (v9 : Transitive v5) => let v10 : forall v10 : forall v10 : v4, Prop, Prop := fun v10 : forall v10 : v4, Prop => exists v11 : v4, v10 v11 in let v11 : Type := {v11 : forall v11 : v4, Prop | v10 v11} in let v12 : forall (v12 : v11) (v13 : v4), Prop := fun (v12 : v11) (v13 : v4) => proj1_sig v12 v13 in let v13 : forall v13 v14 : v4, Prop := fun v13 : v4 => v5 v13 in let v14 : exists v14 : forall v14 : v11, v4, forall v15 : v11, v12 v15 (v14 v15) := v1 v11 v4 v12 (fun v14 : v11 => proj2_sig v14) in match v14 as v15 in (ex _) return (exists v16 : forall v16 : v4, v4, forall v17 : v4, v5 v17 (v16 v17) /\ (forall (v18 : v4) (v19 : v5 v17 v18), v16 v17 = v16 v18)) with | ex_intro _ v15 v16 => (fun (v15 : forall v15 : v11, v4) (v16 : forall v16 : v11, v12 v16 (v15 v16)) => let v17 : exists v17 : forall (v17 : forall v17 : v4, Prop) (v18 : v4), Prop, forall v18 : forall v18 : v4, Prop, (forall v19 : v4, v18 v19 <-> v17 v18 v19) /\ (forall (v19 : forall v19 : v4, Prop) (v20 : forall v20 : v4, v18 v20 <-> v19 v20), v17 v18 = v17 v19) := v2 v4 in match v17 as v18 in (ex _) return (exists v19 : forall v19 : v4, v4, forall v20 : v4, v5 v20 (v19 v20) /\ (forall (v21 : v4) (v22 : v5 v20 v21), v19 v20 = v19 v21)) with | ex_intro _ v18 v19 => (fun (v18 : forall (v18 : forall v18 : v4, Prop) (v19 : v4), Prop) (v19 : forall v19 : forall v19 : v4, Prop, (forall v20 : v4, v19 v20 <-> v18 v19 v20) /\ (forall (v20 : forall v20 : v4, Prop) (v21 : forall v21 : v4, v19 v21 <-> v20 v21), v18 v19 = v18 v20)) => let v20 : forall v20 : v4, v10 (v18 (v13 v20)) := fun v20 : v4 => ex_intro (fun v21 : v4 => v18 (v13 v20) v21) v20 (let v21 : (forall v21 : v4, v13 v20 v21 <-> v18 (v13 v20) v21) /\ (forall (v21 : forall v21 : v4, Prop) (v22 : forall v22 : v4, v13 v20 v22 <-> v21 v22), v18 (v13 v20) = v18 v21) := v19 (v13 v20) in match v21 as v22 in (_ /\ _) return (v18 (v13 v20) v20) with | conj v22 v23 => (fun (v22 : forall v22 : v4, v13 v20 v22 <-> v18 (v13 v20) v22) (v23 : forall (v23 : forall v23 : v4, Prop) (v24 : forall v24 : v4, v13 v20 v24 <-> v23 v24), v18 (v13 v20) = v18 v23) => (fun v24 : v13 v20 v20 <-> v18 (v13 v20) v20 => Morphisms.iff_flip_impl_subrelation (v18 (v13 v20) v20) (v13 v20 v20) (symmetry v24)) (v22 v20) (v7 v20)) v22 v23 end) in let v21 : forall v21 : v4, v11 := fun v21 : v4 => exist v10 (v18 (v13 v21)) (v20 v21) : v11 in ex_intro (fun v22 : forall v22 : v4, v4 => forall v23 : v4, v5 v23 (v22 v23) /\ (forall (v24 : v4) (v25 : v5 v23 v24), v22 v23 = v22 v24)) (fun v22 : v4 => v15 (v21 v22)) (fun v22 : v4 => let v23 : (forall v23 : v4, v13 v22 v23 <-> v18 (v13 v22) v23) /\ (forall (v23 : forall v23 : v4, Prop) (v24 : forall v24 : v4, v13 v22 v24 <-> v23 v24), v18 (v13 v22) = v18 v23) := v19 (v13 v22) in match v23 as v24 in (_ /\ _) return (v5 v22 (v15 (v21 v22)) /\ (forall (v25 : v4) (v26 : v5 v22 v25), v15 (v21 v22) = v15 (v21 v25))) with | conj v24 v25 => (fun (v24 : forall v24 : v4, v13 v22 v24 <-> v18 (v13 v22) v24) (v25 : forall (v25 : forall v25 : v4, Prop) (v26 : forall v26 : v4, v13 v22 v26 <-> v25 v26), v18 (v13 v22) = v18 v25) => conj (let v26 : v12 (v21 v22) (v15 (v21 v22)) := v16 (v21 v22) in (fun v27 : v13 v22 (v15 (v21 v22)) <-> v18 (v13 v22) (v15 (v21 v22)) => Morphisms.iff_impl_subrelation (v18 (v13 v22) (v15 (v21 v22))) (v13 v22 (v15 (v21 v22))) (symmetry v27)) (v24 (v15 (v21 v22))) v26) (fun (v26 : v4) (v27 : v5 v22 v26) => let v28 : v21 v22 = v21 v26 := let v28 : v18 (v13 v22) = v18 (v13 v26) := v25 (v13 v26) (fun v28 : v4 => conj (fun v29 : v5 v22 v28 => (fun v30 : (forall v30 : v4, v5 v22 v30 <-> v18 (v5 v22) v30) /\ (forall (v30 : forall v30 : v4, Prop) (v31 : forall v31 : v4, v5 v22 v31 <-> v30 v31), v18 (v5 v22) = v18 v30) => and_ind (fun (v31 : forall v31 : v4, v5 v22 v31 <-> v18 (v5 v22) v31) (v32 : forall (v32 : forall v32 : v4, Prop) (v33 : forall v33 : v4, v5 v22 v33 <-> v32 v33), v18 (v5 v22) = v18 v32) => (fun v33 : forall (v33 v34 : v4) (v35 : v5 v26 v33) (v36 : v5 v33 v34), v5 v26 v34 => (fun v34 : forall (v34 : v4) (v35 : v5 v26 v22) (v36 : v5 v22 v34), v5 v26 v34 => v8 v28 v26 (v8 v26 v28 (v34 v28 (v8 v22 v26 v27) v29))) (v33 v22)) (v9 v26)) v30) (v19 (v5 v22))) (fun v29 : v5 v26 v28 => (fun v30 : (forall v30 : v4, v5 v22 v30 <-> v18 (v5 v22) v30) /\ (forall (v30 : forall v30 : v4, Prop) (v31 : forall v31 : v4, v5 v22 v31 <-> v30 v31), v18 (v5 v22) = v18 v30) => and_ind (fun (v31 : forall v31 : v4, v5 v22 v31 <-> v18 (v5 v22) v31) (v32 : forall (v32 : forall v32 : v4, Prop) (v33 : forall v33 : v4, v5 v22 v33 <-> v32 v33), v18 (v5 v22) = v18 v32) => (fun v33 : forall (v33 v34 : v4) (v35 : v5 v22 v33) (v36 : v5 v33 v34), v5 v22 v34 => (fun v34 : forall (v34 : v4) (v35 : v5 v22 v26) (v36 : v5 v26 v34), v5 v22 v34 => v8 v28 v22 (v8 v22 v28 (v34 v28 v27 v29))) (v33 v26)) (v9 v22)) v30) (v19 (v5 v22))) : v13 v22 v28 <-> v13 v26 v28) in let v29 : rew [v10] v28 in v20 v22 = v20 v26 := v3 (v10 (v18 (v13 v26))) (rew [v10] v28 in v20 v22) (v20 v26) in eq_ind (rew [v10] v28 in v20 v22) (fun v30 : v10 (v18 (v13 v26)) => exist v10 (v18 (v13 v22)) (v20 v22) = exist v10 (v18 (v13 v26)) v30) (v0 (forall v30 : v4, Prop) (v18 (v13 v22)) (fun (v30 : forall v30 : v4, Prop) (v31 : v18 (v13 v22) = v30) => exist v10 (v18 (v13 v22)) (v20 v22) = exist v10 v30 (rew [v10] v31 in v20 v22)) eq_refl (v18 (v13 v26)) v28) (v20 v26) v29 : v21 v22 = v21 v26 in (fun v29 : v21 v22 = v21 v26 => eq_trans (f_equal (fun v30 : forall v30 : v11, v4 => v30 (v21 v22)) eq_refl) (f_equal v15 v29)) v28)) v24 v25 end)) v18 v19 end) v15 v16 end) v7 v8 v9 end) : RepresentativeFunctionalChoice_on v4)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ChoiceFacts.setoid_functional_choice_second_characterization	100	0.133604	1	1	0	synth with cache (only 1: refine (conj (fun v0 : FunctionalChoice /\ (forall v0 : Type, exists v1 : forall (v1 : forall v1 : v0, Prop) (v2 : v0), Prop, forall v2 : forall v2 : v0, Prop, (forall v3 : v0, v2 v3 <-> v1 v2 v3) /\ (forall (v3 : forall v3 : v0, Prop) (v4 : forall v4 : v0, v2 v4 <-> v3 v4), v1 v2 = v1 v3)) /\ @ProofIrrelevance => match v0 as v1 in (_ /\ _) return SetoidFunctionalChoice with | conj v1 v2 => (fun (v1 : FunctionalChoice) (v2 : (forall v2 : Type, exists v3 : forall (v3 : forall v3 : v2, Prop) (v4 : v2), Prop, forall v4 : forall v4 : v2, Prop, (forall v5 : v2, v4 v5 <-> v3 v4 v5) /\ (forall (v5 : forall v5 : v2, Prop) (v6 : forall v6 : v2, v4 v6 <-> v5 v6), v3 v4 = v3 v5)) /\ @ProofIrrelevance) => match v2 as v3 in (_ /\ _) return SetoidFunctionalChoice with | conj v3 v4 => (fun (v3 : forall v3 : Type, exists v4 : forall (v4 : forall v4 : v3, Prop) (v5 : v3), Prop, forall v5 : forall v5 : v3, Prop, (forall v6 : v3, v5 v6 <-> v4 v5 v6) /\ (forall (v6 : forall v6 : v3, Prop) (v7 : forall v7 : v3, v5 v7 <-> v6 v7), v4 v5 = v4 v6)) (v4 : @ProofIrrelevance) => functional_rel_reification_and_repr_fun_choice_imp_setoid_fun_choice (fun v5 v6 : Type => fun_choice_imp_functional_rel_reification (v1 v5 v6)) (fun_choice_and_ext_pred_ext_and_proof_irrel_imp_setoid_fun_choice v1 v3 v4)) v3 v4 end) v1 v2 end) (fun v0 : SetoidFunctionalChoice => conj (fun v1 v2 : Type => setoid_fun_choice_imp_fun_choice (v0 v1 v2)) (conj (repr_fun_choice_imp_ext_pred_repr (setoid_fun_choice_imp_repr_fun_choice v0)) (proof_irrelevance_cci (repr_fun_choice_imp_excluded_middle (setoid_fun_choice_imp_repr_fun_choice v0)) : @ProofIrrelevance))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_opp_r	100	0.045553	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : forall (v2 v3 : @Z) (v4 : (v2 | v3)), (v2 | - v3) := fun v2 v3 : @Z => match Z.divide_opp_r v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 | v3), (v2 | - v3)) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 | - v3), (v2 | v3)) (v5 : forall v5 : (v2 | v3), (v2 | - v3)) => v5) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_opp_r_rev	100	0.045167	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : forall (v2 v3 : @Z) (v4 : (v2 | - v3)), (v2 | v3) := fun v2 v3 : @Z => match Z.divide_opp_r v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 | - v3), (v2 | v3)) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 | - v3), (v2 | v3)) (v5 : forall v5 : (v2 | v3), (v2 | - v3)) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_opp_l	100	0.046838	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : forall (v2 v3 : @Z) (v4 : (v2 | v3)), (- v2 | v3) := fun v2 v3 : @Z => match Z.divide_opp_l v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 | v3), (- v2 | v3)) with | conj v4 v5 => (fun (v4 : forall v4 : (- v2 | v3), (v2 | v3)) (v5 : forall v5 : (v2 | v3), (- v2 | v3)) => v5) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_opp_l_rev	100	0.042842	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : forall (v2 v3 : @Z) (v4 : (- v2 | v3)), (v2 | v3) := fun v2 v3 : @Z => match Z.divide_opp_l v2 v3 as v4 in (_ /\ _) return (forall v5 : (- v2 | v3), (v2 | v3)) with | conj v4 v5 => (fun (v4 : forall v4 : (- v2 | v3), (v2 | v3)) (v5 : forall v5 : (v2 | v3), (- v2 | v3)) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_Zabs_l	100	0.043433	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : forall (v2 v3 : @Z) (v4 : (BinIntDef.Z.abs v2 | v3)), (v2 | v3) := fun v2 v3 : @Z => match Z.divide_abs_l v2 v3 as v4 in (_ /\ _) return (forall v5 : (BinIntDef.Z.abs v2 | v3), (v2 | v3)) with | conj v4 v5 => (fun (v4 : forall v4 : (BinIntDef.Z.abs v2 | v3), (v2 | v3)) (v5 : forall v5 : (v2 | v3), (BinIntDef.Z.abs v2 | v3)) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_Zabs_inv_l	100	0.043561	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : forall (v2 v3 : @Z) (v4 : (v2 | v3)), (BinIntDef.Z.abs v2 | v3) := fun v2 v3 : @Z => match Z.divide_abs_l v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 | v3), (BinIntDef.Z.abs v2 | v3)) with | conj v4 v5 => (fun (v4 : forall v4 : (BinIntDef.Z.abs v2 | v3), (v2 | v3)) (v5 : forall v5 : (v2 | v3), (BinIntDef.Z.abs v2 | v3)) => v5) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zmult_one	100	0.082231	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => (fun v2 : v0 >= 0 <-> 0 <= v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (v0 >= 0) (0 <= v0) v2 (forall v3 : v0 * v1 = 1, v0 = 1) (forall v3 : v0 * v1 = 1, v0 = 1) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (forall v3 : v0 * v1 = 1, v0 = 1))) (Z.ge_le_iff v0 0) (let v2 : forall (v2 v3 : @Z) (v4 : 0 <= v2) (v5 : v2 * v3 = 1), v2 = 1 := fun (v2 v3 : @Z) (v4 : 0 <= v2) (v5 : v2 * v3 = 1) => match Z.eq_mul_1_nonneg v2 v3 v4 v5 as v6 in (_ /\ _) return (v2 = 1) with | conj v6 v7 => (fun (v6 : v2 = 1) (v7 : v3 = 1) => v6) v6 v7 end in v2 v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_bounds	100	0.070948	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : (v0 | v1)) (v3 : v1 <> 0) => let v4 : forall (v4 : @Z) (v5 : v4 <> 0), 0 < BinIntDef.Z.abs v4 := fun v4 : @Z => match Z.abs_pos v4 as v5 in (_ /\ _) return (forall v6 : v4 <> 0, 0 < BinIntDef.Z.abs v4) with | conj v5 v6 => (fun (v5 : forall v5 : 0 < BinIntDef.Z.abs v4, v4 <> 0) (v6 : forall v6 : v4 <> 0, 0 < BinIntDef.Z.abs v4) => v6) v5 v6 end in let v5 : 0 < BinIntDef.Z.abs v1 := v4 v1 v3 in Z.divide_pos_le (BinIntDef.Z.abs v0) (BinIntDef.Z.abs v1) v5 ((fun v6 : (BinIntDef.Z.abs v0 | BinIntDef.Z.abs v1) <-> (BinIntDef.Z.abs v0 | v1) => Morphisms.iff_impl_subrelation (BinIntDef.Z.abs v0 | v1) (BinIntDef.Z.abs v0 | BinIntDef.Z.abs v1) (RelationClasses.symmetry v6)) (Z.divide_abs_r (BinIntDef.Z.abs v0) v1) ((fun v6 : (BinIntDef.Z.abs v0 | v1) <-> (v0 | v1) => Morphisms.iff_impl_subrelation (v0 | v1) (BinIntDef.Z.abs v0 | v1) (RelationClasses.symmetry v6)) (Z.divide_abs_l v0 v1) v2)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zmod_divide	100	0.054925	1	1	0	synth with cache (only 1: refine (let v0 : forall (v0 v1 : @Z) (v2 : v1 <> 0) (v3 : v0 mod v1 = 0), (v1 | v0) := fun (v0 v1 : @Z) (v2 : v1 <> 0) => match Z.mod_divide v0 v1 v2 as v3 in (_ /\ _) return (forall v4 : v0 mod v1 = 0, (v1 | v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0 mod v1 = 0, (v1 | v0)) (v4 : forall v4 : (v1 | v0), v0 mod v1 = 0) => v3) v3 v4 end in v0)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_mod	100	0.044122	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : (v1 | v0)) => match v2 as v3 in (ex _) return (v0 mod v1 = 0) with | ex_intro _ v3 v4 => (fun (v3 : @Z) (v4 : v0 = v3 * v1) => eq_ind_r (fun v5 : @Z => v5 mod v1 = 0) (Z_mod_mult v3 v1) v4) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_dec	100	0.132318	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : {v0 = 0} + {v0 <> 0} := Z.eq_dec v0 0 in match v2 as v3 in ({_} + {_}) return ({(v0 | v1)} + {~ (v0 | v1)}) with | left v3 => (fun v3 : v0 = 0 => let v4 : {v1 = 0} + {v1 <> 0} := Z.eq_dec v1 0 in match v4 as v5 in ({_} + {_}) return ({(v0 | v1)} + {~ (v0 | v1)}) with | left v5 => (fun v5 : v1 = 0 => left (eq_ind_r (fun v6 : @Z => (v6 | v1)) (eq_ind_r (fun v6 : @Z => (0 | v6)) (Z.divide_0_r 0) v5) v3)) v5 | right v5 => (fun v5 : v1 <> 0 => right (eq_ind_r (fun v6 : @Z => ~ (v6 | v1)) ((fun v6 : (0 | v1) => match v5 (Z.divide_0_l v1 v6) as v7 in False return (@False) with end) : ~ (0 | v1)) v3)) v5 end) v3 | right v3 => (fun v3 : v0 <> 0 => let v4 : {v1 mod v0 = 0} + {v1 mod v0 <> 0} := Z.eq_dec (v1 mod v0) 0 in match v4 as v5 in ({_} + {_}) return ({(v0 | v1)} + {~ (v0 | v1)}) with | left v5 => (fun v5 : v1 mod v0 = 0 => left (let v6 : forall (v6 v7 : @Z) (v8 : v7 <> 0) (v9 : v6 mod v7 = 0), (v7 | v6) := fun (v6 v7 : @Z) (v8 : v7 <> 0) => match Z.mod_divide v6 v7 v8 as v9 in (_ /\ _) return (forall v10 : v6 mod v7 = 0, (v7 | v6)) with | conj v9 v10 => (fun (v9 : forall v9 : v6 mod v7 = 0, (v7 | v6)) (v10 : forall v10 : (v7 | v6), v6 mod v7 = 0) => v9) v9 v10 end in v6 v1 v0 v3 v5)) v5 | right v5 => (fun v5 : v1 mod v0 <> 0 => right ((fun v6 : v1 mod v0 = 0 <-> (v0 | v1) => Morphisms.subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)) (v0 | v1) (v1 mod v0 = 0) (RelationClasses.symmetry v6)) (Z.mod_divide v1 v0 v3) v5)) v5 end) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Z_lt_neq	100	0.076933	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : v0 < v1) => Z.neq_sym v0 v1 (Z.neq_sym v1 v0 (Z.neq_sym v0 v1 (Z.lt_neq v0 v1 v2))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_Zdiv_eq	100	0.096582	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 < v0) (v3 : (v0 | v1)) => (fun v4 : v1 = v0 * (v1 / v0) + v1 mod v0 => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive v1 (v0 * (v1 / v0) + v1 mod v0) v4 (v0 * (v1 / v0)) (v0 * (v1 / v0)) (Morphisms.eq_proper_proxy (v0 * (v1 / v0)))) (Z.div_mod v1 v0 (Z_lt_neq v2)) (eq_ind_r (fun v4 : @Z => v0 * (v1 / v0) + v4 = v0 * (v1 / v0)) (Z.add_0_r (v0 * (v1 / v0))) (Zdivide_mod v1 v0 v3)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_Zdiv_eq_2	100	0.048238	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 < v0) (v4 : (v0 | v1)) => Z.divide_div_mul_exact v1 v0 v2 (Z_lt_neq v3) v4)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_le	100	0.037059	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : 0 < v1) (v4 : (v0 | v1)) => Z.divide_pos_le v0 v1 v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_Zdiv_lt_pos	100	0.082385	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 1 < v0) (v3 : 0 < v1) (v4 : (v0 | v1)) => let v5 : 0 < v0 := RelationClasses.transitivity eq_refl v2 in conj (let v6 : forall (v6 v7 : @Z) (v8 : 0 < v6) (v9 : 0 < v6 * v7), 0 < v7 := fun (v6 v7 : @Z) (v8 : 0 < v6) => match Z.mul_pos_cancel_l v6 v7 v8 as v9 in (_ /\ _) return (forall v10 : 0 < v6 * v7, 0 < v7) with | conj v9 v10 => (fun (v9 : forall v9 : 0 < v6 * v7, 0 < v7) (v10 : forall v10 : 0 < v7, 0 < v6 * v7) => v9) v9 v10 end in v6 v0 (v1 / v0) v5 (eq_ind v1 (fun v7 : @Z => 0 < v7) v3 (v0 * (v1 / v0)) (Zdivide_Zdiv_eq v0 v1 v5 v4))) (Z.div_lt v1 v0 v3 v2))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zmod_div_mod	100	0.203359	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 < v0) (v4 : 0 < v1) (v5 : (v0 | v1)) => match v5 as v6 in (ex _) return (v2 mod v0 = (v2 mod v1) mod v0) with | ex_intro _ v6 v7 => (fun (v6 : @Z) (v7 : v1 = v6 * v0) => (fun v8 : v2 = v1 * (v2 / v1) + v2 mod v1 => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive (v2 mod v0) ((v1 * (v2 / v1) + v2 mod v1) mod v0) (Morphisms.reflexive_proper (@BinIntDef.Z.modulo) v2 (v1 * (v2 / v1) + v2 mod v1) v8 v0 v0 (Morphisms.eq_proper_proxy v0)) ((v2 mod v1) mod v0) ((v2 mod v1) mod v0) (Morphisms.eq_proper_proxy ((v2 mod v1) mod v0))) (Z.div_mod v2 v1 (Z_lt_neq v4)) ((fun v8 : v1 = v6 * v0 => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive ((v1 * (v2 / v1) + v2 mod v1) mod v0) ((v6 * v0 * (v2 / v1) + v2 mod v1) mod v0) (Morphisms.reflexive_proper (@BinIntDef.Z.modulo) (v1 * (v2 / v1) + v2 mod v1) (v6 * v0 * (v2 / v1) + v2 mod v1) (Morphisms.reflexive_proper (@BinIntDef.Z.add) (v1 * (v2 / v1)) (v6 * v0 * (v2 / v1)) (Morphisms.reflexive_proper (@BinIntDef.Z.mul) v1 (v6 * v0) v8 (v2 / v1) (v2 / v1) (Morphisms.eq_proper_proxy (v2 / v1))) (v2 mod v1) (v2 mod v1) (Morphisms.eq_proper_proxy (v2 mod v1))) v0 v0 (Morphisms.eq_proper_proxy v0)) ((v2 mod v1) mod v0) ((v2 mod v1) mod v0) (Morphisms.eq_proper_proxy ((v2 mod v1) mod v0))) v7 (eq_ind_r (fun v8 : @Z => (v8 + v2 mod v1) mod v0 = (v2 mod v1) mod v0) (eq_ind_r (fun v8 : @Z => v8 mod v0 = (v2 mod v1) mod v0) (eq_ind_r (fun v8 : @Z => v8 = (v2 mod v1) mod v0) eq_refl (Z.mod_add (v2 mod v1) (v6 * (v2 / v1)) v0 (Z_lt_neq v3))) (Z.add_comm (v6 * (v2 / v1) * v0) (v2 mod v1))) (Z.mul_shuffle0 v6 v0 (v2 / v1))))) v6 v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zmod_divide_minus	100	0.121916	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 < v1) (v4 : v0 mod v1 = v2) => let v5 : forall (v5 v6 : @Z) (v7 : v6 <> 0) (v8 : v5 mod v6 = 0), (v6 | v5) := fun (v5 v6 : @Z) (v7 : v6 <> 0) => match Z.mod_divide v5 v6 v7 as v8 in (_ /\ _) return (forall v9 : v5 mod v6 = 0, (v6 | v5)) with | conj v8 v9 => (fun (v8 : forall v8 : v5 mod v6 = 0, (v6 | v5)) (v9 : forall v9 : (v6 | v5), v5 mod v6 = 0) => v8) v8 v9 end in v5 (v0 - v2) v1 (Z_lt_neq v3) (eq_ind_r (fun v6 : @Z => v6 = 0) (eq_ind_r (fun v6 : @Z => (v6 - v2 mod v1) mod v1 = 0) ((fun v6 : v2 mod v1 = v2 => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive ((v2 - v2 mod v1) mod v1) ((v2 mod v1 - v2 mod v1) mod v1) (Morphisms.reflexive_proper (@BinIntDef.Z.modulo) (v2 - v2 mod v1) (v2 mod v1 - v2 mod v1) (Morphisms.reflexive_proper (@BinIntDef.Z.sub) v2 (v2 mod v1) (RelationClasses.symmetry v6) (v2 mod v1) (v2 mod v1) (Morphisms.eq_proper_proxy (v2 mod v1))) v1 v1 (Morphisms.eq_proper_proxy v1)) 0 0 (Morphisms.eq_proper_proxy 0)) (Z.mod_small v2 v1 (eq_ind (v0 mod v1) (fun v6 : @Z => 0 <= v6 < v1) (Z.mod_pos_bound v0 v1 v3) v2 v4)) (eq_ind_r (fun v6 : @Z => v6 mod v1 = 0) (eq_ind_r (fun v6 : @Z => v6 = 0) eq_refl (Z.mod_0_l v1 (Z_lt_neq v3))) (Z.sub_diag (v2 mod v1)))) v4) (Zminus_mod v0 v2 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_mod_minus	100	0.125551	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= v2 < v1) => match v3 as v4 in (_ /\ _) return (forall v5 : (v1 | v0 - v2), v0 mod v1 = v2) with | conj v4 v5 => (fun (v4 : 0 <= v2) (v5 : v2 < v1) (v6 : (v1 | v0 - v2)) => let v7 : 0 < v1 := Z.Private_OrderTac.Tac.not_ge_lt ((fun v7 : v1 <= 0 => (fun v8 : 0 < v1 => (fun v9 : v1 < v1 => Z.Private_OrderTac.Tac.lt_irrefl v9) (Z.Private_OrderTac.Tac.le_lt_trans v7 v8)) (Z.Private_OrderTac.Tac.le_lt_trans v4 v5)) : ~ v1 <= 0) in let v8 : v1 <> 0 := Z_lt_neq v7 in let v9 : v0 - v2 + v2 = v0 := (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v10 : list (@Z) := (v0 :: v2 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEX (@Z) 1))) = @true)) : v0 - v2 + v2 = v0 in eq_ind (v0 - v2 + v2) (fun v10 : @Z => v10 mod v1 = v2) (eq_ind_r (fun v10 : @Z => v10 = v2) (eq_ind_r (fun v10 : @Z => (v10 + v2 mod v1) mod v1 = v2) (eq_ind_r (fun v10 : @Z => v10 mod v1 = v2) (eq_ind_r (fun v10 : @Z => v10 = v2) (Zmod_small v2 v1 (conj v4 v5)) (Z.mod_mod v2 v1 v8)) (Z.add_0_l (v2 mod v1))) (Zdivide_mod (v0 - v2) v1 v6)) (Z.add_mod (v0 - v2) v2 v1 v8)) v0 v9) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_sym	100	0.047385	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : Zis_gcd v0 v1 v2) => Zis_gcd_ind v0 v1 v2 (Zis_gcd v1 v0 v2) (fun (v4 : (v2 | v0)) (v5 : (v2 | v1)) (v6 : forall (v6 : @Z) (v7 : (v6 | v0)) (v8 : (v6 | v1)), (v6 | v2)) => Zis_gcd_intro v1 v0 v2 v5 v4 (fun (v7 : @Z) (v8 : (v7 | v1)) (v9 : (v7 | v0)) => v6 v7 v9 v8 : (v7 | v2))) v3)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_0	100	0.032728	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => Zis_gcd_intro v0 0 v0 (Z.divide_refl v0) (Z.divide_0_r v0) (fun (v1 : @Z) (v2 : (v1 | v0)) (v3 : (v1 | 0)) => v2))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_1	100	0.033825	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => Zis_gcd_intro v0 1 1 (Z.divide_1_l v0) (Z.divide_1_l 1) (fun (v1 : @Z) (v2 : (v1 | v0)) (v3 : (v1 | 1)) => v3))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_refl	100	0.028318	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => Zis_gcd_intro v0 v0 v0 (Z.divide_refl v0) (Z.divide_refl v0) (fun (v1 : @Z) (v2 v3 : (v1 | v0)) => v3))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_minus	100	0.047992	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : Zis_gcd v0 (- v1) v2) => Zis_gcd_ind v0 (- v1) v2 (Zis_gcd v1 v0 v2) (fun (v4 : (v2 | v0)) (v5 : (v2 | - v1)) (v6 : forall (v6 : @Z) (v7 : (v6 | v0)) (v8 : (v6 | - v1)), (v6 | v2)) => Zis_gcd_intro v1 v0 v2 (Zdivide_opp_l_rev v2 v1 (Zdivide_opp_l v2 v1 (Zdivide_opp_r_rev v2 v1 v5)) : (v2 | v1)) v4 (fun (v7 : @Z) (v8 : (v7 | v1)) (v9 : (v7 | v0)) => v6 v7 v9 (Zdivide_opp_l_rev v7 (- v1) (Zdivide_opp_l v7 (- v1) (Zdivide_opp_r v7 v1 v8))) : (v7 | v2))) v3)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_opp	100	0.051520	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : Zis_gcd v0 v1 v2) => Zis_gcd_ind v0 v1 v2 (Zis_gcd v1 v0 (- v2)) (fun (v4 : (v2 | v0)) (v5 : (v2 | v1)) (v6 : forall (v6 : @Z) (v7 : (v6 | v0)) (v8 : (v6 | v1)), (v6 | v2)) => Zis_gcd_intro v1 v0 (- v2) (Zdivide_opp_l_rev (- v2) v1 (Zdivide_opp_l (- v2) v1 (Zdivide_opp_l v2 v1 v5)) : (- v2 | v1)) (Zdivide_opp_l_rev (- v2) v0 (Zdivide_opp_l (- v2) v0 (Zdivide_opp_l v2 v0 v4)) : (- v2 | v0)) (fun (v7 : @Z) (v8 : (v7 | v1)) (v9 : (v7 | v0)) => Zdivide_opp_l_rev v7 (- v2) (Zdivide_opp_l v7 (- v2) (Zdivide_opp_r v7 v2 (v6 v7 v9 v8))) : (v7 | - v2))) v3)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_0_abs	100	0.034786	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => Zabs_ind (fun v1 : @Z => Zis_gcd 0 v0 v1) v0 (fun v1 : v0 >= 0 => Zis_gcd_sym v0 0 v0 (Zis_gcd_0 v0)) (fun v1 : v0 <= 0 => Zis_gcd_opp v0 0 v0 (Zis_gcd_0 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_unique	100	0.072777	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : Zis_gcd v0 v1 v2) => match v4 as v5 in (Zis_gcd _ _ _) return (forall v6 : Zis_gcd v0 v1 v3, v2 = v3 \/ v2 = - v3) with | Zis_gcd_intro _ _ _ v5 v6 v7 => (fun (v5 : (v2 | v0)) (v6 : (v2 | v1)) (v7 : forall (v7 : @Z) (v8 : (v7 | v0)) (v9 : (v7 | v1)), (v7 | v2)) (v8 : Zis_gcd v0 v1 v3) => match v8 as v9 in (Zis_gcd _ _ _) return (v2 = v3 \/ v2 = - v3) with | Zis_gcd_intro _ _ _ v9 v10 v11 => (fun (v9 : (v3 | v0)) (v10 : (v3 | v1)) (v11 : forall (v11 : @Z) (v12 : (v11 | v0)) (v13 : (v11 | v1)), (v11 | v3)) => let v12 : (v2 | v3) := v11 v2 v5 v6 in let v13 : (v3 | v2) := v7 v3 v9 v10 in Z.divide_antisym v2 v3 v12 v13) v9 v10 v11 end) v5 v6 v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_for_euclid	100	0.096812	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : Zis_gcd v1 (v0 - v3 * v1) v2) => Zis_gcd_ind v1 (v0 - v3 * v1) v2 (Zis_gcd v0 v1 v2) (fun (v5 : (v2 | v1)) (v6 : (v2 | v0 - v3 * v1)) (v7 : forall (v7 : @Z) (v8 : (v7 | v1)) (v9 : (v7 | v0 - v3 * v1)), (v7 | v2)) => Zis_gcd_intro v0 v1 v2 (let v8 : v0 - v3 * v1 + v3 * v1 = v0 := (let v8 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v9 : list (@Z) := (v0 :: v3 :: v1 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v9 v8 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v10 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v8 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEX (@Z) 1))) = @true)) : v0 - v3 * v1 + v3 * v1 = v0 in eq_ind (v0 - v3 * v1 + v3 * v1) (fun v9 : @Z => (v2 | v9)) (Zdivide_opp_l_rev v2 (v0 - v3 * v1 + v3 * v1) (Zdivide_opp_l v2 (v0 - v3 * v1 + v3 * v1) (Z.divide_add_r v2 (v0 - v3 * v1) (v3 * v1) v6 (Z.divide_mul_r v2 v3 v1 v5)))) v0 v8) v5 (fun (v8 : @Z) (v9 : (v8 | v0)) (v10 : (v8 | v1)) => v7 v8 v10 (Z.divide_sub_r v8 v0 (v3 * v1) v9 (Z.divide_mul_r v8 v3 v1 v10)) : (v8 | v2))) v4)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_for_euclid2	100	0.107503	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : Zis_gcd v3 v0 v1) => Zis_gcd_ind v3 v0 v1 (Zis_gcd v0 (v0 * v2 + v3) v1) (fun (v5 : (v1 | v3)) (v6 : (v1 | v0)) (v7 : forall (v7 : @Z) (v8 : (v7 | v3)) (v9 : (v7 | v0)), (v7 | v1)) => Zis_gcd_intro v0 (v0 * v2 + v3) v1 v6 (Zdivide_opp_l_rev v1 (v0 * v2 + v3) (Zdivide_opp_l v1 (v0 * v2 + v3) (Z.divide_add_r v1 (v0 * v2) v3 (Z.divide_mul_l v1 v0 v2 v6) v5)) : (v1 | v0 * v2 + v3)) (fun (v8 : @Z) (v9 : (v8 | v0)) (v10 : (v8 | v0 * v2 + v3)) => v7 v8 (let v11 : v0 * v2 + v3 - v0 * v2 = v3 := (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v12 : list (@Z) := (v0 :: v2 :: v3 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v12 v11 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 3) (@I) (eq_refl : (let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEX (@Z) 3))) = @true)) : v0 * v2 + v3 - v0 * v2 = v3 in eq_ind (v0 * v2 + v3 - v0 * v2) (fun v12 : @Z => (v8 | v12)) (Zdivide_opp_l_rev v8 (v0 * v2 + v3 - v0 * v2) (Zdivide_opp_l v8 (v0 * v2 + v3 - v0 * v2) (Z.divide_sub_r v8 (v0 * v2 + v3) (v0 * v2) v10 (Z.divide_mul_l v8 v0 v2 v9)))) v3 v11) v9)) v4)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.extended_euclid_algorithm.euclid_rec	100	0.473149	1	1	0	synth with cache (only 1: refine (fun (v0 : @Z) (v1 : 0 <= v0) => (Zlt_0_rec (fun v2 : @Z => forall (v3 : 0 <= v2) (v4 v5 v6 v7 v8 : @Z) (v9 : v4 * @a + v5 * @b = v6) (v10 : v7 * @a + v8 * @b = v2) (v11 : forall (v11 : @Z) (v12 : Zis_gcd v6 v2 v11), Zis_gcd (@a) (@b) v11), @Euclid) (fun (v2 : @Z) (v3 : forall (v3 : @Z) (v4 : 0 <= v3 < v2) (v5 : 0 <= v3) (v6 v7 v8 v9 v10 : @Z) (v11 : v6 * @a + v7 * @b = v8) (v12 : v9 * @a + v10 * @b = v3) (v13 : forall (v13 : @Z) (v14 : Zis_gcd v8 v3 v13), Zis_gcd (@a) (@b) v13), @Euclid) (v4 v5 : 0 <= v2) (v6 v7 v8 v9 v10 : @Z) (v11 : v6 * @a + v7 * @b = v8) (v12 : v9 * @a + v10 * @b = v2) (v13 : forall (v13 : @Z) (v14 : Zis_gcd v8 v2 v13), Zis_gcd (@a) (@b) v13) => let v14 : {v2 = 0} + {v2 <> 0} := Z_zerop v2 in match v14 as v15 in ({_} + {_}) return (@Euclid) with | left v15 => (fun v15 : v2 = 0 => Euclid_intro v6 v7 v8 v11 (v13 v8 (eq_ind_r (fun v16 : @Z => Zis_gcd v8 v16 v8) (Zis_gcd_0 v8) v15))) v15 | right v15 => (fun v15 : v2 <> 0 => let v16 : @Z := v8 / v2 in let v17 : 0 <= v8 - v16 * v2 < v2 := let v17 : v8 mod v2 = v8 - v16 * v2 := let v17 : v2 > 0 := Z.lt_gt 0 v2 (let v17 : forall (v17 v18 : @Z) (v19 : v17 <= v18 /\ v17 <> v18), v17 < v18 := fun v17 v18 : @Z => match Z.le_neq v17 v18 as v19 in (_ /\ _) return (forall v20 : v17 <= v18 /\ v17 <> v18, v17 < v18) with | conj v19 v20 => (fun (v19 : forall v19 : v17 < v18, v17 <= v18 /\ v17 <> v18) (v20 : forall v20 : v17 <= v18 /\ v17 <> v18, v17 < v18) => v20) v19 v20 end in v17 0 v2 (conj v5 (not_eq_sym v15))) in ((fun v18 : v8 = v2 * (v8 / v2) + v8 mod v2 => eq_ind_r (fun v19 : @Z => v8 mod v2 = v19 - v8 / v2 * v2) ((let v19 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v20 : list (@Z) := (v8 mod v2 :: v2 :: v8 / v2 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v20 v19 (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 2))) (@I) (eq_refl : (let v21 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v19 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 2))))) = @true)) : v8 mod v2 = v2 * (v8 / v2) + v8 mod v2 - v8 / v2 * v2) v18 : v8 mod v2 = v8 - v8 / v2 * v2) : forall v18 : v8 = v2 * (v8 / v2) + v8 mod v2, v8 mod v2 = v8 - v16 * v2) (Z_div_mod_eq v8 v2 v17) in eq_ind (v8 mod v2) (fun v18 : @Z => 0 <= v18 < v2) (Z_mod_lt v8 v2 (Z.lt_gt 0 v2 (let v18 : forall (v18 v19 : @Z) (v20 : v18 <= v19 /\ v18 <> v19), v18 < v19 := fun v18 v19 : @Z => match Z.le_neq v18 v19 as v20 in (_ /\ _) return (forall v21 : v18 <= v19 /\ v18 <> v19, v18 < v19) with | conj v20 v21 => (fun (v20 : forall v20 : v18 < v19, v18 <= v19 /\ v18 <> v19) (v21 : forall v21 : v18 <= v19 /\ v18 <> v19, v18 < v19) => v21) v20 v21 end in v18 0 v2 (conj v5 (not_eq_sym v15))))) (v8 - v16 * v2) v17 in v3 (v8 - v16 * v2) v17 (proj1 v17) v9 v10 v2 (v6 - v16 * v9) (v7 - v16 * v10) (and_ind (fun (v18 : 0 <= v8 - v16 * v2) (v19 : v8 - v16 * v2 < v2) => v12) v17) (let v18 : v6 * @a + v7 * @b - v16 * (v9 * @a + v10 * @b) = (v6 - v16 * v9) * @a + (v7 - v16 * v10) * @b := (let v18 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v19 : list (@Z) := (v6 :: @a :: v7 :: @b :: v16 :: v9 :: v10 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v19 v18 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 4))))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 6))) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 7))) (Ring_polynom.PEX (@Z) 4))) (@I) (eq_refl : (let v20 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v18 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 4)))))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 6))) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 7))) (Ring_polynom.PEX (@Z) 4))))) = @true)) : v6 * @a + v7 * @b - v16 * (v9 * @a + v10 * @b) = (v6 - v16 * v9) * @a + (v7 - v16 * v10) * @b in eq_ind (v6 * @a + v7 * @b - v16 * (v9 * @a + v10 * @b)) (fun v19 : @Z => v19 = v8 - v16 * v2) (eq_ind_r (fun v19 : @Z => v19 - v16 * (v9 * @a + v10 * @b) = v8 - v16 * v2) (eq_ind_r (fun v19 : @Z => v8 - v16 * v19 = v8 - v16 * v2) eq_refl v12) v11) ((v6 - v16 * v9) * @a + (v7 - v16 * v10) * @b) v18) (fun (v18 : @Z) (v19 : Zis_gcd v2 (v8 - v16 * v2) v18) => v13 v18 (Zis_gcd_for_euclid v8 v2 v18 v16 v19))) v15 end) v0 v1 : forall (v2 : 0 <= v0) (v3 v4 v5 v6 v7 : @Z) (v8 : v3 * @a + v4 * @b = v5) (v9 : v6 * @a + v7 * @b = v0) (v10 : forall (v10 : @Z) (v11 : Zis_gcd v5 v0 v10), Zis_gcd (@a) (@b) v10), @Euclid) v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.extended_euclid_algorithm.euclid	100	0.417185	1	1	0	synth with cache (only 1: refine match Z_le_gt_dec 0 (@b) as v0 in ({_} + {_}) return (@Euclid) with | left v0 => (fun v0 : 0 <= @b => euclid_rec (@b) v0 1 0 (@a) 0 1 ((let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : list (@Z) := (@a :: @b :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v2 v1 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 1) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEc 0) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 1) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEc 0) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEX (@Z) 1))) = @true)) : 1 * @a + 0 * @b = @a) ((let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : list (@Z) := (@a :: @b :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v2 v1 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEc 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 2) (@I) (eq_refl : (let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEc 1) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEX (@Z) 2))) = @true)) : 0 * @a + 1 * @b = @b) (fun (v1 : @Z) (v2 : Zis_gcd (@a) (@b) v1) => v2)) v0 | right v0 => (fun v0 : 0 > @b => euclid_rec (- @b) (let v1 : forall (v1 : @Z) (v2 : v1 <= 0), 0 <= - v1 := fun v1 : @Z => match Z.opp_nonneg_nonpos v1 as v2 in (_ /\ _) return (forall v3 : v1 <= 0, 0 <= - v1) with | conj v2 v3 => (fun (v2 : forall v2 : 0 <= - v1, v1 <= 0) (v3 : forall v3 : v1 <= 0, 0 <= - v1) => v3) v2 v3 end in v1 (@b) (Z.lt_le_incl (@b) 0 (Z.gt_lt 0 (@b) v0))) 1 0 (@a) 0 (-1) ((let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : list (@Z) := (@a :: @b :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v2 v1 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 1) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEc 0) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 1) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEc 0) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEX (@Z) 1))) = @true)) : 1 * @a + 0 * @b = @a) eq_refl (fun (v1 : @Z) (v2 : Zis_gcd (@a) (- @b) v1) => Zis_gcd_sym (@b) (@a) v1 (Zis_gcd_minus (@a) (@b) v1 v2))) v0 end).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_uniqueness_apart_sign	100	0.067248	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : Zis_gcd v0 v1 v2) => match v4 as v5 in (Zis_gcd _ _ _) return (forall v6 : Zis_gcd v0 v1 v3, v2 = v3 \/ v2 = - v3) with | Zis_gcd_intro _ _ _ v5 v6 v7 => (fun (v5 : (v2 | v0)) (v6 : (v2 | v1)) (v7 : forall (v7 : @Z) (v8 : (v7 | v0)) (v9 : (v7 | v1)), (v7 | v2)) (v8 : Zis_gcd v0 v1 v3) => match v8 as v9 in (Zis_gcd _ _ _) return (v2 = v3 \/ v2 = - v3) with | Zis_gcd_intro _ _ _ v9 v10 v11 => (fun (v9 : (v3 | v0)) (v10 : (v3 | v1)) (v11 : forall (v11 : @Z) (v12 : (v11 | v0)) (v13 : (v11 | v1)), (v11 | v3)) => let v12 : (v2 | v3) := v11 v2 v5 v6 in let v13 : (v3 | v2) := v7 v3 v9 v10 in Z.divide_antisym v2 v3 v12 v13) v9 v10 v11 end) v5 v6 v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_bezout	100	0.145379	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : Zis_gcd v0 v1 v2) => Euclid_ind v0 v1 (fun v4 : Euclid v0 v1 => Bezout v0 v1 v2) (fun (v4 v5 v6 : @Z) (v7 : v4 * v0 + v5 * v1 = v6) (v8 : Zis_gcd v0 v1 v6) => (fun v9 : v2 = v6 \/ v2 = - v6 => or_ind (fun v10 : v2 = v6 => Bezout_intro v0 v1 v2 v4 v5 (eq_ind_r (fun v11 : @Z => v4 * v0 + v5 * v1 = v11) v7 v10)) (fun v10 : v2 = - v6 => Bezout_intro v0 v1 v2 (- v4) (- v5) (eq_ind_r (fun v11 : @Z => - v4 * v0 + - v5 * v1 = v11) (eq_ind (v4 * v0 + v5 * v1) (fun v11 : @Z => - v4 * v0 + - v5 * v1 = - v11) ((let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v12 : list (@Z) := (v4 :: v0 :: v5 :: v1 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v12 v11 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4)))) (@I) (eq_refl : (let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4)))))) = @true)) : - v4 * v0 + - v5 * v1 = - (v4 * v0 + v5 * v1)) v6 v7) v10)) v9) (Zis_gcd_uniqueness_apart_sign v0 v1 v2 v6 v3 v8)) (euclid v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_mult	100	0.420915	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : Zis_gcd v0 v1 v3) => Zis_gcd_ind v0 v1 v3 (Zis_gcd (v2 * v0) (v2 * v1) (v2 * v3)) (fun (v5 : (v3 | v0)) (v6 : (v3 | v1)) (v7 : forall (v7 : @Z) (v8 : (v7 | v0)) (v9 : (v7 | v1)), (v7 | v3)) => Zis_gcd_intro (v2 * v0) (v2 * v1) (v2 * v3) (Zdivide_opp_l_rev (v2 * v3) (v2 * v0) (Zdivide_opp_l (v2 * v3) (v2 * v0) (Z.mul_divide_mono_l v3 v0 v2 v5))) (Zdivide_opp_l_rev (v2 * v3) (v2 * v1) (Zdivide_opp_l (v2 * v3) (v2 * v1) (Z.mul_divide_mono_l v3 v1 v2 v6))) (fun (v8 : @Z) (v9 : (v8 | v2 * v0)) (v10 : (v8 | v2 * v1)) => Bezout_ind v0 v1 v3 (v8 | v2 * v3) (fun (v11 v12 : @Z) (v13 : v11 * v0 + v12 * v1 = v3) => ex_ind (fun (v14 : @Z) (v15 : v2 * v0 = v14 * v8) => ex_ind (fun (v16 : @Z) (v17 : v2 * v1 = v16 * v8) => Zdivide_intro v8 (v2 * v3) (v11 * v14 + v12 * v16) (eq_ind (v11 * v0 + v12 * v1) (fun v18 : @Z => v2 * v18 = (v11 * v14 + v12 * v16) * v8) (let v18 : v11 * (v2 * v0) + v12 * (v2 * v1) = v2 * (v11 * v0 + v12 * v1) := (let v18 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v19 : list (@Z) := (v11 :: v2 :: v0 :: v12 :: v1 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v19 v18 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)))) (@I) (eq_refl : (let v20 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v18 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)))))) = @true)) : v11 * (v2 * v0) + v12 * (v2 * v1) = v2 * (v11 * v0 + v12 * v1) in eq_ind (v11 * (v2 * v0) + v12 * (v2 * v1)) (fun v19 : @Z => v19 = (v11 * v14 + v12 * v16) * v8) (eq_ind_r (fun v19 : @Z => v11 * v19 + v12 * (v2 * v1) = (v11 * v14 + v12 * v16) * v8) (eq_ind_r (fun v19 : @Z => v11 * (v14 * v8) + v12 * v19 = (v11 * v14 + v12 * v16) * v8) ((let v19 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v20 : list (@Z) := (v11 :: v14 :: v8 :: v12 :: v16 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v20 v19 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 3)) (@I) (eq_refl : (let v21 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v19 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 3))))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 3)))) = @true)) : v11 * (v14 * v8) + v12 * (v16 * v8) = (v11 * v14 + v12 * v16) * v8) v17) v15) (v2 * (v11 * v0 + v12 * v1)) v18) v3 v13)) v10) v9) (Zis_gcd_bezout v0 v1 v3 v4))) v4)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_bezout	100	0.039149	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Z => Zis_gcd_bezout v0 v1 1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.bezout_rel_prime	100	0.054387	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : Bezout v0 v1 1) => Bezout_ind v0 v1 1 (rel_prime v0 v1) (fun (v3 v4 : @Z) (v5 : v3 * v0 + v4 * v1 = 1) => Zis_gcd_intro v0 v1 1 (Z.divide_1_l v0) (Z.divide_1_l v1) (fun (v6 : @Z) (v7 : (v6 | v0)) (v8 : (v6 | v1)) => eq_ind (v3 * v0 + v4 * v1) (fun v9 : @Z => (v6 | v9)) (Zdivide_opp_l_rev v6 (v3 * v0 + v4 * v1) (Zdivide_opp_l v6 (v3 * v0 + v4 * v1) (Z.divide_add_r v6 (v3 * v0) (v4 * v1) (Z.divide_mul_r v6 v3 v0 v7) (Z.divide_mul_r v6 v4 v1 v8)))) 1 v5)) v2)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Gauss	100	0.187467	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : (v0 | v1 * v2)) (v4 : rel_prime v0 v1) => Bezout_ind v0 v1 1 (v0 | v2) (fun (v5 v6 : @Z) (v7 : v5 * v0 + v6 * v1 = 1) => let v8 : v2 * 1 = v2 := (let v8 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v9 : list (@Z) := (v2 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v9 v8 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1)) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v10 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v8 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEX (@Z) 1))) = @true)) : v2 * 1 = v2 in eq_ind (v2 * 1) (fun v9 : @Z => (v0 | v9)) (eq_ind (v5 * v0 + v6 * v1) (fun v9 : @Z => (v0 | v2 * v9)) (let v9 : v2 * v5 * v0 + v6 * (v1 * v2) = v2 * (v5 * v0 + v6 * v1) := (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v10 : list (@Z) := (v2 :: v5 :: v0 :: v6 :: v1 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 1)))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)))) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 1))))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)))))) = @true)) : v2 * v5 * v0 + v6 * (v1 * v2) = v2 * (v5 * v0 + v6 * v1) in eq_ind (v2 * v5 * v0 + v6 * (v1 * v2)) (fun v10 : @Z => (v0 | v10)) (Zdivide_opp_l_rev v0 (v2 * v5 * v0 + v6 * (v1 * v2)) (Zdivide_opp_l v0 (v2 * v5 * v0 + v6 * (v1 * v2)) (Z.divide_add_r v0 (v2 * v5 * v0) (v6 * (v1 * v2)) (Z.divide_factor_r v0 (v2 * v5)) (Z.divide_mul_r v0 v6 (v1 * v2) v3)))) (v2 * (v5 * v0 + v6 * v1)) v9) 1 v7) v2 v8) (rel_prime_bezout v0 v1 v4))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_mult	100	0.281719	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : rel_prime v0 v1) (v4 : rel_prime v0 v2) => Bezout_ind v0 v1 1 (rel_prime v0 (v1 * v2)) (fun (v5 v6 : @Z) (v7 : v5 * v0 + v6 * v1 = 1) => Bezout_ind v0 v2 1 (rel_prime v0 (v1 * v2)) (fun (v8 v9 : @Z) (v10 : v8 * v0 + v9 * v2 = 1) => bezout_rel_prime v0 (v1 * v2) (Bezout_intro v0 (v1 * v2) 1 (v5 * v8 * v0 + v9 * v2 * v5 + v8 * v6 * v1) (v6 * v9) (eq_ind (v5 * v0 + v6 * v1) (fun v11 : @Z => (v5 * v8 * v0 + v9 * v2 * v5 + v8 * v6 * v1) * v0 + v6 * v9 * (v1 * v2) = v11) (let v11 : (v5 * v0 + v6 * v1) * 1 = v5 * v0 + v6 * v1 := (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v12 : list (@Z) := (v5 :: v0 :: v6 :: v1 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v12 v11 (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEc 1)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))) (@I) (eq_refl : (let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEc 1))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))))) = @true)) : (v5 * v0 + v6 * v1) * 1 = v5 * v0 + v6 * v1 in eq_ind ((v5 * v0 + v6 * v1) * 1) (fun v12 : @Z => (v5 * v8 * v0 + v9 * v2 * v5 + v8 * v6 * v1) * v0 + v6 * v9 * (v1 * v2) = v12) (eq_ind (v8 * v0 + v9 * v2) (fun v12 : @Z => (v5 * v8 * v0 + v9 * v2 * v5 + v8 * v6 * v1) * v0 + v6 * v9 * (v1 * v2) = (v5 * v0 + v6 * v1) * v12) ((let v12 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v13 : list (@Z) := (v5 :: v8 :: v0 :: v9 :: v2 :: v6 :: v1 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v13 v12 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 1))) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 7))) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 5)))) (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEX (@Z) 7))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)))) (@I) (eq_refl : (let v14 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v12 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v14 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 1))) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 7))) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 5))))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v14 (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEX (@Z) 7))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5)))))) = @true)) : (v5 * v8 * v0 + v9 * v2 * v5 + v8 * v6 * v1) * v0 + v6 * v9 * (v1 * v2) = (v5 * v0 + v6 * v1) * (v8 * v0 + v9 * v2)) 1 v10) (v5 * v0 + v6 * v1) v11) 1 v7))) (rel_prime_bezout v0 v2 v4)) (rel_prime_bezout v0 v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_cross_prod	100	0.137245	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : rel_prime v0 v1) (v5 : rel_prime v2 v3) (v6 : v1 > 0) (v7 : v3 > 0) (v8 : v0 * v3 = v1 * v2) => or_ind (fun v9 : v1 = v3 => conj (let v10 : v0 * v3 = v3 * v2 := eq_ind v1 (fun v10 : @Z => v0 * v3 = v10 * v2) v8 v3 v9 in let v11 : v3 * v0 = v3 * v2 := eq_ind (v0 * v3) (fun v11 : @Z => v11 = v3 * v2) v10 (v3 * v0) (Z.mul_comm v0 v3) in Z.mul_reg_l v0 v2 v3 ((fun v12 : v3 = 0 => False_ind (@False) ((eq_ind_r (fun v13 : @Z => ~ v13 > 0) ((fun v13 : 0 > 0 => let v14 : @False := eq_ind (0 ?= 0) (fun v14 : @comparison => match v14 as v15 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v13 in False_ind (@False) v14) : ~ 0 > 0) v12 : forall v13 : v3 > 0, @False) v7)) : v3 <> 0) v11) v9) (fun v9 : v1 = - v3 => False_ind (v0 = v2 /\ v1 = v3) ((eq_ind_r (fun v10 : @Z => ~ v10 > 0) (Zgt_asym 0 (- v3) (Z.lt_gt (- v3) 0 (let v10 : forall (v10 v11 : @Z) (v12 : - v11 < - v10), v10 < v11 := fun v10 v11 : @Z => match Z.opp_lt_mono v10 v11 as v12 in (_ /\ _) return (forall v13 : - v11 < - v10, v10 < v11) with | conj v12 v13 => (fun (v12 : forall v12 : v10 < v11, - v11 < - v10) (v13 : forall v13 : - v11 < - v10, v10 < v11) => v13) v12 v13 end in v10 (- v3) 0 (eq_ind_r (fun v11 : @Z => - 0 < v11) (Z.gt_lt v3 (- 0) v7) (Z.opp_involutive v3))))) v9 : forall v10 : v1 > 0, @False) v6)) (Z.divide_antisym v1 v3 (Gauss v1 v0 v3 (eq_ind_r (fun v9 : @Z => (v1 | v9)) (Z.divide_factor_l v1 v2) v8) (Zis_gcd_sym v0 v1 1 v4)) (Gauss v3 v2 v1 (eq_ind_r (fun v9 : @Z => (v3 | v9)) (eq_ind (v0 * v3) (fun v9 : @Z => (v3 | v9)) (Z.divide_factor_r v3 v0) (v1 * v2) v8) (Z.mul_comm v2 v1)) (Zis_gcd_sym v2 v3 1 v5))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_rel_prime	100	0.307075	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : v1 > 0) (v4 : v2 >= 0) (v5 : Zis_gcd v0 v1 v2) => let v6 : v2 <> 0 := (fun v6 : v2 = 0 => Zis_gcd_ind v0 v1 v2 (@False) (fun (v7 : (v2 | v0)) (v8 : (v2 | v1)) (v9 : forall (v9 : @Z) (v10 : (v9 | v0)) (v11 : (v9 | v1)), (v9 | v2)) => ex_ind (fun (v10 : @Z) (v11 : v1 = v10 * v2) => let v12 : v1 = v10 * 0 := eq_ind v2 (fun v12 : @Z => v1 = v10 * v12) v11 0 v6 in eq_ind_r (fun v13 : @Z => forall (v14 : v13 > 0) (v15 : Zis_gcd v0 v13 v2) (v16 : (v2 | v13)) (v17 : forall (v17 : @Z) (v18 : (v17 | v0)) (v19 : (v17 | v13)), (v17 | v2)), @False) (fun (v13 : v10 * 0 > 0) (v14 : Zis_gcd v0 (v10 * 0) v2) (v15 : (v2 | v10 * 0)) (v16 : forall (v16 : @Z) (v17 : (v16 | v0)) (v18 : (v16 | v10 * 0)), (v16 | v2)) => False_ind (@False) ((eq_ind_r (fun v17 : @Z => ~ v17 > 0) ((fun v17 : 0 > 0 => let v18 : @False := eq_ind (0 ?= 0) (fun v18 : @comparison => match v18 as v19 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v17 in False_ind (@False) v18) : ~ 0 > 0) (Z.mul_0_r v10) : forall v17 : v10 * 0 > 0, @False) v13)) v12 v3 v5 v8 v9) v8) v5) : v2 <> 0 in let v7 : v2 > 0 := Z.lt_gt 0 v2 (let v7 : forall (v7 v8 : @Z) (v9 : v7 <= v8 /\ v7 <> v8), v7 < v8 := fun v7 v8 : @Z => match Z.le_neq v7 v8 as v9 in (_ /\ _) return (forall v10 : v7 <= v8 /\ v7 <> v8, v7 < v8) with | conj v9 v10 => (fun (v9 : forall v9 : v7 < v8, v7 <= v8 /\ v7 <> v8) (v10 : forall v10 : v7 <= v8 /\ v7 <> v8, v7 < v8) => v10) v9 v10 end in v7 0 v2 (conj (Z.ge_le v2 0 v4) (not_eq_sym v6))) in match v5 as v8 in (Zis_gcd _ _ _) return (Zis_gcd (v0 / v2) (v1 / v2) 1) with | Zis_gcd_intro _ _ _ v8 v9 v10 => (fun (v8 : (v2 | v0)) (v9 : (v2 | v1)) (v10 : forall (v10 : @Z) (v11 : (v10 | v0)) (v12 : (v10 | v1)), (v10 | v2)) => match v8 as v11 in (ex _) return (Zis_gcd (v0 / v2) (v1 / v2) 1) with | ex_intro _ v11 v12 => (fun (v11 : @Z) (v12 : v0 = v11 * v2) => match v9 as v13 in (ex _) return (Zis_gcd (v0 / v2) (v1 / v2) 1) with | ex_intro _ v13 v14 => (fun (v13 : @Z) (v14 : v1 = v13 * v2) => let v15 : v11 = v0 / v2 := eq_ind_r (fun v15 : @Z => v11 = v15 / v2) (eq_ind_r (fun v15 : @Z => v11 = v15) eq_refl (Z_div_mult v11 v2 v7)) v12 in eq_ind v11 (fun v16 : @Z => Zis_gcd v16 (v1 / v2) 1) (let v16 : v13 = v1 / v2 := eq_ind_r (fun v16 : @Z => v13 = v16 / v2) (eq_ind_r (fun v16 : @Z => v13 = v16) eq_refl (Z_div_mult v13 v2 v7)) v14 in eq_ind v13 (fun v17 : @Z => Zis_gcd v11 v17 1) (Zis_gcd_intro v11 v13 1 (ex_intro (fun v17 : @Z => v11 = v17 * 1) v11 (eq_ind_r (fun v17 : @Z => v11 = v17) eq_refl (Z.mul_1_r v11))) (ex_intro (fun v17 : @Z => v13 = v17 * 1) v13 (eq_ind_r (fun v17 : @Z => v13 = v17) eq_refl (Z.mul_1_r v13))) (fun (v17 : @Z) (v18 : (v17 | v11)) => match v18 as v19 in (ex _) return (forall v20 : (v17 | v13), (v17 | 1)) with | ex_intro _ v19 v20 => (fun (v19 : @Z) (v20 : v11 = v19 * v17) (v21 : (v17 | v13)) => match v21 as v22 in (ex _) return (v17 | 1) with | ex_intro _ v22 v23 => (fun (v22 : @Z) (v23 : v13 = v22 * v17) => let v24 : exists v24 : @Z, v2 = v24 * (v17 * v2) := v10 (v17 * v2) (ex_intro (fun v24 : @Z => v0 = v24 * (v17 * v2)) v19 (eq_ind_r (fun v24 : @Z => v0 = v24) (eq_ind v11 (fun v24 : @Z => v0 = v24 * v2) v12 (v19 * v17) v20) (Z.mul_assoc v19 v17 v2))) (ex_intro (fun v24 : @Z => v1 = v24 * (v17 * v2)) v22 (eq_ind_r (fun v24 : @Z => v1 = v24) (eq_ind v13 (fun v24 : @Z => v1 = v24 * v2) v14 (v22 * v17) v23) (Z.mul_assoc v22 v17 v2))) in match v24 as v25 in (ex _) return (v17 | 1) with | ex_intro _ v25 v26 => (fun (v25 : @Z) (v26 : v2 = v25 * (v17 * v2)) => let v27 : 1 * v2 = v2 := Z.mul_1_l v2 in let v28 : 1 * v2 = v25 * (v17 * (1 * v2)) := eq_ind_r (fun v28 : @Z => v28 = v25 * (v17 * v28)) v26 v27 in let v29 : 1 * v2 = v25 * v17 * (1 * v2) := eq_ind (v25 * (v17 * (1 * v2))) (fun v29 : @Z => 1 * v2 = v29) v28 (v25 * v17 * (1 * v2)) (Z.mul_assoc v25 v17 (1 * v2)) in let v30 : 1 * v2 = v25 * v17 * 1 * v2 := eq_ind (v25 * v17 * (1 * v2)) (fun v30 : @Z => 1 * v2 = v30) v29 (v25 * v17 * 1 * v2) (Z.mul_assoc (v25 * v17) 1 v2) in let v31 : 1 = v25 * v17 * 1 := Z.mul_reg_r 1 (v25 * v17 * 1) v2 v6 v30 in let v32 : 1 = v25 * v17 := eq_ind (v25 * v17 * 1) (fun v32 : @Z => 1 = v32) v31 (v25 * v17) (Z.mul_1_r (v25 * v17)) in ex_intro (fun v33 : @Z => 1 = v33 * v17) v25 v32) v25 v26 end) v22 v23 end) v19 v20 end)) (v1 / v2) v16) (v0 / v2) v15) v13 v14 end) v11 v12 end) v8 v9 v10 end : rel_prime (v0 / v2) (v1 / v2))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_sym	100	0.028271	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : rel_prime v0 v1) => Zis_gcd_sym v0 v1 1 v2 : rel_prime v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_div	100	0.072260	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : rel_prime v0 v1) (v4 : (v2 | v0)) => match v4 as v5 in (ex _) return (rel_prime v2 v1) with | ex_intro _ v5 v6 => (fun (v5 : @Z) (v6 : v0 = v5 * v2) => eq_ind_r (fun v7 : @Z => forall v8 : rel_prime v7 v1, rel_prime v2 v1) (fun v7 : rel_prime (v5 * v2) v1 => let v8 : rel_prime v2 v1 := match v7 as v8 in (Zis_gcd _ _ _) return (rel_prime v2 v1) with | Zis_gcd_intro _ _ _ v8 v9 v10 => (fun (v8 : (1 | v5 * v2)) (v9 : (1 | v1)) (v10 : forall (v10 : @Z) (v11 : (v10 | v5 * v2)) (v12 : (v10 | v1)), (v10 | 1)) => (fun (v11 : (1 | v5 * v2)) (v12 : (1 | v1)) (v13 : forall (v13 : @Z) (v14 : (v13 | v5 * v2)) (v15 : (v13 | v1)), (v13 | 1)) => Zis_gcd_intro v2 v1 1 (Z.divide_1_l v2) (Z.divide_1_l v1) (fun (v14 : @Z) (v15 : (v14 | v2)) (v16 : (v14 | v1)) => v13 v14 (Z.divide_mul_r v14 v5 v2 v15) v16) : rel_prime v2 v1) v8 v9 v10) v8 v9 v10 end in v8) v6 v3) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_1	100	0.039127	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => Zis_gcd_intro 1 v0 1 (ex_intro (fun v1 : @Z => 1 = v1 * 1) 1 eq_refl) (ex_intro (fun v1 : @Z => v0 = v1 * 1) v0 (eq_ind_r (fun v1 : @Z => v0 = v1) eq_refl (Z.mul_1_r v0))) (fun (v1 : @Z) (v2 : (v1 | 1)) (v3 : (v1 | v0)) => v2) : rel_prime 1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.not_rel_prime_0	100	0.121226	1	1	0	synth with cache (only 1: refine (fun (v0 : @Z) (v1 : 1 < v0) => (fun v2 : rel_prime 0 v0 => False_ind (@False) (((fun v3 : v0 = 1 \/ v0 = -1 => match v3 as v4 in (_ \/ _) return (@False) with | or_introl v4 => (fun v4 : v0 = 1 => eq_ind_r (fun v5 : @Z => forall (v6 : 1 < v5) (v7 : rel_prime 0 v5), @False) (fun (v5 : 1 < 1) (v6 : rel_prime 0 1) => False_ind (@False) ((((fun v7 : 1 < 1 => let v8 : @False := eq_ind (1 ?= 1) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) : ~ 1 < 1) : forall v7 : 1 < 1, @False) v5)) v4 v1 v2) v4 | or_intror v4 => (fun v4 : v0 = -1 => eq_ind_r (fun v5 : @Z => forall (v6 : 1 < v5) (v7 : rel_prime 0 v5), @False) (fun (v5 : 1 < -1) (v6 : rel_prime 0 (-1)) => False_ind (@False) ((((fun v7 : 1 < -1 => let v8 : @False := eq_ind (1 ?= -1) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) : ~ 1 < -1) : forall v7 : 1 < -1, @False) v5)) v4 v1 v2) v4 end) : ~ (v0 = 1 \/ v0 = -1)) match Zis_gcd_unique 0 v0 v0 1 (Zis_gcd_intro 0 v0 v0 (ex_intro (fun v3 : @Z => 0 = v3 * v0) 0 eq_refl) (ex_intro (fun v3 : @Z => v0 = v3 * v0) 1 (eq_ind_r (fun v3 : @Z => v0 = v3) eq_refl (Z.mul_1_l v0))) (fun (v3 : @Z) (v4 : (v3 | 0)) (v5 : (v3 | v0)) => v5)) v2 as v3 in (_ \/ _) return (v0 = 1 \/ v0 = -1) with | or_introl v3 => (fun v3 : v0 = 1 => or_introl v3) v3 | or_intror v3 => (fun v3 : v0 = - (1) => or_intror v3) v3 end)) : ~ rel_prime 0 v0)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_mod	100	0.188509	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 0 < v1) (v3 : rel_prime v0 v1) => let v4 : Bezout v0 v1 1 := rel_prime_bezout v0 v1 v3 in let v5 : rel_prime (v0 mod v1) v1 := match v4 as v5 in (Bezout _ _ _) return (rel_prime (v0 mod v1) v1) with | Bezout_intro _ _ _ v5 v6 v7 => (fun (v5 v6 : @Z) (v7 : v5 * v0 + v6 * v1 = 1) => (fun v8 : v5 * v0 + v6 * v1 = 1 => bezout_rel_prime (v0 mod v1) v1 (Bezout_intro (v0 mod v1) v1 1 v5 (v6 + v5 * (v0 / v1)) (eq_ind (v5 * v0 + v6 * v1) (fun v9 : @Z => v5 * (v0 mod v1) + (v6 + v5 * (v0 / v1)) * v1 = v9) (eq_ind_r (fun v9 : @Z => v5 * (v0 mod v1) + (v6 + v5 * (v0 / v1)) * v1 = v5 * v9 + v6 * v1) ((let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v10 : list (@Z) := (v5 :: v0 mod v1 :: v6 :: v0 / v1 :: v1 :: nil)%list in Zr_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 5))) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEX (@Z) 5)))) (Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 5))))) = @true)) : v5 * (v0 mod v1) + (v6 + v5 * (v0 / v1)) * v1 = v5 * (v1 * (v0 / v1) + v0 mod v1) + v6 * v1) (Z_div_mod_eq v0 v1 (Z.lt_gt 0 v1 v2)) : v5 * (v0 mod v1) + (v6 + v5 * (v0 / v1)) * v1 = v5 * v0 + v6 * v1) 1 v8))) v7) v5 v6 v7 end in v5)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_mod_rev	100	0.048785	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 0 < v1) (v3 : rel_prime (v0 mod v1) v1) => eq_ind_r (fun v4 : @Z => rel_prime v4 v1) (Zis_gcd_sym v1 (v1 * (v0 / v1) + v0 mod v1) 1 (Zis_gcd_for_euclid2 v1 1 (v0 / v1) (v0 mod v1) v3) : rel_prime (v1 * (v0 / v1) + v0 mod v1) v1) (Z_div_mod_eq v0 v1 (Z.lt_gt 0 v1 v2)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zrel_prime_neq_mod_0	100	0.053359	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 1 < v1) (v3 : rel_prime v0 v1) => (fun v4 : v0 mod v1 = 0 => match not_rel_prime_0 v1 v2 (eq_ind (v0 mod v1) (fun v5 : @Z => rel_prime v5 v1) (rel_prime_mod v0 v1 (RelationClasses.transitivity eq_refl v2) v3) 0 v4) as v5 in False return (@False) with end) : v0 mod v1 <> 0)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_divisors	100	1.110085	1	1
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_rel_prime	100	0.086340	1	1	0	synth with cache (only 1: refine (fun (v0 : @Z) (v1 : prime v0) (v2 : @Z) (v3 : ~ (v0 | v2)) => Zis_gcd_intro v0 v2 1 (Z.divide_1_l v0) (Z.divide_1_l v2) (fun (v4 : @Z) (v5 : (v4 | v0)) (v6 : (v4 | v2)) => let v7 : v4 = -1 \/ v4 = 1 \/ v4 = v0 \/ v4 = - v0 := prime_divisors v0 v1 v4 v5 in or_ind (fun v8 : v4 = -1 => eq_ind_r (fun v9 : @Z => forall v10 : (v9 | v2), (v9 | 1)) (fun v9 : (-1 | v2) => Zdivide_opp_l_rev (-1) 1 (Z.divide_1_l 1)) v8 v6) (fun v8 : v4 = 1 \/ v4 = v0 \/ v4 = - v0 => or_ind (fun v9 : v4 = 1 => eq_ind_r (fun v10 : @Z => forall v11 : (v10 | v2), (v10 | 1)) (fun v10 : (1 | v2) => Z.divide_1_l 1) v9 v6) (fun v9 : v4 = v0 \/ v4 = - v0 => or_ind (fun v10 : v4 = v0 => eq_ind_r (fun v11 : @Z => forall v12 : (v11 | v2), (v11 | 1)) (fun v11 : (v0 | v2) => False_ind (v0 | 1) (v3 v11)) v10 v6) (fun v10 : v4 = - v0 => eq_ind_r (fun v11 : @Z => forall v12 : (v11 | v2), (v11 | 1)) (fun v11 : (- v0 | v2) => False_ind (- v0 | 1) (((fun v12 : (v0 | v2) => let v13 : @False := v3 v12 in False_ind (@False) v13) : ~ (v0 | v2)) (Zdivide_opp_l_rev v0 v2 v11 : (v0 | v2)))) v10 v6) v9) v8) v7))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_le_prime	100	0.188675	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : prime v1) (v3 : 1 <= v0 < v1) => match v3 as v4 in (_ /\ _) return (rel_prime v0 v1) with | conj v4 v5 => (fun (v4 : 1 <= v0) (v5 : v0 < v1) => rel_prime_sym v1 v0 (prime_rel_prime v1 v2 v0 ((fun v6 : (v1 | v0) => match v6 as v7 in (ex _) return (@False) with | ex_intro _ v7 v8 => (fun (v7 : @Z) (v8 : v0 = v7 * v1) => eq_ind_r (fun v9 : @Z => forall (v10 : 1 <= v9) (v11 : v9 < v1), @False) (fun (v9 : 1 <= v7 * v1) (v10 : v7 * v1 < v1) => match v2 as v11 in (prime _) return (@False) with | prime_intro _ v11 v12 => (fun (v11 : 1 < v1) (v12 : forall (v12 : @Z) (v13 : 1 <= v12 < v1), rel_prime v12 v1) => False_ind (@False) ((Zle_not_lt v1 (v7 * v1) ((fun v13 : 1 * v1 = v1 => Morphisms.subrelation_proper (@Z.Proper_instance_0) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl eq) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl eq) (@Morphisms.iff_flip_impl_subrelation))) v1 (1 * v1) (RelationClasses.symmetry v13) (v7 * v1) (v7 * v1) (Morphisms.eq_proper_proxy (v7 * v1))) (Z.mul_1_l v1) (Zmult_le_compat_r 1 v7 v1 (Zlt_le_succ 0 v7 (Zmult_lt_0_reg_r v1 v7 (let v13 : forall (v13 v14 : @Z) (v15 : BinIntDef.Z.succ v13 <= v14), v13 < v14 := fun v13 v14 : @Z => match Z.le_succ_l v13 v14 as v15 in (_ /\ _) return (forall v16 : BinIntDef.Z.succ v13 <= v14, v13 < v14) with | conj v15 v16 => (fun (v15 : forall v15 : BinIntDef.Z.succ v13 <= v14, v13 < v14) (v16 : forall v16 : v13 < v14, BinIntDef.Z.succ v13 <= v14) => v15) v15 v16 end in v13 0 v1 (Z.lt_le_incl (BinIntDef.Z.succ 0) v1 v11)) (let v13 : forall (v13 v14 : @Z) (v15 : BinIntDef.Z.succ v13 <= v14), v13 < v14 := fun v13 v14 : @Z => match Z.le_succ_l v13 v14 as v15 in (_ /\ _) return (forall v16 : BinIntDef.Z.succ v13 <= v14, v13 < v14) with | conj v15 v16 => (fun (v15 : forall v15 : BinIntDef.Z.succ v13 <= v14, v13 < v14) (v16 : forall v16 : v13 < v14, BinIntDef.Z.succ v13 <= v14) => v15) v15 v16 end in v13 0 (v7 * v1) v9))) (Z.lt_le_incl 0 v1 (let v13 : forall (v13 v14 : @Z) (v15 : BinIntDef.Z.succ v13 <= v14), v13 < v14 := fun v13 v14 : @Z => match Z.le_succ_l v13 v14 as v15 in (_ /\ _) return (forall v16 : BinIntDef.Z.succ v13 <= v14, v13 < v14) with | conj v15 v16 => (fun (v15 : forall v15 : BinIntDef.Z.succ v13 <= v14, v13 < v14) (v16 : forall v16 : v13 < v14, BinIntDef.Z.succ v13 <= v14) => v15) v15 v16 end in v13 0 v1 (Z.lt_le_incl (BinIntDef.Z.succ 0) v1 v11))))) : forall v13 : v7 * v1 < v1, @False) v10)) v11 v12 end) v8 v4 v5) v7 v8 end) : ~ (v1 | v0)))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_mult	100	0.062471	1	1	0	synth with cache (only 1: refine (fun (v0 : @Z) (v1 : prime v0) => prime_ind v0 (forall (v2 v3 : @Z) (v4 : (v0 | v2 * v3)), (v0 | v2) \/ (v0 | v3)) (fun (v2 : 1 < v0) (v3 : forall (v3 : @Z) (v4 : 1 <= v3 < v0), rel_prime v3 v0) (v4 v5 : @Z) (v6 : (v0 | v4 * v5)) => match Zdivide_dec v0 v4 as v7 in ({_} + {_}) return ((v0 | v4) \/ (v0 | v5)) with | left v7 => (fun v7 : (v0 | v4) => or_introl v7) v7 | right v7 => (fun v7 : ~ (v0 | v4) => or_intror (Gauss v0 v4 v5 v6 (prime_rel_prime v0 v1 v4 v7))) v7 end) v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.not_prime_0	100	0.112202	1	1	0	synth with cache (only 1: refine ((fun v0 : prime 0 => match prime_divisors 0 v0 2 (Z.divide_0_r 2) as v1 in (_ \/ _) return (@False) with | or_introl v1 => (fun v1 : 2 = -1 => let v2 : @False := eq_ind 2 (fun v2 : @Z => match v2 as v3 in Z return Prop with | 0 => @False | Z.pos v3 => (fun v3 : @positive => @True) v3 | Z.neg v3 => (fun v3 : @positive => @False) v3 end) (@I) (-1) v1 in False_ind (@False) v2) v1 | or_intror v1 => (fun v1 : 2 = 1 \/ 2 = 0 \/ 2 = - 0 => or_ind (fun v2 : 2 = 1 => let v3 : @False := eq_ind 2 (fun v3 : @Z => match v3 as v4 in Z return Prop with | 0 => @False | Z.pos v4 => (fun v4 : @positive => match v4 as v5 in positive return Prop with | (v5~1)%positive => (fun v5 : @positive => @False) v5 | (v5~0)%positive => (fun v5 : @positive => @True) v5 | 1%positive => @False end) v4 | Z.neg v4 => (fun v4 : @positive => @False) v4 end) (@I) 1 v2 in False_ind (@False) v3) (fun v2 : 2 = 0 \/ 2 = - 0 => or_ind (fun v3 : 2 = 0 => let v4 : @False := eq_ind 2 (fun v4 : @Z => match v4 as v5 in Z return Prop with | 0 => @False | Z.pos v5 => (fun v5 : @positive => @True) v5 | Z.neg v5 => (fun v5 : @positive => @False) v5 end) (@I) 0 v3 in False_ind (@False) v4) (fun v3 : 2 = - 0 => let v4 : @False := eq_ind 2 (fun v4 : @Z => match v4 as v5 in Z return Prop with | 0 => @False | Z.pos v5 => (fun v5 : @positive => @True) v5 | Z.neg v5 => (fun v5 : @positive => @False) v5 end) (@I) (- 0) v3 in False_ind (@False) v4) v2) v1) v1 end) : ~ prime 0)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.not_prime_1	100	0.057505	1	1	0	synth with cache (only 1: refine ((fun v0 : prime 1 => False_ind (@False) (((fun v1 : 1 < 1 => let v2 : @False := eq_ind (1 ?= 1) (fun v2 : @comparison => match v2 as v3 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v1 in False_ind (@False) v2) : ~ 1 < 1) (let v1 : 1 < 1 := match v0 as v1 in (prime _) return (1 < 1) with | prime_intro _ v1 v2 => (fun (v1 : 1 < 1) (v2 : forall (v2 : @Z) (v3 : 1 <= v2 < 1), rel_prime v2 1) => (fun (v3 : 1 < 1) (v4 : forall (v4 : @Z) (v5 : 1 <= v4 < 1), rel_prime v4 1) => v3) v1 v2) v1 v2 end in v1))) : ~ prime 1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_2	100	0.084864	1	1	0	synth with cache (only 1: refine (prime_intro 2 (eq_refl : 1 < 2) (fun (v0 : @Z) (v1 : 1 <= v0 < 2) => match v1 as v2 in (_ /\ _) return (rel_prime v0 2) with | conj v2 v3 => (fun (v2 : 1 <= v0) (v3 : v0 < 2) => match (fun v4 : 1 <= v0 <-> 1 < v0 \/ 1 = v0 => Morphisms.iff_impl_subrelation (1 <= v0) (1 < v0 \/ 1 = v0) v4) (Z.lt_eq_cases 1 v0) v2 as v4 in (_ \/ _) return (rel_prime v0 2) with | or_introl v4 => (fun v4 : 1 < v0 => False_ind (rel_prime v0 2) ((Zle_not_lt 2 v0 (Zlt_le_succ 1 v0 v4) : forall v5 : v0 < 2, @False) v3)) v4 | or_intror v4 => (fun v4 : 1 = v0 => eq_ind 1 (fun v5 : @Z => forall v6 : v5 < 2, rel_prime v5 2) (fun v5 : 1 < 2 => Zis_gcd_intro 1 2 1 (Z.divide_1_l 1) (Z.divide_1_l 2) (fun (v6 : @Z) (v7 : (v6 | 1)) (v8 : (v6 | 2)) => v7)) v0 v4 v3) v4 end) v2 v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_3	100	0.476061	1	1	0	synth with cache (only 1: refine (prime_intro 3 (eq_refl : 1 < 3) (fun (v0 : @Z) (v1 : 1 <= v0 < 3) => match v1 as v2 in (_ /\ _) return (rel_prime v0 3) with | conj v2 v3 => (fun (v2 : 1 <= v0) (v3 : v0 < 3) => match (fun v4 : 1 <= v0 <-> 1 < v0 \/ 1 = v0 => Morphisms.iff_impl_subrelation (1 <= v0) (1 < v0 \/ 1 = v0) v4) (Z.lt_eq_cases 1 v0) v2 as v4 in (_ \/ _) return (rel_prime v0 3) with | or_introl v4 => (fun v4 : 1 < v0 => let v5 : 2 = v0 := Z.le_antisymm 2 v0 (Zlt_le_succ 1 v0 v4) (let v5 : forall v5 : v0 < 3, v0 <= BinIntDef.Z.pred 3 := match Z.lt_le_pred v0 3 as v5 in (_ /\ _) return (forall v6 : v0 < 3, v0 <= BinIntDef.Z.pred 3) with | conj v5 v6 => (fun (v5 : forall v5 : v0 < 3, v0 <= BinIntDef.Z.pred 3) (v6 : forall v6 : v0 <= BinIntDef.Z.pred 3, v0 < 3) => v5) v5 v6 end in v5 v3) in eq_ind 2 (fun v6 : @Z => rel_prime v6 3) (Zis_gcd_intro 2 3 1 (Z.divide_1_l 2) (Z.divide_1_l 3) (fun (v6 : @Z) (v7 : (v6 | 2)) => match v7 as v8 in (ex _) return (forall v9 : (v6 | 3), (v6 | 1)) with | ex_intro _ v8 v9 => (fun (v8 : @Z) (v9 : 2 = v8 * v6) (v10 : (v6 | 3)) => match v10 as v11 in (ex _) return (v6 | 1) with | ex_intro _ v11 v12 => (fun (v11 : @Z) (v12 : 3 = v11 * v6) => ex_intro (fun v13 : @Z => 1 = v13 * v6) (v11 - v8) (let v13 : list (@Z) := (1 :: (v11 - v8) * v6 :: nil)%list in (((fun v14 : v13 = (1 :: (v11 - v8) * v6 :: nil)%list => let v15 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v16 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v17 : Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v15 = v16 := eq_refl : Ring_polynom.mk_monpol_list 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v15 = v16 in let v18 : forall (v18 : Ring_polynom.PExpr (@Z)) (v19 : Ring_polynom.Pol (@Z)) (v20 : Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v16 v18 = v19), Ring_polynom.PEeval 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (v11 :: v8 :: v6 :: nil) v18 = Ring_polynom.Pphi_pow 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0 1 (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) (v11 :: v8 :: v6 :: nil) v19 := Zr_ring_lemma2 (@ring_subst_niter) v15 (v11 :: v8 :: v6 :: nil) (@I) v17 in let v19 : Ring_polynom.Pol (@Z) := Ring_polynom.Pc 1 in let v20 : Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v16 (Ring_polynom.PEc 1) = v19 := eq_refl : Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v16 (Ring_polynom.PEc 1) = v19 in let v21 : Ring_polynom.PEeval 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (v11 :: v8 :: v6 :: nil) (Ring_polynom.PEc 1) = Ring_polynom.Pphi_pow 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0 1 (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) (v11 :: v8 :: v6 :: nil) v19 := v18 (Ring_polynom.PEc 1) v19 v20 in let v22 : Ring_polynom.Pol (@Z) := Ring_polynom.PX (Ring_polynom.Pinj 2 (Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0))) 1 (Ring_polynom.PX (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc (-1)) 1 (Ring_polynom.Pc 0))) 1 (Ring_polynom.Pc 0)) in let v23 : Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v16 (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) = v22 := eq_refl : Ring_polynom.norm_subst 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v16 (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) = v22 in let v24 : Ring_polynom.PEeval 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (v11 :: v8 :: v6 :: nil) (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) = Ring_polynom.Pphi_pow 0 1 (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0 1 (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) (v11 :: v8 :: v6 :: nil) v22 := v18 (Ring_polynom.PEmul (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) v22 v23 in eq_ind_r (fun v25 : @Z => 1 = v25) (eq_ind 2 (fun v25 : @Z => 1 = v11 * v6 - v25) (eq_ind 3 (fun v25 : @Z => 1 = v25 - 2) eq_refl (v11 * v6) v12) (v8 * v6) v9) v24) : forall v14 : v13 = (1 :: (v11 - v8) * v6 :: nil)%list, 1 = (v11 - v8) * v6) : forall v14 : v13 = v13, 1 = (v11 - v8) * v6) eq_refl)) v11 v12 end) v8 v9 end)) v0 v5) v4 | or_intror v4 => (fun v4 : 1 = v0 => let v5 : 1 = v0 := v4 in eq_ind 1 (fun v6 : @Z => rel_prime v6 3) (Zis_gcd_intro 1 3 1 (Z.divide_1_l 1) (Z.divide_1_l 3) (fun (v6 : @Z) (v7 : (v6 | 1)) (v8 : (v6 | 3)) => v7)) v0 v5) v4 end) v2 v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_ge_2	100	0.042681	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @Z) (v1 : prime v0) => match v1 as v2 in (prime _) return (2 <= v0) with | prime_intro _ v2 v3 => (fun (v2 : 1 < v0) (v3 : forall (v3 : @Z) (v4 : 1 <= v3 < v0), rel_prime v3 v0) => Zlt_le_succ 1 v0 v2) v2 v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Z_0_1_more	100	0.109005	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @Z) (v1 : 0 <= v0) => match (fun v2 : 0 <= v0 <-> 0 < v0 \/ 0 = v0 => Morphisms.iff_impl_subrelation (0 <= v0) (0 < v0 \/ 0 = v0) v2) (Z.lt_eq_cases 0 v0) v1 as v2 in (_ \/ _) return (v0 = 0 \/ v0 = 1 \/ 1 < v0) with | or_introl v2 => (fun v2 : 0 < v0 => let v3 : forall (v3 v4 : @Z) (v5 : v3 < v4), BinIntDef.Z.succ v3 <= v4 := fun v3 v4 : @Z => match Z.le_succ_l v3 v4 as v5 in (_ /\ _) return (forall v6 : v3 < v4, BinIntDef.Z.succ v3 <= v4) with | conj v5 v6 => (fun (v5 : forall v5 : BinIntDef.Z.succ v3 <= v4, v3 < v4) (v6 : forall v6 : v3 < v4, BinIntDef.Z.succ v3 <= v4) => v6) v5 v6 end in let v4 : BinIntDef.Z.succ 0 <= v0 := v3 0 v0 v2 in match (fun v5 : 1 <= v0 <-> 1 < v0 \/ 1 = v0 => Morphisms.iff_impl_subrelation (1 <= v0) (1 < v0 \/ 1 = v0) v5) (Z.lt_eq_cases 1 v0) v4 as v5 in (_ \/ _) return (v0 = 0 \/ v0 = 1 \/ 1 < v0) with | or_introl v5 => (fun v5 : 1 < v0 => or_intror (or_intror v5)) v5 | or_intror v5 => (fun v5 : 1 = v0 => or_intror (or_introl (eq_sym v5))) v5 end) v2 | or_intror v2 => (fun v2 : 0 = v0 => or_introl (eq_sym v2)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_alt	100	0.282977	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => conj (fun v1 : prime' v0 => match v1 as v2 in (_ /\ _) return (prime v0) with | conj v2 v3 => (fun (v2 : 1 < v0) (v3 : forall (v3 : @Z) (v4 : 1 < v3 < v0), ~ (v3 | v0)) => prime_intro v0 v2 (fun (v4 : @Z) (v5 : 1 <= v4 < v0) => Zis_gcd_intro v4 v0 1 (Z.divide_1_l v4) (Z.divide_1_l v0) (fun (v6 : @Z) (v7 : (v6 | v4)) (v8 : (v6 | v0)) => (fun v9 : (BinIntDef.Z.abs v6 | 1) <-> (v6 | 1) => Morphisms.iff_flip_impl_subrelation (v6 | 1) (BinIntDef.Z.abs v6 | 1) (RelationClasses.symmetry v9)) (Z.divide_abs_l v6 1) (let v9 : 0 <= BinIntDef.Z.abs v6 := Z.abs_nonneg v6 in let v10 : @Z := BinIntDef.Z.abs v6 in let v11 : v10 = 0 \/ v10 = 1 \/ 1 < v10 := Z_0_1_more v10 v9 in match v11 as v12 in (_ \/ _) return (v10 | 1) with | or_introl v12 => (fun v12 : v10 = 0 => eq_ind_r (fun v13 : @Z => forall (v14 : (v13 | v4)) (v15 : (v13 | v0)) (v16 : 0 <= v13), (v13 | 1)) (fun (v13 : (0 | v4)) (v14 : (0 | v0)) (v15 : 0 <= 0) => False_ind (0 | 1) (let v16 : v4 = 0 := Z.divide_0_l v4 v13 in False_ind (@False) (eq_ind_r (fun v17 : @Z => ~ 1 <= v17) ((fun v17 : 1 <= 0 => v17 eq_refl) : ~ 1 <= 0) v16 (and_ind (fun (v17 : 1 <= v4) (v18 : v4 < v0) => v17) v5)))) v12 ((fun v13 : (BinIntDef.Z.abs v6 | v4) <-> (v6 | v4) => Morphisms.iff_impl_subrelation (v6 | v4) (BinIntDef.Z.abs v6 | v4) (RelationClasses.symmetry v13)) (Z.divide_abs_l v6 v4) v7) ((fun v13 : (BinIntDef.Z.abs v6 | v0) <-> (v6 | v0) => Morphisms.iff_impl_subrelation (v6 | v0) (BinIntDef.Z.abs v6 | v0) (RelationClasses.symmetry v13)) (Z.divide_abs_l v6 v0) v8) v9) v12 | or_intror v12 => (fun v12 : v10 = 1 \/ 1 < v10 => match v12 as v13 in (_ \/ _) return (v10 | 1) with | or_introl v13 => (fun v13 : v10 = 1 => eq_ind_r (fun v14 : @Z => forall (v15 : (v14 | v4)) (v16 : (v14 | v0)) (v17 : 0 <= v14), (v14 | 1)) (fun (v14 : (1 | v4)) (v15 : (1 | v0)) (v16 : 0 <= 1) => ex_intro (fun v17 : @Z => 1 = v17 * 1) 1 eq_refl) v13 ((fun v14 : (BinIntDef.Z.abs v6 | v4) <-> (v6 | v4) => Morphisms.iff_impl_subrelation (v6 | v4) (BinIntDef.Z.abs v6 | v4) (RelationClasses.symmetry v14)) (Z.divide_abs_l v6 v4) v7) ((fun v14 : (BinIntDef.Z.abs v6 | v0) <-> (v6 | v0) => Morphisms.iff_impl_subrelation (v6 | v0) (BinIntDef.Z.abs v6 | v0) (RelationClasses.symmetry v14)) (Z.divide_abs_l v6 v0) v8) v9) v13 | or_intror v13 => (fun v13 : 1 < v10 => False_ind (v10 | 1) (v3 v10 (conj v13 (Z.le_lt_trans v10 v4 v0 (and_ind (fun (v14 : 1 <= v4) (v15 : v4 < v0) => Z.divide_pos_le v10 v4 (Z.lt_le_trans 0 1 v4 (eq_refl : 0 < 1) v14) ((fun v16 : (BinIntDef.Z.abs v6 | v4) <-> (v6 | v4) => Morphisms.iff_impl_subrelation (v6 | v4) (BinIntDef.Z.abs v6 | v4) (RelationClasses.symmetry v16)) (Z.divide_abs_l v6 v4) v7) : v10 <= v4) v5) (and_ind (fun (v14 : 1 <= v4) (v15 : v4 < v0) => v15) v5))) ((fun v14 : (BinIntDef.Z.abs v6 | v0) <-> (v6 | v0) => Morphisms.iff_impl_subrelation (v6 | v0) (BinIntDef.Z.abs v6 | v0) (RelationClasses.symmetry v14)) (Z.divide_abs_l v6 v0) v8))) v13 end) v12 end)))) v2 v3 end) (fun v1 : prime v0 => match v1 as v2 in (prime _) return (prime' v0) with | prime_intro _ v2 v3 => (fun (v2 : 1 < v0) (v3 : forall (v3 : @Z) (v4 : 1 <= v3 < v0), rel_prime v3 v0) => conj v2 (fun (v4 : @Z) (v5 : 1 < v4 < v0) => (fun v6 : (v4 | v0) => match Zis_gcd_unique v4 v0 v4 1 (Zis_gcd_intro v4 v0 v4 (Z.divide_refl v4) v6 (fun (v7 : @Z) (v8 : (v7 | v4)) (v9 : (v7 | v0)) => v8)) (v3 v4 (and_ind (fun (v7 : 1 < v4) (v8 : v4 < v0) => conj (Z.lt_le_incl 1 v4 v7) v8) v5)) as v7 in (_ \/ _) return (@False) with | or_introl v7 => (fun v7 : v4 = 1 => and_ind (fun (v8 : 1 < v4) (v9 : v4 < v0) => eq_ind_r (fun v10 : @Z => forall (v11 : (v10 | v0)) (v12 : 1 < v10) (v13 : v10 < v0), @False) (fun (v10 : (1 | v0)) (v11 : 1 < 1) (v12 : 1 < v0) => let v13 : @False := eq_ind (1 ?= 1) (fun v13 : @comparison => match v13 as v14 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v11 in False_ind (@False) v13) v7 v6 v8 v9) v5) v7 | or_intror v7 => (fun v7 : v4 = - (1) => and_ind (fun (v8 : 1 < v4) (v9 : v4 < v0) => eq_ind_r (fun v10 : @Z => forall (v11 : (v10 | v0)) (v12 : 1 < v10) (v13 : v10 < v0), @False) (fun (v10 : (- (1) | v0)) (v11 : 1 < - (1)) (v12 : - (1) < v0) => let v13 : @False := eq_ind (1 ?= - (1)) (fun v13 : @comparison => match v13 as v14 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v11 in False_ind (@False) v13) v7 v6 v8 v9) v5) v7 end) : ~ (v4 | v0))) v2 v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.square_not_prime	100	0.125180	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => (fun v1 : prime (v0 * v0) => let v2 : prime (BinIntDef.Z.abs v0 * BinIntDef.Z.abs v0) := eq_ind_r (fun v2 : @Z => prime v2) v1 (Z.abs_square v0) in let v3 : 0 <= BinIntDef.Z.abs v0 := Z.abs_nonneg v0 in let v4 : @Z := BinIntDef.Z.abs v0 in match (fun v5 : prime' (v4 * v4) <-> prime (v4 * v4) => Morphisms.iff_impl_subrelation (prime (v4 * v4)) (prime' (v4 * v4)) (RelationClasses.symmetry v5)) (prime_alt (v4 * v4)) v2 as v5 in (_ /\ _) return (@False) with | conj v5 v6 => (fun (v5 : 1 < v4 * v4) (v6 : forall (v6 : @Z) (v7 : 1 < v6 < v4 * v4), ~ (v6 | v4 * v4)) => let v7 : 1 < v4 := Z.square_lt_simpl_nonneg 1 v4 v3 v5 in v6 v4 (conj v7 ((fun v8 : 1 * v4 = v4 => Morphisms.reflexive_proper (@Z.lt) v4 (1 * v4) (RelationClasses.symmetry v8) (v4 * v4) (v4 * v4) (Morphisms.eq_proper_proxy (v4 * v4))) (Z.mul_1_l v4) (let v8 : forall (v8 v9 v10 : @Z) (v11 : 0 < v8) (v12 : v9 < v10), v9 * v8 < v10 * v8 := fun (v8 v9 v10 : @Z) (v11 : 0 < v8) => match Z.mul_lt_mono_pos_r v8 v9 v10 v11 as v12 in (_ /\ _) return (forall v13 : v9 < v10, v9 * v8 < v10 * v8) with | conj v12 v13 => (fun (v12 : forall v12 : v9 < v10, v9 * v8 < v10 * v8) (v13 : forall v13 : v9 * v8 < v10 * v8, v9 < v10) => v12) v12 v13 end in v8 v4 1 v4 (Z.lt_trans 0 1 v4 (eq_refl : 0 < 1) v7) v7))) (ex_intro (fun v8 : @Z => v4 * v4 = v8 * v4) v4 eq_refl)) v5 v6 end) : ~ prime (v0 * v0))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_div_prime	100	0.187276	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : prime v0) (v3 : prime v1) (v4 : (v0 | v1)) => let v5 : 0 < v0 := Z.lt_le_trans 0 2 v0 (Pos2Z.is_pos 2) (prime_ge_2 v0 v2) in let v6 : 0 < v1 := Z.lt_le_trans 0 2 v1 (Pos2Z.is_pos 2) (prime_ge_2 v1 v3) in match prime_divisors v1 v3 v0 v4 as v7 in (_ \/ _) return (v0 = v1) with | or_introl v7 => (fun v7 : v0 = -1 => False_ind (v0 = v1) ((eq_ind_r (fun v8 : @Z => forall (v9 : prime v8) (v10 : (v8 | v1)), ~ 0 < v8) (fun (v8 : prime (-1)) (v9 : (-1 | v1)) => (fun v10 : 0 < -1 => let v11 : @False := eq_ind (0 ?= -1) (fun v11 : @comparison => match v11 as v12 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v10 in False_ind (@False) v11) : ~ 0 < -1) v7 v2 v4 : forall v8 : 0 < v0, @False) v5)) v7 | or_intror v7 => (fun v7 : v0 = 1 \/ v0 = v1 \/ v0 = - v1 => match v7 as v8 in (_ \/ _) return (v0 = v1) with | or_introl v8 => (fun v8 : v0 = 1 => eq_ind_r (fun v9 : @Z => forall (v10 : prime v9) (v11 : (v9 | v1)) (v12 : 0 < v9), v9 = v1) (fun (v9 : prime 1) (v10 : (1 | v1)) (v11 : 0 < 1) => False_ind (1 = v1) ((@not_prime_1 : forall v12 : prime 1, @False) v9)) v8 v2 v4 v5) v8 | or_intror v8 => (fun v8 : v0 = v1 \/ v0 = - v1 => match v8 as v9 in (_ \/ _) return (v0 = v1) with | or_introl v9 => (fun v9 : v0 = v1 => eq_ind_r (fun v10 : @Z => forall (v11 : prime v10) (v12 : (v10 | v1)) (v13 : 0 < v10), v10 = v1) (fun (v10 : prime v1) (v11 : (v1 | v1)) (v12 : 0 < v1) => eq_refl) v9 v2 v4 v5) v9 | or_intror v9 => (fun v9 : v0 = - v1 => eq_ind_r (fun v10 : @Z => forall (v11 : prime v10) (v12 : (v10 | v1)) (v13 : 0 < v10), v10 = v1) (fun (v10 : prime (- v1)) (v11 : (- v1 | v1)) (v12 : 0 < - v1) => False_ind (- v1 = v1) ((Zle_not_lt (- v1) 0 (let v13 : forall v13 : - 0 <= - - v1, - v1 <= 0 := match Z.opp_le_mono (- v1) 0 as v13 in (_ /\ _) return (forall v14 : - 0 <= - - v1, - v1 <= 0) with | conj v13 v14 => (fun (v13 : forall v13 : - v1 <= 0, - 0 <= - - v1) (v14 : forall v14 : - 0 <= - - v1, - v1 <= 0) => v14) v13 v14 end in v13 (eq_ind_r (fun v14 : @Z => - 0 <= v14) (Z.lt_le_incl (- 0) v1 v6) (Z.opp_involutive v1))) : forall v13 : 0 < - v1, @False) v12)) v9 v2 v4 v5) v9 end) v8 end) v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zgcd_is_gcd	100	0.032811	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Z => Zis_gcd_intro v0 v1 (BinIntDef.Z.gcd v0 v1) (Z.gcd_divide_l v0 v1) (Z.gcd_divide_r v0 v1) (Z.gcd_greatest v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zgcd_spec	100	0.056756	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Z => exist (fun v2 : @Z => Zis_gcd v0 v1 v2 /\ 0 <= v2) (BinIntDef.Z.gcd v0 v1) (conj (Zgcd_is_gcd v0 v1) (Z.gcd_nonneg v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zdivide_Zgcd	100	0.050996	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : (v0 | v1)) (v4 : (v0 | v2)) => Z.gcd_greatest v1 v2 v0 v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zis_gcd_gcd	100	0.232741	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= v2) (v4 : Zis_gcd v0 v1 v2) => match Zis_gcd_uniqueness_apart_sign v0 v1 v2 (BinIntDef.Z.gcd v0 v1) v4 (Zgcd_is_gcd v0 v1) as v5 in (_ \/ _) return (BinIntDef.Z.gcd v0 v1 = v2) with | or_introl v5 => (fun v5 : v2 = BinIntDef.Z.gcd v0 v1 => eq_sym v5) v5 | or_intror v5 => match (fun v5 : 0 <= v2 <-> 0 < v2 \/ 0 = v2 => Morphisms.iff_impl_subrelation (0 <= v2) (0 < v2 \/ 0 = v2) v5) (Z.lt_eq_cases 0 v2) v3 as v5 in (_ \/ _) return (forall v6 : v2 = - BinIntDef.Z.gcd v0 v1, BinIntDef.Z.gcd v0 v1 = v2) with | or_introl v5 => (fun v5 : 0 < v2 => (fun (v6 : 0 <= BinIntDef.Z.gcd v0 v1) (v7 : v2 = - BinIntDef.Z.gcd v0 v1) => False_ind (BinIntDef.Z.gcd v0 v1 = v2) ((eq_ind (- - BinIntDef.Z.gcd v0 v1) (fun v8 : @Z => ~ 0 <= v8) (eq_ind v2 (fun v8 : @Z => ~ 0 <= - v8) (Zlt_not_le (- v2) 0 (let v8 : forall (v8 v9 : @Z) (v10 : - v9 < - v8), v8 < v9 := fun v8 v9 : @Z => match Z.opp_lt_mono v8 v9 as v10 in (_ /\ _) return (forall v11 : - v9 < - v8, v8 < v9) with | conj v10 v11 => (fun (v10 : forall v10 : v8 < v9, - v9 < - v8) (v11 : forall v11 : - v9 < - v8, v8 < v9) => v11) v10 v11 end in v8 (- v2) 0 (eq_ind_r (fun v9 : @Z => - 0 < v9) v5 (Z.opp_involutive v2)))) (- BinIntDef.Z.gcd v0 v1) v7) (BinIntDef.Z.gcd v0 v1) (Z.opp_involutive (BinIntDef.Z.gcd v0 v1)) : forall v8 : 0 <= BinIntDef.Z.gcd v0 v1, @False) v6)) (Z.gcd_nonneg v0 v1)) v5 | or_intror v5 => (fun v5 : 0 = v2 => eq_ind 0 (fun v6 : @Z => forall (v7 : Zis_gcd v0 v1 v6) (v8 : v6 = - BinIntDef.Z.gcd v0 v1), BinIntDef.Z.gcd v0 v1 = v6) (fun v6 : Zis_gcd v0 v1 0 => match BinIntDef.Z.gcd v0 v1 as v7 in Z return (forall v8 : 0 = - v7, v7 = 0) with | 0 => fun v7 : 0 = - 0 => v7 | Z.pos v7 => (fun (v7 : @positive) (v8 : 0 = - Z.pos v7) => let v9 : forall v9 : - Z.pos v7 = - Z.pos v7, Z.pos v7 = 0 := match v8 as v10 in (_ = v9) return (forall v11 : v9 = - Z.pos v7, Z.pos v7 = 0) with | eq_refl => fun v9 : 0 = - Z.pos v7 => (fun v10 : 0 = - Z.pos v7 => let v11 : @False := eq_ind 0 (fun v11 : @Z => match v11 as v12 in Z return Prop with | 0 => @True | Z.pos v12 | Z.neg v12 => (fun v12 : @positive => @False) v12 end) (@I) (- Z.pos v7) v10 in False_ind (Z.pos v7 = 0) v11) v9 end in v9 eq_refl) v7 | Z.neg v7 => (fun (v7 : @positive) (v8 : 0 = - Z.neg v7) => let v9 : forall v9 : - Z.neg v7 = - Z.neg v7, Z.neg v7 = 0 := match v8 as v10 in (_ = v9) return (forall v11 : v9 = - Z.neg v7, Z.neg v7 = 0) with | eq_refl => fun v9 : 0 = - Z.neg v7 => (fun v10 : 0 = - Z.neg v7 => let v11 : @False := eq_ind 0 (fun v11 : @Z => match v11 as v12 in Z return Prop with | 0 => @True | Z.pos v12 | Z.neg v12 => (fun v12 : @positive => @False) v12 end) (@I) (- Z.neg v7) v10 in False_ind (Z.neg v7 = 0) v11) v9 end in v9 eq_refl) v7 end) v2 v5 v4) v5 end v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zgcd_div_swap0	100	0.190525	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 0 < BinIntDef.Z.gcd v0 v1) (v3 : 0 < v1) => let v4 : Zis_gcd v0 v1 (BinIntDef.Z.gcd v0 v1) := Zgcd_is_gcd v0 v1 in let v5 : v0 / BinIntDef.Z.gcd v0 v1 * v1 = v0 * (v1 / BinIntDef.Z.gcd v0 v1) := match v4 as v5 in (Zis_gcd _ _ _) return (v0 / BinIntDef.Z.gcd v0 v1 * v1 = v0 * (v1 / BinIntDef.Z.gcd v0 v1)) with | Zis_gcd_intro _ _ _ v5 v6 v7 => (fun (v5 : (BinIntDef.Z.gcd v0 v1 | v0)) (v6 : (BinIntDef.Z.gcd v0 v1 | v1)) (v7 : forall (v7 : @Z) (v8 : (v7 | v0)) (v9 : (v7 | v1)), (v7 | BinIntDef.Z.gcd v0 v1)) => (fun (v8 : (BinIntDef.Z.gcd v0 v1 | v0)) (v9 : (BinIntDef.Z.gcd v0 v1 | v1)) (v10 : forall (v10 : @Z) (v11 : (v10 | v0)) (v12 : (v10 | v1)), (v10 | BinIntDef.Z.gcd v0 v1)) => eq_ind_r (fun v11 : @Z => v0 / BinIntDef.Z.gcd v0 v1 * v11 = v0 * (v1 / BinIntDef.Z.gcd v0 v1)) (eq_ind_r (fun v11 : @Z => v11 = v0 * (v1 / BinIntDef.Z.gcd v0 v1)) (let v11 : v1 / BinIntDef.Z.gcd v0 v1 = v1 / BinIntDef.Z.gcd v0 v1 := eq_refl in (let v12 : v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1 = v0 := eq_ind_r (fun v12 : @Z => v12 = v0) (eq_ind v0 (fun v12 : @Z => v12 = v0) eq_refl (BinIntDef.Z.gcd v0 v1 * (v0 / BinIntDef.Z.gcd v0 v1)) (Zdivide_Zdiv_eq (BinIntDef.Z.gcd v0 v1) v0 v2 v8)) (Z.mul_comm (v0 / BinIntDef.Z.gcd v0 v1) (BinIntDef.Z.gcd v0 v1)) in (fun (v13 : v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1 = v0) (v14 : v1 / BinIntDef.Z.gcd v0 v1 = v1 / BinIntDef.Z.gcd v0 v1) => eq_trans (f_equal (fun v15 : forall v15 : @Z, @Z => v15 (v1 / BinIntDef.Z.gcd v0 v1)) (eq_trans (f_equal (fun v15 : forall v15 v16 : @Z, @Z => v15 (v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1)) eq_refl) (f_equal (@BinIntDef.Z.mul) v13))) (f_equal (BinIntDef.Z.mul v0) eq_refl)) v12) v11) (Z.mul_assoc (v0 / BinIntDef.Z.gcd v0 v1) (BinIntDef.Z.gcd v0 v1) (v1 / BinIntDef.Z.gcd v0 v1))) (Zdivide_Zdiv_eq (BinIntDef.Z.gcd v0 v1) v1 v2 v9) : v0 / BinIntDef.Z.gcd v0 v1 * v1 = v0 * (v1 / BinIntDef.Z.gcd v0 v1)) v5 v6 v7) v5 v6 v7 end in v5)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zgcd_div_swap	100	0.245147	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 < BinIntDef.Z.gcd v0 v1) (v4 : 0 < v1) => let v5 : Zis_gcd v0 v1 (BinIntDef.Z.gcd v0 v1) := Zgcd_is_gcd v0 v1 in let v6 : v2 * v0 / BinIntDef.Z.gcd v0 v1 * v1 = v2 * v0 * (v1 / BinIntDef.Z.gcd v0 v1) := match v5 as v6 in (Zis_gcd _ _ _) return (v2 * v0 / BinIntDef.Z.gcd v0 v1 * v1 = v2 * v0 * (v1 / BinIntDef.Z.gcd v0 v1)) with | Zis_gcd_intro _ _ _ v6 v7 v8 => (fun (v6 : (BinIntDef.Z.gcd v0 v1 | v0)) (v7 : (BinIntDef.Z.gcd v0 v1 | v1)) (v8 : forall (v8 : @Z) (v9 : (v8 | v0)) (v10 : (v8 | v1)), (v8 | BinIntDef.Z.gcd v0 v1)) => (fun (v9 : (BinIntDef.Z.gcd v0 v1 | v0)) (v10 : (BinIntDef.Z.gcd v0 v1 | v1)) (v11 : forall (v11 : @Z) (v12 : (v11 | v0)) (v13 : (v11 | v1)), (v11 | BinIntDef.Z.gcd v0 v1)) => eq_ind_r (fun v12 : @Z => v2 * v0 / BinIntDef.Z.gcd v0 v1 * v12 = v2 * v0 * (v1 / BinIntDef.Z.gcd v0 v1)) (eq_ind_r (fun v12 : @Z => v12 = v2 * v0 * (v1 / BinIntDef.Z.gcd v0 v1)) (let v12 : v1 / BinIntDef.Z.gcd v0 v1 = v1 / BinIntDef.Z.gcd v0 v1 := eq_refl in (let v13 : v2 * v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1 = v2 * v0 := eq_ind_r (fun v13 : @Z => v13 * BinIntDef.Z.gcd v0 v1 = v2 * v0) (eq_ind (v2 * (v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1)) (fun v13 : @Z => v13 = v2 * v0) (let v13 : v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1 = v0 := eq_ind_r (fun v13 : @Z => v13 = v0) (eq_ind v0 (fun v13 : @Z => v13 = v0) eq_refl (BinIntDef.Z.gcd v0 v1 * (v0 / BinIntDef.Z.gcd v0 v1)) (Zdivide_Zdiv_eq (BinIntDef.Z.gcd v0 v1) v0 v3 v9)) (Z.mul_comm (v0 / BinIntDef.Z.gcd v0 v1) (BinIntDef.Z.gcd v0 v1)) in (let v14 : v2 = v2 := eq_refl in (fun (v15 : v2 = v2) (v16 : v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1 = v0) => eq_trans (f_equal (fun v17 : forall v17 : @Z, @Z => v17 (v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1)) eq_refl) (f_equal (BinIntDef.Z.mul v2) v16)) v14) v13) (v2 * (v0 / BinIntDef.Z.gcd v0 v1) * BinIntDef.Z.gcd v0 v1) (Z.mul_assoc v2 (v0 / BinIntDef.Z.gcd v0 v1) (BinIntDef.Z.gcd v0 v1))) (Zdivide_Zdiv_eq_2 (BinIntDef.Z.gcd v0 v1) v0 v2 v3 v9) in (fun (v14 : v2 * v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1 = v2 * v0) (v15 : v1 / BinIntDef.Z.gcd v0 v1 = v1 / BinIntDef.Z.gcd v0 v1) => eq_trans (f_equal (fun v16 : forall v16 : @Z, @Z => v16 (v1 / BinIntDef.Z.gcd v0 v1)) (eq_trans (f_equal (fun v16 : forall v16 v17 : @Z, @Z => v16 (v2 * v0 / BinIntDef.Z.gcd v0 v1 * BinIntDef.Z.gcd v0 v1)) eq_refl) (f_equal (@BinIntDef.Z.mul) v14))) (f_equal (BinIntDef.Z.mul (v2 * v0)) eq_refl)) v13) v12) (Z.mul_assoc (v2 * v0 / BinIntDef.Z.gcd v0 v1) (BinIntDef.Z.gcd v0 v1) (v1 / BinIntDef.Z.gcd v0 v1))) (Zdivide_Zdiv_eq (BinIntDef.Z.gcd v0 v1) v1 v3 v10) : v2 * v0 / BinIntDef.Z.gcd v0 v1 * v1 = v2 * v0 * (v1 / BinIntDef.Z.gcd v0 v1)) v6 v7 v8) v6 v7 v8 end in v6)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zgcd_ass	100	0.042431	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (SYM3 Z.gcd_assoc)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.Zgcd_1_rel_prime	100	0.075592	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @Z => conj (fun v2 : BinIntDef.Z.gcd v0 v1 = 1 => eq_ind (BinIntDef.Z.gcd v0 v1) (fun v3 : @Z => Zis_gcd v0 v1 v3) (Zgcd_is_gcd v0 v1) 1 v2) (fun v2 : Zis_gcd v0 v1 1 => match Zis_gcd_unique v0 v1 (BinIntDef.Z.gcd v0 v1) 1 (Zgcd_is_gcd v0 v1) v2 as v3 in (_ \/ _) return (BinIntDef.Z.gcd v0 v1 = 1) with | or_introl v3 => (fun v3 : BinIntDef.Z.gcd v0 v1 = 1 => v3) v3 | or_intror v3 => (fun v3 : BinIntDef.Z.gcd v0 v1 = - (1) => False_ind (BinIntDef.Z.gcd v0 v1 = 1) (eq_ind_r (fun v4 : @Z => ~ 0 <= v4) ((fun v4 : 0 <= - (1) => v4 eq_refl) : ~ 0 <= - (1)) v3 ((fun v4 : 0 <= BinIntDef.Z.gcd v0 v1 => v4) (Z.gcd_nonneg v0 v1)))) v3 end)) : forall v0 v1 : @Z, BinIntDef.Z.gcd v0 v1 = 1 <-> rel_prime v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.rel_prime_dec	100	0.097530	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Z => match Z.eq_dec (BinIntDef.Z.gcd v0 v1) 1 as v2 in ({_} + {_}) return ({rel_prime v0 v1} + {~ rel_prime v0 v1}) with | left v2 => (fun v2 : BinIntDef.Z.gcd v0 v1 = 1 => left (let v3 : forall v3 v4 : @Z, BinIntDef.Z.gcd v3 v4 = 1 <-> rel_prime v3 v4 := @Zgcd_1_rel_prime in let v4 : @Z := v0 in let v5 : forall v5 : @Z, BinIntDef.Z.gcd v4 v5 = 1 <-> rel_prime v4 v5 := v3 v4 in let v6 : @Z := v1 in let v7 : BinIntDef.Z.gcd v0 v6 = 1 <-> rel_prime v0 v6 := v5 v6 in match v7 as v8 in (_ /\ _) return (rel_prime v0 v1) with | conj v8 v9 => (fun (v8 : forall v8 : BinIntDef.Z.gcd v0 v1 = 1, rel_prime v0 v1) (v9 : forall v9 : rel_prime v0 v1, BinIntDef.Z.gcd v0 v1 = 1) => v8 v2) v8 v9 end)) v2 | right v2 => (fun v2 : BinIntDef.Z.gcd v0 v1 <> 1 => right ((fun v3 : rel_prime v0 v1 => match v2 (let v4 : forall v4 v5 : @Z, BinIntDef.Z.gcd v4 v5 = 1 <-> rel_prime v4 v5 := @Zgcd_1_rel_prime in let v5 : @Z := v0 in let v6 : forall v6 : @Z, BinIntDef.Z.gcd v5 v6 = 1 <-> rel_prime v5 v6 := v4 v5 in let v7 : @Z := v1 in let v8 : BinIntDef.Z.gcd v0 v7 = 1 <-> rel_prime v0 v7 := v6 v7 in match v8 as v9 in (_ /\ _) return (BinIntDef.Z.gcd v0 v1 = 1) with | conj v9 v10 => (fun (v9 : forall v9 : BinIntDef.Z.gcd v0 v1 = 1, rel_prime v0 v1) (v10 : forall v10 : rel_prime v0 v1, BinIntDef.Z.gcd v0 v1 = 1) => v10 v3) v9 v10 end) as v4 in False return (@False) with end) : ~ rel_prime v0 v1)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_dec_aux	100	0.477436	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Z => match Z_lt_dec 1 v1 as v2 in ({_} + {_}) return ({forall (v3 : @Z) (v4 : 1 < v3 < v1), rel_prime v3 v0} + {exists v3 : @Z, 1 < v3 < v1 /\ ~ rel_prime v3 v0}) with | left v2 => (fun v2 : 1 < v1 => natlike_rec (fun v3 : @Z => {forall (v4 : @Z) (v5 : 1 < v4 < v3), rel_prime v4 v0} + {exists v4 : @Z, 1 < v4 < v3 /\ ~ rel_prime v4 v0}) (left (fun (v3 : @Z) (v4 : 1 < v3 < 0) => False_ind (rel_prime v3 v0) (False_ind (@False) (((fun v5 : 1 < 0 => let v6 : @False := eq_ind (1 ?= 0) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@False) v6) : ~ 1 < 0) (Z.lt_trans 1 v3 0 (and_ind (fun (v5 : 1 < v3) (v6 : v3 < 0) => v5) v4) (and_ind (fun (v5 : 1 < v3) (v6 : v3 < 0) => v6) v4)))))) (fun (v3 : @Z) (v4 : 0 <= v3) (v5 : {forall (v5 : @Z) (v6 : 1 < v5 < v3), rel_prime v5 v0} + {exists v5 : @Z, 1 < v5 < v3 /\ ~ rel_prime v5 v0}) => match v5 as v6 in ({_} + {_}) return ({forall (v7 : @Z) (v8 : 1 < v7 < BinIntDef.Z.succ v3), rel_prime v7 v0} + {exists v7 : @Z, 1 < v7 < BinIntDef.Z.succ v3 /\ ~ rel_prime v7 v0}) with | left v6 => (fun v6 : forall (v6 : @Z) (v7 : 1 < v6 < v3), rel_prime v6 v0 => let v7 : {rel_prime v3 v0} + {~ rel_prime v3 v0} := rel_prime_dec v3 v0 in match v7 as v8 in ({_} + {_}) return ({forall (v9 : @Z) (v10 : 1 < v9 < BinIntDef.Z.succ v3), rel_prime v9 v0} + {exists v9 : @Z, 1 < v9 < BinIntDef.Z.succ v3 /\ ~ rel_prime v9 v0}) with | left v8 => (fun v8 : rel_prime v3 v0 => left (fun (v9 : @Z) (v10 : 1 < v9 < BinIntDef.Z.succ v3) => match v10 as v11 in (_ /\ _) return (rel_prime v9 v0) with | conj v11 v12 => (fun (v11 : 1 < v9) (v12 : v9 < BinIntDef.Z.succ v3) => match (fun v13 : v9 <= v3 <-> v9 < v3 \/ v9 = v3 => Morphisms.iff_impl_subrelation (v9 <= v3) (v9 < v3 \/ v9 = v3) v13) (Z.lt_eq_cases v9 v3) ((fun v13 : v9 < BinIntDef.Z.succ v3 <-> v9 <= v3 => Morphisms.iff_impl_subrelation (v9 < BinIntDef.Z.succ v3) (v9 <= v3) v13) (Z.lt_succ_r v9 v3) v12) as v13 in (_ \/ _) return (rel_prime v9 v0) with | or_introl v13 => (fun v13 : v9 < v3 => v6 v9 (conj v11 v13)) v13 | or_intror v13 => (fun v13 : v9 = v3 => eq_ind_r (fun v14 : @Z => forall v15 : 1 < v14, rel_prime v14 v0) (fun v14 : 1 < v3 => v8) v13 v11) v13 end) v11 v12 end)) v8 | right v8 => (fun v8 : ~ rel_prime v3 v0 => match Z_lt_dec 1 v3 as v9 in ({_} + {_}) return ({forall (v10 : @Z) (v11 : 1 < v10 < BinIntDef.Z.succ v3), rel_prime v10 v0} + {exists v10 : @Z, 1 < v10 < BinIntDef.Z.succ v3 /\ ~ rel_prime v10 v0}) with | left v9 => (fun v9 : 1 < v3 => right (ex_intro (fun v10 : @Z => 1 < v10 < BinIntDef.Z.succ v3 /\ ~ rel_prime v10 v0) v3 (conj (conj v9 (Z.lt_succ_diag_r v3)) v8))) v9 | right v9 => (fun v9 : ~ 1 < v3 => left (fun (v10 : @Z) (v11 : 1 < v10 < BinIntDef.Z.succ v3) => match v11 as v12 in (_ /\ _) return (rel_prime v10 v0) with | conj v12 v13 => (fun (v12 : 1 < v10) (v13 : v10 < BinIntDef.Z.succ v3) => False_ind (rel_prime v10 v0) ((Zle_not_lt v10 1 (Z.le_trans v10 v3 1 (Zlt_succ_le v10 v3 v13) (Znot_gt_le v3 1 ((fun v14 : v3 > 1 => match v9 (Z.gt_lt v3 1 v14) as v15 in False return (@False) with end) : ~ v3 > 1))) : forall v14 : 1 < v10, @False) v12)) v12 v13 end)) v9 end) v8 end) v6 | right v6 => (fun v6 : exists v6 : @Z, 1 < v6 < v3 /\ ~ rel_prime v6 v0 => right match v6 as v7 in (ex _) return (exists v8 : @Z, 1 < v8 < BinIntDef.Z.succ v3 /\ ~ rel_prime v8 v0) with | ex_intro _ v7 v8 => (fun (v7 : @Z) (v8 : 1 < v7 < v3 /\ ~ rel_prime v7 v0) => match v8 as v9 in (_ /\ _) return (exists v10 : @Z, 1 < v10 < BinIntDef.Z.succ v3 /\ ~ rel_prime v10 v0) with | conj v9 v10 => (fun (v9 : 1 < v7 < v3) (v10 : ~ rel_prime v7 v0) => match v9 as v11 in (_ /\ _) return (exists v12 : @Z, 1 < v12 < BinIntDef.Z.succ v3 /\ ~ rel_prime v12 v0) with | conj v11 v12 => (fun (v11 : 1 < v7) (v12 : v7 < v3) => ex_intro (fun v13 : @Z => 1 < v13 < BinIntDef.Z.succ v3 /\ ~ rel_prime v13 v0) v7 (conj (conj v11 (Z.lt_lt_succ_r v7 v3 v12)) v10)) v11 v12 end) v9 v10 end) v7 v8 end) v6 end) v1 (Z.le_trans 0 1 v1 ((fun v3 : (0 ?= 1) = @Gt => let v4 : @False := eq_ind (0 ?= 1) (fun v4 : @comparison => match v4 as v5 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v3 in False_ind (@False) v4) : 0 <= 1) (Z.lt_le_incl 1 v1 v2)) : {forall (v3 : @Z) (v4 : 1 < v3 < v1), rel_prime v3 v0} + {exists v3 : @Z, 1 < v3 < v1 /\ ~ rel_prime v3 v0}) v2 | right v2 => (fun v2 : ~ 1 < v1 => left (fun (v3 : @Z) (v4 : 1 < v3 < v1) => False_ind (rel_prime v3 v0) match v2 (Z.lt_trans 1 v3 v1 (and_ind (fun (v5 : 1 < v3) (v6 : v3 < v1) => v5) v4) (and_ind (fun (v5 : 1 < v3) (v6 : v3 < v1) => v6) v4)) as v5 in False return (@False) with end)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.prime_dec	100	0.459946	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => match Z_lt_dec 1 v0 as v1 in ({_} + {_}) return ({prime v0} + {~ prime v0}) with | left v1 => (fun v1 : 1 < v0 => match prime_dec_aux v0 v0 as v2 in ({_} + {_}) return ({prime v0} + {~ prime v0}) with | left v2 => (fun v2 : forall (v2 : @Z) (v3 : 1 < v2 < v0), rel_prime v2 v0 => left (prime_intro v0 v1 (fun (v3 : @Z) (v4 : 1 <= v3 < v0) => match v4 as v5 in (_ /\ _) return (rel_prime v3 v0) with | conj v5 v6 => (fun (v5 : 1 <= v3) (v6 : v3 < v0) => match (fun v7 : 1 <= v3 <-> 1 < v3 \/ 1 = v3 => Morphisms.iff_impl_subrelation (1 <= v3) (1 < v3 \/ 1 = v3) v7) (Z.lt_eq_cases 1 v3) v5 as v7 in (_ \/ _) return (rel_prime v3 v0) with | or_introl v7 => (fun v7 : 1 < v3 => v2 v3 (conj v7 v6)) v7 | or_intror v7 => (fun v7 : 1 = v3 => eq_ind 1 (fun v8 : @Z => forall v9 : v8 < v0, rel_prime v8 v0) (fun v8 : 1 < v0 => Zis_gcd_intro 1 v0 1 (Z.divide_1_l 1) (Z.divide_1_l v0) (fun (v9 : @Z) (v10 : (v9 | 1)) (v11 : (v9 | v0)) => v10)) v3 v7 v6) v7 end) v5 v6 end))) v2 | right v2 => (fun v2 : exists v2 : @Z, 1 < v2 < v0 /\ ~ rel_prime v2 v0 => right ((fun v3 : prime v0 => let v4 : @False := match v3 as v4 in (prime _) return (@False) with | prime_intro _ v4 v5 => (fun (v4 : 1 < v0) (v5 : forall (v5 : @Z) (v6 : 1 <= v5 < v0), rel_prime v5 v0) => (fun (v6 : 1 < v0) (v7 : forall (v7 : @Z) (v8 : 1 <= v7 < v0), rel_prime v7 v0) => match v2 as v8 in (ex _) return (@False) with | ex_intro _ v8 v9 => (fun (v8 : @Z) (v9 : 1 < v8 < v0 /\ ~ rel_prime v8 v0) => match v9 as v10 in (_ /\ _) return (@False) with | conj v10 v11 => (fun (v10 : 1 < v8 < v0) (v11 : ~ rel_prime v8 v0) => match v11 (v7 v8 (and_ind (fun (v12 : 1 < v8) (v13 : v8 < v0) => conj (Z.lt_le_incl 1 v8 v12 : 1 <= v8) v13) v10)) as v12 in False return (@False) with end) v10 v11 end) v8 v9 end) v4 v5) v4 v5 end in v4) : ~ prime v0)) v2 end) v1 | right v1 => (fun v1 : ~ 1 < v0 => right ((fun v2 : prime v0 => let v3 : @False := match v2 as v3 in (prime _) return (@False) with | prime_intro _ v3 v4 => (fun (v3 : 1 < v0) (v4 : forall (v4 : @Z) (v5 : 1 <= v4 < v0), rel_prime v4 v0) => (fun (v5 : 1 < v0) (v6 : forall (v6 : @Z) (v7 : 1 <= v6 < v0), rel_prime v6 v0) => match v1 v5 as v7 in False return (@False) with end) v3 v4) v3 v4 end in v3) : ~ prime v0)) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Znumtheory.not_prime_divide	100	0.277260	1	1	0	synth with cache (only 1: refine (fun (v0 : @Z) (v1 : 1 < v0) (v2 : ~ prime v0) => match prime_dec_aux v0 v0 as v3 in ({_} + {_}) return (exists v4 : @Z, 1 < v4 < v0 /\ (v4 | v0)) with | left v3 => (fun v3 : forall (v3 : @Z) (v4 : 1 < v3 < v0), rel_prime v3 v0 => False_ind (exists v4 : @Z, 1 < v4 < v0 /\ (v4 | v0)) (v2 (prime_intro v0 v1 (fun (v4 : @Z) (v5 : 1 <= v4 < v0) => match v5 as v6 in (_ /\ _) return (rel_prime v4 v0) with | conj v6 v7 => (fun (v6 : 1 <= v4) (v7 : v4 < v0) => match (fun v8 : 1 <= v4 <-> 1 < v4 \/ 1 = v4 => Morphisms.iff_impl_subrelation (1 <= v4) (1 < v4 \/ 1 = v4) v8) (Z.lt_eq_cases 1 v4) v6 as v8 in (_ \/ _) return (rel_prime v4 v0) with | or_introl v8 => (fun v8 : 1 < v4 => v3 v4 (conj v8 v7)) v8 | or_intror v8 => (fun v8 : 1 = v4 => eq_ind 1 (fun v9 : @Z => forall v10 : v9 < v0, rel_prime v9 v0) (fun v9 : 1 < v0 => Zis_gcd_intro 1 v0 1 (Z.divide_1_l 1) (Z.divide_1_l v0) (fun (v10 : @Z) (v11 : (v10 | 1)) (v12 : (v10 | v0)) => v11)) v4 v8 v7) v8 end) v6 v7 end)))) v3 | right v3 => (fun v3 : exists v3 : @Z, 1 < v3 < v0 /\ ~ rel_prime v3 v0 => match v3 as v4 in (ex _) return (exists v5 : @Z, 1 < v5 < v0 /\ (v5 | v0)) with | ex_intro _ v4 v5 => (fun (v4 : @Z) (v5 : 1 < v4 < v0 /\ ~ rel_prime v4 v0) => match v5 as v6 in (_ /\ _) return (exists v7 : @Z, 1 < v7 < v0 /\ (v7 | v0)) with | conj v6 v7 => (fun (v6 : 1 < v4 < v0) (v7 : ~ rel_prime v4 v0) => let v8 : BinIntDef.Z.gcd v4 v0 = 0 \/ BinIntDef.Z.gcd v4 v0 = 1 \/ 1 < BinIntDef.Z.gcd v4 v0 := Z_0_1_more (BinIntDef.Z.gcd v4 v0) (Z.gcd_nonneg v4 v0) in match v8 as v9 in (_ \/ _) return (exists v10 : @Z, 1 < v10 < v0 /\ (v10 | v0)) with | or_introl v9 => (fun v9 : BinIntDef.Z.gcd v4 v0 = 0 => False_ind (exists v10 : @Z, 1 < v10 < v0 /\ (v10 | v0)) (let v10 : v4 = 0 := Z.gcd_eq_0_l v4 v0 v9 in False_ind (@False) (eq_ind_r (fun v11 : @Z => ~ 1 < v11) ((fun v11 : 1 < 0 => let v12 : @False := eq_ind (1 ?= 0) (fun v12 : @comparison => match v12 as v13 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v11 in False_ind (@False) v12) : ~ 1 < 0) v10 (and_ind (fun (v11 : 1 < v4) (v12 : v4 < v0) => v11) v6)))) v9 | or_intror v9 => (fun v9 : BinIntDef.Z.gcd v4 v0 = 1 \/ 1 < BinIntDef.Z.gcd v4 v0 => match v9 as v10 in (_ \/ _) return (exists v11 : @Z, 1 < v11 < v0 /\ (v11 | v0)) with | or_introl v10 => (fun v10 : BinIntDef.Z.gcd v4 v0 = 1 => False_ind (exists v11 : @Z, 1 < v11 < v0 /\ (v11 | v0)) (v7 (eq_ind (BinIntDef.Z.gcd v4 v0) (fun v11 : @Z => Zis_gcd v4 v0 v11) (Zgcd_is_gcd v4 v0) 1 v10 : rel_prime v4 v0))) v10 | or_intror v10 => (fun v10 : 1 < BinIntDef.Z.gcd v4 v0 => ex_intro (fun v11 : @Z => 1 < v11 < v0 /\ (v11 | v0)) (BinIntDef.Z.gcd v4 v0) (conj (conj v10 (Z.le_lt_trans (BinIntDef.Z.gcd v4 v0) v4 v0 (Z.divide_pos_le (BinIntDef.Z.gcd v4 v0) v4 (Z.lt_trans 0 1 v4 (and_ind (fun (v11 : 1 < v4) (v12 : v4 < v0) => Pos2Z.is_pos 1 : 0 < 1) v6) (and_ind (fun (v11 : 1 < v4) (v12 : v4 < v0) => v11) v6)) (Z.gcd_divide_l v4 v0)) (and_ind (fun (v11 : 1 < v4) (v12 : v4 < v0) => v12) v6))) (Z.gcd_divide_r v4 v0))) v10 end) v9 end) v6 v7 end) v4 v5 end) v3 end)).
