coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj1	100	0.566336	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@A) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v1) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj2	100	0.019653	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@B) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_refl	100	0.011792	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : v0 => v1) (fun v1 : v0 => v1))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_trans	100	0.033487	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v1 <-> v2, v0 <-> v2) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v1 <-> v2) => match v6 as v7 in (_ /\ _) return (v0 <-> v2) with | conj v7 v8 => (fun (v7 : forall v7 : v1, v2) (v8 : forall v8 : v2, v1) => conj (fun v9 : v0 => v7 (v4 v9)) (fun v9 : v2 => v5 (v4 (v5 (v8 v9))))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_sym	100	0.022698	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return (v1 <-> v0) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v4 v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_l	100	0.041147	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 /\ v1 <-> v0 /\ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 /\ v1 => match v6 as v7 in (_ /\ _) return (v0 /\ v2) with | conj v7 v8 => (fun (v7 : v0) (v8 : v1) => conj v7 (v4 v8)) v7 v8 end) (fun v6 : v0 /\ v2 => match v6 as v7 in (_ /\ _) return (v0 /\ v1) with | conj v7 v8 => (fun (v7 : v0) (v8 : v2) => conj v7 (v5 v8)) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_r	100	0.038853	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 /\ v0 <-> v2 /\ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 /\ v0 => match v6 as v7 in (_ /\ _) return (v2 /\ v0) with | conj v7 v8 => (fun (v7 : v1) (v8 : v0) => conj (v4 v7) v8) v7 v8 end) (fun v6 : v2 /\ v0 => match v6 as v7 in (_ /\ _) return (v1 /\ v0) with | conj v7 v8 => (fun (v7 : v2) (v8 : v0) => conj (v5 v7) v8) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_l	100	0.041239	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 \/ v1 <-> v0 \/ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 \/ v1 => match v6 as v7 in (_ \/ _) return (v0 \/ v2) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v1 => or_intror (v4 v7)) v7 end) (fun v6 : v0 \/ v2 => match v6 as v7 in (_ \/ _) return (v0 \/ v1) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v2 => or_intror (v5 v7)) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_r	100	0.046420	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 \/ v0 <-> v2 \/ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 \/ v0 => match v6 as v7 in (_ \/ _) return (v2 \/ v0) with | or_introl v7 => (fun v7 : v1 => or_introl (v4 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end) (fun v6 : v2 \/ v0 => match v6 as v7 in (_ \/ _) return (v1 \/ v0) with | or_introl v7 => (fun v7 : v2 => or_introl (v5 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_l	100	0.025781	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v0, v1) <-> (forall v5 : v0, v2)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v0, v1) (v7 : v0) => v4 (v6 v7)) (fun (v6 : forall v6 : v0, v2) (v7 : v0) => v5 (v6 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_r	100	0.027691	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v1, v0) <-> (forall v5 : v2, v0)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v1, v0) (v7 : v2) => v6 (v5 v7)) (fun (v6 : forall v6 : v2, v0) (v7 : v1) => v6 (v4 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.not_iff_compat	100	0.017902	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => imp_iff_compat_r (@False) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.neg_false	100	0.027551	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : forall v1 : v0, @False => conj v1 (fun v2 : @False => False_ind v0 v2)) (fun v1 : v0 <-> @False => match v1 as v2 in (_ /\ _) return (forall v3 : v0, @False) with | conj v2 v3 => (fun (v2 : forall v2 : v0, @False) (v3 : forall v3 : @False, v0) => v2) v2 v3 end) : ~ v0 <-> (v0 <-> @False))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_l	100	0.058051	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v0 /\ v1 <-> v0 /\ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 /\ v1, v0 /\ v2) (v7 : forall v7 : v0 /\ v2, v0 /\ v1) => conj (fun v8 : v1 => let v9 : forall v9 : v0 /\ v1, v2 := fun v9 : v0 /\ v1 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v0) (v11 : v2) => v11) v10 v11 end in v9 (conj (v3 v8) v8)) (fun v8 : v2 => let v9 : forall v9 : v0 /\ v2, v1 := fun v9 : v0 /\ v2 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v0) (v11 : v1) => v11) v10 v11 end in v9 (conj (v4 v8) v8))) v6 v7 end) (and_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_r	100	0.056179	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v1 /\ v0 <-> v2 /\ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 /\ v0, v2 /\ v0) (v7 : forall v7 : v2 /\ v0, v1 /\ v0) => conj (fun v8 : v1 => let v9 : forall v9 : v1 /\ v0, v2 := fun v9 : v1 /\ v0 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v2) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v3 v8))) (fun v8 : v2 => let v9 : forall v9 : v2 /\ v0, v1 := fun v9 : v2 /\ v0 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v1) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v4 v8)))) v6 v7 end) (and_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_comm	100	0.034165	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 /\ v1 => match v2 as v3 in (_ /\ _) return (v1 /\ v0) with | conj v3 v4 => (fun (v3 : v0) (v4 : v1) => conj v4 v3) v3 v4 end) (fun v2 : v1 /\ v0 => match v2 as v3 in (_ /\ _) return (v0 /\ v1) with | conj v3 v4 => (fun (v3 : v1) (v4 : v0) => conj v4 v3) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_assoc	100	0.057782	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 /\ v1) /\ v2 => match v3 as v4 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v4 v5 => (fun (v4 : v0 /\ v1) (v5 : v2) => match v4 as v6 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v6 v7 => (fun (v6 : v0) (v7 : v1) => conj v6 (conj v7 v5)) v6 v7 end) v4 v5 end) (fun v3 : v0 /\ v1 /\ v2 => match v3 as v4 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v4 v5 => (fun (v4 : v0) (v5 : v1 /\ v2) => match v5 as v6 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v6 v7 => (fun (v6 : v1) (v7 : v2) => conj (conj v4 v6) v7) v6 v7 end) v4 v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_l	100	0.063765	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v0 \/ v1 <-> v0 \/ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 \/ v1, v0 \/ v2) (v7 : forall v7 : v0 \/ v2, v0 \/ v1) => conj (fun v8 : v1 => let v9 : v0 \/ v2 := v6 (or_intror v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 | or_intror v10 => (fun v10 : v2 => v10) v10 end) (fun v8 : v2 => let v9 : v0 \/ v1 := v7 (or_intror v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 | or_intror v10 => (fun v10 : v1 => v10) v10 end)) v6 v7 end) (or_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_r	100	0.063168	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v1 \/ v0 <-> v2 \/ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 \/ v0, v2 \/ v0) (v7 : forall v7 : v2 \/ v0, v1 \/ v0) => conj (fun v8 : v1 => let v9 : v2 \/ v0 := v6 (or_introl v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v2 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 end) (fun v8 : v2 => let v9 : v1 \/ v0 := v7 (or_introl v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v1 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 end)) v6 v7 end) (or_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_comm	100	0.044077	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 \/ v1 => match v2 as v3 in (_ \/ _) return (v1 \/ v0) with | or_introl v3 => (fun v3 : v0 => or_intror v3) v3 | or_intror v3 => (fun v3 : v1 => or_introl v3) v3 end) (fun v2 : v1 \/ v0 => match v2 as v3 in (_ \/ _) return (v0 \/ v1) with | or_introl v3 => (fun v3 : v1 => or_intror v3) v3 | or_intror v3 => (fun v3 : v0 => or_introl v3) v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_assoc	100	0.067549	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 \/ v1) \/ v2 => match v3 as v4 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v4 => (fun v4 : v0 \/ v1 => match v4 as v5 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v5 => (fun v5 : v0 => or_introl v5) v5 | or_intror v5 => (fun v5 : v1 => or_intror (or_introl v5)) v5 end) v4 | or_intror v4 => (fun v4 : v2 => or_intror (or_intror v4)) v4 end) (fun v3 : v0 \/ v1 \/ v2 => match v3 as v4 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v4 => (fun v4 : v0 => or_introl (or_introl v4)) v4 | or_intror v4 => (fun v4 : v1 \/ v2 => match v4 as v5 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v5 => (fun v5 : v1 => or_introl (or_intror v5)) v5 | or_intror v5 => (fun v5 : v2 => or_intror v5) v5 end) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_and	100	0.025919	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v3 v4) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_to_and	100	0.044745	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 <-> v1 => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end) (fun v2 : (forall v2 : v0, v1) /\ (forall v2 : v1, v0) => match v2 as v3 in (_ /\ _) return (v0 <-> v1) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.inst	100	0.022083	1	1	0	synth with cache (only 1: refine ((fun (v0 : @A) (v1 : forall v1 : @A, P v1) => v1 v0) : forall (v0 : @A) (v1 : all (fun v1 : @A => P v1)), P v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.gen	100	0.020707	1	1	0	synth with cache (only 1: refine ((fun (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0) (v3 : @A) => v1 v3 v2) : forall (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0), all (@P))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.absurd	100	0.015189	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : Prop) (v2 : v0) (v3 : forall v3 : v0, @False) => let v4 : @False := v3 v2 in match v4 as v5 in False return v1 with end) : forall (v0 v1 : Prop) (v2 : v0) (v3 : ~ v0), v1)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_sym	100	0.025887	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (v1 = @x) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans	100	0.032028	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @y = @z) => match v1 as v3 in (_ = v2) return (@x = v2) with | eq_refl => v0 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans_r	100	0.038341	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @z = @y) => match v1 as v3 in (_ = v2) return (forall v4 : @x = v2, @x = @z) with | eq_refl => fun v2 : @x = @z => v2 end v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.f_equal	100	0.035461	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.not_eq_sym	100	0.049859	1	1	0	synth with cache (only 1: refine ((fun (v0 : @x <> @y) (v1 : @y = @x) => v0 (match v1 as v3 in (_ = v2) return (forall v4 : v2 <> @y, v2 = @y) with | eq_refl => fun v2 : @y <> @y => eq_refl end v0)) : forall v0 : @x <> @y, @y <> @x)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_sind_r	100	0.022036	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, SProp) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_sind (fun v6 : v0 => v2 v6) v3 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_ind_r	100	0.028268	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Prop) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_ind v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rec_r	100	0.025777	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Set) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rec v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rect_r	100	0.027675	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rect v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep.f_equal_dep	100	0.048188	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (rew [@B] v2 in f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep2.f_equal_dep2	100	0.083971	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v2 v6) (v9 : v2 v7) (v10 : v6 = v7) => match v10 as v12 in (_ = v11) return (forall (v13 : v2 v11) (v14 : rew [v2] v12 in v8 = v13), rew [v3] f_equal v4 v12 in v5 v6 v8 = v5 v11 v13) with | eq_refl => fun (v11 : v2 v6) (v12 : rew [v2] eq_refl in v8 = v11) => match v12 as v14 in (_ = v13) return (rew [v3] f_equal v4 eq_refl in v5 v6 v8 = v5 v6 v13) with | eq_refl => eq_refl end end v9)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_r	100	0.047734	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v3) => match v4 as v7 in (_ = v6) return (forall v8 : v1 v6, rew [v1] v7 in rew <- [v1] v7 in v8 = v8) with | eq_refl => fun v6 : v1 v2 => eq_refl end v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_l	100	0.039630	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v2) => match v4 as v7 in (_ = v6) return (rew <- [v1] v7 in rew [v1] v7 in v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal2	100	0.049224	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 : forall (v3 : v0) (v4 : v1), v2) (v4 v5 : v0) (v6 v7 : v1) (v8 : v4 = v5) => match v8 as v10 in (_ = v9) return (forall v11 : v6 = v7, v3 v4 v6 = v3 v9 v7) with | eq_refl => fun v9 : v6 = v7 => match v9 as v11 in (_ = v10) return (v3 v4 v6 = v3 v4 v10) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal3	100	0.068511	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : Type) (v4 : forall (v4 : v0) (v5 : v1) (v6 : v2), v3) (v5 v6 : v0) (v7 v8 : v1) (v9 v10 : v2) (v11 : v5 = v6) => match v11 as v13 in (_ = v12) return (forall (v14 : v7 = v8) (v15 : v9 = v10), v4 v5 v7 v9 = v4 v12 v8 v10) with | eq_refl => fun v12 : v7 = v8 => match v12 as v14 in (_ = v13) return (forall v15 : v9 = v10, v4 v5 v7 v9 = v4 v5 v13 v10) with | eq_refl => fun v13 : v9 = v10 => match v13 as v15 in (_ = v14) return (v4 v5 v7 v9 = v4 v5 v7 v14) with | eq_refl => eq_refl end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal4	100	0.081387	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 : Type) (v5 : forall (v5 : v0) (v6 : v1) (v7 : v2) (v8 : v3), v4) (v6 v7 : v0) (v8 v9 : v1) (v10 v11 : v2) (v12 v13 : v3) (v14 : v6 = v7) => match v14 as v16 in (_ = v15) return (forall (v17 : v8 = v9) (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v15 v9 v11 v13) with | eq_refl => fun v15 : v8 = v9 => match v15 as v17 in (_ = v16) return (forall (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v6 v16 v11 v13) with | eq_refl => fun v16 : v10 = v11 => match v16 as v18 in (_ = v17) return (forall v19 : v12 = v13, v5 v6 v8 v10 v12 = v5 v6 v8 v17 v13) with | eq_refl => fun v17 : v12 = v13 => match v17 as v19 in (_ = v18) return (v5 v6 v8 v10 v12 = v5 v6 v8 v10 v18) with | eq_refl => eq_refl end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal5	100	0.110362	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 v5 : Type) (v6 : forall (v6 : v0) (v7 : v1) (v8 : v2) (v9 : v3) (v10 : v4), v5) (v7 v8 : v0) (v9 v10 : v1) (v11 v12 : v2) (v13 v14 : v3) (v15 v16 : v4) (v17 : v7 = v8) => match v17 as v19 in (_ = v18) return (forall (v20 : v9 = v10) (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v18 v10 v12 v14 v16) with | eq_refl => fun v18 : v9 = v10 => match v18 as v20 in (_ = v19) return (forall (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v19 v12 v14 v16) with | eq_refl => fun v19 : v11 = v12 => match v19 as v21 in (_ = v20) return (forall (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v9 v20 v14 v16) with | eq_refl => fun v20 : v13 = v14 => match v20 as v22 in (_ = v21) return (forall v23 : v15 = v16, v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v21 v16) with | eq_refl => fun v21 : v15 = v16 => match v21 as v23 in (_ = v22) return (v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v13 v22) with | eq_refl => eq_refl end end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal_compose	100	0.055789	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : forall v6 : v1, v2) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v6 (f_equal v5 v9) = f_equal (fun v10 : v0 => v6 (v5 v10)) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_l	100	0.044565	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans eq_refl v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_r	100	0.053800	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 eq_refl = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_involutive	100	0.040953	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_sym (eq_sym v5) = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_l	100	0.047573	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans (eq_sym v5) v5 = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_r	100	0.049740	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 (eq_sym v5) = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_assoc	100	0.071714	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 v4 : v0) (v5 : v1 = v2) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (eq_trans v5 (eq_trans v6 v9) = eq_trans (eq_trans v5 v6) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_map	100	0.065083	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v1, Type) (v3 : forall v3 : v0, v1) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v2 (v3 v4), rew [fun v10 : v0 => v2 (v3 v10)] v8 in v9 = rew [v2] f_equal v3 v8 in v9) with | eq_refl => fun v7 : v2 (v3 v4) => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map	100	0.086284	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v1 v2) (v6 : v1 v3) (v7 : v1 v4) (v8 : v2 = v3) (v9 : v3 = v4) (v10 : rew [v1] v8 in v5 = v6) (v11 : rew [v1] v9 in v6 = v7) => match v9 as v13 in (_ = v12) return (forall (v14 : v1 v12) (v15 : rew [v1] v13 in v6 = v14), rew [v1] eq_trans v8 v13 in v5 = v14) with | eq_refl => fun (v12 : v1 v3) (v13 : rew [v1] eq_refl in v6 = v12) => eq_trans v10 v13 end v7 v11)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst	100	0.058679	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v1 v3), v2 v3) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v4, rew [v2] v8 in v3 v4 v9 = v3 v7 (rew [v1] v8 in v9)) with | eq_refl => fun v7 : v1 v4 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst_map	100	0.072513	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v6 = v7) => match v8 as v10 in (_ = v9) return (forall v11 : v2 v6, rew [v3] f_equal v4 v10 in v5 v6 v11 = v5 v9 (rew [v2] v10 in v11)) with | eq_refl => fun v9 : v2 v6 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_swap	100	0.056593	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall (v7 : v1 v2) (v8 : v1 v5) (v9 : rew [v1] v6 in v7 = v8), v7 = rew <- [v1] v6 in v8) with | eq_refl => fun (v5 v6 : v1 v2) (v7 : rew [v1] eq_refl in v5 = v6) => v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_compose	100	0.081670	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) (v6 : v3 = v4) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] v8 in rew [v1] v5 in v9 = rew [v1] eq_trans v5 v8 in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_l	100	0.101543	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v2 = v1 v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 v3)) (v2 v3)) (fun v4 : v1 v3 = v1 v3 => match v2 v3 as v6 in (_ = v5) return (v1 v3 = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : v3 = v1 v3 := v2 v3 in let v5 : v0 := v1 v3 in match v4 as v7 in (_ = v6) return (match v7 as v9 in (_ = v8) return (v6 = v1 v8) with | eq_refl => eq_trans (eq_sym v7) (v2 v3) end = v2 v6) with | eq_refl => let v6 : v3 = v1 v3 := v2 v3 in let v7 : v0 := v1 v3 in match v6 as v9 in (_ = v8) return (eq_trans (eq_sym eq_refl) v9 = v9) with | eq_refl => eq_refl end end) eq_refl (eq_trans_sym_inv_l (v2 v3)) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_r	100	0.546317	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v1 v2 = v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 (v1 (v1 v3)))) (v2 (v1 (v1 v3)))) (fun v4 : v1 (v1 v3) = v1 (v1 v3) => match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : forall v4 : v0, v4 = v1 v4 := fun v4 : v0 => eq_sym (v2 v4) in (let v5 : f_equal v1 (v4 (v1 v3)) = v4 (v1 (v1 v3)) := eq_id_comm_l v1 v4 (v1 v3) in let v6 : v1 (v1 v3) = v1 (v1 (v1 v3)) := v4 (v1 (v1 v3)) in match v5 as v8 in (_ = v7) return (match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans v7 (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => let v7 : f_equal v1 (v4 v3) = v4 (v1 v3) := eq_id_comm_l v1 v4 v3 in let v8 : v1 v3 = v1 (v1 v3) := v4 (v1 v3) in match v7 as v10 in (_ = v9) return (match v2 v3 as v12 in (_ = v11) return (v1 (v1 v3) = v1 v11) with | eq_refl => eq_trans (f_equal v1 v9) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => (let v9 : v1 v3 = v3 := v2 v3 in match v9 as v11 in (_ = v10) return (match v11 as v13 in (_ = v12) return (v1 (v1 v10) = v1 v12) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (eq_sym v11))) (v2 (v1 (v1 v3))) end = v2 (v1 v10)) with | eq_refl => eq_ind_r (fun v10 : v1 (v1 (v1 v3)) = v1 (v1 v3) => v10 = v2 (v1 (v1 v3))) eq_refl (eq_trans_refl_l (v2 (v1 (v1 v3)))) : eq_trans (f_equal v1 (f_equal v1 (eq_sym eq_refl))) (v2 (v1 (v1 v3))) = v2 (v1 (v1 v3)) end) : match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (v4 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3) end end) : match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => eq_trans (v4 (v1 (v1 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) eq_refl (eq_trans_sym_inv_l (v2 (v1 (v1 v3)))) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_refl_map_distr	100	0.043701	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : v0) (v3 : forall v3 : v0, v1) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map_distr	100	0.070990	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v5 (eq_trans v6 v9) = eq_trans (f_equal v5 v6) (f_equal v5 v9)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_map_distr	100	0.071890	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : forall v4 : v0, v1) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (eq_sym (f_equal v4 v7) = f_equal v4 (eq_sym v7)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_distr	100	0.078583	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) => match v4 as v6 in (_ = v5) return (forall v7 : v5 = v3, eq_sym (eq_trans v6 v7) = eq_trans (eq_sym v7) (eq_sym v6)) with | eq_refl => fun v5 : v1 = v3 => match v5 as v7 in (_ = v6) return (eq_sym (eq_trans eq_refl v7) = eq_trans (eq_sym v7) (eq_sym eq_refl)) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_rew_distr	100	0.090374	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (forall (v8 : v6 = v4) (v9 : v1 v2), rew [v1] eq_trans v7 v8 in v9 = rew [v1] v8 in rew [v1] v7 in v9) with | eq_refl => fun v6 : v2 = v4 => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] eq_trans eq_refl v8 in v9 = rew [v1] v8 in rew [v1] eq_refl in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_const	100	0.032034	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall v7 : v1, rew [fun v8 : v0 => v1] v6 in v7 = v7) with | eq_refl => fun v5 : v1 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.unique_existence	100	0.095652	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) => conj (fun v2 : (exists v2 : v0, v1 v2) /\ uniqueness v1 => match v2 as v3 in (_ /\ _) return (exists ! v4 : v0, v1 v4) with | conj v3 v4 => (fun (v3 : exists v3 : v0, v1 v3) (v4 : uniqueness v1) => match v3 as v5 in (ex _) return (exists ! v6 : v0, v1 v6) with | ex_intro _ v5 v6 => (fun (v5 : v0) (v6 : v1 v5) => ex_intro (unique (fun v7 : v0 => v1 v7)) v5 (conj v6 (fun (v7 : v0) (v8 : v1 v7) => v4 v5 v7 v6 v8) : unique (fun v7 : v0 => v1 v7) v5)) v5 v6 end) v3 v4 end) (fun v2 : exists ! v2 : v0, v1 v2 => match v2 as v3 in (ex _) return ((exists v4 : v0, v1 v4) /\ uniqueness v1) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return ((exists v6 : v0, v1 v6) /\ uniqueness v1) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) => conj (ex_intro (fun v7 : v0 => v1 v7) v3 v5) ((fun (v7 v8 : v0) (v9 : v1 v7) (v10 : v1 v8) => eq_trans (eq_sym (v6 v7 v9)) (v6 v8 v10)) : uniqueness v1)) v5 v6 end) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_unique_domain_coincide	100	0.102135	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists ! v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (forall v4 : forall v4 : v0, Prop, (forall (v5 : v0) (v6 : v1 v5), v4 v5) <-> (exists v5 : v0, v1 v5 /\ v4 v5)) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return (forall v6 : forall v6 : v0, Prop, (forall (v7 : v0) (v8 : v1 v7), v6 v7) <-> (exists v7 : v0, v1 v7 /\ v6 v7)) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) (v7 : forall v7 : v0, Prop) => conj (fun v8 : forall (v8 : v0) (v9 : v1 v8), v7 v8 => ex_intro (fun v9 : v0 => v1 v9 /\ v7 v9) v3 (conj v5 (v8 v3 v5))) (fun v8 : exists v8 : v0, v1 v8 /\ v7 v8 => match v8 as v9 in (ex _) return (forall (v10 : v0) (v11 : v1 v10), v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v0) (v10 : v1 v9 /\ v7 v9) => match v10 as v11 in (_ /\ _) return (forall (v12 : v0) (v13 : v1 v12), v7 v12) with | conj v11 v12 => (fun (v11 : v1 v9) (v12 : v7 v9) (v13 : v0) (v14 : v1 v13) => let v15 : v9 = v13 := eq_trans (eq_sym (v6 v9 v11)) (v6 v13 v14) in match v15 as v17 in (_ = v16) return (forall v18 : v1 v16, v7 v16) with | eq_refl => fun v16 : v1 v9 => v12 end v14) v11 v12 end) v9 v10 end)) v5 v6 end) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_coincide_unique_domain	100	0.146799	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : forall v2 : v0, Prop, (forall (v3 : v0) (v4 : v1 v3), v2 v3) <-> (exists v3 : v0, v1 v3 /\ v2 v3)) => let v3 : (forall v3 : forall (v3 : v0) (v4 : v1 v3), v1 v3, exists v4 : v0, v1 v4 /\ v1 v4) /\ (forall (v3 : exists v3 : v0, v1 v3 /\ v1 v3) (v4 : v0) (v5 : v1 v4), v1 v4) := v2 v1 in match v3 as v4 in (_ /\ _) return (exists ! v5 : v0, v1 v5) with | conj v4 v5 => (fun (v4 : forall v4 : forall (v4 : v0) (v5 : v1 v4), v1 v4, exists v5 : v0, v1 v5 /\ v1 v5) (v5 : forall (v5 : exists v5 : v0, v1 v5 /\ v1 v5) (v6 : v0) (v7 : v1 v6), v1 v6) => let v6 : exists v6 : v0, v1 v6 /\ v1 v6 := v4 (fun (v6 : v0) (v7 : v1 v6) => v7) in match v6 as v7 in (ex _) return (exists ! v8 : v0, v1 v8) with | ex_intro _ v7 v8 => (fun (v7 : v0) (v8 : v1 v7 /\ v1 v7) => match v8 as v9 in (_ /\ _) return (exists ! v10 : v0, v1 v10) with | conj v9 v10 => (fun v9 v10 : v1 v7 => ex_intro (unique (fun v11 : v0 => v1 v11)) v7 (conj v9 (let v11 : (forall v11 : forall (v11 : v0) (v12 : v1 v11), v7 = v11, exists v12 : v0, v1 v12 /\ v7 = v12) /\ (forall (v11 : exists v11 : v0, v1 v11 /\ v7 = v11) (v12 : v0) (v13 : v1 v12), v7 = v12) := v2 (fun v11 : v0 => v7 = v11) in match v11 as v12 in (_ /\ _) return (forall (v13 : v0) (v14 : v1 v13), v7 = v13) with | conj v12 v13 => (fun (v12 : forall v12 : forall (v12 : v0) (v13 : v1 v12), v7 = v12, exists v13 : v0, v1 v13 /\ v7 = v13) (v13 : forall (v13 : exists v13 : v0, v1 v13 /\ v7 = v13) (v14 : v0) (v15 : v1 v14), v7 = v14) => v13 (ex_intro (fun v14 : v0 => v1 v14 /\ v7 = v14) v7 (conj v9 eq_refl))) v12 v13 end))) v9 v10 end) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.exists_inhabited	100	0.026939	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (inhabited v0) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : v1 v3) => inhabits v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.inhabited_covariant	100	0.028594	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, v1) (v3 : inhabited v0) => match v3 as v4 in (inhabited _) return (inhabited v1) with | inhabits v4 => (fun v4 : v0 => inhabits (v2 v4)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_stepl	100	0.025890	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) (v5 : v1 = v3) => eq_ind v1 (fun v6 : v0 => v6 = v2) v4 v3 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_stepl	100	0.032677	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v0 <-> v2, v2 <-> v1) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v0 <-> v2) => match v6 as v7 in (_ /\ _) return (v2 <-> v1) with | conj v7 v8 => (fun (v7 : forall v7 : v0, v2) (v8 : forall v8 : v2, v0) => conj (fun v9 : v2 => v4 (v5 (v4 (v8 v9)))) (fun v9 : v1 => v7 (v5 v9))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.eq_ex_uncurried	100	0.137211	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 v3 : v0) (v4 : v1 v2) (v5 : v1 v3) (v6 : exists v6 : v2 = v3, rew [v1] v6 in v4 = v5) => match v6 as v7 in (ex _) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v5) with | ex_intro _ v7 v8 => (fun (v7 : v2 = v3) (v8 : rew [v1] v7 in v4 = v5) => match v8 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v9) with | eq_refl => match v7 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v9 (rew [v1] v10 in v4)) with | eq_refl => eq_refl end : ex_intro v1 v2 v4 = ex_intro v1 v3 (rew [v1] v7 in v4) end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.rew_ex	100	0.138921	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : exists v4 : v2 v1, v3 v1 v4) (v5 : v0) (v6 : v1 = v5) => match v6 as v8 in (_ = v7) return (rew [fun v9 : v0 => exists v10 : v2 v9, v3 v9 v10] v8 in v4 = match v4 as v9 in (ex _) return (exists v10 : v2 v7, v3 v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) => ex_intro (v3 v7) (rew [v2] v8 in v9) match v8 as v12 in (_ = v11) return (v3 v11 (rew [v2] v12 in v9)) with | eq_refl => v10 end) v9 v10 end) with | eq_refl => match v4 as v7 in (ex _) return (rew [fun v8 : v0 => exists v9 : v2 v8, v3 v8 v9] eq_refl in v7 = match v7 as v8 in (ex _) return (exists v9 : v2 v1, v3 v1 v9) with | ex_intro _ v8 v9 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) => ex_intro (v3 v1) (rew [v2] eq_refl in v8) v9) v8 v9 end) with | ex_intro _ v7 v8 => (fun (v7 : v2 v1) (v8 : v3 v1 v7) => eq_refl) v7 v8 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.eq_ex2_uncurried	100	0.136596	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : v0, Prop) (v3 v4 : v0) (v5 : v1 v3) (v6 : v1 v4) (v7 : v2 v3) (v8 : v2 v4) (v9 : exists2 v9 : v3 = v4, rew [v1] v9 in v5 = v6 & rew [v2] v9 in v7 = v8) => match v9 as v10 in (ex2 _ _) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v8) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v3 = v4) (v11 : rew [v1] v10 in v5 = v6) (v12 : rew [v2] v10 in v7 = v8) => match v12 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v13) with | eq_refl => match v11 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v13 (rew [v2] v10 in v7)) with | eq_refl => match v10 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v13 (rew [v1] v14 in v5) (rew [v2] v14 in v7)) with | eq_refl => eq_refl : ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v3 (rew [v1] eq_refl in v5) (rew [v2] eq_refl in v7) end end end) v10 v11 v12 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.rew_ex2	100	0.185923	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : forall (v4 : v0) (v5 : v2 v4), Prop) (v5 : exists2 v5 : v2 v1, v3 v1 v5 & v4 v1 v5) (v6 : v0) (v7 : v1 = v6) => match v7 as v9 in (_ = v8) return (rew [fun v10 : v0 => exists2 v11 : v2 v10, v3 v10 v11 & v4 v10 v11] v9 in v5 = match v5 as v10 in (ex2 _ _) return (exists2 v11 : v2 v8, v3 v8 v11 & v4 v8 v11) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v2 v1) (v11 : v3 v1 v10) (v12 : v4 v1 v10) => ex_intro2 (v3 v8) (v4 v8) (rew [v2] v9 in v10) match v9 as v14 in (_ = v13) return (v3 v13 (rew [v2] v14 in v10)) with | eq_refl => v11 end match v9 as v14 in (_ = v13) return (v4 v13 (rew [v2] v14 in v10)) with | eq_refl => v12 end) v10 v11 v12 end) with | eq_refl => match v5 as v8 in (ex2 _ _) return (rew [fun v9 : v0 => exists2 v10 : v2 v9, v3 v9 v10 & v4 v9 v10] eq_refl in v8 = match v8 as v9 in (ex2 _ _) return (exists2 v10 : v2 v1, v3 v1 v10 & v4 v1 v10) with | ex_intro2 _ _ v9 v10 v11 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) (v11 : v4 v1 v9) => ex_intro2 (v3 v1) (v4 v1) (rew [v2] eq_refl in v9) v10 v11) v9 v10 v11 end) with | ex_intro2 _ _ v8 v9 v10 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) (v10 : v4 v1 v8) => eq_refl) v8 v9 v10 end end)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.prop_congr	100	0.026858	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @bool) (v2 : v0 = v1) => (fun v3 : v1 = v1 => eq_ind_r (fun v4 : @bool => v4 = v1) v3 v2) (erefl v1))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.is_true_true	100	0.012938	1	1	0	synth with cache (only 1: refine (erefl (@true) : @true)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.not_false_is_true	100	0.023540	1	1	0	synth with cache (only 1: refine ((fun v0 : @false => let v1 : @False := eq_ind (@false) (fun v1 : @bool => match v1 as v2 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v0 in False_ind (@False) v1) : ~ @false)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.is_true_locked_true	100	0.030444	1	1	0	synth with cache (only 1: refine ((fun v0 : (fun v0 : @unit => is_true (match v0 as v1 in unit return (forall v2 : @bool, @bool) with | tt => id end (@true))) (@tt) => match @master_key as v1 in unit return ((fun v2 : @unit => is_true (match v2 as v3 in unit return (forall v4 : @bool, @bool) with | tt => id end (@true))) v1) with | tt => v0 end) (erefl (@true) : @true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbT	100	0.036215	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : v1 = @false, ~~ v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : v2 = @false, ~~ v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : v4 = @false, ~~ v4) v3) with | true => v1 | false => v2 end) ([eta eq_sym (y:=~~ @true)] : (forall v1 : @true = @false, ~~ @true)) (fun v1 : @false = @false => @is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbTE	100	0.036530	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : ~~ v1, v1 = @false) (@true)) (v2 : (fun v2 : @bool => forall v3 : ~~ v2, v2 = @false) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : ~~ v4, v4 = @false) v3) with | true => v1 | false => v2 end) ([eta eq_sym (y:=@true)] : (forall v1 : ~~ @true, @true = @false)) (fun v1 : ~~ @false => erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbF	100	0.089145	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : v1, ~~ v1 = @false) (@true)) (v2 : (fun v2 : @bool => forall v3 : v2, ~~ v2 = @false) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : v4, ~~ v4 = @false) v3) with | true => v1 | false => v2 end) (fun v1 : @true => erefl (@false)) ([eta eq_sym (y:=~~ @false)] : (forall v1 : @false, ~~ @false = @false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbFE	100	0.037206	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : ~~ v1 = @false, v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : ~~ v2 = @false, v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : ~~ v4 = @false, v4) v3) with | true => v1 | false => v2 end) (fun v1 : ~~ @true = @false => @is_true_true) ([eta eq_sym (y:=@false)] : (forall v1 : ~~ @false = @false, @false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbK	100	0.026142	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => ~~ ~~ v1 = v1) (@true)) (v2 : (fun v2 : @bool => ~~ ~~ v2 = v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => ~~ ~~ v4 = v4) v3) with | true => v1 | false => v2 end) (erefl (@true)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbNE	100	0.033055	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : ~~ ~~ v1, v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : ~~ ~~ v2, v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : ~~ ~~ v4, v4) v3) with | true => v1 | false => v2 end) id id)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negb_inj	100	0.017386	1	1	0	synth with cache (only 1: refine (can_inj (@negbK))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbLR	100	0.031354	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => [eta eq_ind_r (fun v3 : @bool => ~~ v3 = v1) (Bool.negb_involutive v1) (y:=v0)])).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negbRL	100	0.027184	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (canRL (x:=v0))^~ (@negbK))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contra	100	0.071305	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : v0, v2) (v4 : ~~ v2), ~~ v0) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : v0, v3) (v5 : ~~ v3), ~~ v0) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : v0, v5) (v7 : ~~ v5), ~~ v0) v4) with | true => v2 | false => v3 end) ((fun (v2 : forall v2 : v0, @true) (v3 : ~~ @true) => let v4 : @False := eq_ind (~~ @true) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (~~ v0) v4) : (forall (v2 : forall v2 : v0, @true) (v3 : ~~ @true), ~~ v0)) ((fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : v2, @false) (v4 : ~~ @false), ~~ v2) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : v3, @false) (v5 : ~~ @false), ~~ v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : v5, @false) (v7 : ~~ @false), ~~ v5) v4) with | true => v2 | false => v3 end) id (fun v2 : forall v2 : @false, @false => id)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraL	100	0.071273	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : v0, ~~ v2) (v4 : v2), ~~ v0) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : v0, ~~ v3) (v5 : v3), ~~ v0) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : v0, ~~ v5) (v7 : v5), ~~ v0) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : v2, ~~ @true) (v4 : @true), ~~ v2) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : v3, ~~ @true) (v5 : @true), ~~ v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : v5, ~~ @true) (v7 : @true), ~~ v5) v4) with | true => v2 | false => v3 end) id (fun v2 : forall v2 : @false, ~~ @true => id)) ((fun (v2 : forall v2 : v0, ~~ @false) (v3 : @false) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (~~ v0) v4) : (forall (v2 : forall v2 : v0, ~~ @false) (v3 : @false), ~~ v0)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraR	100	0.076158	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : ~~ v0, v2) (v4 : ~~ v2), v0) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : ~~ v0, v3) (v5 : ~~ v3), v0) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : ~~ v0, v5) (v7 : ~~ v5), v0) v4) with | true => v2 | false => v3 end) ((fun (v2 : forall v2 : ~~ v0, @true) (v3 : ~~ @true) => let v4 : @False := eq_ind (~~ @true) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind v0 v4) : (forall (v2 : forall v2 : ~~ v0, @true) (v3 : ~~ @true), v0)) ((fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : ~~ v2, @false) (v4 : ~~ @false), v2) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : ~~ v3, @false) (v5 : ~~ @false), v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : ~~ v5, @false) (v7 : ~~ @false), v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : ~~ @true, @false => id) id))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraLR	100	0.069948	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : ~~ v0, ~~ v2) (v4 : v2), v0) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : ~~ v0, ~~ v3) (v5 : v3), v0) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : ~~ v0, ~~ v5) (v7 : v5), v0) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall (v3 : forall v3 : ~~ v2, ~~ @true) (v4 : @true), v2) (@true)) (v3 : (fun v3 : @bool => forall (v4 : forall v4 : ~~ v3, ~~ @true) (v5 : @true), v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall (v6 : forall v6 : ~~ v5, ~~ @true) (v7 : @true), v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : ~~ @true, ~~ @true => id) id) ((fun (v2 : forall v2 : ~~ v0, ~~ @false) (v3 : @false) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind v0 v4) : (forall (v2 : forall v2 : ~~ v0, ~~ @false) (v3 : @false), v0)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraT	100	0.045464	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : forall v2 : ~~ v1, @false, v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : forall v3 : ~~ v2, @false, v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : forall v5 : ~~ v4, @false, v4) v3) with | true => v1 | false => v2 end) (fun v1 : forall v1 : ~~ @true, @false => @is_true_true) (fun v1 : forall v1 : ~~ @false, @false => (fun (v2 : @true) (v3 : ~~ @false) => eq_ind_r [eta is_true] v2 (v1 v3)) (@is_true_true) (@is_true_true)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.wlog_neg	100	0.038594	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : forall v2 : ~~ v1, v1, v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : forall v3 : ~~ v2, v2, v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : forall v5 : ~~ v4, v4, v4) v3) with | true => v1 | false => v2 end) (fun v1 : forall v1 : ~~ @true, @true => @is_true_true) (fun v1 : forall v1 : ~~ @false, @false => (fun (v2 : @true) (v3 : ~~ @false) => eq_ind_r [eta is_true] v2 (v1 v3)) (@is_true_true) (@is_true_true)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraFT	100	0.035972	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @bool) (v2 : forall v2 : ~~ v0, v1) => ((fun (v3 : forall v3 : ~~ v1, v0) (v4 : v1 = @false) => (v3 : (forall v5 : ~~ v1, v0)) (negbT v4)) : (forall (v3 : forall v3 : ~~ v1, v0) (v4 : v1 = @false), v0)) (contraR v2))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraFN	100	0.032292	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @bool) (v2 : forall v2 : v0, v1) => ((fun (v3 : forall v3 : ~~ v1, ~~ v0) (v4 : v1 = @false) => (v3 : (forall v5 : ~~ v1, ~~ v0)) (negbT v4)) : (forall (v3 : forall v3 : ~~ v1, ~~ v0) (v4 : v1 = @false), ~~ v0)) (contra v2))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraTF	100	0.033079	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @bool) (v2 : forall v2 : v0, ~~ v1) => ((fun (v3 : forall v3 : v1, ~~ v0) (v4 : v1) => (id : (forall v5 : v0 = @false, v0 = @false)) (negbTE (v3 v4))) : (forall (v3 : forall v3 : v1, ~~ v0) (v4 : v1), v0 = @false)) (contraL v2))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraNF	100	0.034738	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @bool) (v2 : forall v2 : v0, v1) => ((fun (v3 : forall v3 : ~~ v1, ~~ v0) (v4 : ~~ v1) => (id : (forall v5 : v0 = @false, v0 = @false)) (negbTE (v3 v4))) : (forall (v3 : forall v3 : ~~ v1, ~~ v0) (v4 : ~~ v1), v0 = @false)) (contra v2))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.contraFF	100	0.041965	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @bool) (v2 : forall v2 : v0, v1) => ((fun (v3 : forall v3 : v1 = @false, ~~ v0) (v4 : v1 = @false) => (id : (forall v5 : v0 = @false, v0 = @false)) (negbTE (v3 v4))) : (forall (v3 : forall v3 : v1 = @false, ~~ v0) (v4 : v1 = @false), v0 = @false)) (contraFN v2))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.ifP	100	0.078964	1	1	0	synth with cache (only 1: refine ((fun (v0 : (fun v0 : @bool => forall v1 : protect_term (@b = v0), if_spec (v0 = @false) v0 match v0 as v2 in bool return (@A) with | true => @vT | false => @vF end) (@true)) (v1 : (fun v1 : @bool => forall v2 : protect_term (@b = v1), if_spec (v1 = @false) v1 match v1 as v3 in bool return (@A) with | true => @vT | false => @vF end) (@false)) => match @b as v2 in bool return ((fun v3 : @bool => forall v4 : protect_term (@b = v3), if_spec (v3 = @false) v3 match v3 as v5 in bool return (@A) with | true => @vT | false => @vF end) v2) with | true => v0 | false => v1 end) ([eta IfSpecTrue (@true = @false)] : (forall v0 : protect_term (@b = @true), if_spec (@true = @false) (@true) (@vT))) ((fun v0 : @b = @false => IfSpecFalse (erefl (@false))) : (forall v0 : protect_term (@b = @false), if_spec (@false = @false) (@false) (@vF))) (erefl (@b)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.ifPn	100	0.081089	1	1	0	synth with cache (only 1: refine ((fun (v0 : (fun v0 : @bool => forall v1 : protect_term (@b = v0), if_spec (~~ v0) v0 match v0 as v2 in bool return (@A) with | true => @vT | false => @vF end) (@true)) (v1 : (fun v1 : @bool => forall v2 : protect_term (@b = v1), if_spec (~~ v1) v1 match v1 as v3 in bool return (@A) with | true => @vT | false => @vF end) (@false)) => match @b as v2 in bool return ((fun v3 : @bool => forall v4 : protect_term (@b = v3), if_spec (~~ v3) v3 match v3 as v5 in bool return (@A) with | true => @vT | false => @vF end) v2) with | true => v0 | false => v1 end) ((fun v0 : @b = @true => IfSpecTrue (~~ @true) ((fun v1 : @true => eq_ind_r [eta is_true] v1 v0) (@is_true_true))) : (forall v0 : protect_term (@b = @true), if_spec (~~ @true) (@true) (@vT))) ((fun v0 : @b = @false => IfSpecFalse (@is_true_true)) : (forall v0 : protect_term (@b = @false), if_spec (~~ @false) (@false) (@vF))) (erefl (@b)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.ifT	100	0.045876	1	1	0	synth with cache (only 1: refine (fun v0 : @b => (fun v1 : match @true as v1 in bool return (@A) with | true => @vT | false => @vF end = @vT => eq_ind_r (fun v2 : @bool => match v2 as v3 in bool return (@A) with | true => @vT | false => @vF end = @vT) v1 v0) (erefl (@vT)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.ifF	100	0.047369	1	1	0	synth with cache (only 1: refine (fun v0 : @b = @false => (fun v1 : match @false as v1 in bool return (@A) with | true => @vT | false => @vF end = @vF => eq_ind_r (fun v2 : @bool => match v2 as v3 in bool return (@A) with | true => @vT | false => @vF end = @vF) v1 v0) (erefl (@vF)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.ifN	100	0.056361	1	1	0	synth with cache (only 1: refine (fun v0 : ~~ @b => ((fun v1 : @b = @false => (fun v2 : match @false as v2 in bool return (@A) with | true => @vT | false => @vF end = @vF => eq_ind_r (fun v3 : @bool => match v3 as v4 in bool return (@A) with | true => @vT | false => @vF end = @vF) v2 v1) (erefl (@vF))) : (forall v1 : @b = @false, match @b as v2 in bool return (@A) with | true => @vT | false => @vF end = @vF)) (negbTE v0))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.if_same	100	0.037869	1	1	0	synth with cache (only 1: refine match @b as v0 in bool return (match v0 as v1 in bool return (@A) with | true | _ => @vT end = @vT) with | true | _ => erefl (@vT) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.if_neg	100	0.058741	1	1	0	synth with cache (only 1: refine match @b as v0 in bool return (match ~~ v0 as v1 in bool return (@A) with | true => @vT | false => @vF end = match v0 as v1 in bool return (@A) with | true => @vF | false => @vT end) with | true => erefl (@vF) | false => erefl (@vT) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.fun_if	100	0.060964	1	1	0	synth with cache (only 1: refine match @b as v0 in bool return (f match v0 as v1 in bool return (@A) with | true => @vT | false => @vF end = match v0 as v1 in bool return (@B) with | true => f (@vT) | false => f (@vF) end) with | true => erefl (f (@vT)) | false => erefl (f (@vF)) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.if_arg	100	0.017762	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.BoolIf.ifE	100	0.031296	1	1	0	synth with cache (only 1: refine (erefl (@if_expr))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectCore.introNTF	100	0.065817	1	1
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectCore.introTF	100	0.064226	1	1
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectCore.elimNTF	100	0.056722	1	1	0	synth with cache (only 1: refine (fun v0 : ~~ @b = @c => (fun v1 : match ~~ @b as v1 in bool return Prop with | true => ~ @P | false => @P end => eq_ind (~~ @b) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => ~ @P | false => @P end) v1 (@c) v0) match @Hb as v2 in (reflect _ v1) return match ~~ v1 as v3 in bool return Prop with | true => ~ @P | false => @P end with | ReflectT _ v1 => id v1 | ReflectF _ v1 => id v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectCore.elimTF	100	0.054768	1	1	0	synth with cache (only 1: refine (fun v0 : @b = @c => (fun v1 : match @b as v1 in bool return Prop with | true => @P | false => ~ @P end => eq_ind (@b) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @P | false => ~ @P end) v1 (@c) v0) match @Hb as v2 in (reflect _ v1) return match v1 as v3 in bool return Prop with | true => @P | false => ~ @P end with | ReflectT _ v1 => id v1 | ReflectF _ v1 => id v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectCore.equivPif	100	0.105835	1	1
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectCore.xorPif	100	0.061219	1	1
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectNegCore.introTFn	100	0.046856	1	1	0	synth with cache (only 1: refine (fun v0 : match @c as v0 in bool return Prop with | true => ~ @P | false => @P end => ((fun v1 : ~~ ~~ @b = @c => (fun v2 : @b = ~~ ~~ @b => eq_ind (~~ ~~ @b) [eta eq (@b)] v2 (@c) v1) match @b as v2 in bool return (v2 = ~~ ~~ v2) with | true => erefl (~~ ~~ @true) | false => erefl (~~ ~~ @false) end) : (forall v1 : ~~ ~~ @b = @c, @b = @c)) (introNTF (@Hb) v0))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectNegCore.elimTFn	100	0.053894	1	1	0	synth with cache (only 1: refine (fun v0 : @b = @c => (fun v1 : match @b as v1 in bool return Prop with | true => ~ @P | false => @P end => eq_ind (@b) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => ~ @P | false => @P end) v1 (@c) v0) (elimNTF (@Hb) match @b as v1 in bool return (~~ ~~ v1 = v1) with | true => erefl (@true) | false => erefl (@false) end))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectNegCore.equivPifn	100	0.051018	1	1	0	synth with cache (only 1: refine ((fun v0 : forall (v0 : forall v0 : @Q, @P) (v1 : forall v1 : @P, @Q), match ~~ @b as v2 in bool return Prop with | true => @Q | false => ~ @Q end => eq_ind match ~~ @b as v1 in bool return Prop with | true => @Q | false => ~ @Q end (fun v1 : Prop => forall (v2 : forall v2 : @Q, @P) (v3 : forall v3 : @P, @Q), v1) v0 match @b as v1 in bool return Prop with | true => ~ @Q | false => @Q end (if_neg (@b) (@Q) (~ @Q))) (equivPif (@Hb)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectNegCore.xorPifn	100	0.052871	1	1	0	synth with cache (only 1: refine ((fun v0 : forall (v0 : @Q \/ @P) (v1 : ~ (@Q /\ @P)), match ~~ @b as v2 in bool return Prop with | true => ~ @Q | false => @Q end => eq_ind match ~~ @b as v1 in bool return Prop with | true => ~ @Q | false => @Q end (fun v1 : Prop => forall (v2 : @Q \/ @P) (v3 : ~ (@Q /\ @P)), v1) v0 match @b as v1 in bool return Prop with | true => @Q | false => ~ @Q end (if_neg (@b) (~ @Q) (@Q))) (xorPif (@Hb)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.introT	100	0.013181	1	1	0	synth with cache (only 1: refine (introTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.introF	100	0.017543	1	1	0	synth with cache (only 1: refine (introTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.introN	100	0.016530	1	1	0	synth with cache (only 1: refine (introNTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.introNf	100	0.017943	1	1	0	synth with cache (only 1: refine (introNTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.introTn	100	0.014621	1	1	0	synth with cache (only 1: refine (introTFn (@Pb'))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.introFn	100	0.016246	1	1	0	synth with cache (only 1: refine (introTFn (@Pb'))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.elimT	100	0.013581	1	1	0	synth with cache (only 1: refine (elimTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.elimF	100	0.018619	1	1	0	synth with cache (only 1: refine (elimTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.elimN	100	0.017181	1	1	0	synth with cache (only 1: refine (elimNTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.elimNf	100	0.019239	1	1	0	synth with cache (only 1: refine (elimNTF (@Pb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.elimTn	100	0.015571	1	1	0	synth with cache (only 1: refine (elimTFn (@Pb'))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.elimFn	100	0.018302	1	1	0	synth with cache (only 1: refine (elimTFn (@Pb'))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.introP	100	0.040580	1	1	0	synth with cache (only 1: refine match @b as v0 in bool return (forall (v1 : forall v1 : v0, @Q) (v2 : forall v2 : ~~ v0, ~ @Q), reflect (@Q) v0) with | true => fun (v0 : forall v0 : @true, @Q) (v1 : forall v1 : ~~ @true, ~ @Q) => ReflectT (@Q) (v0 (@is_true_true)) | false => fun (v0 : forall v0 : @false, @Q) (v1 : forall v1 : ~~ @false, ~ @Q) => ReflectF (@Q) (v1 (@is_true_true)) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.iffP	100	0.045266	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @P, (fun (v1 : @bool) (v2 : reflect (@P) v1) => forall (v3 : forall v3 : @P, @Q) (v4 : forall v4 : @Q, @P), reflect (@Q) v1) (@true) (ReflectT (@P) v0)) (v1 : forall v1 : ~ @P, (fun (v2 : @bool) (v3 : reflect (@P) v2) => forall (v4 : forall v4 : @P, @Q) (v5 : forall v5 : @Q, @P), reflect (@Q) v2) (@false) (ReflectF (@P) v1)) => match @Pb as v3 in (reflect _ v2) return ((fun (v4 : @bool) (v5 : reflect (@P) v4) => forall (v6 : forall v6 : @P, @Q) (v7 : forall v7 : @Q, @P), reflect (@Q) v4) v2 v3) with | ReflectT _ v2 => v0 v2 | ReflectF _ v2 => v1 v2 end) (fun (v0 : @P) (v1 : forall v1 : @P, @Q) (v2 : forall v2 : @Q, @P) => ReflectT (@Q) (v1 v0)) (fun (v0 : ~ @P) (v1 : forall v1 : @P, @Q) (v2 : forall v2 : @Q, @P) => ReflectF (@Q) ((fun v3 : @Q => v0 (v2 v3)) : ~ @Q)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.equivP	100	0.032146	1	1	0	synth with cache (only 1: refine (fun v0 : @P <-> @Q => (fun v1 : forall (v1 : forall v1 : @P, @Q) (v2 : forall v2 : @Q, @P), (fun v3 : (forall v3 : @P, @Q) /\ (forall v3 : @Q, @P) => reflect (@Q) (@b)) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : (forall v3 : @P, @Q) /\ (forall v3 : @Q, @P) => reflect (@Q) (@b)) v2) with | conj v2 v3 => v1 v2 v3 end) (@iffP))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.sumboolP	100	0.011723	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.appP	100	0.049417	1	1	0	synth with cache (only 1: refine (fun (v0 : reflect (@Q) (@b)) (v1 : @P) => ((fun (v2 : forall v2 : @Q, (fun (v3 : @bool) (v4 : reflect (@Q) v3) => forall v5 : v3, @Q) (@true) (ReflectT (@Q) v2)) (v3 : forall v3 : ~ @Q, (fun (v4 : @bool) (v5 : reflect (@Q) v4) => forall v6 : v4, @Q) (@false) (ReflectF (@Q) v3)) => match v0 as v5 in (reflect _ v4) return ((fun (v6 : @bool) (v7 : reflect (@Q) v6) => forall v8 : v6, @Q) v4 v5) with | ReflectT _ v4 => v2 v4 | ReflectF _ v4 => v3 v4 end) (fun (v2 : @Q) (v3 : @true) => v2) ((fun (v2 : ~ @Q) (v3 : @false) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@Q) v4) : (forall (v2 : ~ @Q) (v3 : @false), @Q)) : (forall v2 : @b, @Q)) (introT v1))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.sameP	100	0.035952	1	1	0	synth with cache (only 1: refine (fun v0 : reflect (@P) (@c) => (fun (v1 : forall v1 : @P, (fun (v2 : @bool) (v3 : reflect (@P) v2) => @b = v2) (@true) (ReflectT (@P) v1)) (v2 : forall v2 : ~ @P, (fun (v3 : @bool) (v4 : reflect (@P) v3) => @b = v3) (@false) (ReflectF (@P) v2)) => match v0 as v4 in (reflect _ v3) return ((fun (v5 : @bool) (v6 : reflect (@P) v5) => @b = v5) v3 v4) with | ReflectT _ v3 => v1 v3 | ReflectF _ v3 => v2 v3 end) (@introT) (@introF))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.decPcases	100	0.038516	1	1
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.decP	100	0.039733	1	1	0	synth with cache (only 1: refine ((fun (v0 : (fun v0 : @bool => forall v1 : match v0 as v1 in bool return Prop with | true => @P | false => ~ @P end, decidable (@P)) (@true)) (v1 : (fun v1 : @bool => forall v2 : match v1 as v2 in bool return Prop with | true => @P | false => ~ @P end, decidable (@P)) (@false)) => match @b as v2 in bool return ((fun v3 : @bool => forall v4 : match v3 as v4 in bool return Prop with | true => @P | false => ~ @P end, decidable (@P)) v2) with | true => v0 | false => v1 end) [eta left] [eta right] (@decPcases))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.rwP	100	0.016708	1	1	0	synth with cache (only 1: refine (conj (@introT) (@elimT))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.rwP2	100	0.035801	1	1	0	synth with cache (only 1: refine (fun v0 : reflect (@Q) (@b) => conj [eta appP v0] (fun v1 : @Q => elimT ((fun (v2 : forall v2 : @Q, (fun (v3 : @bool) (v4 : reflect (@Q) v3) => is_true v3) (@true) (ReflectT (@Q) v2)) (v3 : forall v3 : ~ @Q, (fun (v4 : @bool) (v5 : reflect (@Q) v4) => is_true v4) (@false) (ReflectF (@Q) v3)) => match v0 as v5 in (reflect _ v4) return ((fun (v6 : @bool) (v7 : reflect (@Q) v6) => is_true v6) v4 v5) with | ReflectT _ v4 => v2 v4 | ReflectF _ v4 => v3 v4 end) (fun v2 : @Q => @is_true_true) ((fun v2 : ~ @Q => False_ind (@false) (v2 v1)) : (forall v2 : ~ @Q, @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.Reflect.altP	100	0.038299	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @P, (fun (v1 : @bool) (v2 : reflect (@P) v1) => forall v3 : protect_term (@b = v1), alt_spec v1) (@true) (ReflectT (@P) v0)) (v1 : forall v1 : ~ @P, (fun (v2 : @bool) (v3 : reflect (@P) v2) => forall v4 : protect_term (@b = v2), alt_spec v2) (@false) (ReflectF (@P) v1)) => match @Pb as v3 in (reflect _ v2) return ((fun (v4 : @bool) (v5 : reflect (@P) v4) => forall v6 : protect_term (@b = v4), alt_spec v4) v2 v3) with | ReflectT _ v2 => v0 v2 | ReflectF _ v2 => v1 v2 end) (fun v0 : @P => (fun v1 : @b = @true => AltTrue v0) : (forall v1 : protect_term (@b = @true), alt_spec (@true))) (fun v0 : ~ @P => (fun v1 : @b = @false => AltFalse ((fun v2 : ~~ @false => eq_ind_r (fun v3 : @bool => ~~ v3) v2 v1) (@is_true_true))) : (forall v1 : protect_term (@b = @false), alt_spec (@false))) (erefl (@b)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.impliesP	100	0.025070	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : implies v0 v1) => (fun v3 : forall v3 : forall v3 : v0, v1, (fun v4 : implies v0 v1 => forall v5 : v0, v1) (Implies v3) => match v2 as v4 in (implies _ _) return ((fun v5 : implies v0 v1 => forall v6 : v0, v1) v4) with | Implies v4 => v3 v4 end) id)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.impliesPn	100	0.028690	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Prop) (v2 : implies v0 v1) => (fun v3 : forall v3 : forall v3 : v0, v1, (fun v4 : implies v0 v1 => forall v5 : ~ v1, ~ v0) (Implies v3) => match v2 as v4 in (implies _ _) return ((fun v5 : implies v0 v1 => forall v6 : ~ v1, ~ v0) v4) with | Implies v4 => v3 v4 end) (fun (v3 : forall v3 : v0, v1) (v4 : ~ v1) (v5 : v0) => (v4 : (forall v6 : v1, @False)) (v3 v5)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.unlessL	100	0.020892	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : Type => Implies (fun (v2 : v0) (v3 : Prop) (v4 : forall v4 : v0, v3) => ((fun (v5 : v3) (v6 : forall v6 : v1, v3) => v5) : (forall (v5 : v3) (v6 : forall v6 : v1, v3), v3)) (v4 v2)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.unlessR	100	0.020407	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : Type => Implies (fun (v2 : v1) (v3 : Prop) (v4 : forall v4 : v0, v3) (v5 : forall v5 : v1, v3) => (id : (forall v6 : v3, v3)) (v5 v2)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.unless_sym	100	0.028791	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : Type => Implies (fun v2 : \unless v0, v1 => (fun v3 : forall v3 : v0, \unless v1, v0 => [eta v2 (\unless v1, v0) v3]) (unlessR v1 v0) (unlessL v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.unlessP	100	0.053407	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : Prop => conj (fun v2 : \unless v0, v1 => (fun v3 : forall v3 : v0, v0 \/ v1 => [eta v2 (v0 \/ v1) v3]) [eta or_introl (B:=v1)] [eta or_intror (B:=v1)]) (fun v2 : v0 \/ v1 => (fun (v3 : forall v3 : v0, (fun v4 : v0 \/ v1 => \unless v0, v1) (or_introl v3)) (v4 : forall v4 : v1, (fun v5 : v0 \/ v1 => \unless v0, v1) (or_intror v4)) => match v2 as v5 in (_ \/ _) return ((fun v6 : v0 \/ v1 => \unless v0, v1) v5) with | or_introl v5 => v3 v5 | or_intror v5 => v4 v5 end) (fun v3 : v0 => (@^~ v1 : (forall v4 : forall v4 : Type, \unless v0, v4, \unless v0, v1)) (fun v4 : Type => unlessL v0 v4 v3)) (fun v3 : v1 => (@^~ v0 : (forall v4 : forall v4 : Type, \unless v4, v1, \unless v0, v1)) (fun v4 : Type => unlessR v4 v1 v3))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.bind_unless	100	0.041006	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 v2 : Type => Implies (fun v3 : \unless v0, v1 => (fun v4 : forall v4 : v0, \unless (\unless v0, v2), v1 => [eta v3 (\unless (\unless v0, v2), v1) v4]) (fun v4 : v0 => [eta unlessL (\unless v0, v2) v1] ([eta unlessL v0 v2] v4)) [eta [eta unlessR (\unless v0, v2) v1]]))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.unless_contra	100	0.057213	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @bool) (v1 : Type) => Implies ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : ~~ v2, v1, \unless v1, v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ v3, v1, \unless v1, v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : ~~ v5, v1, \unless v1, v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : ~~ @true, v1 => [eta unlessR v1 (@true)] (@is_true_true)) (fun v2 : forall v2 : ~~ @false, v1 => [eta unlessL v1 (@false)] ([eta v2] (@is_true_true)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.classicP	100	0.090629	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : Prop => conj (fun (v1 : classically v0) (v2 : ~ v0) => ssr_have (forall v3 : v0, @false) (fun v3 : v0 => (([eta False_ind (@false)] : (forall v4 : @False, @false)) : (forall v4 : @False, @false)) (v2 v3)) (fun v3 : forall v3 : v0, @false => (((fun v4 : @false => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall v4 : @false, @False)) : (forall v4 : @false, @False)) (v1 (@false) v3))) (fun (v1 : ~ ~ v0) (v2 : @bool) => (fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : v0, v3, v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : v0, v4, v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : v0, v6, v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : v0, @true => @is_true_true) (fun v3 : forall v3 : v0, @false => match v1 (fun v4 : v0 => (((fun v5 : @false => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall v5 : @false, @False)) : (forall v5 : @false, @False)) (v3 v4)) as v4 in False return (@false) with end)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.classicW	100	0.023464	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : @bool) (v3 : forall v3 : v0, v2) => (fun (v4 : @true) (v5 : v0) => eq_ind_r [eta is_true] v4 (v3 v5)) (@is_true_true) v1)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.classic_bind	100	0.032757	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, classically v1) (v3 : classically v0) (v4 : @bool) (v5 : forall v5 : v1, v4) => ((fun v6 : forall v6 : v0, v4 => (id : (forall v7 : v4, v4)) (v3 v4 v6)) : (forall v6 : forall v6 : v0, v4, v4)) (fun v6 : v0 => v2 v6 v4 v5))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.classic_EM	100	0.040637	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Prop) (v1 : @bool) => (fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : decidable v0, v2, v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : decidable v0, v3, v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : decidable v0, v5, v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : decidable v0, @true => @is_true_true) (fun v2 : forall v2 : decidable v0, @false => [eta v2] (right (fun v3 : v0 => [eta notF] ([eta v2] (left v3))))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.classic_pick	100	0.062153	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : @bool) => (fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : {v4 : v0 | v1 v4} + (forall v4 : v0, ~ v1 v4), v3, v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : {v5 : v0 | v1 v5} + (forall v5 : v0, ~ v1 v5), v4, v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : {v7 : v0 | v1 v7} + (forall v7 : v0, ~ v1 v7), v6, v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : {v3 : v0 | v1 v3} + (forall v3 : v0, ~ v1 v3), @true => @is_true_true) (fun v3 : forall v3 : {v3 : v0 | v1 v3} + (forall v3 : v0, ~ v1 v3), @false => [eta v3] (inr (fun (v4 : v0) (v5 : v1 v4) => [eta notF] ([eta v3] (inl (exist [eta v1] v4 v5)))))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.classic_imply	100	0.045437	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, classically v1) (v3 : @bool) => (fun (v4 : (fun v4 : @bool => forall v5 : forall v5 : forall v5 : v0, v1, v4, v4) (@true)) (v5 : (fun v5 : @bool => forall v6 : forall v6 : forall v6 : v0, v1, v5, v5) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => forall v8 : forall v8 : forall v8 : v0, v1, v7, v7) v6) with | true => v4 | false => v5 end) (fun v4 : forall v4 : forall v4 : v0, v1, @true => @is_true_true) (fun v4 : forall v4 : forall v4 : v0, v1, @false => [eta v4] (fun v5 : v0 => ((fun v6 : classically v1 => (fun v7 : @false => match notF v7 as v8 in False return ((fun v9 : @False => v1) v8) with end) (v6 (@false) (fun v7 : v1 => v4 (fun v8 : v0 => v7)))) : (forall v6 : classically v1, v1)) (v2 v5))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.AllAnd.all_and2	100	0.060687	1	1	0	synth with cache (only 1: refine (Implies (fun v0 : forall v0 : @T, P1 v0 /\ P2 v0 => conj (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1), (fun v4 : P1 v1 /\ P2 v1 => P1 v1) (conj v2 v3) => match v0 v1 as v3 in (_ /\ _) return ((fun v4 : P1 v1 /\ P2 v1 => P1 v1) v3) with | conj v3 v4 => v2 v3 v4 end) (fun (v2 : P1 v1) (v3 : P2 v1) => v2)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1), (fun v4 : P1 v1 /\ P2 v1 => P2 v1) (conj v2 v3) => match v0 v1 as v3 in (_ /\ _) return ((fun v4 : P1 v1 /\ P2 v1 => P2 v1) v3) with | conj v3 v4 => v2 v3 v4 end) (fun v2 : P1 v1 => id))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.AllAnd.all_and3	100	0.084567	1	1	0	synth with cache (only 1: refine (Implies (fun v0 : forall v0 : @T, [/\ P1 v0, P2 v0 & P3 v0] => And3 (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1), (fun v5 : [/\ P1 v1, P2 v1 & P3 v1] => P1 v1) (And3 v2 v3 v4) => match v0 v1 as v3 in [/\ _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1 & P3 v1] => P1 v1) v3) with | And3 v3 v4 v5 => v2 v3 v4 v5 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) => v2)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1), (fun v5 : [/\ P1 v1, P2 v1 & P3 v1] => P2 v1) (And3 v2 v3 v4) => match v0 v1 as v3 in [/\ _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1 & P3 v1] => P2 v1) v3) with | And3 v3 v4 v5 => v2 v3 v4 v5 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) => v3)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1), (fun v5 : [/\ P1 v1, P2 v1 & P3 v1] => P3 v1) (And3 v2 v3 v4) => match v0 v1 as v3 in [/\ _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1 & P3 v1] => P3 v1) v3) with | And3 v3 v4 v5 => v2 v3 v4 v5 end) (fun (v2 : P1 v1) (v3 : P2 v1) => id))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.AllAnd.all_and4	100	0.116325	1	1	0	synth with cache (only 1: refine (Implies (fun v0 : forall v0 : @T, [/\ P1 v0, P2 v0, P3 v0 & P4 v0] => And4 (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1), (fun v6 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P1 v1) (And4 v2 v3 v4 v5) => match v0 v1 as v3 in [/\ _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P1 v1) v3) with | And4 v3 v4 v5 v6 => v2 v3 v4 v5 v6 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) => v2)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1), (fun v6 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P2 v1) (And4 v2 v3 v4 v5) => match v0 v1 as v3 in [/\ _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P2 v1) v3) with | And4 v3 v4 v5 v6 => v2 v3 v4 v5 v6 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) => v3)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1), (fun v6 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P3 v1) (And4 v2 v3 v4 v5) => match v0 v1 as v3 in [/\ _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P3 v1) v3) with | And4 v3 v4 v5 v6 => v2 v3 v4 v5 v6 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) => v4)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1), (fun v6 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P4 v1) (And4 v2 v3 v4 v5) => match v0 v1 as v3 in [/\ _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1 & P4 v1] => P4 v1) v3) with | And4 v3 v4 v5 v6 => v2 v3 v4 v5 v6 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) => id))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.AllAnd.all_and5	100	0.141868	1	1	0	synth with cache (only 1: refine (Implies (fun v0 : forall v0 : @T, [/\ P1 v0, P2 v0, P3 v0, P4 v0 & P5 v0] => And5 (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1), (fun v7 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P1 v1) (And5 v2 v3 v4 v5 v6) => match v0 v1 as v3 in [/\ _, _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P1 v1) v3) with | And5 v3 v4 v5 v6 v7 => v2 v3 v4 v5 v6 v7 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1) => v2)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1), (fun v7 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P2 v1) (And5 v2 v3 v4 v5 v6) => match v0 v1 as v3 in [/\ _, _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P2 v1) v3) with | And5 v3 v4 v5 v6 v7 => v2 v3 v4 v5 v6 v7 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1) => v3)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1), (fun v7 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P3 v1) (And5 v2 v3 v4 v5 v6) => match v0 v1 as v3 in [/\ _, _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P3 v1) v3) with | And5 v3 v4 v5 v6 v7 => v2 v3 v4 v5 v6 v7 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1) => v4)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1), (fun v7 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P4 v1) (And5 v2 v3 v4 v5 v6) => match v0 v1 as v3 in [/\ _, _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P4 v1) v3) with | And5 v3 v4 v5 v6 v7 => v2 v3 v4 v5 v6 v7 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1) => v5)) (fun v1 : @T => (fun v2 : forall (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) (v6 : P5 v1), (fun v7 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P5 v1) (And5 v2 v3 v4 v5 v6) => match v0 v1 as v3 in [/\ _, _, _, _ & _] return ((fun v4 : [/\ P1 v1, P2 v1, P3 v1, P4 v1 & P5 v1] => P5 v1) v3) with | And5 v3 v4 v5 v6 v7 => v2 v3 v4 v5 v6 v7 end) (fun (v2 : P1 v1) (v3 : P2 v1) (v4 : P3 v1) (v5 : P4 v1) => id))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.pair_andP	100	0.091515	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 /\ v1 => (fun v3 : forall (v3 : v0) (v4 : v1), (fun v5 : v0 /\ v1 => (v0 * v1)%type) (conj v3 v4) => match v2 as v4 in (_ /\ _) return ((fun v5 : v0 /\ v1 => (v0 * v1)%type) v4) with | conj v4 v5 => v3 v4 v5 end) ((fun v3 : v0 => [eta pair v3]) : (forall (v3 : v0) (v4 : v1), v0 * v1))) (fun v2 : v0 * v1 => (fun v3 : forall (v3 : v0) (v4 : v1), (fun v5 : v0 * v1 => v0 /\ v1) (v3, v4) => match v2 as v4 in (_ * _)%type return ((fun v5 : v0 * v1 => v0 /\ v1) v4) with | (v4, v5) => v3 v4 v5 end) ((fun v3 : v0 => [eta conj v3]) : (forall (v3 : v0) (v4 : v1), v0 /\ v1))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.idP	100	0.023224	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect v0 v0) with | true => ReflectT (@true) (@is_true_true) | false => ReflectF (@false) (@not_false_is_true) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.boolP	100	0.017957	1	1	0	synth with cache (only 1: refine (altP (@idP))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.idPn	100	0.028602	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (~~ v0) (~~ v0)) with | true => ReflectF (~~ @true) (@not_false_is_true) | false => ReflectT (~~ @false) (@is_true_true) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.negP	100	0.032551	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (~ v0) (~~ v0)) with | true => ReflectF (~ @true) (@^~ (@is_true_true) : ~ ~ @true) | false => ReflectT (~ @false) (@not_false_is_true) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.negPn	100	0.028449	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect v0 (~~ ~~ v0)) with | true => ReflectT (@true) (@is_true_true) | false => ReflectF (@false) (@not_false_is_true) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.negPf	100	0.043572	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (v0 = @false) (~~ v0)) with | true => ReflectF (@true = @false) ((fun v0 : @true = @false => let v1 : @False := eq_ind (@true) (fun v1 : @bool => match v1 as v2 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v0 in False_ind (@False) v1) : @true <> @false) | false => ReflectT (@false = @false) (erefl (@false)) end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.andP	100	0.116269	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (v0 /\ @b2) (v0 && @b2)) with | true => match @b2 as v0 in bool return (reflect (@true /\ v0) (@true && v0)) with | true => ReflectT (@true /\ @true) (conj (@is_true_true) (@is_true_true) : @true /\ @true) | false => ReflectF (@true /\ @false) (fun v0 : @true /\ @false => (fun v1 : forall (v1 : @true) (v2 : @false), (fun v3 : @true /\ @false => @False) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : @true /\ @false => @False) v2) with | conj v2 v3 => v1 v2 v3 end) ((fun (v1 : @true) (v2 : @false) => let v3 : @False := eq_ind (@false) (fun v3 : @bool => match v3 as v4 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v3) : (forall (v1 : @true) (v2 : @false), @False))) end | false => match @b2 as v0 in bool return (reflect (@false /\ v0) (@false && v0)) with | true => ReflectF (@false /\ @true) (fun v0 : @false /\ @true => (fun v1 : forall (v1 : @false) (v2 : @true), (fun v3 : @false /\ @true => @False) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : @false /\ @true => @False) v2) with | conj v2 v3 => v1 v2 v3 end) ((fun (v1 : @false) (v2 : @true) => let v3 : @False := eq_ind (@false) (fun v3 : @bool => match v3 as v4 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v3) : (forall (v1 : @false) (v2 : @true), @False))) | false => ReflectF (@false /\ @false) (fun v0 : @false /\ @false => (fun v1 : forall v1 v2 : @false, (fun v3 : @false /\ @false => @False) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : @false /\ @false => @False) v2) with | conj v2 v3 => v1 v2 v3 end) ((fun v1 v2 : @false => let v3 : @False := eq_ind (@false) (fun v3 : @bool => match v3 as v4 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v3) : (forall v1 v2 : @false, @False))) end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.and3P	100	0.308493	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect [/\ v0, @b2 & @b3] [&& v0, @b2 & @b3]) with | true => match @b2 as v0 in bool return (reflect [/\ @true, v0 & @b3] [&& @true, v0 & @b3]) with | true => match @b3 as v0 in bool return (reflect [/\ @true, @true & v0] [&& @true, @true & v0]) with | true => ReflectT [/\ @true, @true & @true] (And3 (@is_true_true) (@is_true_true) (@is_true_true) : [/\ @true, @true & @true]) | false => ReflectF [/\ @true, @true & @false] (fun v0 : [/\ @true, @true & @false] => (fun v1 : forall (v1 v2 : @true) (v3 : @false), (fun v4 : [/\ @true, @true & @false] => @False) (And3 v1 v2 v3) => match v0 as v2 in [/\ _, _ & _] return ((fun v3 : [/\ @true, @true & @false] => @False) v2) with | And3 v2 v3 v4 => v1 v2 v3 v4 end) ((fun (v1 v2 : @true) (v3 : @false) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v4) : (forall (v1 v2 : @true) (v3 : @false), @False))) end | false => match @b3 as v0 in bool return (reflect [/\ @true, @false & v0] [&& @true, @false & v0]) with | true => ReflectF [/\ @true, @false & @true] (fun v0 : [/\ @true, @false & @true] => (fun v1 : forall (v1 : @true) (v2 : @false) (v3 : @true), (fun v4 : [/\ @true, @false & @true] => @False) (And3 v1 v2 v3) => match v0 as v2 in [/\ _, _ & _] return ((fun v3 : [/\ @true, @false & @true] => @False) v2) with | And3 v2 v3 v4 => v1 v2 v3 v4 end) ((fun (v1 : @true) (v2 : @false) (v3 : @true) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v4) : (forall (v1 : @true) (v2 : @false) (v3 : @true), @False))) | false => ReflectF [/\ @true, @false & @false] (fun v0 : [/\ @true, @false & @false] => (fun v1 : forall (v1 : @true) (v2 v3 : @false), (fun v4 : [/\ @true, @false & @false] => @False) (And3 v1 v2 v3) => match v0 as v2 in [/\ _, _ & _] return ((fun v3 : [/\ @true, @false & @false] => @False) v2) with | And3 v2 v3 v4 => v1 v2 v3 v4 end) ((fun (v1 : @true) (v2 v3 : @false) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v4) : (forall (v1 : @true) (v2 v3 : @false), @False))) end end | false => match @b2 as v0 in bool return (reflect [/\ @false, v0 & @b3] [&& @false, v0 & @b3]) with | true => match @b3 as v0 in bool return (reflect [/\ @false, @true & v0] [&& @false, @true & v0]) with | true => ReflectF [/\ @false, @true & @true] (fun v0 : [/\ @false, @true & @true] => (fun v1 : forall (v1 : @false) (v2 v3 : @true), (fun v4 : [/\ @false, @true & @true] => @False) (And3 v1 v2 v3) => match v0 as v2 in [/\ _, _ & _] return ((fun v3 : [/\ @false, @true & @true] => @False) v2) with | And3 v2 v3 v4 => v1 v2 v3 v4 end) ((fun (v1 : @false) (v2 v3 : @true) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v4) : (forall (v1 : @false) (v2 v3 : @true), @False))) | false => ReflectF [/\ @false, @true & @false] (fun v0 : [/\ @false, @true & @false] => (fun v1 : forall (v1 : @false) (v2 : @true) (v3 : @false), (fun v4 : [/\ @false, @true & @false] => @False) (And3 v1 v2 v3) => match v0 as v2 in [/\ _, _ & _] return ((fun v3 : [/\ @false, @true & @false] => @False) v2) with | And3 v2 v3 v4 => v1 v2 v3 v4 end) ((fun (v1 : @false) (v2 : @true) (v3 : @false) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v4) : (forall (v1 : @false) (v2 : @true) (v3 : @false), @False))) end | false => match @b3 as v0 in bool return (reflect [/\ @false, @false & v0] [&& @false, @false & v0]) with | true => ReflectF [/\ @false, @false & @true] (fun v0 : [/\ @false, @false & @true] => (fun v1 : forall (v1 v2 : @false) (v3 : @true), (fun v4 : [/\ @false, @false & @true] => @False) (And3 v1 v2 v3) => match v0 as v2 in [/\ _, _ & _] return ((fun v3 : [/\ @false, @false & @true] => @False) v2) with | And3 v2 v3 v4 => v1 v2 v3 v4 end) ((fun (v1 v2 : @false) (v3 : @true) => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v4) : (forall (v1 v2 : @false) (v3 : @true), @False))) | false => ReflectF [/\ @false, @false & @false] (fun v0 : [/\ @false, @false & @false] => (fun v1 : forall v1 v2 v3 : @false, (fun v4 : [/\ @false, @false & @false] => @False) (And3 v1 v2 v3) => match v0 as v2 in [/\ _, _ & _] return ((fun v3 : [/\ @false, @false & @false] => @False) v2) with | And3 v2 v3 v4 => v1 v2 v3 v4 end) ((fun v1 v2 v3 : @false => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v4) : (forall v1 v2 v3 : @false, @False))) end end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.and4P	100	0.677113	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect [/\ v0, @b2, @b3 & @b4] [&& v0, @b2, @b3 & @b4]) with | true => match @b2 as v0 in bool return (reflect [/\ @true, v0, @b3 & @b4] [&& @true, v0, @b3 & @b4]) with | true => match @b3 as v0 in bool return (reflect [/\ @true, @true, v0 & @b4] [&& @true, @true, v0 & @b4]) with | true => match @b4 as v0 in bool return (reflect [/\ @true, @true, @true & v0] [&& @true, @true, @true & v0]) with | true => ReflectT [/\ @true, @true, @true & @true] (And4 (@is_true_true) (@is_true_true) (@is_true_true) (@is_true_true) : [/\ @true, @true, @true & @true]) | false => ReflectF [/\ @true, @true, @true & @false] (fun v0 : [/\ @true, @true, @true & @false] => (fun v1 : forall (v1 v2 v3 : @true) (v4 : @false), (fun v5 : [/\ @true, @true, @true & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @true, @true, @true & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 v2 v3 : @true) (v4 : @false) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall (v1 v2 v3 : @true) (v4 : @false), @False))) end | false => match @b4 as v0 in bool return (reflect [/\ @true, @true, @false & v0] [&& @true, @true, @false & v0]) with | true => ReflectF [/\ @true, @true, @false & @true] (fun v0 : [/\ @true, @true, @false & @true] => (fun v1 : forall (v1 v2 : @true) (v3 : @false) (v4 : @true), (fun v5 : [/\ @true, @true, @false & @true] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @true, @true, @false & @true] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 v2 : @true) (v3 : @false) (v4 : @true) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v5) : (forall (v1 v2 : @true) (v3 : @false) (v4 : @true), @False))) | false => ReflectF [/\ @true, @true, @false & @false] (fun v0 : [/\ @true, @true, @false & @false] => (fun v1 : forall (v1 v2 : @true) (v3 v4 : @false), (fun v5 : [/\ @true, @true, @false & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @true, @true, @false & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 v2 : @true) (v3 v4 : @false) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall (v1 v2 : @true) (v3 v4 : @false), @False))) end end | false => match @b3 as v0 in bool return (reflect [/\ @true, @false, v0 & @b4] [&& @true, @false, v0 & @b4]) with | true => match @b4 as v0 in bool return (reflect [/\ @true, @false, @true & v0] [&& @true, @false, @true & v0]) with | true => ReflectF [/\ @true, @false, @true & @true] (fun v0 : [/\ @true, @false, @true & @true] => (fun v1 : forall (v1 : @true) (v2 : @false) (v3 v4 : @true), (fun v5 : [/\ @true, @false, @true & @true] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @true, @false, @true & @true] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @true) (v2 : @false) (v3 v4 : @true) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v5) : (forall (v1 : @true) (v2 : @false) (v3 v4 : @true), @False))) | false => ReflectF [/\ @true, @false, @true & @false] (fun v0 : [/\ @true, @false, @true & @false] => (fun v1 : forall (v1 : @true) (v2 : @false) (v3 : @true) (v4 : @false), (fun v5 : [/\ @true, @false, @true & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @true, @false, @true & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @true) (v2 : @false) (v3 : @true) (v4 : @false) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall (v1 : @true) (v2 : @false) (v3 : @true) (v4 : @false), @False))) end | false => match @b4 as v0 in bool return (reflect [/\ @true, @false, @false & v0] [&& @true, @false, @false & v0]) with | true => ReflectF [/\ @true, @false, @false & @true] (fun v0 : [/\ @true, @false, @false & @true] => (fun v1 : forall (v1 : @true) (v2 v3 : @false) (v4 : @true), (fun v5 : [/\ @true, @false, @false & @true] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @true, @false, @false & @true] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @true) (v2 v3 : @false) (v4 : @true) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v5) : (forall (v1 : @true) (v2 v3 : @false) (v4 : @true), @False))) | false => ReflectF [/\ @true, @false, @false & @false] (fun v0 : [/\ @true, @false, @false & @false] => (fun v1 : forall (v1 : @true) (v2 v3 v4 : @false), (fun v5 : [/\ @true, @false, @false & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @true, @false, @false & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @true) (v2 v3 v4 : @false) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall (v1 : @true) (v2 v3 v4 : @false), @False))) end end end | false => match @b2 as v0 in bool return (reflect [/\ @false, v0, @b3 & @b4] [&& @false, v0, @b3 & @b4]) with | true => match @b3 as v0 in bool return (reflect [/\ @false, @true, v0 & @b4] [&& @false, @true, v0 & @b4]) with | true => match @b4 as v0 in bool return (reflect [/\ @false, @true, @true & v0] [&& @false, @true, @true & v0]) with | true => ReflectF [/\ @false, @true, @true & @true] (fun v0 : [/\ @false, @true, @true & @true] => (fun v1 : forall (v1 : @false) (v2 v3 v4 : @true), (fun v5 : [/\ @false, @true, @true & @true] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @true, @true & @true] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @false) (v2 v3 v4 : @true) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v5) : (forall (v1 : @false) (v2 v3 v4 : @true), @False))) | false => ReflectF [/\ @false, @true, @true & @false] (fun v0 : [/\ @false, @true, @true & @false] => (fun v1 : forall (v1 : @false) (v2 v3 : @true) (v4 : @false), (fun v5 : [/\ @false, @true, @true & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @true, @true & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @false) (v2 v3 : @true) (v4 : @false) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall (v1 : @false) (v2 v3 : @true) (v4 : @false), @False))) end | false => match @b4 as v0 in bool return (reflect [/\ @false, @true, @false & v0] [&& @false, @true, @false & v0]) with | true => ReflectF [/\ @false, @true, @false & @true] (fun v0 : [/\ @false, @true, @false & @true] => (fun v1 : forall (v1 : @false) (v2 : @true) (v3 : @false) (v4 : @true), (fun v5 : [/\ @false, @true, @false & @true] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @true, @false & @true] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @false) (v2 : @true) (v3 : @false) (v4 : @true) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v5) : (forall (v1 : @false) (v2 : @true) (v3 : @false) (v4 : @true), @False))) | false => ReflectF [/\ @false, @true, @false & @false] (fun v0 : [/\ @false, @true, @false & @false] => (fun v1 : forall (v1 : @false) (v2 : @true) (v3 v4 : @false), (fun v5 : [/\ @false, @true, @false & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @true, @false & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 : @false) (v2 : @true) (v3 v4 : @false) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall (v1 : @false) (v2 : @true) (v3 v4 : @false), @False))) end end | false => match @b3 as v0 in bool return (reflect [/\ @false, @false, v0 & @b4] [&& @false, @false, v0 & @b4]) with | true => match @b4 as v0 in bool return (reflect [/\ @false, @false, @true & v0] [&& @false, @false, @true & v0]) with | true => ReflectF [/\ @false, @false, @true & @true] (fun v0 : [/\ @false, @false, @true & @true] => (fun v1 : forall (v1 v2 : @false) (v3 v4 : @true), (fun v5 : [/\ @false, @false, @true & @true] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @false, @true & @true] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 v2 : @false) (v3 v4 : @true) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v5) : (forall (v1 v2 : @false) (v3 v4 : @true), @False))) | false => ReflectF [/\ @false, @false, @true & @false] (fun v0 : [/\ @false, @false, @true & @false] => (fun v1 : forall (v1 v2 : @false) (v3 : @true) (v4 : @false), (fun v5 : [/\ @false, @false, @true & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @false, @true & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 v2 : @false) (v3 : @true) (v4 : @false) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall (v1 v2 : @false) (v3 : @true) (v4 : @false), @False))) end | false => match @b4 as v0 in bool return (reflect [/\ @false, @false, @false & v0] [&& @false, @false, @false & v0]) with | true => ReflectF [/\ @false, @false, @false & @true] (fun v0 : [/\ @false, @false, @false & @true] => (fun v1 : forall (v1 v2 v3 : @false) (v4 : @true), (fun v5 : [/\ @false, @false, @false & @true] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @false, @false & @true] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun (v1 v2 v3 : @false) (v4 : @true) => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v5) : (forall (v1 v2 v3 : @false) (v4 : @true), @False))) | false => ReflectF [/\ @false, @false, @false & @false] (fun v0 : [/\ @false, @false, @false & @false] => (fun v1 : forall v1 v2 v3 v4 : @false, (fun v5 : [/\ @false, @false, @false & @false] => @False) (And4 v1 v2 v3 v4) => match v0 as v2 in [/\ _, _, _ & _] return ((fun v3 : [/\ @false, @false, @false & @false] => @False) v2) with | And4 v2 v3 v4 v5 => v1 v2 v3 v4 v5 end) ((fun v1 v2 v3 v4 : @false => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v5) : (forall v1 v2 v3 v4 : @false, @False))) end end end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.and5P	100	1.843073	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect [/\ v0, @b2, @b3, @b4 & @b5] [&& v0, @b2, @b3, @b4 & @b5]) with | true => match @b2 as v0 in bool return (reflect [/\ @true, v0, @b3, @b4 & @b5] [&& @true, v0, @b3, @b4 & @b5]) with | true => match @b3 as v0 in bool return (reflect [/\ @true, @true, v0, @b4 & @b5] [&& @true, @true, v0, @b4 & @b5]) with | true => match @b4 as v0 in bool return (reflect [/\ @true, @true, @true, v0 & @b5] [&& @true, @true, @true, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @true, @true, @true, @true & v0] [&& @true, @true, @true, @true & v0]) with | true => ReflectT [/\ @true, @true, @true, @true & @true] (And5 (@is_true_true) (@is_true_true) (@is_true_true) (@is_true_true) (@is_true_true) : [/\ @true, @true, @true, @true & @true]) | false => ReflectF [/\ @true, @true, @true, @true & @false] (fun v0 : [/\ @true, @true, @true, @true & @false] => (fun v1 : forall (v1 v2 v3 v4 : @true) (v5 : @false), (fun v6 : [/\ @true, @true, @true, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @true, @true, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 v3 v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 v2 v3 v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @true, @true, @true, @false & v0] [&& @true, @true, @true, @false & v0]) with | true => ReflectF [/\ @true, @true, @true, @false & @true] (fun v0 : [/\ @true, @true, @true, @false & @true] => (fun v1 : forall (v1 v2 v3 : @true) (v4 : @false) (v5 : @true), (fun v6 : [/\ @true, @true, @true, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @true, @true, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 v3 : @true) (v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 v2 v3 : @true) (v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @true, @true, @true, @false & @false] (fun v0 : [/\ @true, @true, @true, @false & @false] => (fun v1 : forall (v1 v2 v3 : @true) (v4 v5 : @false), (fun v6 : [/\ @true, @true, @true, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @true, @true, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 v3 : @true) (v4 v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 v2 v3 : @true) (v4 v5 : @false), @False))) end end | false => match @b4 as v0 in bool return (reflect [/\ @true, @true, @false, v0 & @b5] [&& @true, @true, @false, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @true, @true, @false, @true & v0] [&& @true, @true, @false, @true & v0]) with | true => ReflectF [/\ @true, @true, @false, @true & @true] (fun v0 : [/\ @true, @true, @false, @true & @true] => (fun v1 : forall (v1 v2 : @true) (v3 : @false) (v4 v5 : @true), (fun v6 : [/\ @true, @true, @false, @true & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @true, @false, @true & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @true) (v3 : @false) (v4 v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v6) : (forall (v1 v2 : @true) (v3 : @false) (v4 v5 : @true), @False))) | false => ReflectF [/\ @true, @true, @false, @true & @false] (fun v0 : [/\ @true, @true, @false, @true & @false] => (fun v1 : forall (v1 v2 : @true) (v3 : @false) (v4 : @true) (v5 : @false), (fun v6 : [/\ @true, @true, @false, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @true, @false, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @true) (v3 : @false) (v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 v2 : @true) (v3 : @false) (v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @true, @true, @false, @false & v0] [&& @true, @true, @false, @false & v0]) with | true => ReflectF [/\ @true, @true, @false, @false & @true] (fun v0 : [/\ @true, @true, @false, @false & @true] => (fun v1 : forall (v1 v2 : @true) (v3 v4 : @false) (v5 : @true), (fun v6 : [/\ @true, @true, @false, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @true, @false, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @true) (v3 v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 v2 : @true) (v3 v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @true, @true, @false, @false & @false] (fun v0 : [/\ @true, @true, @false, @false & @false] => (fun v1 : forall (v1 v2 : @true) (v3 v4 v5 : @false), (fun v6 : [/\ @true, @true, @false, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @true, @false, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @true) (v3 v4 v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 v2 : @true) (v3 v4 v5 : @false), @False))) end end end | false => match @b3 as v0 in bool return (reflect [/\ @true, @false, v0, @b4 & @b5] [&& @true, @false, v0, @b4 & @b5]) with | true => match @b4 as v0 in bool return (reflect [/\ @true, @false, @true, v0 & @b5] [&& @true, @false, @true, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @true, @false, @true, @true & v0] [&& @true, @false, @true, @true & v0]) with | true => ReflectF [/\ @true, @false, @true, @true & @true] (fun v0 : [/\ @true, @false, @true, @true & @true] => (fun v1 : forall (v1 : @true) (v2 : @false) (v3 v4 v5 : @true), (fun v6 : [/\ @true, @false, @true, @true & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @true, @true & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 : @false) (v3 v4 v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v6) : (forall (v1 : @true) (v2 : @false) (v3 v4 v5 : @true), @False))) | false => ReflectF [/\ @true, @false, @true, @true & @false] (fun v0 : [/\ @true, @false, @true, @true & @false] => (fun v1 : forall (v1 : @true) (v2 : @false) (v3 v4 : @true) (v5 : @false), (fun v6 : [/\ @true, @false, @true, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @true, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 : @false) (v3 v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @true) (v2 : @false) (v3 v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @true, @false, @true, @false & v0] [&& @true, @false, @true, @false & v0]) with | true => ReflectF [/\ @true, @false, @true, @false & @true] (fun v0 : [/\ @true, @false, @true, @false & @true] => (fun v1 : forall (v1 : @true) (v2 : @false) (v3 : @true) (v4 : @false) (v5 : @true), (fun v6 : [/\ @true, @false, @true, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @true, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 : @false) (v3 : @true) (v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 : @true) (v2 : @false) (v3 : @true) (v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @true, @false, @true, @false & @false] (fun v0 : [/\ @true, @false, @true, @false & @false] => (fun v1 : forall (v1 : @true) (v2 : @false) (v3 : @true) (v4 v5 : @false), (fun v6 : [/\ @true, @false, @true, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @true, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 : @false) (v3 : @true) (v4 v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @true) (v2 : @false) (v3 : @true) (v4 v5 : @false), @False))) end end | false => match @b4 as v0 in bool return (reflect [/\ @true, @false, @false, v0 & @b5] [&& @true, @false, @false, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @true, @false, @false, @true & v0] [&& @true, @false, @false, @true & v0]) with | true => ReflectF [/\ @true, @false, @false, @true & @true] (fun v0 : [/\ @true, @false, @false, @true & @true] => (fun v1 : forall (v1 : @true) (v2 v3 : @false) (v4 v5 : @true), (fun v6 : [/\ @true, @false, @false, @true & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @false, @true & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 v3 : @false) (v4 v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v6) : (forall (v1 : @true) (v2 v3 : @false) (v4 v5 : @true), @False))) | false => ReflectF [/\ @true, @false, @false, @true & @false] (fun v0 : [/\ @true, @false, @false, @true & @false] => (fun v1 : forall (v1 : @true) (v2 v3 : @false) (v4 : @true) (v5 : @false), (fun v6 : [/\ @true, @false, @false, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @false, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 v3 : @false) (v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @true) (v2 v3 : @false) (v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @true, @false, @false, @false & v0] [&& @true, @false, @false, @false & v0]) with | true => ReflectF [/\ @true, @false, @false, @false & @true] (fun v0 : [/\ @true, @false, @false, @false & @true] => (fun v1 : forall (v1 : @true) (v2 v3 v4 : @false) (v5 : @true), (fun v6 : [/\ @true, @false, @false, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @false, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 v3 v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 : @true) (v2 v3 v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @true, @false, @false, @false & @false] (fun v0 : [/\ @true, @false, @false, @false & @false] => (fun v1 : forall (v1 : @true) (v2 v3 v4 v5 : @false), (fun v6 : [/\ @true, @false, @false, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @true, @false, @false, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @true) (v2 v3 v4 v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @true) (v2 v3 v4 v5 : @false), @False))) end end end end | false => match @b2 as v0 in bool return (reflect [/\ @false, v0, @b3, @b4 & @b5] [&& @false, v0, @b3, @b4 & @b5]) with | true => match @b3 as v0 in bool return (reflect [/\ @false, @true, v0, @b4 & @b5] [&& @false, @true, v0, @b4 & @b5]) with | true => match @b4 as v0 in bool return (reflect [/\ @false, @true, @true, v0 & @b5] [&& @false, @true, @true, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @false, @true, @true, @true & v0] [&& @false, @true, @true, @true & v0]) with | true => ReflectF [/\ @false, @true, @true, @true & @true] (fun v0 : [/\ @false, @true, @true, @true & @true] => (fun v1 : forall (v1 : @false) (v2 v3 v4 v5 : @true), (fun v6 : [/\ @false, @true, @true, @true & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @true, @true & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 v3 v4 v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v6) : (forall (v1 : @false) (v2 v3 v4 v5 : @true), @False))) | false => ReflectF [/\ @false, @true, @true, @true & @false] (fun v0 : [/\ @false, @true, @true, @true & @false] => (fun v1 : forall (v1 : @false) (v2 v3 v4 : @true) (v5 : @false), (fun v6 : [/\ @false, @true, @true, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @true, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 v3 v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @false) (v2 v3 v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @false, @true, @true, @false & v0] [&& @false, @true, @true, @false & v0]) with | true => ReflectF [/\ @false, @true, @true, @false & @true] (fun v0 : [/\ @false, @true, @true, @false & @true] => (fun v1 : forall (v1 : @false) (v2 v3 : @true) (v4 : @false) (v5 : @true), (fun v6 : [/\ @false, @true, @true, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @true, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 v3 : @true) (v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 : @false) (v2 v3 : @true) (v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @false, @true, @true, @false & @false] (fun v0 : [/\ @false, @true, @true, @false & @false] => (fun v1 : forall (v1 : @false) (v2 v3 : @true) (v4 v5 : @false), (fun v6 : [/\ @false, @true, @true, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @true, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 v3 : @true) (v4 v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @false) (v2 v3 : @true) (v4 v5 : @false), @False))) end end | false => match @b4 as v0 in bool return (reflect [/\ @false, @true, @false, v0 & @b5] [&& @false, @true, @false, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @false, @true, @false, @true & v0] [&& @false, @true, @false, @true & v0]) with | true => ReflectF [/\ @false, @true, @false, @true & @true] (fun v0 : [/\ @false, @true, @false, @true & @true] => (fun v1 : forall (v1 : @false) (v2 : @true) (v3 : @false) (v4 v5 : @true), (fun v6 : [/\ @false, @true, @false, @true & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @false, @true & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 : @true) (v3 : @false) (v4 v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v6) : (forall (v1 : @false) (v2 : @true) (v3 : @false) (v4 v5 : @true), @False))) | false => ReflectF [/\ @false, @true, @false, @true & @false] (fun v0 : [/\ @false, @true, @false, @true & @false] => (fun v1 : forall (v1 : @false) (v2 : @true) (v3 : @false) (v4 : @true) (v5 : @false), (fun v6 : [/\ @false, @true, @false, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @false, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 : @true) (v3 : @false) (v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @false) (v2 : @true) (v3 : @false) (v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @false, @true, @false, @false & v0] [&& @false, @true, @false, @false & v0]) with | true => ReflectF [/\ @false, @true, @false, @false & @true] (fun v0 : [/\ @false, @true, @false, @false & @true] => (fun v1 : forall (v1 : @false) (v2 : @true) (v3 v4 : @false) (v5 : @true), (fun v6 : [/\ @false, @true, @false, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @false, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 : @true) (v3 v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 : @false) (v2 : @true) (v3 v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @false, @true, @false, @false & @false] (fun v0 : [/\ @false, @true, @false, @false & @false] => (fun v1 : forall (v1 : @false) (v2 : @true) (v3 v4 v5 : @false), (fun v6 : [/\ @false, @true, @false, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @true, @false, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 : @false) (v2 : @true) (v3 v4 v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 : @false) (v2 : @true) (v3 v4 v5 : @false), @False))) end end end | false => match @b3 as v0 in bool return (reflect [/\ @false, @false, v0, @b4 & @b5] [&& @false, @false, v0, @b4 & @b5]) with | true => match @b4 as v0 in bool return (reflect [/\ @false, @false, @true, v0 & @b5] [&& @false, @false, @true, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @false, @false, @true, @true & v0] [&& @false, @false, @true, @true & v0]) with | true => ReflectF [/\ @false, @false, @true, @true & @true] (fun v0 : [/\ @false, @false, @true, @true & @true] => (fun v1 : forall (v1 v2 : @false) (v3 v4 v5 : @true), (fun v6 : [/\ @false, @false, @true, @true & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @true, @true & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @false) (v3 v4 v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (@False) v6) : (forall (v1 v2 : @false) (v3 v4 v5 : @true), @False))) | false => ReflectF [/\ @false, @false, @true, @true & @false] (fun v0 : [/\ @false, @false, @true, @true & @false] => (fun v1 : forall (v1 v2 : @false) (v3 v4 : @true) (v5 : @false), (fun v6 : [/\ @false, @false, @true, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @true, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @false) (v3 v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 v2 : @false) (v3 v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @false, @false, @true, @false & v0] [&& @false, @false, @true, @false & v0]) with | true => ReflectF [/\ @false, @false, @true, @false & @true] (fun v0 : [/\ @false, @false, @true, @false & @true] => (fun v1 : forall (v1 v2 : @false) (v3 : @true) (v4 : @false) (v5 : @true), (fun v6 : [/\ @false, @false, @true, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @true, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @false) (v3 : @true) (v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 v2 : @false) (v3 : @true) (v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @false, @false, @true, @false & @false] (fun v0 : [/\ @false, @false, @true, @false & @false] => (fun v1 : forall (v1 v2 : @false) (v3 : @true) (v4 v5 : @false), (fun v6 : [/\ @false, @false, @true, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @true, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 : @false) (v3 : @true) (v4 v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 v2 : @false) (v3 : @true) (v4 v5 : @false), @False))) end end | false => match @b4 as v0 in bool return (reflect [/\ @false, @false, @false, v0 & @b5] [&& @false, @false, @false, v0 & @b5]) with | true => match @b5 as v0 in bool return (reflect [/\ @false, @false, @false, @true & v0] [&& @false, @false, @false, @true & v0]) with | true => ReflectF [/\ @false, @false, @false, @true & @true] (fun v0 : [/\ @false, @false, @false, @true & @true] => (fun v1 : forall (v1 v2 v3 : @false) (v4 v5 : @true), (fun v6 : [/\ @false, @false, @false, @true & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @false, @true & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 v3 : @false) (v4 v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v6) : (forall (v1 v2 v3 : @false) (v4 v5 : @true), @False))) | false => ReflectF [/\ @false, @false, @false, @true & @false] (fun v0 : [/\ @false, @false, @false, @true & @false] => (fun v1 : forall (v1 v2 v3 : @false) (v4 : @true) (v5 : @false), (fun v6 : [/\ @false, @false, @false, @true & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @false, @true & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 v3 : @false) (v4 : @true) (v5 : @false) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall (v1 v2 v3 : @false) (v4 : @true) (v5 : @false), @False))) end | false => match @b5 as v0 in bool return (reflect [/\ @false, @false, @false, @false & v0] [&& @false, @false, @false, @false & v0]) with | true => ReflectF [/\ @false, @false, @false, @false & @true] (fun v0 : [/\ @false, @false, @false, @false & @true] => (fun v1 : forall (v1 v2 v3 v4 : @false) (v5 : @true), (fun v6 : [/\ @false, @false, @false, @false & @true] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @false, @false & @true] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun (v1 v2 v3 v4 : @false) (v5 : @true) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (@False) v6) : (forall (v1 v2 v3 v4 : @false) (v5 : @true), @False))) | false => ReflectF [/\ @false, @false, @false, @false & @false] (fun v0 : [/\ @false, @false, @false, @false & @false] => (fun v1 : forall v1 v2 v3 v4 v5 : @false, (fun v6 : [/\ @false, @false, @false, @false & @false] => @False) (And5 v1 v2 v3 v4 v5) => match v0 as v2 in [/\ _, _, _, _ & _] return ((fun v3 : [/\ @false, @false, @false, @false & @false] => @False) v2) with | And5 v2 v3 v4 v5 v6 => v1 v2 v3 v4 v5 v6 end) ((fun v1 v2 v3 v4 v5 : @false => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : (forall v1 v2 v3 v4 v5 : @false, @False))) end end end end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.orP	100	0.086269	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (v0 \/ @b2) (v0 || @b2)) with | true => match @b2 as v0 in bool return (reflect (@true \/ v0) (@true || v0)) with | true => ReflectT (@true \/ @true) (or_intror (@is_true_true)) | false => ReflectT (@true \/ @false) (or_introl (@is_true_true)) end | false => match @b2 as v0 in bool return (reflect (@false \/ v0) (@false || v0)) with | true => ReflectT (@false \/ @true) (or_intror (@is_true_true)) | false => ReflectF (@false \/ @false) (fun v0 : @false \/ @false => (fun (v1 : forall v1 : @false, (fun v2 : @false \/ @false => @False) (or_introl v1)) (v2 : forall v2 : @false, (fun v3 : @false \/ @false => @False) (or_intror v2)) => match v0 as v3 in (_ \/ _) return ((fun v4 : @false \/ @false => @False) v3) with | or_introl v3 => v1 v3 | or_intror v3 => v2 v3 end) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False)) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False))) end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.or3P	100	0.111881	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect [\/ v0, @b2 | @b3] [|| v0, @b2 | @b3]) with | true => ReflectT [\/ @true, @b2 | @b3] (Or31 (@b2) (@b3) (@is_true_true)) | false => match @b2 as v0 in bool return (reflect [\/ @false, v0 | @b3] [|| @false, v0 | @b3]) with | true => ReflectT [\/ @false, @true | @b3] (Or32 (@false) (@b3) (@is_true_true)) | false => match @b3 as v0 in bool return (reflect [\/ @false, @false | v0] [|| @false, @false | v0]) with | true => ReflectT [\/ @false, @false | @true] (Or33 (@false) (@false) (@is_true_true)) | false => ReflectF [\/ @false, @false | @false] (fun v0 : [\/ @false, @false | @false] => (fun (v1 : forall v1 : @false, (fun v2 : [\/ @false, @false | @false] => @False) (Or31 (@false) (@false) v1)) (v2 : forall v2 : @false, (fun v3 : [\/ @false, @false | @false] => @False) (Or32 (@false) (@false) v2)) (v3 : forall v3 : @false, (fun v4 : [\/ @false, @false | @false] => @False) (Or33 (@false) (@false) v3)) => match v0 as v4 in [\/ _, _ | _] return ((fun v5 : [\/ @false, @false | @false] => @False) v4) with | Or31 _ _ v4 => v1 v4 | Or32 _ _ v4 => v2 v4 | Or33 _ _ v4 => v3 v4 end) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False)) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False)) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False))) end end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.or4P	100	0.227180	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect [\/ v0, @b2, @b3 | @b4] [|| v0, @b2, @b3 | @b4]) with | true => ReflectT [\/ @true, @b2, @b3 | @b4] (Or41 (@b2) (@b3) (@b4) (@is_true_true)) | false => match @b2 as v0 in bool return (reflect [\/ @false, v0, @b3 | @b4] [|| @false, v0, @b3 | @b4]) with | true => ReflectT [\/ @false, @true, @b3 | @b4] (Or42 (@false) (@b3) (@b4) (@is_true_true)) | false => match @b3 as v0 in bool return (reflect [\/ @false, @false, v0 | @b4] [|| @false, @false, v0 | @b4]) with | true => ReflectT [\/ @false, @false, @true | @b4] (Or43 (@false) (@false) (@b4) (@is_true_true)) | false => match @b4 as v0 in bool return (reflect [\/ @false, @false, @false | v0] [|| @false, @false, @false | v0]) with | true => ReflectT [\/ @false, @false, @false | @true] (Or44 (@false) (@false) (@false) (@is_true_true)) | false => ReflectF [\/ @false, @false, @false | @false] (fun v0 : [\/ @false, @false, @false | @false] => (fun (v1 : forall v1 : @false, (fun v2 : [\/ @false, @false, @false | @false] => @False) (Or41 (@false) (@false) (@false) v1)) (v2 : forall v2 : @false, (fun v3 : [\/ @false, @false, @false | @false] => @False) (Or42 (@false) (@false) (@false) v2)) (v3 : forall v3 : @false, (fun v4 : [\/ @false, @false, @false | @false] => @False) (Or43 (@false) (@false) (@false) v3)) (v4 : forall v4 : @false, (fun v5 : [\/ @false, @false, @false | @false] => @False) (Or44 (@false) (@false) (@false) v4)) => match v0 as v5 in [\/ _, _, _ | _] return ((fun v6 : [\/ @false, @false, @false | @false] => @False) v5) with | Or41 _ _ _ v5 => v1 v5 | Or42 _ _ _ v5 => v2 v5 | Or43 _ _ _ v5 => v3 v5 | Or44 _ _ _ v5 => v4 v5 end) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False)) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False)) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False)) ((fun v1 : @false => let v2 : @False := eq_ind (@false) (fun v2 : @bool => match v2 as v3 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v1 in False_ind (@False) v2) : (forall v1 : @false, @False))) end end end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.nandP	100	0.084041	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (~~ v0 \/ ~~ @b2) (~~ (v0 && @b2))) with | true => match @b2 as v0 in bool return (reflect (~~ @true \/ ~~ v0) (~~ (@true && v0))) with | true => ReflectF (~~ @true \/ ~~ @true) (fun v0 : ~~ @true \/ ~~ @true => (fun (v1 : forall v1 : ~~ @true, (fun v2 : ~~ @true \/ ~~ @true => @False) (or_introl v1)) (v2 : forall v2 : ~~ @true, (fun v3 : ~~ @true \/ ~~ @true => @False) (or_intror v2)) => match v0 as v3 in (_ \/ _) return ((fun v4 : ~~ @true \/ ~~ @true => @False) v3) with | or_introl v3 => v1 v3 | or_intror v3 => v2 v3 end) [eta not_false_is_true] [eta not_false_is_true]) | false => ReflectT (~~ @true \/ ~~ @false) (or_intror (@is_true_true)) end | false => match @b2 as v0 in bool return (reflect (~~ @false \/ ~~ v0) (~~ (@false && v0))) with | true => ReflectT (~~ @false \/ ~~ @true) (or_introl (@is_true_true)) | false => ReflectT (~~ @false \/ ~~ @false) (or_intror (@is_true_true)) end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.norP	100	0.104071	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (~~ v0 /\ ~~ @b2) (~~ (v0 || @b2))) with | true => match @b2 as v0 in bool return (reflect (~~ @true /\ ~~ v0) (~~ (@true || v0))) with | true => ReflectF (~~ @true /\ ~~ @true) (fun v0 : ~~ @true /\ ~~ @true => (fun v1 : forall v1 v2 : ~~ @true, (fun v3 : ~~ @true /\ ~~ @true => @False) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : ~~ @true /\ ~~ @true => @False) v2) with | conj v2 v3 => v1 v2 v3 end) (fun v1 : ~~ @true => [eta not_false_is_true])) | false => ReflectF (~~ @true /\ ~~ @false) (fun v0 : ~~ @true /\ ~~ @false => (fun v1 : forall (v1 : ~~ @true) (v2 : ~~ @false), (fun v3 : ~~ @true /\ ~~ @false => @False) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : ~~ @true /\ ~~ @false => @False) v2) with | conj v2 v3 => v1 v2 v3 end) (fun (v1 : ~~ @true) (v2 : ~~ @false) => not_false_is_true v1)) end | false => match @b2 as v0 in bool return (reflect (~~ @false /\ ~~ v0) (~~ (@false || v0))) with | true => ReflectF (~~ @false /\ ~~ @true) (fun v0 : ~~ @false /\ ~~ @true => (fun v1 : forall (v1 : ~~ @false) (v2 : ~~ @true), (fun v3 : ~~ @false /\ ~~ @true => @False) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : ~~ @false /\ ~~ @true => @False) v2) with | conj v2 v3 => v1 v2 v3 end) (fun v1 : ~~ @false => [eta not_false_is_true])) | false => ReflectT (~~ @false /\ ~~ @false) (conj (@is_true_true) (@is_true_true)) end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.ReflectConnectives.implyP	100	0.047955	1	1	0	synth with cache (only 1: refine match @b1 as v0 in bool return (reflect (forall v1 : v0, @b2) (v0 ==> @b2)) with | true => match @b2 as v0 in bool return (reflect (forall v1 : @true, v0) (@true ==> v0)) with | true => ReflectT (forall v0 : @true, @true) id | false => ReflectF (forall v0 : @true, @false) ((fun v0 : forall v0 : @true, @false => not_false_is_true (v0 (@is_true_true))) : ~ (forall v0 : @true, @false)) end | false => match @b2 as v0 in bool return (reflect (forall v1 : @false, v0) (@false ==> v0)) with | true => ReflectT (forall v0 : @false, @true) (fun v0 : @false => @is_true_true) | false => ReflectT (forall v0 : @false, @false) id end end).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andTb	100	0.019228	1	1	0	synth with cache (only 1: refine ([eta erefl (A:=@bool)] : left_id (@true) (@andb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andFb	100	0.020226	1	1	0	synth with cache (only 1: refine ((fun v0 : @bool => erefl (@false)) : left_zero (@false) (@andb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbT	100	0.031850	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 && @true = v1) (@true)) (v2 : (fun v2 : @bool => v2 && @true = v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 && @true = v4) v3) with | true => v1 | false => v2 end) (erefl (@true)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbF	100	0.030236	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 && @false = @false) (@true)) (v2 : (fun v2 : @bool => v2 && @false = @false) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 && @false = @false) v3) with | true => v1 | false => v2 end) (erefl (@false)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbb	100	0.028094	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 && v1 = v1) (@true)) (v2 : (fun v2 : @bool => v2 && v2 = v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 && v4 = v4) v3) with | true => v1 | false => v2 end) (erefl (@true)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbC	100	0.056132	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : @bool, v1 && v2 = v2 && v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : @bool, v2 && v3 = v3 && v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : @bool, v4 && v5 = v5 && v4) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @true && v2 = v2 && @true) (@true)) (v3 : (fun v3 : @bool => @true && v3 = v3 && @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true && v5 = v5 && @true) v4) with | true => v2 | false => v3 end) (erefl (@true && @true)) (erefl (@false && @true))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @false && v2 = v2 && @false) (@true)) (v3 : (fun v3 : @bool => @false && v3 = v3 && @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false && v5 = v5 && @false) v4) with | true => v2 | false => v3 end) (erefl (@true && @false)) (erefl (@false && @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbA	100	0.171660	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, [&& v1, v2 & v3] = v1 && v2 && v3) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [&& v2, v3 & v4] = v2 && v3 && v4) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, [&& v4, v5 & v6] = v4 && v5 && v6) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [&& @true, v2 & v3] = @true && v2 && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @true, v3 & v4] = @true && v3 && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [&& @true, v5 & v6] = @true && v5 && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @true, @true & v3] = @true && @true && v3) (@true)) (v4 : (fun v4 : @bool => [&& @true, @true & v4] = @true && @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @true, @true & v6] = @true && @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @true && @true)) (erefl (@true && @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @true, @false & v3] = @true && @false && v3) (@true)) (v4 : (fun v4 : @bool => [&& @true, @false & v4] = @true && @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @true, @false & v6] = @true && @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @false && @true)) (erefl (@true && @false && @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [&& @false, v2 & v3] = @false && v2 && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @false, v3 & v4] = @false && v3 && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [&& @false, v5 & v6] = @false && v5 && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @false, @true & v3] = @false && @true && v3) (@true)) (v4 : (fun v4 : @bool => [&& @false, @true & v4] = @false && @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @false, @true & v6] = @false && @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @true && @true)) (erefl (@false && @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @false, @false & v3] = @false && @false && v3) (@true)) (v4 : (fun v4 : @bool => [&& @false, @false & v4] = @false && @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @false, @false & v6] = @false && @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @false && @true)) (erefl (@false && @false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbCA	100	0.177074	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, [&& v1, v2 & v3] = [&& v2, v1 & v3]) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [&& v2, v3 & v4] = [&& v3, v2 & v4]) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, [&& v4, v5 & v6] = [&& v5, v4 & v6]) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [&& @true, v2 & v3] = [&& v2, @true & v3]) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @true, v3 & v4] = [&& v3, @true & v4]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [&& @true, v5 & v6] = [&& v5, @true & v6]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @true, @true & v3] = [&& @true, @true & v3]) (@true)) (v4 : (fun v4 : @bool => [&& @true, @true & v4] = [&& @true, @true & v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @true, @true & v6] = [&& @true, @true & v6]) v5) with | true => v3 | false => v4 end) (erefl [&& @true, @true & @true]) (erefl [&& @true, @true & @false])) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @true, @false & v3] = [&& @false, @true & v3]) (@true)) (v4 : (fun v4 : @bool => [&& @true, @false & v4] = [&& @false, @true & v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @true, @false & v6] = [&& @false, @true & v6]) v5) with | true => v3 | false => v4 end) (erefl [&& @false, @true & @true]) (erefl [&& @false, @true & @false]))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [&& @false, v2 & v3] = [&& v2, @false & v3]) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @false, v3 & v4] = [&& v3, @false & v4]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [&& @false, v5 & v6] = [&& v5, @false & v6]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @false, @true & v3] = [&& @true, @false & v3]) (@true)) (v4 : (fun v4 : @bool => [&& @false, @true & v4] = [&& @true, @false & v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @false, @true & v6] = [&& @true, @false & v6]) v5) with | true => v3 | false => v4 end) (erefl [&& @true, @false & @true]) (erefl [&& @true, @false & @false])) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [&& @false, @false & v3] = [&& @false, @false & v3]) (@true)) (v4 : (fun v4 : @bool => [&& @false, @false & v4] = [&& @false, @false & v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [&& @false, @false & v6] = [&& @false, @false & v6]) v5) with | true => v3 | false => v4 end) (erefl [&& @false, @false & @true]) (erefl [&& @false, @false & @false]))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbAC	100	0.177646	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 && v2 && v3 = v1 && v3 && v2) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 && v3 && v4 = v2 && v4 && v3) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 && v5 && v6 = v4 && v6 && v5) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true && v2 && v3 = @true && v3 && v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true && v3 && v4 = @true && v4 && v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true && v5 && v6 = @true && v6 && v5) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && @true && v3 = @true && v3 && @true) (@true)) (v4 : (fun v4 : @bool => @true && @true && v4 = @true && v4 && @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && @true && v6 = @true && v6 && @true) v5) with | true => v3 | false => v4 end) (erefl (@true && @true && @true)) (erefl (@true && @false && @true))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && @false && v3 = @true && v3 && @false) (@true)) (v4 : (fun v4 : @bool => @true && @false && v4 = @true && v4 && @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && @false && v6 = @true && v6 && @false) v5) with | true => v3 | false => v4 end) (erefl (@true && @true && @false)) (erefl (@true && @false && @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false && v2 && v3 = @false && v3 && v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false && v3 && v4 = @false && v4 && v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false && v5 && v6 = @false && v6 && v5) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && @true && v3 = @false && v3 && @true) (@true)) (v4 : (fun v4 : @bool => @false && @true && v4 = @false && v4 && @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && @true && v6 = @false && v6 && @true) v5) with | true => v3 | false => v4 end) (erefl (@false && @true && @true)) (erefl (@false && @false && @true))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && @false && v3 = @false && v3 && @false) (@true)) (v4 : (fun v4 : @bool => @false && @false && v4 = @false && v4 && @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && @false && v6 = @false && v6 && @false) v5) with | true => v3 | false => v4 end) (erefl (@false && @true && @false)) (erefl (@false && @false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbACA	100	0.326542	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 v4 : @bool, [&& v1 && v2, v3 & v4] = [&& v1 && v3, v2 & v4]) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 v5 : @bool, [&& v2 && v3, v4 & v5] = [&& v2 && v4, v3 & v5]) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 v7 : @bool, [&& v4 && v5, v6 & v7] = [&& v4 && v6, v5 & v7]) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [&& @true && v2, v3 & v4] = [&& @true && v3, v2 & v4]) (@true)) (v3 : (fun v3 : @bool => forall v4 v5 : @bool, [&& @true && v3, v4 & v5] = [&& @true && v4, v3 & v5]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 v7 : @bool, [&& @true && v5, v6 & v7] = [&& @true && v6, v5 & v7]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @true && @true, v3 & v4] = [&& @true && v3, @true & v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [&& @true && @true, v4 & v5] = [&& @true && v4, @true & v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [&& @true && @true, v6 & v7] = [&& @true && v6, @true & v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @true && @true, @true & v4] = [&& @true && @true, @true & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @true && @true, @true & v5] = [&& @true && @true, @true & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @true && @true, @true & v7] = [&& @true && @true, @true & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @true && @true, @true & @true]) (erefl [&& @true && @true, @true & @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @true && @true, @false & v4] = [&& @true && @false, @true & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @true && @true, @false & v5] = [&& @true && @false, @true & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @true && @true, @false & v7] = [&& @true && @false, @true & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @true && @false, @true & @true]) (erefl [&& @true && @false, @true & @false]))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @true && @false, v3 & v4] = [&& @true && v3, @false & v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [&& @true && @false, v4 & v5] = [&& @true && v4, @false & v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [&& @true && @false, v6 & v7] = [&& @true && v6, @false & v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @true && @false, @true & v4] = [&& @true && @true, @false & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @true && @false, @true & v5] = [&& @true && @true, @false & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @true && @false, @true & v7] = [&& @true && @true, @false & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @true && @true, @false & @true]) (erefl [&& @true && @true, @false & @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @true && @false, @false & v4] = [&& @true && @false, @false & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @true && @false, @false & v5] = [&& @true && @false, @false & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @true && @false, @false & v7] = [&& @true && @false, @false & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @true && @false, @false & @true]) (erefl [&& @true && @false, @false & @false])))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [&& @false && v2, v3 & v4] = [&& @false && v3, v2 & v4]) (@true)) (v3 : (fun v3 : @bool => forall v4 v5 : @bool, [&& @false && v3, v4 & v5] = [&& @false && v4, v3 & v5]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 v7 : @bool, [&& @false && v5, v6 & v7] = [&& @false && v6, v5 & v7]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @false && @true, v3 & v4] = [&& @false && v3, @true & v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [&& @false && @true, v4 & v5] = [&& @false && v4, @true & v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [&& @false && @true, v6 & v7] = [&& @false && v6, @true & v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @false && @true, @true & v4] = [&& @false && @true, @true & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @false && @true, @true & v5] = [&& @false && @true, @true & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @false && @true, @true & v7] = [&& @false && @true, @true & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @false && @true, @true & @true]) (erefl [&& @false && @true, @true & @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @false && @true, @false & v4] = [&& @false && @false, @true & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @false && @true, @false & v5] = [&& @false && @false, @true & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @false && @true, @false & v7] = [&& @false && @false, @true & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @false && @false, @true & @true]) (erefl [&& @false && @false, @true & @false]))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [&& @false && @false, v3 & v4] = [&& @false && v3, @false & v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [&& @false && @false, v4 & v5] = [&& @false && v4, @false & v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [&& @false && @false, v6 & v7] = [&& @false && v6, @false & v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @false && @false, @true & v4] = [&& @false && @true, @false & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @false && @false, @true & v5] = [&& @false && @true, @false & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @false && @false, @true & v7] = [&& @false && @true, @false & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @false && @true, @false & @true]) (erefl [&& @false && @true, @false & @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [&& @false && @false, @false & v4] = [&& @false && @false, @false & v4]) (@true)) (v5 : (fun v5 : @bool => [&& @false && @false, @false & v5] = [&& @false && @false, @false & v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [&& @false && @false, @false & v7] = [&& @false && @false, @false & v7]) v6) with | true => v4 | false => v5 end) (erefl [&& @false && @false, @false & @true]) (erefl [&& @false && @false, @false & @false])))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orTb	100	0.016076	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => @is_true_true)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orFb	100	0.019090	1	1	0	synth with cache (only 1: refine ([eta erefl (A:=@bool)] : left_id (@false) (@orb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbT	100	0.027277	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => is_true (v1 || @true)) (@true)) (v2 : (fun v2 : @bool => is_true (v2 || @true)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => is_true (v4 || @true)) v3) with | true => v1 | false => v2 end) (@is_true_true) (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbF	100	0.031696	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 || @false = v1) (@true)) (v2 : (fun v2 : @bool => v2 || @false = v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 || @false = v4) v3) with | true => v1 | false => v2 end) (erefl (@true)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbb	100	0.030963	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 || v1 = v1) (@true)) (v2 : (fun v2 : @bool => v2 || v2 = v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 || v4 = v4) v3) with | true => v1 | false => v2 end) (erefl (@true)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbC	100	0.068119	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : @bool, v1 || v2 = v2 || v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : @bool, v2 || v3 = v3 || v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : @bool, v4 || v5 = v5 || v4) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @true || v2 = v2 || @true) (@true)) (v3 : (fun v3 : @bool => @true || v3 = v3 || @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true || v5 = v5 || @true) v4) with | true => v2 | false => v3 end) (erefl (@true || @true)) (erefl (@false || @true))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @false || v2 = v2 || @false) (@true)) (v3 : (fun v3 : @bool => @false || v3 = v3 || @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false || v5 = v5 || @false) v4) with | true => v2 | false => v3 end) (erefl (@true || @false)) (erefl (@false || @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbA	100	0.182389	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, [|| v1, v2 | v3] = v1 || v2 || v3) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [|| v2, v3 | v4] = v2 || v3 || v4) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, [|| v4, v5 | v6] = v4 || v5 || v6) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [|| @true, v2 | v3] = @true || v2 || v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @true, v3 | v4] = @true || v3 || v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [|| @true, v5 | v6] = @true || v5 || v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @true, @true | v3] = @true || @true || v3) (@true)) (v4 : (fun v4 : @bool => [|| @true, @true | v4] = @true || @true || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @true, @true | v6] = @true || @true || v6) v5) with | true => v3 | false => v4 end) (erefl (@true || @true || @true)) (erefl (@true || @true || @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @true, @false | v3] = @true || @false || v3) (@true)) (v4 : (fun v4 : @bool => [|| @true, @false | v4] = @true || @false || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @true, @false | v6] = @true || @false || v6) v5) with | true => v3 | false => v4 end) (erefl (@true || @false || @true)) (erefl (@true || @false || @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [|| @false, v2 | v3] = @false || v2 || v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @false, v3 | v4] = @false || v3 || v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [|| @false, v5 | v6] = @false || v5 || v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @false, @true | v3] = @false || @true || v3) (@true)) (v4 : (fun v4 : @bool => [|| @false, @true | v4] = @false || @true || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @false, @true | v6] = @false || @true || v6) v5) with | true => v3 | false => v4 end) (erefl (@false || @true || @true)) (erefl (@false || @true || @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @false, @false | v3] = @false || @false || v3) (@true)) (v4 : (fun v4 : @bool => [|| @false, @false | v4] = @false || @false || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @false, @false | v6] = @false || @false || v6) v5) with | true => v3 | false => v4 end) (erefl (@false || @false || @true)) (erefl (@false || @false || @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbCA	100	0.178970	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, [|| v1, v2 | v3] = [|| v2, v1 | v3]) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [|| v2, v3 | v4] = [|| v3, v2 | v4]) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, [|| v4, v5 | v6] = [|| v5, v4 | v6]) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [|| @true, v2 | v3] = [|| v2, @true | v3]) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @true, v3 | v4] = [|| v3, @true | v4]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [|| @true, v5 | v6] = [|| v5, @true | v6]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @true, @true | v3] = [|| @true, @true | v3]) (@true)) (v4 : (fun v4 : @bool => [|| @true, @true | v4] = [|| @true, @true | v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @true, @true | v6] = [|| @true, @true | v6]) v5) with | true => v3 | false => v4 end) (erefl [|| @true, @true | @true]) (erefl [|| @true, @true | @false])) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @true, @false | v3] = [|| @false, @true | v3]) (@true)) (v4 : (fun v4 : @bool => [|| @true, @false | v4] = [|| @false, @true | v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @true, @false | v6] = [|| @false, @true | v6]) v5) with | true => v3 | false => v4 end) (erefl [|| @false, @true | @true]) (erefl [|| @false, @true | @false]))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, [|| @false, v2 | v3] = [|| v2, @false | v3]) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @false, v3 | v4] = [|| v3, @false | v4]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, [|| @false, v5 | v6] = [|| v5, @false | v6]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @false, @true | v3] = [|| @true, @false | v3]) (@true)) (v4 : (fun v4 : @bool => [|| @false, @true | v4] = [|| @true, @false | v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @false, @true | v6] = [|| @true, @false | v6]) v5) with | true => v3 | false => v4 end) (erefl [|| @true, @false | @true]) (erefl [|| @true, @false | @false])) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => [|| @false, @false | v3] = [|| @false, @false | v3]) (@true)) (v4 : (fun v4 : @bool => [|| @false, @false | v4] = [|| @false, @false | v4]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => [|| @false, @false | v6] = [|| @false, @false | v6]) v5) with | true => v3 | false => v4 end) (erefl [|| @false, @false | @true]) (erefl [|| @false, @false | @false]))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbAC	100	0.179403	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 || v2 || v3 = v1 || v3 || v2) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 || v3 || v4 = v2 || v4 || v3) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 || v5 || v6 = v4 || v6 || v5) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true || v2 || v3 = @true || v3 || v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true || v3 || v4 = @true || v4 || v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true || v5 || v6 = @true || v6 || v5) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true || @true || v3 = @true || v3 || @true) (@true)) (v4 : (fun v4 : @bool => @true || @true || v4 = @true || v4 || @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true || @true || v6 = @true || v6 || @true) v5) with | true => v3 | false => v4 end) (erefl (@true || @true || @true)) (erefl (@true || @false || @true))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true || @false || v3 = @true || v3 || @false) (@true)) (v4 : (fun v4 : @bool => @true || @false || v4 = @true || v4 || @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true || @false || v6 = @true || v6 || @false) v5) with | true => v3 | false => v4 end) (erefl (@true || @true || @false)) (erefl (@true || @false || @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false || v2 || v3 = @false || v3 || v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false || v3 || v4 = @false || v4 || v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false || v5 || v6 = @false || v6 || v5) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false || @true || v3 = @false || v3 || @true) (@true)) (v4 : (fun v4 : @bool => @false || @true || v4 = @false || v4 || @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false || @true || v6 = @false || v6 || @true) v5) with | true => v3 | false => v4 end) (erefl (@false || @true || @true)) (erefl (@false || @false || @true))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false || @false || v3 = @false || v3 || @false) (@true)) (v4 : (fun v4 : @bool => @false || @false || v4 = @false || v4 || @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false || @false || v6 = @false || v6 || @false) v5) with | true => v3 | false => v4 end) (erefl (@false || @true || @false)) (erefl (@false || @false || @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbACA	100	0.621944	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 v4 : @bool, [|| v1 || v2, v3 | v4] = [|| v1 || v3, v2 | v4]) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 v5 : @bool, [|| v2 || v3, v4 | v5] = [|| v2 || v4, v3 | v5]) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 v7 : @bool, [|| v4 || v5, v6 | v7] = [|| v4 || v6, v5 | v7]) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [|| @true || v2, v3 | v4] = [|| @true || v3, v2 | v4]) (@true)) (v3 : (fun v3 : @bool => forall v4 v5 : @bool, [|| @true || v3, v4 | v5] = [|| @true || v4, v3 | v5]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 v7 : @bool, [|| @true || v5, v6 | v7] = [|| @true || v6, v5 | v7]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @true || @true, v3 | v4] = [|| @true || v3, @true | v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [|| @true || @true, v4 | v5] = [|| @true || v4, @true | v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [|| @true || @true, v6 | v7] = [|| @true || v6, @true | v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @true || @true, @true | v4] = [|| @true || @true, @true | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @true || @true, @true | v5] = [|| @true || @true, @true | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @true || @true, @true | v7] = [|| @true || @true, @true | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @true || @true, @true | @true]) (erefl [|| @true || @true, @true | @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @true || @true, @false | v4] = [|| @true || @false, @true | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @true || @true, @false | v5] = [|| @true || @false, @true | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @true || @true, @false | v7] = [|| @true || @false, @true | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @true || @false, @true | @true]) (erefl [|| @true || @false, @true | @false]))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @true || @false, v3 | v4] = [|| @true || v3, @false | v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [|| @true || @false, v4 | v5] = [|| @true || v4, @false | v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [|| @true || @false, v6 | v7] = [|| @true || v6, @false | v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @true || @false, @true | v4] = [|| @true || @true, @false | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @true || @false, @true | v5] = [|| @true || @true, @false | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @true || @false, @true | v7] = [|| @true || @true, @false | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @true || @true, @false | @true]) (erefl [|| @true || @true, @false | @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @true || @false, @false | v4] = [|| @true || @false, @false | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @true || @false, @false | v5] = [|| @true || @false, @false | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @true || @false, @false | v7] = [|| @true || @false, @false | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @true || @false, @false | @true]) (erefl [|| @true || @false, @false | @false])))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 v4 : @bool, [|| @false || v2, v3 | v4] = [|| @false || v3, v2 | v4]) (@true)) (v3 : (fun v3 : @bool => forall v4 v5 : @bool, [|| @false || v3, v4 | v5] = [|| @false || v4, v3 | v5]) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 v7 : @bool, [|| @false || v5, v6 | v7] = [|| @false || v6, v5 | v7]) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @false || @true, v3 | v4] = [|| @false || v3, @true | v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [|| @false || @true, v4 | v5] = [|| @false || v4, @true | v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [|| @false || @true, v6 | v7] = [|| @false || v6, @true | v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @false || @true, @true | v4] = [|| @false || @true, @true | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @false || @true, @true | v5] = [|| @false || @true, @true | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @false || @true, @true | v7] = [|| @false || @true, @true | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @false || @true, @true | @true]) (erefl [|| @false || @true, @true | @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @false || @true, @false | v4] = [|| @false || @false, @true | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @false || @true, @false | v5] = [|| @false || @false, @true | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @false || @true, @false | v7] = [|| @false || @false, @true | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @false || @false, @true | @true]) (erefl [|| @false || @false, @true | @false]))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, [|| @false || @false, v3 | v4] = [|| @false || v3, @false | v4]) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, [|| @false || @false, v4 | v5] = [|| @false || v4, @false | v5]) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, [|| @false || @false, v6 | v7] = [|| @false || v6, @false | v7]) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @false || @false, @true | v4] = [|| @false || @true, @false | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @false || @false, @true | v5] = [|| @false || @true, @false | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @false || @false, @true | v7] = [|| @false || @true, @false | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @false || @true, @false | @true]) (erefl [|| @false || @true, @false | @false])) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => [|| @false || @false, @false | v4] = [|| @false || @false, @false | v4]) (@true)) (v5 : (fun v5 : @bool => [|| @false || @false, @false | v5] = [|| @false || @false, @false | v5]) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => [|| @false || @false, @false | v7] = [|| @false || @false, @false | v7]) v6) with | true => v4 | false => v5 end) (erefl [|| @false || @false, @false | @true]) (erefl [|| @false || @false, @false | @false])))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbN	100	0.038205	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => match v0 as v1 in bool return (v1 && ~~ v1 = @false) with | true => erefl (@false) : @true && ~~ @true = @false | false => erefl (@false) : @false && ~~ @false = @false end)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andNb	100	0.038983	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => ~~ v1 && v1 = @false) (@true)) (v2 : (fun v2 : @bool => ~~ v2 && v2 = @false) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => ~~ v4 && v4 = @false) v3) with | true => v1 | false => v2 end) (erefl (@false)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbN	100	0.049757	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => match v0 as v1 in bool return (v1 || ~~ v1 = @true) with | true => erefl (@true) : @true || ~~ @true = @true | false => erefl (@true) : @false || ~~ @false = @true end)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orNb	100	0.058238	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => ~~ v1 || v1 = @true) (@true)) (v2 : (fun v2 : @bool => ~~ v2 || v2 = @true) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => ~~ v4 || v4 = @true) v3) with | true => v1 | false => v2 end) (erefl (@true)) (erefl (@true)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_orl	100	0.292606	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, (v1 || v2) && v3 = v1 && v3 || v2 && v3) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, (v2 || v3) && v4 = v2 && v4 || v3 && v4) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, (v4 || v5) && v6 = v4 && v6 || v5 && v6) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, (@true || v2) && v3 = @true && v3 || v2 && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, (@true || v3) && v4 = @true && v4 || v3 && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, (@true || v5) && v6 = @true && v6 || v5 && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@true || @true) && v3 = @true && v3 || @true && v3) (@true)) (v4 : (fun v4 : @bool => (@true || @true) && v4 = @true && v4 || @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@true || @true) && v6 = @true && v6 || @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @true || @true && @true)) (erefl (@true && @false || @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@true || @false) && v3 = @true && v3 || @false && v3) (@true)) (v4 : (fun v4 : @bool => (@true || @false) && v4 = @true && v4 || @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@true || @false) && v6 = @true && v6 || @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @true || @false && @true)) (erefl (@true && @false || @false && @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, (@false || v2) && v3 = @false && v3 || v2 && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, (@false || v3) && v4 = @false && v4 || v3 && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, (@false || v5) && v6 = @false && v6 || v5 && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@false || @true) && v3 = @false && v3 || @true && v3) (@true)) (v4 : (fun v4 : @bool => (@false || @true) && v4 = @false && v4 || @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@false || @true) && v6 = @false && v6 || @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @true || @true && @true)) (erefl (@false && @false || @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@false || @false) && v3 = @false && v3 || @false && v3) (@true)) (v4 : (fun v4 : @bool => (@false || @false) && v4 = @false && v4 || @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@false || @false) && v6 = @false && v6 || @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @true || @false && @true)) (erefl (@false && @false || @false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_orr	100	0.328145	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 && (v2 || v3) = v1 && v2 || v1 && v3) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 && (v3 || v4) = v2 && v3 || v2 && v4) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 && (v5 || v6) = v4 && v5 || v4 && v6) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true && (v2 || v3) = @true && v2 || @true && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true && (v3 || v4) = @true && v3 || @true && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true && (v5 || v6) = @true && v5 || @true && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && (@true || v3) = @true && @true || @true && v3) (@true)) (v4 : (fun v4 : @bool => @true && (@true || v4) = @true && @true || @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && (@true || v6) = @true && @true || @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @true || @true && @true)) (erefl (@true && @true || @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && (@false || v3) = @true && @false || @true && v3) (@true)) (v4 : (fun v4 : @bool => @true && (@false || v4) = @true && @false || @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && (@false || v6) = @true && @false || @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @false || @true && @true)) (erefl (@true && @false || @true && @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false && (v2 || v3) = @false && v2 || @false && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false && (v3 || v4) = @false && v3 || @false && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false && (v5 || v6) = @false && v5 || @false && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && (@true || v3) = @false && @true || @false && v3) (@true)) (v4 : (fun v4 : @bool => @false && (@true || v4) = @false && @true || @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && (@true || v6) = @false && @true || @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @true || @false && @true)) (erefl (@false && @true || @false && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && (@false || v3) = @false && @false || @false && v3) (@true)) (v4 : (fun v4 : @bool => @false && (@false || v4) = @false && @false || @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && (@false || v6) = @false && @false || @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @false || @false && @true)) (erefl (@false && @false || @false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orb_andl	100	0.216792	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 && v2 || v3 = (v1 || v3) && (v2 || v3)) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 && v3 || v4 = (v2 || v4) && (v3 || v4)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 && v5 || v6 = (v4 || v6) && (v5 || v6)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true && v2 || v3 = (@true || v3) && (v2 || v3)) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true && v3 || v4 = (@true || v4) && (v3 || v4)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true && v5 || v6 = (@true || v6) && (v5 || v6)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && @true || v3 = (@true || v3) && (@true || v3)) (@true)) (v4 : (fun v4 : @bool => @true && @true || v4 = (@true || v4) && (@true || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && @true || v6 = (@true || v6) && (@true || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@true || @true) && (@true || @true))) (erefl ((@true || @false) && (@true || @false)))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && @false || v3 = (@true || v3) && (@false || v3)) (@true)) (v4 : (fun v4 : @bool => @true && @false || v4 = (@true || v4) && (@false || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && @false || v6 = (@true || v6) && (@false || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@true || @true) && (@false || @true))) (erefl ((@true || @false) && (@false || @false))))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false && v2 || v3 = (@false || v3) && (v2 || v3)) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false && v3 || v4 = (@false || v4) && (v3 || v4)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false && v5 || v6 = (@false || v6) && (v5 || v6)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && @true || v3 = (@false || v3) && (@true || v3)) (@true)) (v4 : (fun v4 : @bool => @false && @true || v4 = (@false || v4) && (@true || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && @true || v6 = (@false || v6) && (@true || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@false || @true) && (@true || @true))) (erefl ((@false || @false) && (@true || @false)))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && @false || v3 = (@false || v3) && (@false || v3)) (@true)) (v4 : (fun v4 : @bool => @false && @false || v4 = (@false || v4) && (@false || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && @false || v6 = (@false || v6) && (@false || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@false || @true) && (@false || @true))) (erefl ((@false || @false) && (@false || @false))))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orb_andr	100	0.202118	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 || v2 && v3 = (v1 || v2) && (v1 || v3)) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 || v3 && v4 = (v2 || v3) && (v2 || v4)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 || v5 && v6 = (v4 || v5) && (v4 || v6)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true || v2 && v3 = (@true || v2) && (@true || v3)) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true || v3 && v4 = (@true || v3) && (@true || v4)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true || v5 && v6 = (@true || v5) && (@true || v6)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true || @true && v3 = (@true || @true) && (@true || v3)) (@true)) (v4 : (fun v4 : @bool => @true || @true && v4 = (@true || @true) && (@true || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true || @true && v6 = (@true || @true) && (@true || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@true || @true) && (@true || @true))) (erefl ((@true || @true) && (@true || @false)))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true || @false && v3 = (@true || @false) && (@true || v3)) (@true)) (v4 : (fun v4 : @bool => @true || @false && v4 = (@true || @false) && (@true || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true || @false && v6 = (@true || @false) && (@true || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@true || @false) && (@true || @true))) (erefl ((@true || @false) && (@true || @false))))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false || v2 && v3 = (@false || v2) && (@false || v3)) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false || v3 && v4 = (@false || v3) && (@false || v4)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false || v5 && v6 = (@false || v5) && (@false || v6)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false || @true && v3 = (@false || @true) && (@false || v3)) (@true)) (v4 : (fun v4 : @bool => @false || @true && v4 = (@false || @true) && (@false || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false || @true && v6 = (@false || @true) && (@false || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@false || @true) && (@false || @true))) (erefl ((@false || @true) && (@false || @false)))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false || @false && v3 = (@false || @false) && (@false || v3)) (@true)) (v4 : (fun v4 : @bool => @false || @false && v4 = (@false || @false) && (@false || v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false || @false && v6 = (@false || @false) && (@false || v6)) v5) with | true => v3 | false => v4 end) (erefl ((@false || @false) && (@false || @true))) (erefl ((@false || @false) && (@false || @false))))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_idl	100	0.099277	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v1, v2, v2 && v1 = v1) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v1, v3, v3 && v1 = v1) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v1, v5, v5 && v1 = v1) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, @true, @true && v2 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, @true, @true && v3 = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, @true, @true && v5 = v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, @true => erefl (@true)) (fun v2 : forall v2 : @false, @true => erefl (@false))) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, @false, @false && v2 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, @false, @false && v3 = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, @false, @false && v5 = v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, @false => (fun (v3 : @true && @true = @true) (v4 : @true) => eq_ind_r (fun v5 : @bool => v5 && @true = @true) v3 (v2 v4)) (erefl (@true)) (@is_true_true)) (fun v2 : forall v2 : @false, @false => erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_idr	100	0.076779	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, v1, v2 && v1 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, v1, v3 && v1 = v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, v1, v5 && v1 = v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : @true, v2, @true && v2 = @true) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, v3, @true && v3 = @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : @true, v5, @true && v5 = @true) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, @true => erefl (@true)) (fun v2 : forall v2 : @true, @false => (fun (v3 : @true && @true = @true) (v4 : @true) => eq_ind_r (fun v5 : @bool => @true && v5 = @true) v3 (v2 v4)) (erefl (@true)) (@is_true_true))) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : @false, v2, @false && v2 = @false) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, v3, @false && v3 = @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : @false, v5, @false && v5 = @false) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @false, @true => erefl (@false)) (fun v2 : forall v2 : @false, @false => erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_id2l	100	0.223064	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, v1 = v2, v3 && v1 = v3 && v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : v4, v1 = v2, v4 && v1 = v4 && v2) (@false)) => match v0 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : v6, v1 = v2, v6 && v1 = v6 && v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, v3 = v2, @true && v3 = @true && v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, v4 = v2, @true && v4 = @true && v2) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, v6 = v2, @true && v6 = @true && v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, @true = v3, @true && @true = @true && v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, @true = v4, @true && @true = @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, @true = v6, @true && @true = @true && v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @true, @true = @true => erefl (@true && @true)) (fun v3 : forall v3 : @true, @true = @false => (fun (v4 : @false && @false = @false && @false) (v5 : @true) => eq_ind_r (fun v6 : @bool => v6 && v6 = v6 && @false) v4 (v3 v5)) (erefl (@false && @false)) (@is_true_true))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, @false = v3, @true && @false = @true && v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, @false = v4, @true && @false = @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, @false = v6, @true && @false = @true && v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @true, @false = @true => (fun (v4 : @true && @true = @true && @true) (v5 : @true) => eq_ind_r (fun v6 : @bool => @true && v6 = @true && @true) v4 (v3 v5)) (erefl (@true && @true)) (@is_true_true)) (fun v3 : forall v3 : @true, @false = @false => erefl (@true && @false)))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, v3 = v2, @false && v3 = @false && v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, v4 = v2, @false && v4 = @false && v2) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, v6 = v2, @false && v6 = @false && v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, @true = v3, @false && @true = @false && v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, @true = v4, @false && @true = @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, @true = v6, @false && @true = @false && v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @false, @true = @true => erefl (@false && @true)) (fun v3 : forall v3 : @false, @true = @false => erefl (@false && @false))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, @false = v3, @false && @false = @false && v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, @false = v4, @false && @false = @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, @false = v6, @false && @false = @false && v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @false, @false = @true => erefl (@false && @true)) (fun v3 : forall v3 : @false, @false = @false => erefl (@false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_id2r	100	0.217188	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : v1, v3 = v2, v3 && v1 = v2 && v1) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : v1, v4 = v2, v4 && v1 = v2 && v1) (@false)) => match v0 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : v1, v6 = v2, v6 && v1 = v2 && v1) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, @true = v2, @true && v3 = v2 && v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : v4, @true = v2, @true && v4 = v2 && v4) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : v6, @true = v2, @true && v6 = v2 && v6) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, @true = v3, @true && @true = v3 && @true) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, @true = v4, @true && @true = v4 && @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, @true = v6, @true && @true = v6 && @true) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @true, @true = @true => erefl (@true && @true)) (fun v3 : forall v3 : @true, @true = @false => (fun (v4 : @false && @false = @false && @false) (v5 : @true) => eq_ind_r (fun v6 : @bool => v6 && v6 = @false && v6) v4 (v3 v5)) (erefl (@false && @false)) (@is_true_true))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, @true = v3, @true && @false = v3 && @false) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, @true = v4, @true && @false = v4 && @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, @true = v6, @true && @false = v6 && @false) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @false, @true = @true => erefl (@true && @false)) (fun v3 : forall v3 : @false, @true = @false => erefl (@false && @false)))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, @false = v2, @false && v3 = v2 && v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : v4, @false = v2, @false && v4 = v2 && v4) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : v6, @false = v2, @false && v6 = v2 && v6) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, @false = v3, @false && @true = v3 && @true) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, @false = v4, @false && @true = v4 && @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, @false = v6, @false && @true = v6 && @true) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @true, @false = @true => (fun (v4 : @true && @true = @true && @true) (v5 : @true) => eq_ind_r (fun v6 : @bool => v6 && @true = @true && @true) v4 (v3 v5)) (erefl (@true && @true)) (@is_true_true)) (fun v3 : forall v3 : @true, @false = @false => erefl (@false && @true))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, @false = v3, @false && @false = v3 && @false) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, @false = v4, @false && @false = v4 && @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, @false = v6, @false && @false = v6 && @false) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @false, @false = @true => erefl (@true && @false)) (fun v3 : forall v3 : @false, @false = @false => erefl (@false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orb_idl	100	0.082437	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, v1, v2 || v1 = v1) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, v1, v3 || v1 = v1) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, v1, v5 || v1 = v1) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : @true, v2, @true || v2 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, v3, @true || v3 = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : @true, v5, @true || v5 = v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, @true => erefl (@true)) (fun v2 : forall v2 : @true, @false => (fun (v3 : @true || @true = @true) (v4 : @true) => eq_ind_r (fun v5 : @bool => @true || v5 = v5) v3 (v2 v4)) (erefl (@true)) (@is_true_true))) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : @false, v2, @false || v2 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, v3, @false || v3 = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : @false, v5, @false || v5 = v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @false, @true => erefl (@true)) (fun v2 : forall v2 : @false, @false => erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orb_idr	100	0.092804	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v1, v2, v2 || v1 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v1, v3, v3 || v1 = v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v1, v5, v5 || v1 = v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, @true, @true || v2 = @true) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, @true, @true || v3 = @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, @true, @true || v5 = @true) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, @true => erefl (@true)) (fun v2 : forall v2 : @false, @true => erefl (@true))) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, @false, @false || v2 = @false) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, @false, @false || v3 = @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, @false, @false || v5 = @false) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, @false => (fun (v3 : @true || @true = @true) (v4 : @true) => eq_ind_r (fun v5 : @bool => v5 || @true = v5) v3 (v2 v4)) (erefl (@true)) (@is_true_true)) (fun v2 : forall v2 : @false, @false => erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orb_id2l	100	0.226522	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ v3, v1 = v2, v3 || v1 = v3 || v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ v4, v1 = v2, v4 || v1 = v4 || v2) (@false)) => match v0 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ v6, v1 = v2, v6 || v1 = v6 || v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @true, v3 = v2, @true || v3 = @true || v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @true, v4 = v2, @true || v4 = @true || v2) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @true, v6 = v2, @true || v6 = @true || v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @true, @true = v3, @true || @true = @true || v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @true, @true = v4, @true || @true = @true || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @true, @true = v6, @true || @true = @true || v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @true, @true = @true => erefl (@true || @true)) (fun v3 : forall v3 : ~~ @true, @true = @false => erefl (@true || @false))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @true, @false = v3, @true || @false = @true || v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @true, @false = v4, @true || @false = @true || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @true, @false = v6, @true || @false = @true || v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @true, @false = @true => erefl (@true || @true)) (fun v3 : forall v3 : ~~ @true, @false = @false => erefl (@true || @false)))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @false, v3 = v2, @false || v3 = @false || v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @false, v4 = v2, @false || v4 = @false || v2) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @false, v6 = v2, @false || v6 = @false || v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @false, @true = v3, @false || @true = @false || v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @false, @true = v4, @false || @true = @false || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @false, @true = v6, @false || @true = @false || v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @false, @true = @true => erefl (@false || @true)) (fun v3 : forall v3 : ~~ @false, @true = @false => (fun (v4 : @false || @false = @false || @false) (v5 : ~~ @false) => eq_ind_r (fun v6 : @bool => @false || v6 = @false || @false) v4 (v3 v5)) (erefl (@false || @false)) (@is_true_true))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @false, @false = v3, @false || @false = @false || v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @false, @false = v4, @false || @false = @false || v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @false, @false = v6, @false || @false = @false || v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @false, @false = @true => (fun (v4 : @true || @true = @true || @true) (v5 : ~~ @false) => eq_ind_r (fun v6 : @bool => v6 || v6 = v6 || @true) v4 (v3 v5)) (erefl (@true || @true)) (@is_true_true)) (fun v3 : forall v3 : ~~ @false, @false = @false => erefl (@false || @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orb_id2r	100	0.220545	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ v1, v3 = v2, v3 || v1 = v2 || v1) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ v1, v4 = v2, v4 || v1 = v2 || v1) (@false)) => match v0 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ v1, v6 = v2, v6 || v1 = v2 || v1) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ v3, @true = v2, @true || v3 = v2 || v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ v4, @true = v2, @true || v4 = v2 || v4) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ v6, @true = v2, @true || v6 = v2 || v6) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @true, @true = v3, @true || @true = v3 || @true) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @true, @true = v4, @true || @true = v4 || @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @true, @true = v6, @true || @true = v6 || @true) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @true, @true = @true => erefl (@true || @true)) (fun v3 : forall v3 : ~~ @true, @true = @false => erefl (@false || @true))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @false, @true = v3, @true || @false = v3 || @false) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @false, @true = v4, @true || @false = v4 || @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @false, @true = v6, @true || @false = v6 || @false) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @false, @true = @true => erefl (@true || @false)) (fun v3 : forall v3 : ~~ @false, @true = @false => (fun (v4 : @false || @false = @false || @false) (v5 : ~~ @false) => eq_ind_r (fun v6 : @bool => v6 || @false = @false || @false) v4 (v3 v5)) (erefl (@false || @false)) (@is_true_true)))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ v3, @false = v2, @false || v3 = v2 || v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ v4, @false = v2, @false || v4 = v2 || v4) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ v6, @false = v2, @false || v6 = v2 || v6) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @true, @false = v3, @false || @true = v3 || @true) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @true, @false = v4, @false || @true = v4 || @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @true, @false = v6, @false || @true = v6 || @true) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @true, @false = @true => erefl (@true || @true)) (fun v3 : forall v3 : ~~ @true, @false = @false => erefl (@false || @true))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @false, @false = v3, @false || @false = v3 || @false) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : ~~ @false, @false = v4, @false || @false = v4 || @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : ~~ @false, @false = v6, @false || @false = v6 || @false) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : ~~ @false, @false = @true => (fun (v4 : @true || @true = @true || @true) (v5 : ~~ @false) => eq_ind_r (fun v6 : @bool => v6 || v6 = @true || v6) v4 (v3 v5)) (erefl (@true || @true)) (@is_true_true)) (fun v3 : forall v3 : ~~ @false, @false = @false => erefl (@false || @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negb_and	100	0.076742	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => match v1 as v2 in bool return (~~ (v0 && v2) = ~~ v0 || ~~ v2) with | true => match v0 as v2 in bool return (~~ (v2 && @true) = ~~ v2 || ~~ @true) with | true => erefl (@false) : ~~ (@true && @true) = ~~ @true || ~~ @true | false => erefl (@true) : ~~ (@false && @true) = ~~ @false || ~~ @true end | false => match v0 as v2 in bool return (~~ (v2 && @false) = ~~ v2 || ~~ @false) with | true => erefl (@true) : ~~ (@true && @false) = ~~ @true || ~~ @false | false => erefl (@true) : ~~ (@false && @false) = ~~ @false || ~~ @false end end)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negb_or	100	0.083979	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => match v1 as v2 in bool return (~~ (v0 || v2) = ~~ v0 && ~~ v2) with | true => match v0 as v2 in bool return (~~ (v2 || @true) = ~~ v2 && ~~ @true) with | true => erefl (@false) : ~~ (@true || @true) = ~~ @true && ~~ @true | false => erefl (@false) : ~~ (@false || @true) = ~~ @false && ~~ @true end | false => match v0 as v2 in bool return (~~ (v2 || @false) = ~~ v2 && ~~ @false) with | true => erefl (@false) : ~~ (@true || @false) = ~~ @true && ~~ @false | false => erefl (@true) : ~~ (@false || @false) = ~~ @false && ~~ @false end end)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andbK	100	0.073011	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 && v1 || v2 = v2) (@true)) (v3 : (fun v3 : @bool => v3 && v1 || v3 = v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => v5 && v1 || v5 = v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => @true && v2 || @true = @true) (@true)) (v3 : (fun v3 : @bool => @true && v3 || @true = @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true && v5 || @true = @true) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@true))) ((fun (v2 : (fun v2 : @bool => @false && v2 || @false = @false) (@true)) (v3 : (fun v3 : @bool => @false && v3 || @false = @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false && v5 || @false = @false) v4) with | true => v2 | false => v3 end) (erefl (@false)) (erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andKb	100	0.066944	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 || v1 && v2 = v2) (@true)) (v3 : (fun v3 : @bool => v3 || v1 && v3 = v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => v5 || v1 && v5 = v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => @true || v2 && @true = @true) (@true)) (v3 : (fun v3 : @bool => @true || v3 && @true = @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true || v5 && @true = @true) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@true))) ((fun (v2 : (fun v2 : @bool => @false || v2 && @false = @false) (@true)) (v3 : (fun v3 : @bool => @false || v3 && @false = @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false || v5 && @false = @false) v4) with | true => v2 | false => v3 end) (erefl (@false)) (erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orbK	100	0.071871	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => (v2 || v1) && v2 = v2) (@true)) (v3 : (fun v3 : @bool => (v3 || v1) && v3 = v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => (v5 || v1) && v5 = v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => (@true || v2) && @true = @true) (@true)) (v3 : (fun v3 : @bool => (@true || v3) && @true = @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => (@true || v5) && @true = @true) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@true))) ((fun (v2 : (fun v2 : @bool => (@false || v2) && @false = @false) (@true)) (v3 : (fun v3 : @bool => (@false || v3) && @false = @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => (@false || v5) && @false = @false) v4) with | true => v2 | false => v3 end) (erefl (@false)) (erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.orKb	100	0.065831	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 && (v1 || v2) = v2) (@true)) (v3 : (fun v3 : @bool => v3 && (v1 || v3) = v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => v5 && (v1 || v5) = v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => @true && (v2 || @true) = @true) (@true)) (v3 : (fun v3 : @bool => @true && (v3 || @true) = @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true && (v5 || @true) = @true) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@true))) ((fun (v2 : (fun v2 : @bool => @false && (v2 || @false) = @false) (@true)) (v3 : (fun v3 : @bool => @false && (v3 || @false) = @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false && (v5 || @false) = @false) v4) with | true => v2 | false => v3 end) (erefl (@false)) (erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implybT	100	0.030428	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => is_true (v1 ==> @true)) (@true)) (v2 : (fun v2 : @bool => is_true (v2 ==> @true)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => is_true (v4 ==> @true)) v3) with | true => v1 | false => v2 end) (@is_true_true) (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implybF	100	0.037128	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 ==> @false = ~~ v1) (@true)) (v2 : (fun v2 : @bool => v2 ==> @false = ~~ v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 ==> @false = ~~ v4) v3) with | true => v1 | false => v2 end) (erefl (~~ @true)) (erefl (~~ @false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implyFb	100	0.017959	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => @is_true_true)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implyTb	100	0.021931	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine [eta erefl (A:=@bool)]).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implybb	100	0.030906	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => is_true (v1 ==> v1)) (@true)) (v2 : (fun v2 : @bool => is_true (v2 ==> v2)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => is_true (v4 ==> v4)) v3) with | true => v1 | false => v2 end) (@is_true_true) (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.negb_imply	100	0.073979	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => ~~ (v2 ==> v1) = v2 && ~~ v1) (@true)) (v3 : (fun v3 : @bool => ~~ (v3 ==> v1) = v3 && ~~ v1) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => ~~ (v5 ==> v1) = v5 && ~~ v1) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => ~~ (@true ==> v2) = @true && ~~ v2) (@true)) (v3 : (fun v3 : @bool => ~~ (@true ==> v3) = @true && ~~ v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ (@true ==> v5) = @true && ~~ v5) v4) with | true => v2 | false => v3 end) (erefl (@true && ~~ @true)) (erefl (@true && ~~ @false))) ((fun (v2 : (fun v2 : @bool => ~~ (@false ==> v2) = @false && ~~ v2) (@true)) (v3 : (fun v3 : @bool => ~~ (@false ==> v3) = @false && ~~ v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ (@false ==> v5) = @false && ~~ v5) v4) with | true => v2 | false => v3 end) (erefl (@false && ~~ @true)) (erefl (@false && ~~ @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implybE	100	0.072180	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 ==> v1 = ~~ v2 || v1) (@true)) (v3 : (fun v3 : @bool => v3 ==> v1 = ~~ v3 || v1) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => v5 ==> v1 = ~~ v5 || v1) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => @true ==> v2 = ~~ @true || v2) (@true)) (v3 : (fun v3 : @bool => @true ==> v3 = ~~ @true || v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true ==> v5 = ~~ @true || v5) v4) with | true => v2 | false => v3 end) (erefl (~~ @true || @true)) (erefl (~~ @true || @false))) ((fun (v2 : (fun v2 : @bool => @false ==> v2 = ~~ @false || v2) (@true)) (v3 : (fun v3 : @bool => @false ==> v3 = ~~ @false || v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false ==> v5 = ~~ @false || v5) v4) with | true => v2 | false => v3 end) (erefl (~~ @false || @true)) (erefl (~~ @false || @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implyNb	100	0.077582	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => ~~ v2 ==> v1 = v2 || v1) (@true)) (v3 : (fun v3 : @bool => ~~ v3 ==> v1 = v3 || v1) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => ~~ v5 ==> v1 = v5 || v1) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => ~~ @true ==> v2 = @true || v2) (@true)) (v3 : (fun v3 : @bool => ~~ @true ==> v3 = @true || v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ @true ==> v5 = @true || v5) v4) with | true => v2 | false => v3 end) (erefl (@true || @true)) (erefl (@true || @false))) ((fun (v2 : (fun v2 : @bool => ~~ @false ==> v2 = @false || v2) (@true)) (v3 : (fun v3 : @bool => ~~ @false ==> v3 = @false || v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ @false ==> v5 = @false || v5) v4) with | true => v2 | false => v3 end) (erefl (@false || @true)) (erefl (@false || @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implybN	100	0.081778	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 ==> ~~ v1 = v1 ==> ~~ v2) (@true)) (v3 : (fun v3 : @bool => v3 ==> ~~ v1 = v1 ==> ~~ v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => v5 ==> ~~ v1 = v1 ==> ~~ v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => @true ==> ~~ v2 = v2 ==> ~~ @true) (@true)) (v3 : (fun v3 : @bool => @true ==> ~~ v3 = v3 ==> ~~ @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true ==> ~~ v5 = v5 ==> ~~ @true) v4) with | true => v2 | false => v3 end) (erefl (@true ==> ~~ @true)) (erefl (@false ==> ~~ @true))) ((fun (v2 : (fun v2 : @bool => @false ==> ~~ v2 = v2 ==> ~~ @false) (@true)) (v3 : (fun v3 : @bool => @false ==> ~~ v3 = v3 ==> ~~ @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false ==> ~~ v5 = v5 ==> ~~ @false) v4) with | true => v2 | false => v3 end) (erefl (@true ==> ~~ @false)) (erefl (@false ==> ~~ @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implybNN	100	0.078030	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => ~~ v2 ==> ~~ v1 = v1 ==> v2) (@true)) (v3 : (fun v3 : @bool => ~~ v3 ==> ~~ v1 = v1 ==> v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => ~~ v5 ==> ~~ v1 = v1 ==> v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => ~~ @true ==> ~~ v2 = v2 ==> @true) (@true)) (v3 : (fun v3 : @bool => ~~ @true ==> ~~ v3 = v3 ==> @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ @true ==> ~~ v5 = v5 ==> @true) v4) with | true => v2 | false => v3 end) (erefl (@true ==> @true)) (erefl (@false ==> @true))) ((fun (v2 : (fun v2 : @bool => ~~ @false ==> ~~ v2 = v2 ==> @false) (@true)) (v3 : (fun v3 : @bool => ~~ @false ==> ~~ v3 = v3 ==> @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ @false ==> ~~ v5 = v5 ==> @false) v4) with | true => v2 | false => v3 end) (erefl (@true ==> @false)) (erefl (@false ==> @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implyb_idl	100	0.088583	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : ~~ v2, v1, v2 ==> v1 = v1) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ v3, v1, v3 ==> v1 = v1) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : ~~ v5, v1, v5 ==> v1 = v1) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : ~~ @true, v2, @true ==> v2 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @true, v3, @true ==> v3 = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : ~~ @true, v5, @true ==> v5 = v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : ~~ @true, @true => erefl (@true)) (fun v2 : forall v2 : ~~ @true, @false => erefl (@false))) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : ~~ @false, v2, @false ==> v2 = v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : ~~ @false, v3, @false ==> v3 = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : ~~ @false, v5, @false ==> v5 = v5) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : ~~ @false, @true => erefl (@true)) (fun v2 : forall v2 : ~~ @false, @false => (fun (v3 : @true ==> @true = @true) (v4 : ~~ @false) => eq_ind_r (fun v5 : @bool => v5 ==> v5 = v5) v3 (v2 v4)) (erefl (@true)) (@is_true_true))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implyb_idr	100	0.089275	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v1, ~~ v2, v2 ==> v1 = ~~ v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v1, ~~ v3, v3 ==> v1 = ~~ v3) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v1, ~~ v5, v5 ==> v1 = ~~ v5) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, ~~ @true, @true ==> v2 = ~~ @true) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, ~~ @true, @true ==> v3 = ~~ @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, ~~ @true, @true ==> v5 = ~~ @true) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, ~~ @true => (fun (v3 : @true ==> @true = @true) (v4 : @true) => eq_ind_r [eta eq (@true ==> @true)] v3 (v2 v4)) (erefl (@true)) (@is_true_true)) (fun v2 : forall v2 : @false, ~~ @true => erefl (~~ @true))) ((fun (v2 : (fun v2 : @bool => forall v3 : forall v3 : v2, ~~ @false, @false ==> v2 = ~~ @false) (@true)) (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, ~~ @false, @false ==> v3 = ~~ @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : forall v6 : v5, ~~ @false, @false ==> v5 = ~~ @false) v4) with | true => v2 | false => v3 end) (fun v2 : forall v2 : @true, ~~ @false => erefl (~~ @false)) (fun v2 : forall v2 : @false, ~~ @false => erefl (~~ @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.implyb_id2l	100	0.248952	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : v3, v1 = v2, v3 ==> v1 = v3 ==> v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : v4, v1 = v2, v4 ==> v1 = v4 ==> v2) (@false)) => match v0 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : v6, v1 = v2, v6 ==> v1 = v6 ==> v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, v3 = v2, @true ==> v3 = @true ==> v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, v4 = v2, @true ==> v4 = @true ==> v2) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, v6 = v2, @true ==> v6 = @true ==> v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, @true = v3, @true ==> @true = @true ==> v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, @true = v4, @true ==> @true = @true ==> v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, @true = v6, @true ==> @true = @true ==> v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @true, @true = @true => erefl (@true ==> @true)) (fun v3 : forall v3 : @true, @true = @false => (fun (v4 : @false ==> @false = @false ==> @false) (v5 : @true) => eq_ind_r (fun v6 : @bool => v6 ==> v6 = v6 ==> @false) v4 (v3 v5)) (erefl (@false ==> @false)) (@is_true_true))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @true, @false = v3, @true ==> @false = @true ==> v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @true, @false = v4, @true ==> @false = @true ==> v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @true, @false = v6, @true ==> @false = @true ==> v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @true, @false = @true => (fun (v4 : @true ==> @true = @true ==> @true) (v5 : @true) => eq_ind_r (fun v6 : @bool => @true ==> v6 = @true ==> @true) v4 (v3 v5)) (erefl (@true ==> @true)) (@is_true_true)) (fun v3 : forall v3 : @true, @false = @false => erefl (@true ==> @false)))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, v3 = v2, @false ==> v3 = @false ==> v2) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, v4 = v2, @false ==> v4 = @false ==> v2) (@false)) => match v1 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, v6 = v2, @false ==> v6 = @false ==> v2) v5) with | true => v3 | false => v4 end) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, @true = v3, @false ==> @true = @false ==> v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, @true = v4, @false ==> @true = @false ==> v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, @true = v6, @false ==> @true = @false ==> v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @false, @true = @true => erefl (@false ==> @true)) (fun v3 : forall v3 : @false, @true = @false => erefl (@false ==> @false))) ((fun (v3 : (fun v3 : @bool => forall v4 : forall v4 : @false, @false = v3, @false ==> @false = @false ==> v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : forall v5 : @false, @false = v4, @false ==> @false = @false ==> v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : forall v7 : @false, @false = v6, @false ==> @false = @false ==> v6) v5) with | true => v3 | false => v4 end) (fun v3 : forall v3 : @false, @false = @true => erefl (@false ==> @true)) (fun v3 : forall v3 : @false, @false = @false => erefl (@false ==> @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addFb	100	0.021820	1	1	0	synth with cache (only 1: refine ([eta erefl (A:=@bool)] : left_id (@false) (@addb))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbF	100	0.036128	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 (+) @false = v1) (@true)) (v2 : (fun v2 : @bool => v2 (+) @false = v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 (+) @false = v4) v3) with | true => v1 | false => v2 end) (erefl (@true)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbb	100	0.040438	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 (+) v1 = @false) (@true)) (v2 : (fun v2 : @bool => v2 (+) v2 = @false) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 (+) v4 = @false) v3) with | true => v1 | false => v2 end) (erefl (@false)) (erefl (@false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbC	100	0.066240	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 : @bool, v1 (+) v2 = v2 (+) v1) (@true)) (v2 : (fun v2 : @bool => forall v3 : @bool, v2 (+) v3 = v3 (+) v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 : @bool, v4 (+) v5 = v5 (+) v4) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @true (+) v2 = v2 (+) @true) (@true)) (v3 : (fun v3 : @bool => @true (+) v3 = v3 (+) @true) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true (+) v5 = v5 (+) @true) v4) with | true => v2 | false => v3 end) (erefl (@true (+) @true)) (erefl (@false (+) @true))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @false (+) v2 = v2 (+) @false) (@true)) (v3 : (fun v3 : @bool => @false (+) v3 = v3 (+) @false) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false (+) v5 = v5 (+) @false) v4) with | true => v2 | false => v3 end) (erefl (@true (+) @false)) (erefl (@false (+) @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbA	100	0.176615	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 (+) (v2 (+) v3) = v1 (+) v2 (+) v3) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 (+) (v3 (+) v4) = v2 (+) v3 (+) v4) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 (+) (v5 (+) v6) = v4 (+) v5 (+) v6) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true (+) (v2 (+) v3) = @true (+) v2 (+) v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true (+) (v3 (+) v4) = @true (+) v3 (+) v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true (+) (v5 (+) v6) = @true (+) v5 (+) v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true (+) (@true (+) v3) = @true (+) @true (+) v3) (@true)) (v4 : (fun v4 : @bool => @true (+) (@true (+) v4) = @true (+) @true (+) v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true (+) (@true (+) v6) = @true (+) @true (+) v6) v5) with | true => v3 | false => v4 end) (erefl (@true (+) @true (+) @true)) (erefl (@true (+) @true (+) @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true (+) (@false (+) v3) = @true (+) @false (+) v3) (@true)) (v4 : (fun v4 : @bool => @true (+) (@false (+) v4) = @true (+) @false (+) v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true (+) (@false (+) v6) = @true (+) @false (+) v6) v5) with | true => v3 | false => v4 end) (erefl (@true (+) @false (+) @true)) (erefl (@true (+) @false (+) @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false (+) (v2 (+) v3) = @false (+) v2 (+) v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false (+) (v3 (+) v4) = @false (+) v3 (+) v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false (+) (v5 (+) v6) = @false (+) v5 (+) v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false (+) (@true (+) v3) = @false (+) @true (+) v3) (@true)) (v4 : (fun v4 : @bool => @false (+) (@true (+) v4) = @false (+) @true (+) v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false (+) (@true (+) v6) = @false (+) @true (+) v6) v5) with | true => v3 | false => v4 end) (erefl (@false (+) @true (+) @true)) (erefl (@false (+) @true (+) @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false (+) (@false (+) v3) = @false (+) @false (+) v3) (@true)) (v4 : (fun v4 : @bool => @false (+) (@false (+) v4) = @false (+) @false (+) v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false (+) (@false (+) v6) = @false (+) @false (+) v6) v5) with | true => v3 | false => v4 end) (erefl (@false (+) @false (+) @true)) (erefl (@false (+) @false (+) @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbCA	100	0.183161	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 (+) (v2 (+) v3) = v2 (+) (v1 (+) v3)) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 (+) (v3 (+) v4) = v3 (+) (v2 (+) v4)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 (+) (v5 (+) v6) = v5 (+) (v4 (+) v6)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true (+) (v2 (+) v3) = v2 (+) (@true (+) v3)) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true (+) (v3 (+) v4) = v3 (+) (@true (+) v4)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true (+) (v5 (+) v6) = v5 (+) (@true (+) v6)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true (+) (@true (+) v3) = @true (+) (@true (+) v3)) (@true)) (v4 : (fun v4 : @bool => @true (+) (@true (+) v4) = @true (+) (@true (+) v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true (+) (@true (+) v6) = @true (+) (@true (+) v6)) v5) with | true => v3 | false => v4 end) (erefl (@true (+) (@true (+) @true))) (erefl (@true (+) (@true (+) @false)))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true (+) (@false (+) v3) = @false (+) (@true (+) v3)) (@true)) (v4 : (fun v4 : @bool => @true (+) (@false (+) v4) = @false (+) (@true (+) v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true (+) (@false (+) v6) = @false (+) (@true (+) v6)) v5) with | true => v3 | false => v4 end) (erefl (@false (+) (@true (+) @true))) (erefl (@false (+) (@true (+) @false))))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false (+) (v2 (+) v3) = v2 (+) (@false (+) v3)) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false (+) (v3 (+) v4) = v3 (+) (@false (+) v4)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false (+) (v5 (+) v6) = v5 (+) (@false (+) v6)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false (+) (@true (+) v3) = @true (+) (@false (+) v3)) (@true)) (v4 : (fun v4 : @bool => @false (+) (@true (+) v4) = @true (+) (@false (+) v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false (+) (@true (+) v6) = @true (+) (@false (+) v6)) v5) with | true => v3 | false => v4 end) (erefl (@true (+) (@false (+) @true))) (erefl (@true (+) (@false (+) @false)))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false (+) (@false (+) v3) = @false (+) (@false (+) v3)) (@true)) (v4 : (fun v4 : @bool => @false (+) (@false (+) v4) = @false (+) (@false (+) v4)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false (+) (@false (+) v6) = @false (+) (@false (+) v6)) v5) with | true => v3 | false => v4 end) (erefl (@false (+) (@false (+) @true))) (erefl (@false (+) (@false (+) @false))))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbAC	100	0.174262	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 (+) v2 (+) v3 = v1 (+) v3 (+) v2) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 (+) v3 (+) v4 = v2 (+) v4 (+) v3) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 (+) v5 (+) v6 = v4 (+) v6 (+) v5) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true (+) v2 (+) v3 = @true (+) v3 (+) v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true (+) v3 (+) v4 = @true (+) v4 (+) v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true (+) v5 (+) v6 = @true (+) v6 (+) v5) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true (+) @true (+) v3 = @true (+) v3 (+) @true) (@true)) (v4 : (fun v4 : @bool => @true (+) @true (+) v4 = @true (+) v4 (+) @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true (+) @true (+) v6 = @true (+) v6 (+) @true) v5) with | true => v3 | false => v4 end) (erefl (@true (+) @true (+) @true)) (erefl (@true (+) @false (+) @true))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true (+) @false (+) v3 = @true (+) v3 (+) @false) (@true)) (v4 : (fun v4 : @bool => @true (+) @false (+) v4 = @true (+) v4 (+) @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true (+) @false (+) v6 = @true (+) v6 (+) @false) v5) with | true => v3 | false => v4 end) (erefl (@true (+) @true (+) @false)) (erefl (@true (+) @false (+) @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false (+) v2 (+) v3 = @false (+) v3 (+) v2) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false (+) v3 (+) v4 = @false (+) v4 (+) v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false (+) v5 (+) v6 = @false (+) v6 (+) v5) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false (+) @true (+) v3 = @false (+) v3 (+) @true) (@true)) (v4 : (fun v4 : @bool => @false (+) @true (+) v4 = @false (+) v4 (+) @true) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false (+) @true (+) v6 = @false (+) v6 (+) @true) v5) with | true => v3 | false => v4 end) (erefl (@false (+) @true (+) @true)) (erefl (@false (+) @false (+) @true))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false (+) @false (+) v3 = @false (+) v3 (+) @false) (@true)) (v4 : (fun v4 : @bool => @false (+) @false (+) v4 = @false (+) v4 (+) @false) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false (+) @false (+) v6 = @false (+) v6 (+) @false) v5) with | true => v3 | false => v4 end) (erefl (@false (+) @true (+) @false)) (erefl (@false (+) @false (+) @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbACA	100	0.658286	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 v4 : @bool, v1 (+) v2 (+) (v3 (+) v4) = v1 (+) v3 (+) (v2 (+) v4)) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 v5 : @bool, v2 (+) v3 (+) (v4 (+) v5) = v2 (+) v4 (+) (v3 (+) v5)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 v7 : @bool, v4 (+) v5 (+) (v6 (+) v7) = v4 (+) v6 (+) (v5 (+) v7)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 v4 : @bool, @true (+) v2 (+) (v3 (+) v4) = @true (+) v3 (+) (v2 (+) v4)) (@true)) (v3 : (fun v3 : @bool => forall v4 v5 : @bool, @true (+) v3 (+) (v4 (+) v5) = @true (+) v4 (+) (v3 (+) v5)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 v7 : @bool, @true (+) v5 (+) (v6 (+) v7) = @true (+) v6 (+) (v5 (+) v7)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, @true (+) @true (+) (v3 (+) v4) = @true (+) v3 (+) (@true (+) v4)) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, @true (+) @true (+) (v4 (+) v5) = @true (+) v4 (+) (@true (+) v5)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, @true (+) @true (+) (v6 (+) v7) = @true (+) v6 (+) (@true (+) v7)) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @true (+) @true (+) (@true (+) v4) = @true (+) @true (+) (@true (+) v4)) (@true)) (v5 : (fun v5 : @bool => @true (+) @true (+) (@true (+) v5) = @true (+) @true (+) (@true (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @true (+) @true (+) (@true (+) v7) = @true (+) @true (+) (@true (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@true (+) @true (+) (@true (+) @true))) (erefl (@true (+) @true (+) (@true (+) @false)))) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @true (+) @true (+) (@false (+) v4) = @true (+) @false (+) (@true (+) v4)) (@true)) (v5 : (fun v5 : @bool => @true (+) @true (+) (@false (+) v5) = @true (+) @false (+) (@true (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @true (+) @true (+) (@false (+) v7) = @true (+) @false (+) (@true (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@true (+) @false (+) (@true (+) @true))) (erefl (@true (+) @false (+) (@true (+) @false))))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, @true (+) @false (+) (v3 (+) v4) = @true (+) v3 (+) (@false (+) v4)) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, @true (+) @false (+) (v4 (+) v5) = @true (+) v4 (+) (@false (+) v5)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, @true (+) @false (+) (v6 (+) v7) = @true (+) v6 (+) (@false (+) v7)) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @true (+) @false (+) (@true (+) v4) = @true (+) @true (+) (@false (+) v4)) (@true)) (v5 : (fun v5 : @bool => @true (+) @false (+) (@true (+) v5) = @true (+) @true (+) (@false (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @true (+) @false (+) (@true (+) v7) = @true (+) @true (+) (@false (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@true (+) @true (+) (@false (+) @true))) (erefl (@true (+) @true (+) (@false (+) @false)))) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @true (+) @false (+) (@false (+) v4) = @true (+) @false (+) (@false (+) v4)) (@true)) (v5 : (fun v5 : @bool => @true (+) @false (+) (@false (+) v5) = @true (+) @false (+) (@false (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @true (+) @false (+) (@false (+) v7) = @true (+) @false (+) (@false (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@true (+) @false (+) (@false (+) @true))) (erefl (@true (+) @false (+) (@false (+) @false)))))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 v4 : @bool, @false (+) v2 (+) (v3 (+) v4) = @false (+) v3 (+) (v2 (+) v4)) (@true)) (v3 : (fun v3 : @bool => forall v4 v5 : @bool, @false (+) v3 (+) (v4 (+) v5) = @false (+) v4 (+) (v3 (+) v5)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 v7 : @bool, @false (+) v5 (+) (v6 (+) v7) = @false (+) v6 (+) (v5 (+) v7)) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, @false (+) @true (+) (v3 (+) v4) = @false (+) v3 (+) (@true (+) v4)) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, @false (+) @true (+) (v4 (+) v5) = @false (+) v4 (+) (@true (+) v5)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, @false (+) @true (+) (v6 (+) v7) = @false (+) v6 (+) (@true (+) v7)) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @false (+) @true (+) (@true (+) v4) = @false (+) @true (+) (@true (+) v4)) (@true)) (v5 : (fun v5 : @bool => @false (+) @true (+) (@true (+) v5) = @false (+) @true (+) (@true (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @false (+) @true (+) (@true (+) v7) = @false (+) @true (+) (@true (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@false (+) @true (+) (@true (+) @true))) (erefl (@false (+) @true (+) (@true (+) @false)))) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @false (+) @true (+) (@false (+) v4) = @false (+) @false (+) (@true (+) v4)) (@true)) (v5 : (fun v5 : @bool => @false (+) @true (+) (@false (+) v5) = @false (+) @false (+) (@true (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @false (+) @true (+) (@false (+) v7) = @false (+) @false (+) (@true (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@false (+) @false (+) (@true (+) @true))) (erefl (@false (+) @false (+) (@true (+) @false))))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @bool, @false (+) @false (+) (v3 (+) v4) = @false (+) v3 (+) (@false (+) v4)) (@true)) (v4 : (fun v4 : @bool => forall v5 : @bool, @false (+) @false (+) (v4 (+) v5) = @false (+) v4 (+) (@false (+) v5)) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @bool, @false (+) @false (+) (v6 (+) v7) = @false (+) v6 (+) (@false (+) v7)) v5) with | true => v3 | false => v4 end) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @false (+) @false (+) (@true (+) v4) = @false (+) @true (+) (@false (+) v4)) (@true)) (v5 : (fun v5 : @bool => @false (+) @false (+) (@true (+) v5) = @false (+) @true (+) (@false (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @false (+) @false (+) (@true (+) v7) = @false (+) @true (+) (@false (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@false (+) @true (+) (@false (+) @true))) (erefl (@false (+) @true (+) (@false (+) @false)))) (fun v3 : @bool => (fun (v4 : (fun v4 : @bool => @false (+) @false (+) (@false (+) v4) = @false (+) @false (+) (@false (+) v4)) (@true)) (v5 : (fun v5 : @bool => @false (+) @false (+) (@false (+) v5) = @false (+) @false (+) (@false (+) v5)) (@false)) => match v3 as v6 in bool return ((fun v7 : @bool => @false (+) @false (+) (@false (+) v7) = @false (+) @false (+) (@false (+) v7)) v6) with | true => v4 | false => v5 end) (erefl (@false (+) @false (+) (@false (+) @true))) (erefl (@false (+) @false (+) (@false (+) @false)))))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_addl	100	0.192195	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, (v1 (+) v2) && v3 = v1 && v3 (+) v2 && v3) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, (v2 (+) v3) && v4 = v2 && v4 (+) v3 && v4) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, (v4 (+) v5) && v6 = v4 && v6 (+) v5 && v6) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, (@true (+) v2) && v3 = @true && v3 (+) v2 && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, (@true (+) v3) && v4 = @true && v4 (+) v3 && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, (@true (+) v5) && v6 = @true && v6 (+) v5 && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@true (+) @true) && v3 = @true && v3 (+) @true && v3) (@true)) (v4 : (fun v4 : @bool => (@true (+) @true) && v4 = @true && v4 (+) @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@true (+) @true) && v6 = @true && v6 (+) @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @true (+) @true && @true)) (erefl (@true && @false (+) @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@true (+) @false) && v3 = @true && v3 (+) @false && v3) (@true)) (v4 : (fun v4 : @bool => (@true (+) @false) && v4 = @true && v4 (+) @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@true (+) @false) && v6 = @true && v6 (+) @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @true (+) @false && @true)) (erefl (@true && @false (+) @false && @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, (@false (+) v2) && v3 = @false && v3 (+) v2 && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, (@false (+) v3) && v4 = @false && v4 (+) v3 && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, (@false (+) v5) && v6 = @false && v6 (+) v5 && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@false (+) @true) && v3 = @false && v3 (+) @true && v3) (@true)) (v4 : (fun v4 : @bool => (@false (+) @true) && v4 = @false && v4 (+) @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@false (+) @true) && v6 = @false && v6 (+) @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @true (+) @true && @true)) (erefl (@false && @false (+) @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => (@false (+) @false) && v3 = @false && v3 (+) @false && v3) (@true)) (v4 : (fun v4 : @bool => (@false (+) @false) && v4 = @false && v4 (+) @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => (@false (+) @false) && v6 = @false && v6 (+) @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @true (+) @false && @true)) (erefl (@false && @false (+) @false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.andb_addr	100	0.197948	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => forall v2 v3 : @bool, v1 && (v2 (+) v3) = v1 && v2 (+) v1 && v3) (@true)) (v2 : (fun v2 : @bool => forall v3 v4 : @bool, v2 && (v3 (+) v4) = v2 && v3 (+) v2 && v4) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => forall v5 v6 : @bool, v4 && (v5 (+) v6) = v4 && v5 (+) v4 && v6) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @true && (v2 (+) v3) = @true && v2 (+) @true && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @true && (v3 (+) v4) = @true && v3 (+) @true && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @true && (v5 (+) v6) = @true && v5 (+) @true && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && (@true (+) v3) = @true && @true (+) @true && v3) (@true)) (v4 : (fun v4 : @bool => @true && (@true (+) v4) = @true && @true (+) @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && (@true (+) v6) = @true && @true (+) @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @true (+) @true && @true)) (erefl (@true && @true (+) @true && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @true && (@false (+) v3) = @true && @false (+) @true && v3) (@true)) (v4 : (fun v4 : @bool => @true && (@false (+) v4) = @true && @false (+) @true && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @true && (@false (+) v6) = @true && @false (+) @true && v6) v5) with | true => v3 | false => v4 end) (erefl (@true && @false (+) @true && @true)) (erefl (@true && @false (+) @true && @false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall v3 : @bool, @false && (v2 (+) v3) = @false && v2 (+) @false && v3) (@true)) (v3 : (fun v3 : @bool => forall v4 : @bool, @false && (v3 (+) v4) = @false && v3 (+) @false && v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall v6 : @bool, @false && (v5 (+) v6) = @false && v5 (+) @false && v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && (@true (+) v3) = @false && @true (+) @false && v3) (@true)) (v4 : (fun v4 : @bool => @false && (@true (+) v4) = @false && @true (+) @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && (@true (+) v6) = @false && @true (+) @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @true (+) @false && @true)) (erefl (@false && @true (+) @false && @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => @false && (@false (+) v3) = @false && @false (+) @false && v3) (@true)) (v4 : (fun v4 : @bool => @false && (@false (+) v4) = @false && @false (+) @false && v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => @false && (@false (+) v6) = @false && @false (+) @false && v6) v5) with | true => v3 | false => v4 end) (erefl (@false && @false (+) @false && @true)) (erefl (@false && @false (+) @false && @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addKb	100	0.058586	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => cancel (addb v1) (addb v1)) (@true)) (v2 : (fun v2 : @bool => cancel (addb v2) (addb v2)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => cancel (addb v4) (addb v4)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @true (+) (@true (+) v2) = v2) (@true)) (v3 : (fun v3 : @bool => @true (+) (@true (+) v3) = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true (+) (@true (+) v5) = v5) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@false))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => @false (+) (@false (+) v2) = v2) (@true)) (v3 : (fun v3 : @bool => @false (+) (@false (+) v3) = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false (+) (@false (+) v5) = v5) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbK	100	0.061407	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => cancel (addb^~ v1) (addb^~ v1)) (@true)) (v2 : (fun v2 : @bool => cancel (addb^~ v2) (addb^~ v2)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => cancel (addb^~ v4) (addb^~ v4)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 (+) @true (+) @true = v2) (@true)) (v3 : (fun v3 : @bool => v3 (+) @true (+) @true = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => v5 (+) @true (+) @true = v5) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@false))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 (+) @false (+) @false = v2) (@true)) (v3 : (fun v3 : @bool => v3 (+) @false (+) @false = v3) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => v5 (+) @false (+) @false = v5) v4) with | true => v2 | false => v3 end) (erefl (@true)) (erefl (@false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addIb	100	0.217183	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => injective (addb^~ v1)) (@true)) (v2 : (fun v2 : @bool => injective (addb^~ v2)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => injective (addb^~ v4)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : @bool) (v4 : v2 (+) @true = v3 (+) @true), v2 = v3) (@true)) (v3 : (fun v3 : @bool => forall (v4 : @bool) (v5 : v3 (+) @true = v4 (+) @true), v3 = v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : @bool) (v7 : v5 (+) @true = v6 (+) @true), v5 = v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @true (+) @true = v3 (+) @true, @true = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @true (+) @true = v4 (+) @true, @true = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @true (+) @true = v6 (+) @true, @true = v6) v5) with | true => v3 | false => v4 end) (fun v3 : @true (+) @true = @true (+) @true => erefl (@true)) ([eta eq_sym (y:=@true)] : (forall v3 : @true (+) @true = @false (+) @true, @true = @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @false (+) @true = v3 (+) @true, @false = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @false (+) @true = v4 (+) @true, @false = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @false (+) @true = v6 (+) @true, @false = v6) v5) with | true => v3 | false => v4 end) ([eta eq_sym (y:=@false)] : (forall v3 : @false (+) @true = @true (+) @true, @false = @true)) (fun v3 : @false (+) @true = @false (+) @true => erefl (@false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : @bool) (v4 : v2 (+) @false = v3 (+) @false), v2 = v3) (@true)) (v3 : (fun v3 : @bool => forall (v4 : @bool) (v5 : v3 (+) @false = v4 (+) @false), v3 = v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : @bool) (v7 : v5 (+) @false = v6 (+) @false), v5 = v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @true (+) @false = v3 (+) @false, @true = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @true (+) @false = v4 (+) @false, @true = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @true (+) @false = v6 (+) @false, @true = v6) v5) with | true => v3 | false => v4 end) id id) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @false (+) @false = v3 (+) @false, @false = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @false (+) @false = v4 (+) @false, @false = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @false (+) @false = v6 (+) @false, @false = v6) v5) with | true => v3 | false => v4 end) id id)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbI	100	0.173241	1	1	0	synth with cache (only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => injective (addb v1)) (@true)) (v2 : (fun v2 : @bool => injective (addb v2)) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => injective (addb v4)) v3) with | true => v1 | false => v2 end) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : @bool) (v4 : @true (+) v2 = @true (+) v3), v2 = v3) (@true)) (v3 : (fun v3 : @bool => forall (v4 : @bool) (v5 : @true (+) v3 = @true (+) v4), v3 = v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : @bool) (v7 : @true (+) v5 = @true (+) v6), v5 = v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @true (+) @true = @true (+) v3, @true = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @true (+) @true = @true (+) v4, @true = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @true (+) @true = @true (+) v6, @true = v6) v5) with | true => v3 | false => v4 end) (fun v3 : @true (+) @true = @true (+) @true => erefl (@true)) ([eta eq_sym (y:=@true)] : (forall v3 : @true (+) @true = @true (+) @false, @true = @false))) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @true (+) @false = @true (+) v3, @false = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @true (+) @false = @true (+) v4, @false = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @true (+) @false = @true (+) v6, @false = v6) v5) with | true => v3 | false => v4 end) ([eta eq_sym (y:=@false)] : (forall v3 : @true (+) @false = @true (+) @true, @false = @true)) (fun v3 : @true (+) @false = @true (+) @false => erefl (@false)))) (fun v1 : @bool => (fun (v2 : (fun v2 : @bool => forall (v3 : @bool) (v4 : @false (+) v2 = @false (+) v3), v2 = v3) (@true)) (v3 : (fun v3 : @bool => forall (v4 : @bool) (v5 : @false (+) v3 = @false (+) v4), v3 = v4) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => forall (v6 : @bool) (v7 : @false (+) v5 = @false (+) v6), v5 = v6) v4) with | true => v2 | false => v3 end) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @false (+) @true = @false (+) v3, @true = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @false (+) @true = @false (+) v4, @true = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @false (+) @true = @false (+) v6, @true = v6) v5) with | true => v3 | false => v4 end) id id) (fun v2 : @bool => (fun (v3 : (fun v3 : @bool => forall v4 : @false (+) @false = @false (+) v3, @false = v3) (@true)) (v4 : (fun v4 : @bool => forall v5 : @false (+) @false = @false (+) v4, @false = v4) (@false)) => match v2 as v5 in bool return ((fun v6 : @bool => forall v7 : @false (+) @false = @false (+) v6, @false = v6) v5) with | true => v3 | false => v4 end) id id)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addTb	100	0.023362	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => erefl (~~ v0))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbT	100	0.035666	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @bool => (fun (v1 : (fun v1 : @bool => v1 (+) @true = ~~ v1) (@true)) (v2 : (fun v2 : @bool => v2 (+) @true = ~~ v2) (@false)) => match v0 as v3 in bool return ((fun v4 : @bool => v4 (+) @true = ~~ v4) v3) with | true => v1 | false => v2 end) (erefl (~~ @true)) (erefl (~~ @false)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbN	100	0.072764	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => v2 (+) ~~ v1 = ~~ (v2 (+) v1)) (@true)) (v3 : (fun v3 : @bool => v3 (+) ~~ v1 = ~~ (v3 (+) v1)) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => v5 (+) ~~ v1 = ~~ (v5 (+) v1)) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => @true (+) ~~ v2 = ~~ (@true (+) v2)) (@true)) (v3 : (fun v3 : @bool => @true (+) ~~ v3 = ~~ (@true (+) v3)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @true (+) ~~ v5 = ~~ (@true (+) v5)) v4) with | true => v2 | false => v3 end) (erefl (~~ (@true (+) @true))) (erefl (~~ (@true (+) @false)))) ((fun (v2 : (fun v2 : @bool => @false (+) ~~ v2 = ~~ (@false (+) v2)) (@true)) (v3 : (fun v3 : @bool => @false (+) ~~ v3 = ~~ (@false (+) v3)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => @false (+) ~~ v5 = ~~ (@false (+) v5)) v4) with | true => v2 | false => v3 end) (erefl (~~ (@false (+) @true))) (erefl (~~ (@false (+) @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addNb	100	0.074974	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => ~~ v2 (+) v1 = ~~ (v2 (+) v1)) (@true)) (v3 : (fun v3 : @bool => ~~ v3 (+) v1 = ~~ (v3 (+) v1)) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => ~~ v5 (+) v1 = ~~ (v5 (+) v1)) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => ~~ @true (+) v2 = ~~ (@true (+) v2)) (@true)) (v3 : (fun v3 : @bool => ~~ @true (+) v3 = ~~ (@true (+) v3)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ @true (+) v5 = ~~ (@true (+) v5)) v4) with | true => v2 | false => v3 end) (erefl (~~ (@true (+) @true))) (erefl (~~ (@true (+) @false)))) ((fun (v2 : (fun v2 : @bool => ~~ @false (+) v2 = ~~ (@false (+) v2)) (@true)) (v3 : (fun v3 : @bool => ~~ @false (+) v3 = ~~ (@false (+) v3)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => ~~ @false (+) v5 = ~~ (@false (+) v5)) v4) with | true => v2 | false => v3 end) (erefl (~~ (@false (+) @true))) (erefl (~~ (@false (+) @false)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.addbP	100	0.079538	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => (fun (v2 : (fun v2 : @bool => reflect (~~ v2 = v1) (v2 (+) v1)) (@true)) (v3 : (fun v3 : @bool => reflect (~~ v3 = v1) (v3 (+) v1)) (@false)) => match v0 as v4 in bool return ((fun v5 : @bool => reflect (~~ v5 = v1) (v5 (+) v1)) v4) with | true => v2 | false => v3 end) ((fun (v2 : (fun v2 : @bool => reflect (~~ @true = v2) (@true (+) v2)) (@true)) (v3 : (fun v3 : @bool => reflect (~~ @true = v3) (@true (+) v3)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => reflect (~~ @true = v5) (@true (+) v5)) v4) with | true => v2 | false => v3 end) (ReflectF (~~ @true = @true) (@not_false_is_true)) (ReflectT (~~ @true = @false) (erefl (@false)))) ((fun (v2 : (fun v2 : @bool => reflect (~~ @false = v2) (@false (+) v2)) (@true)) (v3 : (fun v3 : @bool => reflect (~~ @false = v3) (@false (+) v3)) (@false)) => match v1 as v4 in bool return ((fun v5 : @bool => reflect (~~ @false = v5) (@false (+) v5)) v4) with | true => v2 | false => v3 end) (ReflectT (~~ @false = @true) (erefl (@true))) (ReflectF (~~ @false = @false) ((fun v2 : ~~ @false = @false => let v3 : @False := eq_ind (~~ @false) (fun v3 : @bool => match v3 as v4 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v2 in False_ind (@False) v3) : ~~ @false <> @false))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.subrelUl	100	0.046580	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 v2 : rel v0) => (fun (v3 v4 : v0) (v5 : v1 v3 v4) => [eta introTF orP] (or_introl v5)) : subrel v1 (relU v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.subrelUr	100	0.047396	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 v2 : rel v0) => (fun (v3 v4 : v0) (v5 : v2 v3 v4) => [eta introTF orP] (or_intror v5)) : subrel v2 (relU v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.sub_refl	100	0.021229	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : mem_pred v0) => (fun v2 : v0 => id) : sub_mem v1 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.mem_topred	100	0.014483	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.topredE	100	0.013548	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.app_predE	100	0.082963	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @T) (v1 : pred (@T)) (v2 : registered_applicative_pred v1) => (fun v3 : forall (v3 : pred (@T)) (v4 : v3 = v1), (fun v5 : registered_applicative_pred v1 => v5 v0 = (v0 \in v1)) (RegisteredApplicativePred v4) => match v2 as v4 in (registered_applicative_pred _) return ((fun v5 : registered_applicative_pred v1 => v5 v0 = (v0 \in v1)) v4) with | @RegisteredApplicativePred _ v4 v5 => v3 v4 v5 end) (fun (v3 : pred (@T)) (v4 : v3 = v1) => (fun v5 : v1 v0 = (v0 \in v1) => eq_ind_r (fun v6 : pred (@T) => v6 v0 = (v0 \in v1)) v5 v4) (erefl (v0 \in v1))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.in_applicative	100	0.079210	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @T) (v1 : pred (@T)) (v2 : applicative_mem_pred v1) => (fun v3 : forall v3 : manifest_mem_pred v1, (fun v4 : applicative_mem_pred v1 => in_mem v0 v4 = v1 v0) {| applicative_mem_pred_value := v3 |} => match v2 as v4 in (applicative_mem_pred _) return ((fun v5 : applicative_mem_pred v1 => in_mem v0 v5 = v1 v0) v4) with | {| applicative_mem_pred_value := v4 |} => v3 v4 end) (fun v3 : manifest_mem_pred v1 => (fun v4 : forall (v4 : mem_pred (@T)) (v5 : v4 = Mem [eta v1]), (fun v6 : manifest_mem_pred v1 => in_mem v0 {| applicative_mem_pred_value := v6 |} = v1 v0) (ManifestMemPred v5) => match v3 as v5 in (manifest_mem_pred _) return ((fun v6 : manifest_mem_pred v1 => in_mem v0 {| applicative_mem_pred_value := v6 |} = v1 v0) v5) with | @ManifestMemPred _ v5 v6 => v4 v5 v6 end) (fun (v4 : mem_pred (@T)) (v5 : v4 = Mem [eta v1]) => (fun v6 : in_mem v0 (Mem [eta v1]) = v1 v0 => eq_ind_r (fun v7 : mem_pred (@T) => in_mem v0 v7 = v1 v0) v6 v5) (erefl (v1 v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.in_collective	100	0.156247	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @T) (v1 : pred (@T)) (v2 : manifest_simpl_pred v1) => (fun v3 : forall (v3 : simpl_pred (@T)) (v4 : v3 = [pred x | v1 x]), (fun v5 : manifest_simpl_pred v1 => (v0 \in v5) = v1 v0) (ManifestSimplPred v4) => match v2 as v4 in (manifest_simpl_pred _) return ((fun v5 : manifest_simpl_pred v1 => (v0 \in v5) = v1 v0) v4) with | @ManifestSimplPred _ v4 v5 => v3 v4 v5 end) (fun (v3 : simpl_pred (@T)) (v4 : v3 = [pred x | v1 x]) => (fun v5 : (v0 \in [pred x | v1 x]) = v1 v0 => eq_ind_r (fun v6 : simpl_pred (@T) => (v0 \in v6) = v1 v0) v5 v4) (erefl (v1 v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.in_simpl	100	0.151853	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @T) (v1 : pred (@T)) (v2 : manifest_simpl_pred v1) => (fun v3 : forall (v3 : simpl_pred (@T)) (v4 : v3 = [pred x | v1 x]), (fun v5 : manifest_simpl_pred v1 => in_mem v0 (Mem [eta v5]) = v1 v0) (ManifestSimplPred v4) => match v2 as v4 in (manifest_simpl_pred _) return ((fun v5 : manifest_simpl_pred v1 => in_mem v0 (Mem [eta v5]) = v1 v0) v4) with | @ManifestSimplPred _ v4 v5 => v3 v4 v5 end) (fun (v3 : simpl_pred (@T)) (v4 : v3 = [pred x | v1 x]) => (fun v5 : in_mem v0 (Mem [eta [pred x | v1 x]]) = v1 v0 => eq_ind_r (fun v6 : simpl_pred (@T) => in_mem v0 (Mem [eta v6]) = v1 v0) v5 v4) (erefl (v1 v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.unfold_in	100	0.010935	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.simpl_predE	100	0.011046	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.mem_simpl	100	0.013250	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.PredicateSimplification.mem_mem	100	0.017928	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.qualifE	100	0.047818	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @nat) (v1 : Type) (v2 : {pred v1}) (v3 : v1) => erefl (v2 v3))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.KeyPred.keyed_predE	100	0.063995	1	1	0	synth with cache (only 1: refine ((fun v0 : forall (v0 : {pred @T}) (v1 : v0 =i @p), (fun v2 : keyed_pred (@k) => v2 =i @p) (PackKeyedPred (@k) v1) => match @k_p as v1 in (keyed_pred _) return ((fun v2 : keyed_pred (@k) => v2 =i @p) v1) with | @PackKeyedPred _ v1 v2 => v0 v1 v2 end) (fun v0 : {pred @T} => id))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.KeyedQualifier.keyed_qualifier_suproof	100	0.100381	1	1	0	synth with cache (only 1: refine ((fun v0 : forall (v0 : qualifier (@n) (@T)) (v1 : v0 = @q), (fun v2 : keyed_qualifier (@k) => unkey_qualifier v2 =i @q) (PackKeyedQualifier (@k) v1) => match @k_q as v1 in (keyed_qualifier _) return ((fun v2 : keyed_qualifier (@k) => unkey_qualifier v2 =i @q) v1) with | @PackKeyedQualifier _ v1 v2 => v0 v1 v2 end) (fun (v0 : qualifier (@n) (@T)) (v1 : v0 = @q) => (fun v2 : @q =i @q => eq_ind_r (fun v3 : qualifier (@n) (@T) => v3 =i @q) v2 v1) ((fun v2 : @T => erefl (v2 \in @q)) : @q =i @q)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.all_tag_cond_dep	100	0.123507	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 : pred v0) (v3 : forall (v3 : v0) (v4 : v1 v3), Type) (v4 : forall v4 : v0, v1 v4) (v5 : forall (v5 : v0) (v6 : v2 v5), {v7 : v1 v5 & v3 v5 v7}) => all_tag (fun v6 : v0 => (fun (v7 : (fun v7 : @bool => forall v8 : protect_term (v2 v6 = v7), {v9 : v1 v6 & forall v10 : v7, v3 v6 v9}) (@true)) (v8 : (fun v8 : @bool => forall v9 : protect_term (v2 v6 = v8), {v10 : v1 v6 & forall v11 : v8, v3 v6 v10}) (@false)) => match v2 v6 as v9 in bool return ((fun v10 : @bool => forall v11 : protect_term (v2 v6 = v10), {v12 : v1 v6 & forall v13 : v10, v3 v6 v12}) v9) with | true => v7 | false => v8 end) ((fun v7 : v2 v6 = @true => (fun v8 : forall (v8 : v1 v6) (v9 : [eta v3 v6] v8), (fun v10 : {v10 : v1 v6 & v3 v6 v10} => {v11 : v1 v6 & forall v12 : @true, v3 v6 v11}) (existT [eta v3 v6] v8 v9) => match v5 v6 v7 as v9 in (sigT _) return ((fun v10 : {v10 : v1 v6 & v3 v6 v10} => {v11 : v1 v6 & forall v12 : @true, v3 v6 v11}) v9) with | existT _ v9 v10 => v8 v9 v10 end) (fun (v8 : v1 v6) (v9 : v3 v6 v8) => existT (fun v10 : v1 v6 => forall v11 : @true, v3 v6 v10) v8 (fun v10 : @true => v9))) : (forall v7 : protect_term (v2 v6 = @true), {v8 : v1 v6 & forall v9 : @true, v3 v6 v8})) ((fun v7 : v2 v6 = @false => existT (fun v8 : v1 v6 => forall v9 : @false, v3 v6 v8) (v4 v6) ((fun v8 : @false => let v9 : @False := eq_ind (@false) (fun v9 : @bool => match v9 as v10 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v8 in False_rect (v3 v6 (v4 v6)) v9) : (forall v8 : @false, v3 v6 (v4 v6)))) : (forall v7 : protect_term (v2 v6 = @false), {v8 : v1 v6 & forall v9 : @false, v3 v6 v8})) (erefl (v2 v6))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.all_tag_cond	100	0.116584	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : pred v0) (v3 : forall (v3 : v0) (v4 : v1), Type) (v4 : v1) => all_tag_cond_dep (fun v5 : v0 => v4))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.all_sig_cond_dep	100	0.104919	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 : pred v0) (v3 : forall (v3 : v0) (v4 : v1 v3), Prop) (v4 : forall v4 : v0, v1 v4) (v5 : forall (v5 : v0) (v6 : v2 v5), {v7 : v1 v5 | v3 v5 v7}) => ((fun v6 : {v6 : forall v6 : v0, v1 v6 & forall (v7 : v0) (v8 : v2 v7), v3 v7 (v6 v7)} => (fun v7 : forall (v7 : forall v7 : v0, v1 v7) (v8 : (fun v8 : forall v8 : v0, v1 v8 => forall (v9 : v0) (v10 : v2 v9), v3 v9 (v8 v9)) v7), (fun v9 : {v9 : forall v9 : v0, v1 v9 & forall (v10 : v0) (v11 : v2 v10), v3 v10 (v9 v10)} => {v10 : forall v10 : v0, v1 v10 | forall (v11 : v0) (v12 : v2 v11), v3 v11 (v10 v11)}) (existT (fun v9 : forall v9 : v0, v1 v9 => forall (v10 : v0) (v11 : v2 v10), v3 v10 (v9 v10)) v7 v8) => match v6 as v8 in (sigT _) return ((fun v9 : {v9 : forall v9 : v0, v1 v9 & forall (v10 : v0) (v11 : v2 v10), v3 v10 (v9 v10)} => {v10 : forall v10 : v0, v1 v10 | forall (v11 : v0) (v12 : v2 v11), v3 v11 (v10 v11)}) v8) with | existT _ v8 v9 => v7 v8 v9 end) (fun v7 : forall v7 : v0, v1 v7 => [eta exist (fun v9 : forall v9 : v0, v1 v9 => forall (v10 : v0) (v11 : v2 v10), v3 v10 (v9 v10)) v7])) : (forall v6 : {v6 : forall v6 : v0, v1 v6 & forall (v7 : v0) (v8 : v2 v7), (fun v9 : v0 => [eta [eta v3 v9]]) v7 (v6 v7)}, {v7 : forall v7 : v0, v1 v7 | forall (v8 : v0) (v9 : v2 v8), v3 v8 (v7 v8)})) (all_tag_cond_dep v4 (fun (v6 : v0) (v7 : v2 v6) => v5 v6 v7)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.all_sig_cond	100	0.055601	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : pred v0) (v3 : forall (v3 : v0) (v4 : v1), Prop) (v4 : v1) => all_sig_cond_dep (fun v5 : v0 => v4))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.RelationProperties.symmetric_from_pre	100	0.035399	1	1	0	synth with cache (only 1: refine (fun (v0 : @pre_symmetric) (v1 v2 : @T) => [eta introTF idP] ((fun v3 : forall v3 : R v1 v2, R v2 v1 => [eta equivPif idP v3]) (v0 v1 v2) (v0 v2 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.RelationProperties.PER.sym_left_transitive	100	0.038902	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @T) (v2 : R v0 v1) (v3 : @T) => [eta introTF idP] ((fun v4 : forall v4 : R v0 v3, R v1 v3 => [eta equivPif idP v4]) (trR ((fun v4 : R v0 v1 => eq_ind_r [eta is_true] v4 (symR v1 v0)) v2)) (trR v2))) : @left_transitive)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.RelationProperties.PER.sym_right_transitive	100	0.036078	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @T) (v2 : R v0 v1) => ((fun (v3 : R v0 =1 R v1) (v4 : @T) => (fun v5 : R v0 v4 = R v4 v1 => eq_ind_r (eq^~ (R v4 v1)) v5 (symR v4 v0)) ((fun v5 : R v0 v4 = R v1 v4 => eq_ind_r [eta eq (R v0 v4)] v5 (symR v4 v1)) ((fun v5 : R v1 v4 = R v1 v4 => eq_ind_r (eq^~ (R v1 v4)) v5 (v3 v4)) (erefl (R v1 v4))))) : (forall v3 : R v0 =1 R v1, R^~ v0 =1 R^~ v1)) (sym_left_transitive v2)) : @right_transitive)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.RelationProperties.equivalence_relP	100	0.068465	1	1	0	synth with cache (only 1: refine (conj (fun v0 : @equivalence_rel => conj (fun v1 : @T => (fun v2 : @true => eq_ind_r [eta is_true] v2 (v0 v1 v1 v1).1) (@is_true_true)) (fun (v1 v2 : @T) (v3 : R v1 v2) (v4 : @T) => (fun (v5 : R v2 v4 = R v2 v4) (v6 : R v1 v2) => eq_ind_r (eq^~ (R v2 v4)) v5 ((v0 v1 v2 v4).2 v6)) (erefl (R v2 v4)) v3)) (fun v0 : @reflexive /\ @left_transitive => (fun v1 : forall (v1 : @reflexive) (v2 : @left_transitive), (fun v3 : @reflexive /\ @left_transitive => @equivalence_rel) (conj v1 v2) => match v0 as v2 in (_ /\ _) return ((fun v3 : @reflexive /\ @left_transitive => @equivalence_rel) v2) with | conj v2 v3 => v1 v2 v3 end) (fun (v1 : @reflexive) (v2 : @left_transitive) (v3 v4 v5 : @T) => (v1 v5, fun v6 : R v3 v4 => ((fun v7 : R v3 =1 R v4 => (fun v8 : R v4 v5 = R v4 v5 => eq_ind_r (eq^~ (R v4 v5)) v8 (v7 v5)) (erefl (R v4 v5))) : (forall v7 : R v3 =1 R v4, R v3 v5 = R v4 v5)) (v2 v3 v4 v6)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.rev_trans	100	0.031564	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : rel v0) (v2 : transitive v1) (v3 v4 v5 : v0) (v6 : v1 v3 v4) => (v2 v3 v5 v4)^~ v6)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalProperties.forE	100	0.013737	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.in1W	100	0.032250	1	1	0	synth with cache (only 1: refine (fun (v0 : { all1 P1}) (v1 : @T1) (v2 : v1 \in @D1) => v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.in2W	100	0.046967	1	1	0	synth with cache (only 1: refine (fun (v0 : { all2 P2}) (v1 : @T1) (v2 : @T2) (v3 : v1 \in @D1) (v4 : v2 \in @D2) => v0 v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.in3W	100	0.065098	1	1	0	synth with cache (only 1: refine (fun (v0 : { all3 P3}) (v1 : @T1) (v2 : @T2) (v3 : @T3) (v4 : v1 \in @D1) (v5 : v2 \in @D2) (v6 : v3 \in @D3) => v0 v1 v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.in1T	100	0.046245	1	1	0	synth with cache (only 1: refine (fun v0 : {in @T1, { all1 P1}} => v0^~ (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.in2T	100	0.064566	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @T1 & @T2, { all2 P2}}) (v1 : @T1) (v2 : @T2) => v0 v1 v2 (@is_true_true) (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.in3T	100	0.086451	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @T1 & @T2 & @T3, { all3 P3}}) (v1 : @T1) (v2 : @T2) (v3 : @T3) => v0 v1 v2 v3 (@is_true_true) (@is_true_true) (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.sub_in1	100	0.027774	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.sub_in11	100	0.045139	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.sub_in111	100	0.035610	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.on1W	100	0.060344	1	1	0	synth with cache (only 1: refine (fun (v0 : allQ1 (@f)) (v1 : @T1) (v2 : f v1 \in @D2) => v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.on1lW	100	0.060584	1	1	0	synth with cache (only 1: refine (fun (v0 : allQ1l (@f) (@h)) (v1 : @T1) (v2 : f v1 \in @D2) => v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.on2W	100	0.081161	1	1	0	synth with cache (only 1: refine (fun (v0 : allQ2 (@f)) (v1 v2 : @T1) (v3 : f v1 \in @D2) (v4 : f v2 \in @D2) => v0 v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.on1T	100	0.062291	1	1	0	synth with cache (only 1: refine (fun v0 : {on @T2, allQ1 (@f)} => v0^~ (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.on1lT	100	0.073688	1	1	0	synth with cache (only 1: refine (fun v0 : prop_on1 (mem (@T2)) (Phantom (forall v0 : @T3, Prop) (allQ1l (@f))) (onPhantom (allQ1l (@f)) (@h)) => v0^~ (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.on2T	100	0.063477	1	1	0	synth with cache (only 1: refine (fun (v0 : {on @T2 &, allQ2 (@f)}) (v1 v2 : @T1) => v0 v1 v2 (@is_true_true) (@is_true_true))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.subon1	100	0.036312	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.subon1l	100	0.034917	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.subon2	100	0.036523	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.can_in_inj	100	0.115121	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @D1, cancel (@f) (@g)}) (v1 v2 : @T1) (v3 : v1 \in @D1) => ((fun v4 : g (f v1) = v1 => (fun v5 : forall (v5 : v2 \in @D1) (v6 : f v1 = f v2), g (f v1) = v2 => eq_ind (g (f v1)) (fun v6 : @T1 => forall (v7 : v2 \in @D1) (v8 : f v1 = f v2), v6 = v2) v5 v1 v4) (fun v5 : v2 \in @D1 => ((fun v6 : g (f v2) = v2 => (fun v7 : forall v7 : f v1 = f v2, g (f v1) = g (f v2) => eq_ind (g (f v2)) (fun v8 : @T1 => forall v9 : f v1 = f v2, g (f v1) = v8) v7 v2 v6) (fun v7 : f v1 = f v2 => (fun v8 : g (f v2) = g (f v2) => eq_ind_r (fun v9 : @T2 => g v9 = g (f v2)) v8 v7) (erefl (g (f v2))))) : (forall (v6 : (fun v6 : @T1 => g (f v6) = v6) v2) (v7 : f v1 = f v2), g (f v1) = v2)) (v0 v2 v5))) : (forall (v4 : (fun v4 : @T1 => g (f v4) = v4) v1) (v5 : v2 \in @D1) (v6 : f v1 = f v2), v1 = v2)) (v0 v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.canLR_in	100	0.042789	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.canRL_in	100	0.114059	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.on_can_inj	100	0.217460	1	1	0	synth with cache (only 1: refine (fun (v0 : prop_on1 (mem (@D2)) (Phantom (forall v0 : forall v0 : @T2, @T1, Prop) (cancel (@f))) (onPhantom (cancel (@f)) (@g))) (v1 v2 : @T1) (v3 : f v1 \in @D2) => ((fun v4 : g (f v1) = v1 => (fun v5 : forall (v5 : f v2 \in @D2) (v6 : f v1 = f v2), g (f v1) = v2 => eq_ind (g (f v1)) (fun v6 : @T1 => forall (v7 : f v2 \in @D2) (v8 : f v1 = f v2), v6 = v2) v5 v1 v4) (fun v5 : f v2 \in @D2 => ((fun v6 : g (f v2) = v2 => (fun v7 : forall v7 : f v1 = f v2, g (f v1) = g (f v2) => eq_ind (g (f v2)) (fun v8 : @T1 => forall v9 : f v1 = f v2, g (f v1) = v8) v7 v2 v6) (fun v7 : f v1 = f v2 => (fun v8 : g (f v2) = g (f v2) => eq_ind_r (fun v9 : @T2 => g v9 = g (f v2)) v8 v7) (erefl (g (f v2))))) : (forall (v6 : (fun v6 : @T1 => g (f v6) = v6) v2) (v7 : f v1 = f v2), g (f v1) = v2)) (v0 v2 v5))) : (forall (v4 : (fun v4 : @T1 => g (f v4) = v4) v1) (v5 : f v2 \in @D2) (v6 : f v1 = f v2), v1 = v2)) (v0 v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.canLR_on	100	0.040975	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.canRL_on	100	0.045283	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.inW_bij	100	0.072282	1	1	0	synth with cache (only 1: refine (fun v0 : bijective (@f) => (fun v1 : forall (v1 : forall v1 : @T2, @T1) (v2 : cancel (@f) v1) (v3 : cancel v1 (@f)), (fun v4 : bijective (@f) => {in @D1, bijective (@f)}) (Bijective v2 v3) => match v0 as v2 in (bijective _) return ((fun v3 : bijective (@f) => {in @D1, bijective (@f)}) v2) with | @Bijective _ _ _ v2 v3 v4 => v1 v2 v3 v4 end) (fun (v1 : forall v1 : @T2, @T1) (v2 : cancel (@f) v1) (v3 : cancel v1 (@f)) => ex_intro2 (fun v4 : forall v4 : @T2, @T1 => {in @D1, cancel (@f) v4}) (fun v4 : forall v4 : @T2, @T1 => prop_on1 (mem (@D1)) (Phantom (forall v5 : forall v5 : @T1, @T2, Prop) (cancel v4)) (onPhantom (cancel v4) (@f))) v1 (fun (v4 : @T1) (v5 : v4 \in @D1) => v2 v4) (fun (v4 : @T2) (v5 : v1 v4 \in @D1) => v3 v4)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.onW_bij	100	0.073061	1	1	0	synth with cache (only 1: refine (fun v0 : bijective (@f) => (fun v1 : forall (v1 : forall v1 : @T2, @T1) (v2 : cancel (@f) v1) (v3 : cancel v1 (@f)), (fun v4 : bijective (@f) => {on @D2, bijective (@f)}) (Bijective v2 v3) => match v0 as v2 in (bijective _) return ((fun v3 : bijective (@f) => {on @D2, bijective (@f)}) v2) with | @Bijective _ _ _ v2 v3 v4 => v1 v2 v3 v4 end) (fun (v1 : forall v1 : @T2, @T1) (v2 : cancel (@f) v1) (v3 : cancel v1 (@f)) => ex_intro2 (fun v4 : forall v4 : @T2, @T1 => prop_on1 (mem (@D2)) (Phantom (forall v5 : forall v5 : @T2, @T1, Prop) (cancel (@f))) (onPhantom (cancel (@f)) v4)) (fun v4 : forall v4 : @T2, @T1 => {in @D2, cancel v4 (@f)}) v1 (fun (v4 : @T1) (v5 : f v4 \in @D2) => v2 v4) (fun (v4 : @T2) (v5 : v4 \in @D2) => v3 v4)))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.inT_bij	100	0.127217	1	1	0	synth with cache (only 1: refine (fun v0 : {in @T1, bijective (@f)} => (fun v1 : forall (v1 : forall v1 : @T2, @T1) (v2 : (fun v2 : forall v2 : @T2, @T1 => {in @T1, cancel (@f) v2}) v1) (v3 : (fun v3 : forall v3 : @T2, @T1 => prop_on1 (mem (@T1)) (Phantom (forall v4 : forall v4 : @T1, @T2, Prop) (cancel v3)) (onPhantom (cancel v3) (@f))) v1), (fun v4 : exists2 v4 : forall v4 : @T2, @T1, {in @T1, cancel (@f) v4} & prop_on1 (mem (@T1)) (Phantom (forall v5 : forall v5 : @T1, @T2, Prop) (cancel v4)) (onPhantom (cancel v4) (@f)) => bijective (@f)) (ex_intro2 (fun v4 : forall v4 : @T2, @T1 => {in @T1, cancel (@f) v4}) (fun v4 : forall v4 : @T2, @T1 => prop_on1 (mem (@T1)) (Phantom (forall v5 : forall v5 : @T1, @T2, Prop) (cancel v4)) (onPhantom (cancel v4) (@f))) v1 v2 v3) => match v0 as v2 in (ex2 _ _) return ((fun v3 : exists2 v3 : forall v3 : @T2, @T1, {in @T1, cancel (@f) v3} & prop_on1 (mem (@T1)) (Phantom (forall v4 : forall v4 : @T1, @T2, Prop) (cancel v3)) (onPhantom (cancel v3) (@f)) => bijective (@f)) v2) with | ex_intro2 _ _ v2 v3 v4 => v1 v2 v3 v4 end) (fun (v1 : forall v1 : @T2, @T1) (v2 : {in @T1, cancel (@f) v1}) (v3 : prop_on1 (mem (@T1)) (Phantom (forall v3 : forall v3 : @T1, @T2, Prop) (cancel v1)) (onPhantom (cancel v1) (@f))) => Bijective (v2^~ (@is_true_true)) (v3^~ (@is_true_true))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.onT_bij	100	0.126869	1	1	0	synth with cache (only 1: refine (fun v0 : {on @T2, bijective (@f)} => (fun v1 : forall (v1 : forall v1 : @T2, @T1) (v2 : (fun v2 : forall v2 : @T2, @T1 => prop_on1 (mem (@T2)) (Phantom (forall v3 : forall v3 : @T2, @T1, Prop) (cancel (@f))) (onPhantom (cancel (@f)) v2)) v1) (v3 : (fun v3 : forall v3 : @T2, @T1 => {in @T2, cancel v3 (@f)}) v1), (fun v4 : exists2 v4 : forall v4 : @T2, @T1, prop_on1 (mem (@T2)) (Phantom (forall v5 : forall v5 : @T2, @T1, Prop) (cancel (@f))) (onPhantom (cancel (@f)) v4) & {in @T2, cancel v4 (@f)} => bijective (@f)) (ex_intro2 (fun v4 : forall v4 : @T2, @T1 => prop_on1 (mem (@T2)) (Phantom (forall v5 : forall v5 : @T2, @T1, Prop) (cancel (@f))) (onPhantom (cancel (@f)) v4)) (fun v4 : forall v4 : @T2, @T1 => {in @T2, cancel v4 (@f)}) v1 v2 v3) => match v0 as v2 in (ex2 _ _) return ((fun v3 : exists2 v3 : forall v3 : @T2, @T1, prop_on1 (mem (@T2)) (Phantom (forall v4 : forall v4 : @T2, @T1, Prop) (cancel (@f))) (onPhantom (cancel (@f)) v3) & {in @T2, cancel v3 (@f)} => bijective (@f)) v2) with | ex_intro2 _ _ v2 v3 v4 => v1 v2 v3 v4 end) (fun (v1 : forall v1 : @T2, @T1) (v2 : prop_on1 (mem (@T2)) (Phantom (forall v2 : forall v2 : @T2, @T1, Prop) (cancel (@f))) (onPhantom (cancel (@f)) v1)) (v3 : {in @T2, cancel v1 (@f)}) => Bijective (v2^~ (@is_true_true)) (v3^~ (@is_true_true))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.sub_in_bij	100	0.036687	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.LocalGlobal.subon_bij	100	0.031683	2	2
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.sub_in2	100	0.039278	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 v2 : mem_pred v0) (v3 : forall v3 v4 : v0, Prop) (v4 : sub_mem v1 v2) => sub_in11 v4 v4)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.sub_in3	100	0.041513	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 v2 : mem_pred v0) (v3 : forall v3 v4 v5 : v0, Prop) (v4 : sub_mem v1 v2) => sub_in111 v4 v4 v4)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.sub_in12	100	0.057804	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 v3 : mem_pred v0) (v4 v5 : mem_pred v1) (v6 : forall (v6 : v0) (v7 v8 : v1), Prop) (v7 : sub_mem v2 v3) (v8 : sub_mem v4 v5) => sub_in111 v7 v8 v8)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.sub_in21	100	0.057769	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 v3 : mem_pred v0) (v4 v5 : mem_pred v1) (v6 : forall (v6 v7 : v0) (v8 : v1), Prop) (v7 : sub_mem v2 v3) => [eta sub_in111 v7 v7])).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.equivalence_relP_in	100	0.464783	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : rel v0) (v2 : pred v0) => conj (fun v3 : {in v2 & &, equivalence_rel v1} => conj (fun (v4 : v0) (v5 : v4 \in v2) => (fun (v6 : @true) (v7 v8 v9 : v4 \in v2) => eq_ind_r [eta is_true] v6 (v3 v4 v4 v4 v7 v8 v9).1) (@is_true_true) v5 v5 v5) (fun (v4 v5 : v0) (v6 : v4 \in v2) (v7 : v5 \in v2) (v8 : v1 v4 v5) (v9 : v0) => ((fun (v11 : v1 v5 v9 = v1 v5 v9) (v12 : v4 \in v2) (v13 : v5 \in v2) (v14 : v9 \in v2) (v15 : v1 v4 v5) => eq_ind_r (eq^~ (v1 v5 v9)) v11 ((v3 v4 v5 v9 v12 v13 v14).2 v15)) (erefl (v1 v5 v9)) v6 v7)^~ v8)) (fun v3 : {in v2, reflexive v1} /\ {in v2 &, forall (v3 v4 : v0) (v5 : v1 v3 v4), {in v2, v1 v3 =1 v1 v4}} => (fun v4 : forall (v4 : {in v2, reflexive v1}) (v5 : {in v2 &, forall (v5 v6 : v0) (v7 : v1 v5 v6), {in v2, v1 v5 =1 v1 v6}}), (fun v6 : {in v2, reflexive v1} /\ {in v2 &, forall (v6 v7 : v0) (v8 : v1 v6 v7), {in v2, v1 v6 =1 v1 v7}} => {in v2 & &, equivalence_rel v1}) (conj v4 v5) => match v3 as v5 in (_ /\ _) return ((fun v6 : {in v2, reflexive v1} /\ {in v2 &, forall (v6 v7 : v0) (v8 : v1 v6 v7), {in v2, v1 v6 =1 v1 v7}} => {in v2 & &, equivalence_rel v1}) v5) with | conj v5 v6 => v4 v5 v6 end) (fun (v4 : {in v2, reflexive v1}) (v5 : {in v2 &, forall (v5 v6 : v0) (v7 : v1 v5 v6), {in v2, v1 v5 =1 v1 v6}}) (v6 v7 v8 : v0) (v9 : v6 \in v2) (v10 : v7 \in v2) (v11 : v8 \in v2) => (v4 v8 v11, fun v12 : v1 v6 v7 => ((fun v13 : forall (v13 : v6 \in v2) (v14 : v7 \in v2), {in v2, v1 v6 =1 v1 v7} => (fun (v14 : v1 v7 v8 = v1 v7 v8) (v15 : v6 \in v2) (v16 : v7 \in v2) (v17 : v8 \in v2) => eq_ind_r (eq^~ (v1 v7 v8)) v14 (v13 v15 v16 v8 v17)) (erefl (v1 v7 v8)) v9 v10 v11) : (forall v13 : forall (v13 : v6 \in v2) (v14 : v7 \in v2), {in v2, v1 v6 =1 v1 v7}, v1 v6 v8 = v1 v7 v8)) (fun v13 : v6 \in v2 => (v5 v6 v7 v13)^~ v12)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.monoW	100	0.043587	1	1	0	synth with cache (only 1: refine (fun (v0 : {mono @f : v0 / aP v0 >-> rP v0}) (v1 : @aT) => [eta fun v3 : aP v1 => eq_ind_r [eta is_true] v3 (v0 v1)])).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.mono2W	100	0.053662	1	1	0	synth with cache (only 1: refine (fun (v0 : {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}) (v1 v2 : @aT) => [eta fun v4 : aR v1 v2 => eq_ind_r [eta is_true] v4 (v0 v1 v2)])).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.homoRL	100	0.059616	1	1	0	synth with cache (only 1: refine (fun (v0 : {homo @f : v0 v1 / aR v0 v1 >-> rR v0 v1}) (v1 : @rT) (v2 : @aT) (v3 : aR (g v1) v2) => ((fun v4 : forall v4 : rR v1 (f v2), rR v1 (f v2) => eq_ind_r (fun v5 : @rT => forall v6 : rR v5 (f v2), rR v1 (f v2)) v4 (fgK v1)) id : (forall v4 : (fun v4 v5 : @rT => is_true (rR v4 v5)) (f (g v1)) (f v2), rR v1 (f v2))) (v0 (g v1) v2 v3))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.homoLR	100	0.058599	1	1	0	synth with cache (only 1: refine (fun (v0 : {homo @f : v0 v1 / aR v0 v1 >-> rR v0 v1}) (v1 : @aT) (v2 : @rT) (v3 : aR v1 (g v2)) => ((fun v4 : forall v4 : rR (f v1) v2, rR (f v1) v2 => eq_ind_r (fun v5 : @rT => forall v6 : rR (f v1) v5, rR (f v1) v2) v4 (fgK v2)) id : (forall v4 : (fun v4 v5 : @rT => is_true (rR v4 v5)) (f v1) (f (g v2)), rR (f v1) v2)) (v0 v1 (g v2) v3))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.homo_mono	100	0.173741	1	1	0	synth with cache (only 1: refine (fun (v0 : {homo @f : v0 v1 / aR v0 v1 >-> rR v0 v1}) (v1 : {homo @g : v1 v2 / rR v1 v2 >-> aR v1 v2}) (v2 v3 : @rT) => (fun (v4 : forall v4 : rR v2 v3, (fun (v5 : @bool) (v6 : alt_spec (rR v2 v3) (rR v2 v3) v5) => aR (g v2) (g v3) = v5) (@true) (AltTrue (rR v2 v3) v4)) (v5 : forall v5 : ~~ rR v2 v3, (fun (v6 : @bool) (v7 : alt_spec (rR v2 v3) (rR v2 v3) v6) => aR (g v2) (g v3) = v6) (@false) (AltFalse (rR v2 v3) v5)) => match boolP (rR v2 v3) as v7 in (alt_spec _ _ v6) return ((fun (v8 : @bool) (v9 : alt_spec (rR v2 v3) (rR v2 v3) v8) => aR (g v2) (g v3) = v8) v6 v7) with | AltTrue _ v6 => v4 v6 | AltFalse _ v6 => v5 v6 end) (fun v4 : rR v2 v3 => (id : (forall v5 : (fun v5 v6 : @aT => is_true (aR v5 v6)) (g v2) (g v3), aR (g v2) (g v3) = @true)) (v1 v2 v3 v4)) (contraNF (fun v4 : aR (g v2) (g v3) => ((fun v5 : forall v5 : rR v2 (f (g v3)), rR v2 v3 => eq_ind_r (fun v6 : @rT => forall v7 : rR v6 (f (g v3)), rR v2 v3) v5 (fgK v2)) ((fun v5 : forall v5 : rR v2 v3, rR v2 v3 => eq_ind_r (fun v6 : @rT => forall v7 : rR v2 v6, rR v2 v3) v5 (fgK v3)) id) : (forall v5 : (fun v5 v6 : @rT => is_true (rR v5 v6)) (f (g v2)) (f (g v3)), rR v2 v3)) (v0 (g v2) (g v3) v4))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.monoLR	100	0.060632	1	1	0	synth with cache (only 1: refine (fun (v0 : {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}) (v1 : @aT) (v2 : @rT) => (fun v3 : rR (f v1) (f (g v2)) = aR v1 (g v2) => eq_ind (f (g v2)) (fun v4 : @rT => rR (f v1) v4 = aR v1 (g v2)) v3 v2 (fgK v2)) ((fun v3 : aR v1 (g v2) = aR v1 (g v2) => eq_ind_r (eq^~ (aR v1 (g v2))) v3 (v0 v1 (g v2))) (erefl (aR v1 (g v2)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.monoRL	100	0.083881	1	1	0	synth with cache (only 1: refine (fun (v0 : {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}) (v1 : @rT) (v2 : @aT) => (fun v3 : rR (f (g v1)) (f v2) = aR (g v1) v2 => eq_ind (f (g v1)) (fun v4 : @rT => rR v4 (f v2) = aR (g v1) v2) v3 v1 (fgK v1)) ((fun v3 : aR (g v1) v2 = aR (g v1) v2 => eq_ind_r (eq^~ (aR (g v1) v2)) v3 (v0 (g v1) v2)) (erefl (aR (g v1) v2))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory.can_mono	100	0.074349	1	1	0	synth with cache (only 1: refine (fun (v0 : {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}) (v1 v2 : @rT) => (fun v3 : rR (f (g v1)) (f (g v2)) = rR v1 v2 => eq_ind ((fun v4 : @rT => [eta rR v4]) (f (g v1)) (f (g v2))) (eq^~ (rR v1 v2)) v3 (aR (g v1) (g v2)) (v0 (g v1) (g v2))) ((fun v3 : rR v1 (f (g v2)) = rR v1 v2 => eq_ind_r (fun v4 : @rT => rR v4 (f (g v2)) = rR v1 v2) v3 (fgK v1)) ((fun v3 : rR v1 v2 = rR v1 v2 => eq_ind_r (fun v4 : @rT => rR v1 v4 = rR v1 v2) v3 (fgK v2)) (erefl (rR v1 v2)))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.monoW_in	100	0.150075	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD &, {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}}) (v1 v2 : @aT) (v3 : v1 \in @aD) (v4 : v2 \in @aD) (v5 : aR v1 v2) => (fun (v6 : aR v1 v2) (v7 : v1 \in @aD) (v8 : v2 \in @aD) => eq_ind_r [eta is_true] v6 (v0 v1 v2 v7 v8)) v5 v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.mono2W_in	100	0.107336	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD, {mono @f : v0 / aP v0 >-> rP v0}}) (v1 : @aT) (v2 : v1 \in @aD) => (fun (v4 : aP v1) (v5 : v1 \in @aD) => eq_ind_r [eta is_true] v4 (v0 v1 v5))^~ v2)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.homoRL_in	100	0.204668	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD &, {homo @f : v0 v1 / aR v0 v1 >-> rR v0 v1}}) (v1 : @rT) (v2 : @aT) (v3 : v1 \in [pred v3 | g v3 \in @aD]) (v4 : v2 \in @aD) (v5 : aR (g v1) v2) => ((fun (v6 : forall v6 : forall (v6 : g v1 \in @aD) (v7 : v2 \in @aD), rR v1 (f v2), rR v1 (f v2)) (v7 : g v1 \in @aD) => eq_ind_r (fun v8 : @rT => forall v9 : forall (v9 : g v1 \in @aD) (v10 : v2 \in @aD), rR v8 (f v2), rR v1 (f v2)) v6 (fgK_on v7)) (fun v6 : forall (v6 : g v1 \in @aD) (v7 : v2 \in @aD), rR v1 (f v2) => (fun v7 : g v1 \in @aD => [eta v6 v7]) v3 v4) v3 : (forall v6 : forall (v6 : g v1 \in @aD) (v7 : v2 \in @aD), (fun v8 v9 : @rT => is_true (rR v8 v9)) (f (g v1)) (f v2), rR v1 (f v2))) (fun v6 : g v1 \in @aD => (v0 (g v1) v2 v6)^~ v5))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.homoLR_in	100	0.208973	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD &, {homo @f : v0 v1 / aR v0 v1 >-> rR v0 v1}}) (v1 : @aT) (v2 : @rT) (v3 : v1 \in @aD) (v4 : v2 \in [pred v4 | g v4 \in @aD]) (v5 : aR v1 (g v2)) => ((fun (v6 : forall v6 : forall (v6 : v1 \in @aD) (v7 : g v2 \in @aD), rR (f v1) v2, rR (f v1) v2) (v7 : g v2 \in @aD) => eq_ind_r (fun v8 : @rT => forall v9 : forall (v9 : v1 \in @aD) (v10 : g v2 \in @aD), rR (f v1) v8, rR (f v1) v2) v6 (fgK_on v7)) (fun v6 : forall (v6 : v1 \in @aD) (v7 : g v2 \in @aD), rR (f v1) v2 => (fun v7 : v1 \in @aD => [eta v6 v7]) v3 v4) v4 : (forall v6 : forall (v6 : v1 \in @aD) (v7 : g v2 \in @aD), (fun v8 v9 : @rT => is_true (rR v8 v9)) (f v1) (f (g v2)), rR (f v1) v2)) (fun v6 : v1 \in @aD => (v0 v1 (g v2) v6)^~ v5))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.homo_mono_in	100	0.387599	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD &, {homo @f : v0 v1 / aR v0 v1 >-> rR v0 v1}}) (v1 : {in [pred v1 | g v1 \in @aD] &, {homo @g : v1 v2 / rR v1 v2 >-> aR v1 v2}}) (v2 v3 : @rT) (v4 : v2 \in [pred v4 | g v4 \in @aD]) (v5 : v3 \in [pred v5 | g v5 \in @aD]) => (fun (v6 : forall v6 : rR v2 v3, (fun (v7 : @bool) (v8 : alt_spec (rR v2 v3) (rR v2 v3) v7) => aR (g v2) (g v3) = v7) (@true) (AltTrue (rR v2 v3) v6)) (v7 : forall v7 : ~~ rR v2 v3, (fun (v8 : @bool) (v9 : alt_spec (rR v2 v3) (rR v2 v3) v8) => aR (g v2) (g v3) = v8) (@false) (AltFalse (rR v2 v3) v7)) => match boolP (rR v2 v3) as v9 in (alt_spec _ _ v8) return ((fun (v10 : @bool) (v11 : alt_spec (rR v2 v3) (rR v2 v3) v10) => aR (g v2) (g v3) = v10) v8 v9) with | AltTrue _ v8 => v6 v8 | AltFalse _ v8 => v7 v8 end) (fun v6 : rR v2 v3 => ((fun v7 : forall (v7 : v2 \in [pred v7 | g v7 \in @aD]) (v8 : v3 \in [pred v8 | g v8 \in @aD]), aR (g v2) (g v3) => (fun v8 : v2 \in [pred v8 | g v8 \in @aD] => [eta v7 v8]) v4 v5) : (forall v7 : forall (v7 : v2 \in [pred v7 | g v7 \in @aD]) (v8 : v3 \in [pred v8 | g v8 \in @aD]), (fun v9 v10 : @aT => is_true (aR v9 v10)) (g v2) (g v3), aR (g v2) (g v3) = @true)) (fun v7 : v2 \in [pred v7 | g v7 \in @aD] => (v1 v2 v3 v7)^~ v6)) (contraNF (fun v6 : aR (g v2) (g v3) => ((fun (v7 : forall v7 : forall (v7 : g v2 \in @aD) (v8 : g v3 \in @aD), rR v2 (f (g v3)), rR v2 v3) (v8 : g v2 \in @aD) => eq_ind_r (fun v9 : @rT => forall v10 : forall (v10 : g v2 \in @aD) (v11 : g v3 \in @aD), rR v9 (f (g v3)), rR v2 v3) v7 (fgK_on v8)) ((fun (v7 : forall v7 : forall (v7 : g v2 \in @aD) (v8 : g v3 \in @aD), rR v2 v3, rR v2 v3) (v8 : g v3 \in @aD) => eq_ind_r (fun v9 : @rT => forall v10 : forall (v10 : g v2 \in @aD) (v11 : g v3 \in @aD), rR v2 v9, rR v2 v3) v7 (fgK_on v8)) (fun v7 : forall (v7 : g v2 \in @aD) (v8 : g v3 \in @aD), rR v2 v3 => (fun v8 : g v2 \in @aD => [eta v7 v8]) v4 v5) v5) v4 : (forall v7 : forall (v7 : g v2 \in @aD) (v8 : g v3 \in @aD), (fun v9 v10 : @rT => is_true (rR v9 v10)) (f (g v2)) (f (g v3)), rR v2 v3)) (fun v7 : g v2 \in @aD => (v0 (g v2) (g v3) v7)^~ v6))))).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.monoLR_in	100	0.307176	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD &, {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}}) (v1 : @aT) (v2 : @rT) (v3 : v1 \in @aD) (v4 : v2 \in [pred v4 | g v4 \in @aD]) => (fun (v5 : rR (f v1) (f (g v2)) = aR v1 (g v2)) (v6 : g v2 \in @aD) => eq_ind (f (g v2)) (fun v7 : @rT => rR (f v1) v7 = aR v1 (g v2)) v5 v2 (fgK_on v6)) ((fun (v5 : aR v1 (g v2) = aR v1 (g v2)) (v6 : v1 \in @aD) (v7 : g v2 \in @aD) => eq_ind_r (eq^~ (aR v1 (g v2))) v5 (v0 v1 (g v2) v6 v7)) (erefl (aR v1 (g v2))) v3 v4) v4)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.monoRL_in	100	0.197291	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD &, {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}}) (v1 : @rT) (v2 : @aT) (v3 : v1 \in [pred v3 | g v3 \in @aD]) (v4 : v2 \in @aD) => (fun (v5 : rR (f (g v1)) (f v2) = aR (g v1) v2) (v6 : g v1 \in @aD) => eq_ind (f (g v1)) (fun v7 : @rT => rR v7 (f v2) = aR (g v1) v2) v5 v1 (fgK_on v6)) ((fun (v5 : aR (g v1) v2 = aR (g v1) v2) (v6 : g v1 \in @aD) (v7 : v2 \in @aD) => eq_ind_r (eq^~ (aR (g v1) v2)) v5 (v0 (g v1) v2 v6 v7)) (erefl (aR (g v1) v2)) v3 v4) v3)).
coq-tactician-stdlib.8.11.dev	Coq.ssr.ssrbool.MonoHomoMorphismTheory_in.can_mono_in	100	0.183415	1	1	0	synth with cache (only 1: refine (fun (v0 : {in @aD &, {mono @f : v0 v1 / aR v0 v1 >-> rR v0 v1}}) (v1 v2 : @rT) (v3 : v1 \in [pred v3 | g v3 \in @aD]) (v4 : v2 \in [pred v4 | g v4 \in @aD]) => (fun (v5 : rR (f (g v1)) (f (g v2)) = rR v1 v2) (v6 : g v1 \in @aD) (v7 : g v2 \in @aD) => eq_ind ((fun v8 : @rT => [eta rR v8]) (f (g v1)) (f (g v2))) (eq^~ (rR v1 v2)) v5 (aR (g v1) (g v2)) (v0 (g v1) (g v2) v6 v7)) ((fun (v5 : rR v1 (f (g v2)) = rR v1 v2) (v6 : g v1 \in @aD) => eq_ind_r (fun v7 : @rT => rR v7 (f (g v2)) = rR v1 v2) v5 (fgK_on v6)) ((fun (v5 : rR v1 v2 = rR v1 v2) (v6 : g v2 \in @aD) => eq_ind_r (fun v7 : @rT => rR v1 v7 = rR v1 v2) v5 (fgK_on v6)) (erefl (rR v1 v2)) v4) v3) v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.prop_degen_ext	100	0.076984	1	1	0	synth with cache (only 1: refine (fun v0 : @prop_degeneracy => (fun (v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 = v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => let v6 : v1 = @True \/ v1 = @False := v0 v1 in match v6 as v7 in (_ \/ _) return (v1 = v2) with | or_introl v7 => (fun v7 : v1 = @True => let v8 : v2 = @True \/ v2 = @False := v0 v2 in match v8 as v9 in (_ \/ _) return (v1 = v2) with | or_introl v9 => (fun v9 : v2 = @True => eq_ind_r (fun v10 : Prop => v1 = v10) v7 v9) v9 | or_intror v9 => (fun v9 : v2 = @False => False_ind (v1 = v2) (eq_ind_r (fun v10 : Prop => ~ v10) (fun v10 : @False => v10) v9 (v4 (eq_ind_r (fun v10 : Prop => v10) (@I) v7)))) v9 end) v7 | or_intror v7 => (fun v7 : v1 = @False => let v8 : v2 = @True \/ v2 = @False := v0 v2 in match v8 as v9 in (_ \/ _) return (v1 = v2) with | or_introl v9 => (fun v9 : v2 = @True => False_ind (v1 = v2) (eq_ind_r (fun v10 : Prop => ~ v10) (fun v10 : @False => v10) v7 (v5 (eq_ind_r (fun v10 : Prop => v10) (@I) v9)))) v9 | or_intror v9 => (fun v9 : v2 = @False => eq_ind_r (fun v10 : Prop => v1 = v10) v7 v9) v9 end) v7 end) v4 v5 end) : @prop_extensionality)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.prop_degen_em	100	0.034419	1	1	0	synth with cache (only 1: refine (fun v0 : @prop_degeneracy => (fun v1 : Prop => let v2 : v1 = @True \/ v1 = @False := v0 v1 in match v2 as v3 in (_ \/ _) return (v1 \/ ~ v1) with | or_introl v3 => (fun v3 : v1 = @True => or_introl (eq_ind_r (fun v4 : Prop => v4) (@I) v3)) v3 | or_intror v3 => (fun v3 : v1 = @False => or_intror (eq_ind_r (fun v4 : Prop => ~ v4) (fun v4 : @False => v4) v3)) v3 end) : @excluded_middle)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.prop_ext_em_degen	100	0.044853	1	1	0	synth with cache (only 1: refine (fun (v0 : @prop_extensionality) (v1 : @excluded_middle) => (fun v2 : Prop => let v3 : v2 \/ ~ v2 := v1 v2 in match v3 as v4 in (_ \/ _) return (v2 = @True \/ v2 = @False) with | or_introl v4 => (fun v4 : v2 => or_introl (v0 v2 (@True) (conj (fun v5 : v2 => @I) (fun v5 : @True => v4)))) v4 | or_intror v4 => (fun v4 : ~ v2 => or_intror (v0 v2 (@False) (conj v4 (False_ind v2)))) v4 end) : @prop_degeneracy)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.provable_prop_ext	100	0.022914	1	1	0	synth with cache (only 1: refine @PropExt_imp_ProvPropExt).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.prop_ext_A_eq_A_imp_A	100	0.028949	1	1	0	synth with cache (only 1: refine (fun (v0 : @prop_extensionality) (v1 : Prop) (v2 : v1) => v0 (forall v3 : v1, v1) v1 (conj (fun v3 : forall v3 : v1, v1 => v2) (fun v3 v4 : v1 => v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.prop_ext_retract_A_A_imp_A	100	0.030599	1	1	0	synth with cache (only 1: refine (fun (v0 : @prop_extensionality) (v1 : Prop) (v2 : v1) => eq_ind_r (fun v3 : Prop => retract v1 v3) {| f1 := fun v3 : v1 => v3; f2 := fun v3 : v1 => v3; f1_o_f2 := fun v3 : v1 => eq_refl |} (prop_ext_A_eq_A_imp_A v0 v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.ext_prop_fixpoint	100	0.060169	1	1	0	synth with cache (only 1: refine (fun (v0 : @prop_extensionality) (v1 : Prop) (v2 : v1) => match prop_ext_retract_A_A_imp_A v0 v1 v2 as v3 in (retract _ _) return (has_fixpoint v1) with | {| f1 := v3; f2 := v4; f1_o_f2 := v5 |} => (fun (v3 : forall v3 v4 : v1, v1) (v4 : forall v4 : forall v4 : v1, v1, v1) (v5 : forall v5 : forall v5 : v1, v1, v3 (v4 v5) = v5) => {| F := fun v6 : forall v6 : v1, v1 => v6 (v3 (v4 (fun v7 : v1 => v6 (v3 v7 v7))) (v4 (fun v7 : v1 => v6 (v3 v7 v7)))); Fix := fun v6 : forall v6 : v1, v1 => eq_ind_r (fun v7 : forall v7 : v1, v1 => v6 (v7 (v4 (fun v8 : v1 => v6 (v3 v8 v8)))) = v6 (v6 (v3 (v4 (fun v8 : v1 => v6 (v3 v8 v8))) (v4 (fun v8 : v1 => v6 (v3 v8 v8)))))) eq_refl (v5 (fun v7 : v1 => v6 (v3 v7 v7))) : v6 (v3 (v4 (fun v7 : v1 => v6 (v3 v7 v7))) (v4 (fun v7 : v1 => v6 (v3 v7 v7)))) = v6 (v6 (v3 (v4 (fun v7 : v1 => v6 (v3 v7 v7))) (v4 (fun v7 : v1 => v6 (v3 v7 v7))))) |}) v3 v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_gen.aux	100	0.064239	1	1	0	synth with cache (only 1: refine (fun (v0 : @prop_extensionality) (v1 : @bool_dep_induction) => match ext_prop_fixpoint v0 (@bool) (@true) as v2 in (has_fixpoint _) return (@true = @false) with | {| F := v2; Fix := v3 |} => (fun (v2 : forall v2 : forall v2 : @bool, @bool, @bool) (v3 : forall v3 : forall v3 : @bool, @bool, v2 v3 = v3 (v2 v3)) => let v4 : forall v4 : @bool, @bool := fun v4 : @bool => bool_elim (@bool) (@false) (@true) v4 in (v1 (fun v5 : @bool => forall v6 : v5 = v2 v4, @true = @false) (fun v5 : @true = v2 v4 => eq_ind_r (fun v6 : @bool => @true = v6) (eq_ind_r (fun v6 : @bool => v6 = v4 v6) (v3 v4) v5) (bool_elim_redl (@bool) (@false) (@true))) (fun v5 : @false = v2 v4 => eq_ind_r (fun v6 : @bool => v6 = @false) (eq_ind_r (fun v6 : @bool => v4 v6 = v6) (eq_sym (v3 v4)) v5) (bool_elim_redr (@bool) (@false) (@true))) (v2 v4) : forall v5 : v2 v4 = v2 v4, @true = @false) eq_refl) v2 v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_gen.ext_prop_dep_proof_irrel_gen	100	0.042499	1	1	0	synth with cache (only 1: refine (fun (v0 : @prop_extensionality) (v1 : @bool_dep_induction) => (fun (v2 : Prop) (v3 v4 : v2) => let v5 : forall v5 : @bool, v2 := fun v5 : @bool => bool_elim v2 v3 v4 v5 in eq_ind_r (fun v6 : v2 => v6 = v4) (eq_ind_r (fun v6 : v2 => v5 (@true) = v6) (eq_ind_r (fun v6 : @bool => v5 v6 = v5 (@false)) eq_refl (aux v0 v1)) (bool_elim_redr v2 v3 v4)) (bool_elim_redl v2 v3 v4)) : @proof_irrelevance)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_Prop_Ext_CC.ext_prop_dep_proof_irrel_cc	100	0.026864	1	1	0	synth with cache (only 1: refine (ext_prop_dep_proof_irrel_gen (@BoolP) (@TrueP) (@FalseP) (@BoolP_elim) (@BoolP_elim_redl) (@BoolP_elim_redr))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_CIC.ext_prop_dep_proof_irrel_cic	100	0.028775	1	1	0	synth with cache (only 1: refine (fun v0 : @prop_extensionality => ext_prop_dep_proof_irrel_gen (@boolP) (@trueP) (@falseP) (@boolP_ind) (@boolP_elim_redl) (@boolP_elim_redr) v0 (@boolP_indd))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_EM_CC.p2p1	100	0.044236	1	1	0	synth with cache (only 1: refine ((fun v0 : Prop => or_dep_elim v0 (~ v0) (fun v1 : or v0 (~ v0) => forall v2 : v0, b2p (or_elim v0 (~ v0) (@B) (fun v3 : v0 => @b1) (fun v3 : ~ v0 => @b2) v1)) ((fun v1 v2 : v0 => or_elim_redl v0 (~ v0) (@B) (fun v3 : v0 => @b1) (fun v3 : ~ v0 => @b2) v1) : forall v1 v2 : v0, b2p (or_elim v0 (~ v0) (@B) (fun v3 : v0 => @b1) (fun v3 : ~ v0 => @b2) (or_introl v0 (~ v0) v1))) ((fun (v1 : ~ v0) (v2 : v0) => let v3 : @False := v1 v2 in match v3 as v4 in False return (@b1 = or_elim v0 (~ v0) (@B) (fun v5 : v0 => @b1) (fun v5 : ~ v0 => @b2) (or_intror v0 (~ v0) v1)) with end) : forall (v1 : ~ v0) (v2 : v0), b2p (or_elim v0 (~ v0) (@B) (fun v3 : v0 => @b1) (fun v3 : ~ v0 => @b2) (or_intror v0 (~ v0) v1))) (em v0)) : forall (v0 : Prop) (v1 : v0), b2p (p2b v0))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_EM_CC.p2p2	100	0.077604	1	1	0	synth with cache (only 1: refine (fun v0 : @b1 <> @b2 => (fun v1 : Prop => or_dep_elim v1 (~ v1) (fun v2 : or v1 (~ v1) => forall v3 : b2p (or_elim v1 (~ v1) (@B) (fun v3 : v1 => @b1) (fun v3 : ~ v1 => @b2) v2), v1) ((fun (v2 : v1) (v3 : @b1 = or_elim v1 (~ v1) (@B) (fun v3 : v1 => @b1) (fun v3 : ~ v1 => @b2) (or_introl v1 (~ v1) v2)) => v2) : forall (v2 : v1) (v3 : b2p (or_elim v1 (~ v1) (@B) (fun v3 : v1 => @b1) (fun v3 : ~ v1 => @b2) (or_introl v1 (~ v1) v2))), v1) ((fun (v2 : ~ v1) (v3 : @b1 = or_elim v1 (~ v1) (@B) (fun v3 : v1 => @b1) (fun v3 : ~ v1 => @b2) (or_intror v1 (~ v1) v2)) => let v4 : @False := v0 (let v4 : @b1 = @b2 := eq_ind_r (fun v4 : @B => @b1 = v4) v3 (or_elim_redr v1 (~ v1) (@B) (fun v4 : v1 => @b1) (fun v4 : ~ v1 => @b2) v2) in v4) in match v4 as v5 in False return v1 with end) : forall (v2 : ~ v1) (v3 : b2p (or_elim v1 (~ v1) (@B) (fun v3 : v1 => @b1) (fun v3 : ~ v1 => @b2) (or_intror v1 (~ v1) v2))), v1) (em v1)) : forall (v1 : Prop) (v2 : b2p (p2b v1)), v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_EM_CC.proof_irrelevance_cc	100	0.040949	1	1	0	synth with cache (only 1: refine (or_elim (@b1 = @b2) (@b1 <> @b2) (@b1 = @b2) ((fun v0 : @b1 = @b2 => v0) : forall v0 : @b1 = @b2, @b1 = @b2) ((fun v0 : @b1 <> @b2 => NoRetractFromSmallPropositionToProp.paradox (@B) (@p2b) (@b2p) (p2p2 v0) (@p2p1) (@b1 = @b2)) : forall v0 : @b1 <> @b2, @b1 = @b2) (em (@b1 = @b2)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_WEM_CC.wp2p1	100	0.077980	1	1	0	synth with cache (only 1: refine (fun v0 : NProp => or_dep_elim (~ ~ El v0) (~ El v0) (fun v1 : or (~ ~ El v0) (~ El v0) => forall v2 : El v0, El (b2p (or_elim (~ ~ El v0) (~ El v0) (@B) (fun v3 : ~ ~ El v0 => @b1) (fun v3 : ~ El v0 => @b2) v1))) (fun (v1 : ~ ~ El v0) (v2 : El v0) => eq_ind (@b1) (fun v3 : @B => El (b2p v3)) (((fun v3 : forall v3 : @b1 = @b1, @False => v3 eq_refl) : ~ @b1 <> @b1) : El (b2p (@b1))) (or_elim (~ ~ El v0) (~ El v0) (@B) (fun v3 : ~ ~ El v0 => @b1) (fun v3 : ~ El v0 => @b2) (or_introl (~ ~ El v0) (~ El v0) v1)) (or_elim_redl (~ ~ El v0) (~ El v0) (@B) (fun v3 : ~ ~ El v0 => @b1) (fun v3 : ~ El v0 => @b2) v1)) (fun (v1 : ~ El v0) (v2 : El v0) => let v3 : @False := v1 v2 in match v3 as v4 in False return (El (b2p (or_elim (~ ~ El v0) (~ El v0) (@B) (fun v5 : ~ ~ El v0 => @b1) (fun v5 : ~ El v0 => @b2) (or_intror (~ ~ El v0) (~ El v0) v1)))) with end) (wem (El v0)) : forall v1 : El v0, El (b2p (p2b v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_WEM_CC.wp2p2	100	0.109928	1	1	0	synth with cache (only 1: refine (fun (v0 : @b1 <> @b2) (v1 : NProp) => or_dep_elim (~ ~ El v1) (~ El v1) (fun v2 : or (~ ~ El v1) (~ El v1) => forall v3 : El (b2p (or_elim (~ ~ El v1) (~ El v1) (@B) (fun v3 : ~ ~ El v1 => @b1) (fun v3 : ~ El v1 => @b2) v2)), El v1) ((fun (v2 : ~ ~ El v1) (v3 : ~ @b1 <> or_elim (~ ~ El v1) (~ El v1) (@B) (fun v3 : ~ ~ El v1 => @b1) (fun v3 : ~ El v1 => @b2) (or_introl (~ ~ El v1) (~ El v1) v2)) => match v1 as v4 in (sig _) return (forall v5 : ~ ~ El v4, El v4) with | exist _ v4 v5 => (fun (v4 : Prop) (v5 : forall v5 : ~ ~ v4, v4) (v6 : ~ ~ El (exist (fun v6 : Prop => forall v7 : ~ ~ v6, v6) v4 v5)) => v5 v6 : El (exist (fun v7 : Prop => forall v8 : ~ ~ v7, v7) v4 v5)) v4 v5 end v2) : forall (v2 : ~ ~ El v1) (v3 : El (b2p (or_elim (~ ~ El v1) (~ El v1) (@B) (fun v3 : ~ ~ El v1 => @b1) (fun v3 : ~ El v1 => @b2) (or_introl (~ ~ El v1) (~ El v1) v2)))), El v1) (fun v2 : ~ El v1 => eq_ind (@b2) (fun v3 : @B => forall v4 : El (b2p v3), El v1) ((fun v3 : ~ @b1 <> @b2 => let v4 : @False := v3 v0 in match v4 as v5 in False return (El v1) with end) : forall v3 : El (b2p (@b2)), El v1) (or_elim (~ ~ El v1) (~ El v1) (@B) (fun v3 : ~ ~ El v1 => @b1) (fun v3 : ~ El v1 => @b2) (or_intror (~ ~ El v1) (~ El v1) v2)) (or_elim_redr (~ ~ El v1) (~ El v1) (@B) (fun v3 : ~ ~ El v1 => @b1) (fun v3 : ~ El v1 => @b2) v2)) (wem (El v1)) : forall v2 : El (b2p (p2b v1)), El v1)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_WEM_CC.wproof_irrelevance_cc	100	0.046004	1	1	0	synth with cache (only 1: refine ((fun v0 : @b1 <> @b2 => let v1 : {v1 : Prop | forall v2 : ~ ~ v1, v1} := exist (fun v1 : Prop => forall v2 : ~ ~ v1, v1) (@B) ((fun v1 : ~ ~ @B => @b1) : (fun v1 : Prop => forall v2 : ~ ~ v1, v1) (@B)) in (let v2 : forall v2 : NProp, El v2 := NoRetractToNegativeProp.paradox v1 (@p2b) (@b2p) (wp2p2 v0) (@wp2p1) in let v3 : {v3 : Prop | forall v4 : ~ ~ v3, v3} := exist (fun v3 : Prop => forall v4 : ~ ~ v3, v3) (@False) ((fun v3 : ~ ~ @False => v3 ((fun v4 : @False => v4) : ~ @False)) : (fun v3 : Prop => forall v4 : ~ ~ v3, v3) (@False)) in v2 v3 : @False) : @False) : ~ @b1 <> @b2)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Proof_irrelevance_CCI.proof_irrelevance_cci	100	0.033166	0	1
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Weak_proof_irrelevance_CCI.wem_proof_irrelevance_cci	100	0.029344	1	1	0	synth with cache (only 1: refine (wproof_irrelevance_cc (@or) (@or_introl) (@or_intror) (@or_ind) (@or_elim_redl) (@or_elim_redr) (@or_indd) (@wem))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.excluded_middle_Godel_Dummett	100	0.042265	1	1	0	synth with cache (only 1: refine (fun v0 : @excluded_middle => (fun v1 v2 : Prop => let v3 : v2 \/ ~ v2 := v0 v2 in match v3 as v4 in (_ \/ _) return ((forall v5 : v1, v2) \/ (forall v5 : v2, v1)) with | or_introl v4 => (fun v4 : v2 => or_introl (fun v5 : v1 => v4)) v4 | or_intror v4 => (fun v4 : ~ v2 => or_intror (fun v5 : v2 => let v6 : @False := v4 v5 in match v6 as v7 in False return v1 with end)) v4 end) : @GodelDummett)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Godel_Dummett_iff_right_distr_implication_over_disjunction	100	0.076730	1	1	0	synth with cache (only 1: refine (conj (fun v0 : @GodelDummett => (fun (v1 v2 v3 : Prop) (v4 : forall v4 : v3, v1 \/ v2) => let v5 : (forall v5 : v2, v1) \/ (forall v5 : v1, v2) := v0 v2 v1 in match v5 as v6 in (_ \/ _) return ((forall v7 : v3, v1) \/ (forall v7 : v3, v2)) with | or_introl v6 => (fun v6 : forall v6 : v2, v1 => or_introl (fun v7 : v3 => let v8 : v1 \/ v2 := v4 v7 in match v8 as v9 in (_ \/ _) return v1 with | or_introl v9 => (fun v9 : v1 => v9) v9 | or_intror v9 => (fun v9 : v2 => v6 v9) v9 end)) v6 | or_intror v6 => (fun v6 : forall v6 : v1, v2 => or_intror (fun v7 : v3 => let v8 : v1 \/ v2 := v4 v7 in match v8 as v9 in (_ \/ _) return v2 with | or_introl v9 => (fun v9 : v1 => v6 v9) v9 | or_intror v9 => (fun v9 : v2 => v9) v9 end)) v6 end) : @RightDistributivityImplicationOverDisjunction) (fun v0 : @RightDistributivityImplicationOverDisjunction => (fun v1 v2 : Prop => let v3 : (forall v3 : v1 \/ v2, v1) \/ (forall v3 : v1 \/ v2, v2) := v0 v1 v2 (v1 \/ v2) (fun v3 : v1 \/ v2 => v3) in match v3 as v4 in (_ \/ _) return ((forall v5 : v1, v2) \/ (forall v5 : v2, v1)) with | or_introl v4 => (fun v4 : forall v4 : v1 \/ v2, v1 => or_intror (fun v5 : v2 => v4 (or_intror v5))) v4 | or_intror v4 => (fun v4 : forall v4 : v1 \/ v2, v2 => or_introl (fun v5 : v1 => v4 (or_introl v5))) v4 end) : @GodelDummett))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Godel_Dummett_weak_excluded_middle	100	0.041281	1	1	0	synth with cache (only 1: refine (fun v0 : @GodelDummett => (fun v1 : Prop => let v2 : (forall v2 : ~ v1, v1) \/ (forall v2 : v1, ~ v1) := v0 (~ v1) v1 in match v2 as v3 in (_ \/ _) return (~ ~ v1 \/ ~ v1) with | or_introl v3 => (fun v3 : forall v3 : ~ v1, v1 => or_introl ((fun v4 : ~ v1 => v4 (v3 v4)) : ~ ~ v1)) v3 | or_intror v3 => (fun v3 : forall v3 : v1, ~ v1 => or_intror ((fun v4 : v1 => v3 v4 v4) : ~ v1)) v3 end) : @weak_excluded_middle)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.weak_excluded_middle_iff_classical_de_morgan_law	100	0.077713	1	1	0	synth with cache (only 1: refine (conj (fun v0 : @weak_excluded_middle => (fun v1 v2 : Prop => let v3 : ~ ~ v1 \/ ~ v1 := v0 v1 in match v3 as v4 in (_ \/ _) return (forall v5 : ~ (v1 /\ v2), ~ v1 \/ ~ v2) with | or_introl v4 => (fun (v4 : ~ ~ v1) (v5 : ~ (v1 /\ v2)) => let v6 : forall (v6 : v1) (v7 : v2), @False := fun (v6 : v1) (v7 : v2) => v5 (conj v6 v7) in or_intror ((fun v7 : v2 => let v8 : @False := let v8 : ~ v1 := (fun v8 : v1 => let v9 : forall v9 : v2, @False := v6 v8 in let v10 : @False := v9 v7 in False_ind (@False) v10) : ~ v1 in v4 v8 in (fun v9 : @False => False_ind (@False) v9) v8) : ~ v2)) v4 | or_intror v4 => (fun (v4 : ~ v1) (v5 : ~ (v1 /\ v2)) => let v6 : forall (v6 : v1) (v7 : v2), @False := fun (v6 : v1) (v7 : v2) => v5 (conj v6 v7) in or_introl ((fun v7 : v1 => let v8 : @False := v4 v7 in let v9 : forall v9 : v2, @False := v6 v7 in False_ind (@False) v8) : ~ v1)) v4 end) : @classical_de_morgan_law) (fun v0 : @classical_de_morgan_law => (fun v1 : Prop => let v2 : ~ v1 \/ ~ ~ v1 := v0 v1 (~ v1) ((fun v2 : v1 /\ ~ v1 => and_ind (fun (v3 : v1) (v4 : ~ v1) => let v5 : @False := v4 v3 in False_ind (@False) v5) v2) : ~ (v1 /\ ~ v1)) in match v2 as v3 in (_ \/ _) return (~ ~ v1 \/ ~ v1) with | or_introl v3 => (fun v3 : ~ v1 => or_intror ((fun v4 : v1 => let v5 : @False := v3 v4 in False_ind (@False) v5) : ~ v1)) v3 | or_intror v3 => (fun v3 : ~ ~ v1 => or_introl ((fun v4 : ~ v1 => let v5 : @False := v3 v4 in False_ind (@False) v5) : ~ ~ v1)) v3 end) : @weak_excluded_middle))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.independence_general_premises_right_distr_implication_over_disjunction	100	0.095108	1	1	0	synth with cache (only 1: refine (fun v0 : @IndependenceOfGeneralPremises => (fun (v1 v2 v3 : Prop) (v4 : forall v4 : v3, v1 \/ v2) => let v5 : exists v5 : @bool, forall v6 : v3, (fun v7 : @bool => match v7 as v8 in bool return Prop with | true => v1 | false => v2 end) v5 := v0 (@bool) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => v1 | false => v2 end) v3 (@true) (fun v5 : v3 => let v6 : v1 \/ v2 := v4 v5 in match v6 as v7 in (_ \/ _) return (exists v8 : @bool, match v8 as v9 in bool return Prop with | true => v1 | false => v2 end) with | or_introl v7 => (fun v7 : v1 => ex_intro (fun v8 : @bool => match v8 as v9 in bool return Prop with | true => v1 | false => v2 end) (@true) v7) v7 | or_intror v7 => (fun v7 : v2 => ex_intro (fun v8 : @bool => match v8 as v9 in bool return Prop with | true => v1 | false => v2 end) (@false) v7) v7 end) in match v5 as v6 in (ex _) return ((forall v7 : v3, v1) \/ (forall v7 : v3, v2)) with | ex_intro _ v6 v7 => (fun (v6 : @bool) (v7 : forall v7 : v3, match v6 as v8 in bool return Prop with | true => v1 | false => v2 end) => match v6 as v8 in bool return (forall v9 : forall v9 : v3, match v8 as v10 in bool return Prop with | true => v1 | false => v2 end, (forall v10 : v3, v1) \/ (forall v10 : v3, v2)) with | true => fun v8 : forall v8 : v3, v1 => or_introl v8 | false => fun v8 : forall v8 : v3, v2 => or_intror v8 end v7) v6 v7 end) : @RightDistributivityImplicationOverDisjunction)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.independence_general_premises_Godel_Dummett	100	0.026243	1	1	0	synth with cache (only 1: refine (let v0 : (forall v0 : @GodelDummett, @RightDistributivityImplicationOverDisjunction) /\ (forall v0 : @RightDistributivityImplicationOverDisjunction, @GodelDummett) := @Godel_Dummett_iff_right_distr_implication_over_disjunction in match v0 as v1 in (_ /\ _) return (forall v2 : @IndependenceOfGeneralPremises, @GodelDummett) with | conj v1 v2 => (fun (v1 : forall v1 : @GodelDummett, @RightDistributivityImplicationOverDisjunction) (v2 : forall v2 : @RightDistributivityImplicationOverDisjunction, @GodelDummett) (v3 : @IndependenceOfGeneralPremises) => v2 (independence_general_premises_right_distr_implication_over_disjunction v3)) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.independence_general_premises_drinker	100	0.044602	1	1	0	synth with cache (only 1: refine (conj (fun v0 : @IndependenceOfGeneralPremises => (fun (v1 : Type) (v2 : forall v2 : v1, Prop) (v3 : v1) => v0 v1 v2 (exists v4 : v1, v2 v4) v3 (fun v4 : exists v4 : v1, v2 v4 => v4)) : @DrinkerParadox) (fun v0 : @DrinkerParadox => (fun (v1 : Type) (v2 : forall v2 : v1, Prop) (v3 : Prop) (v4 : v1) (v5 : forall v5 : v3, exists v6 : v1, v2 v6) => let v6 : exists v6 : v1, forall v7 : exists v7 : v1, v2 v7, v2 v6 := v0 v1 v2 v4 in match v6 as v7 in (ex _) return (exists v8 : v1, forall v9 : v3, v2 v8) with | ex_intro _ v7 v8 => (fun (v7 : v1) (v8 : forall v8 : exists v8 : v1, v2 v8, v2 v7) => ex_intro (fun v9 : v1 => forall v10 : v3, v2 v9) v7 (fun v9 : v3 => v8 (v5 v9))) v7 v8 end) : @IndependenceOfGeneralPremises))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.excluded_middle_independence_general_premises	100	0.058208	1	1	0	synth with cache (only 1: refine (fun v0 : @generalized_excluded_middle => (fun (v1 : Type) (v2 : forall v2 : v1, Prop) (v3 : v1) => let v4 : (exists v4 : v1, v2 v4) \/ (forall v4 : exists v4 : v1, v2 v4, v2 v3) := v0 (exists v4 : v1, v2 v4) (v2 v3) in match v4 as v5 in (_ \/ _) return (exists v6 : v1, forall v7 : exists v7 : v1, v2 v7, v2 v6) with | or_introl v5 => (fun v5 : exists v5 : v1, v2 v5 => match v5 as v6 in (ex _) return (exists v7 : v1, forall v8 : exists v8 : v1, v2 v8, v2 v7) with | ex_intro _ v6 v7 => (fun (v6 : v1) (v7 : v2 v6) => ex_intro (fun v8 : v1 => forall v9 : exists v9 : v1, v2 v9, v2 v8) v6 (fun v8 : exists v8 : v1, v2 v8 => v7)) v6 v7 end) v5 | or_intror v5 => (fun v5 : forall v5 : exists v5 : v1, v2 v5, v2 v3 => ex_intro (fun v6 : v1 => forall v7 : exists v7 : v1, v2 v7, v2 v6) v3 v5) v5 end) : @DrinkerParadox)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Unrestricted_minimization_entails_excluded_middle.unrestricted_minimization_entails_excluded_middle	100	0.512124	0	1
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Excluded_middle_entails_unrestricted_minimization.excluded_middle_entails_unrestricted_minimization	100	0.066954	1	1	0	synth with cache (only 1: refine (fun v0 : forall v0 : @nat, Prop => (fun (v1 : @nat) (v2 : v0 v1) => let v3 : forall v3 : @nat, v0 v3 \/ ~ v0 v3 := fun v3 : @nat => em (v0 v3) in let v4 : exists v4 : @nat, v0 v4 := ex_intro (fun v4 : @nat => v0 v4) v1 v2 in let v5 : exists ! v5 : @nat, v0 v5 /\ (forall (v6 : @nat) (v7 : v0 v6), v5 <= v6) := dec_inh_nat_subset_has_unique_least_element v0 v3 v4 in match v5 as v6 in (ex _) return (exists v7 : @nat, Minimal v0 v7) with | ex_intro _ v6 v7 => (fun (v6 : @nat) (v7 : unique (fun v7 : @nat => v0 v7 /\ (forall (v8 : @nat) (v9 : v0 v8), v7 <= v8)) v6) => match v7 as v8 in (_ /\ _) return (exists v9 : @nat, Minimal v0 v9) with | conj v8 v9 => (fun (v8 : v0 v6 /\ (forall (v8 : @nat) (v9 : v0 v8), v6 <= v8)) (v9 : forall (v9 : @nat) (v10 : v0 v9 /\ (forall (v10 : @nat) (v11 : v0 v10), v9 <= v10)), v6 = v9) => ex_intro (fun v10 : @nat => Minimal v0 v10) v6 v8) v8 v9 end) v6 v7 end) : Minimization_Property v0)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.Example_of_undecidable_predicate_with_the_minimization_property.undecidable_predicate_with_the_minimization_property	100	0.063798	1	1	0	synth with cache (only 1: refine ((fun (v0 : @nat) (v1 : P v0) => ex_intro (fun v2 : @nat => Minimal (@P) v2) 0 (conj (match v1 as v2 in (ex _) return (exists v3 : @nat, 0 <= v3 /\ s v3 = @true) with | ex_intro _ v2 v3 => (fun (v2 : @nat) (v3 : v0 <= v2 /\ s v2 = @true) => match v3 as v4 in (_ /\ _) return (exists v5 : @nat, 0 <= v5 /\ s v5 = @true) with | conj v4 v5 => (fun (v4 : v0 <= v2) (v5 : s v2 = @true) => ex_intro (fun v6 : @nat => 0 <= v6 /\ s v6 = @true) v2 (conj ((fun v6 : v0 <= v2 => Morphisms.trans_contra_inv_impl_morphism RelationClasses.PreOrder_Transitive v2 v0 v6) v4 (Nat.le_0_l v0)) v5)) v4 v5 end) v2 v3 end : P 0) (fun (v2 : @nat) (v3 : P v2) => Nat.le_0_l v2))) : Minimization_Property (@P))).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.representative_boolean_partition_imp_excluded_middle	100	0.746871	1	1	0	synth with cache (only 1: refine (fun v0 : forall (v0 : forall v0 v1 : @bool, Prop) (v1 : Equivalence v0), exists v2 : forall v2 : @bool, @bool, forall v3 : @bool, v0 v3 (v2 v3) /\ (forall (v4 : @bool) (v5 : v0 v3 v4), v2 v3 = v2 v4) => (fun v1 : Prop => let v2 : forall v2 v3 : @bool, Prop := fun v2 v3 : @bool => v2 = v3 \/ v1 in let v3 : Equivalence v2 := {| Equivalence_Reflexive := fun v3 : @bool => or_introl eq_refl; Equivalence_Symmetric := (fun (v3 v4 : @bool) (v5 : v2 v3 v4) => match v5 as v6 in (_ \/ _) return (v2 v4 v3) with | or_introl v6 => (fun v6 : v3 = v4 => or_introl (eq_sym v6)) v6 | or_intror v6 => (fun v6 : v1 => or_intror v6) v6 end) : Symmetric v2; Equivalence_Transitive := (fun (v3 v4 v5 : @bool) (v6 : v2 v3 v4) => match v6 as v7 in (_ \/ _) return (forall v8 : v2 v4 v5, v2 v3 v5) with | or_introl v7 => (fun (v7 : v3 = v4) (v8 : v2 v4 v5) => match v8 as v9 in (_ \/ _) return (v2 v3 v5) with | or_introl v9 => (fun v9 : v4 = v5 => or_introl (eq_trans v7 v9)) v9 | or_intror v9 => (fun v9 : v1 => or_intror v9) v9 end) v7 | or_intror v7 => (fun (v7 : v1) (v8 : v2 v4 v5) => match v8 as v9 in (_ \/ _) return (v2 v3 v5) with | or_introl v9 => (fun v9 : v4 = v5 => or_intror v7) v9 | or_intror v9 => (fun v9 : v1 => or_intror v9) v9 end) v7 end) : Transitive v2 |} in let v4 : exists v4 : forall v4 : @bool, @bool, forall v5 : @bool, v2 v5 (v4 v5) /\ (forall (v6 : @bool) (v7 : v2 v5 v6), v4 v5 = v4 v6) := v0 v2 v3 in match v4 as v5 in (ex _) return (v1 \/ ~ v1) with | ex_intro _ v5 v6 => (fun (v5 : forall v5 : @bool, @bool) (v6 : forall v6 : @bool, v2 v6 (v5 v6) /\ (forall (v7 : @bool) (v8 : v2 v6 v7), v5 v6 = v5 v7)) => let v7 : {v5 (@true) = v5 (@false)} + {v5 (@true) <> v5 (@false)} := Bool.bool_dec (v5 (@true)) (v5 (@false)) in match v7 as v8 in ({_} + {_}) return (v1 \/ ~ v1) with | left v8 => (fun v8 : v5 (@true) = v5 (@false) => or_introl (let v9 : v2 (@false) (v5 (@false)) /\ (forall (v9 : @bool) (v10 : v2 (@false) v9), v5 (@false) = v5 v9) := v6 (@false) in match v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v2 (@false) (v5 (@false))) (v11 : forall (v11 : @bool) (v12 : v2 (@false) v11), v5 (@false) = v5 v11) => match v10 as v12 in (_ \/ _) return v1 with | or_introl v12 => (fun v12 : @false = v5 (@false) => let v13 : v2 (@true) (v5 (@true)) /\ (forall (v13 : @bool) (v14 : v2 (@true) v13), v5 (@true) = v5 v13) := v6 (@true) in match v13 as v14 in (_ /\ _) return v1 with | conj v14 v15 => (fun (v14 : v2 (@true) (v5 (@true))) (v15 : forall (v15 : @bool) (v16 : v2 (@true) v15), v5 (@true) = v5 v15) => match v14 as v16 in (_ \/ _) return v1 with | or_introl v16 => (fun v16 : @true = v5 (@true) => let v17 : @true = @false := eq_trans v16 (eq_trans v8 (eq_sym v12)) in let v18 : @False := eq_ind (@true) (fun v18 : @bool => match v18 as v19 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v17 in False_ind v1 v18) v16 | or_intror v16 => (fun v16 : v1 => v16) v16 end) v14 v15 end) v12 | or_intror v12 => (fun v12 : v1 => v12) v12 end) v10 v11 end)) v8 | right v8 => (fun v8 : v5 (@true) <> v5 (@false) => or_intror ((fun v9 : v1 => let v10 : v2 (@true) (v5 (@true)) /\ (forall (v10 : @bool) (v11 : v2 (@true) v10), v5 (@true) = v5 v10) := v6 (@true) in match v10 as v11 in (_ /\ _) return (@False) with | conj v11 v12 => (fun (v11 : v2 (@true) (v5 (@true))) (v12 : forall (v12 : @bool) (v13 : v2 (@true) v12), v5 (@true) = v5 v12) => v8 (v12 (@false) (or_intror v9))) v11 v12 end) : ~ v1)) v8 end) v5 v6 end) : @excluded_middle)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.excluded_middle_imp_representative_boolean_partition	100	0.220851	1	1	0	synth with cache (only 1: refine (fun (v0 : @excluded_middle) (v1 : forall v1 v2 : @bool, Prop) (v2 : Equivalence v1) => let v3 : v1 (@true) (@false) \/ ~ v1 (@true) (@false) := v0 (v1 (@true) (@false)) in match v3 as v4 in (_ \/ _) return (exists v5 : forall v5 : @bool, @bool, forall v6 : @bool, v1 v6 (v5 v6) /\ (forall (v7 : @bool) (v8 : v1 v6 v7), v5 v6 = v5 v7)) with | or_introl v4 => (fun v4 : v1 (@true) (@false) => ex_intro (fun v5 : forall v5 : @bool, @bool => forall v6 : @bool, v1 v6 (v5 v6) /\ (forall (v7 : @bool) (v8 : v1 v6 v7), v5 v6 = v5 v7)) (fun v5 : @bool => @true) (fun v5 : @bool => match v5 as v6 in bool return (v1 v6 (@true) /\ (forall (v7 : @bool) (v8 : v1 v6 v7), @true = @true)) with | true => match v2 as v6 in (Equivalence _) return (v1 (@true) (@true) /\ (forall (v7 : @bool) (v8 : v1 (@true) v7), @true = @true)) with | {| Equivalence_Reflexive := v6; Equivalence_Symmetric := v7; Equivalence_Transitive := v8 |} => (fun (v6 : Reflexive v1) (v7 : Symmetric v1) (v8 : Transitive v1) => conj ((fun v9 : forall (v9 v10 : @bool) (v11 : v1 (@true) v9) (v12 : v1 v9 v10), v1 (@true) v10 => (fun v10 : forall (v10 : @bool) (v11 : v1 (@true) (@false)) (v12 : v1 (@false) v10), v1 (@true) v10 => (fun v11 : forall (v11 : v1 (@true) (@false)) (v12 : v1 (@false) (@false)), v1 (@true) (@false) => (fun v12 : forall v12 : v1 (@false) (@false), v1 (@true) (@false) => v6 (@true)) (v11 v4)) (v10 (@false))) (v9 (@false))) (v8 (@true))) (fun (v9 : @bool) (v10 : v1 (@true) v9) => eq_refl)) v6 v7 v8 end | false => match v2 as v6 in (Equivalence _) return (v1 (@false) (@true) /\ (forall (v7 : @bool) (v8 : v1 (@false) v7), @true = @true)) with | {| Equivalence_Reflexive := v6; Equivalence_Symmetric := v7; Equivalence_Transitive := v8 |} => (fun (v6 : Reflexive v1) (v7 : Symmetric v1) (v8 : Transitive v1) => conj ((fun v9 : forall (v9 v10 : @bool) (v11 : v1 (@false) v9) (v12 : v1 v9 v10), v1 (@false) v10 => (fun v10 : forall (v10 : @bool) (v11 : v1 (@false) (@false)) (v12 : v1 (@false) v10), v1 (@false) v10 => (fun v11 : forall v11 v12 : v1 (@false) (@false), v1 (@false) (@false) => v7 (@true) (@false) v4) (v10 (@false))) (v9 (@false))) (v8 (@false))) (fun (v9 : @bool) (v10 : v1 (@false) v9) => eq_refl)) v6 v7 v8 end end)) v4 | or_intror v4 => (fun v4 : ~ v1 (@true) (@false) => ex_intro (fun v5 : forall v5 : @bool, @bool => forall v6 : @bool, v1 v6 (v5 v6) /\ (forall (v7 : @bool) (v8 : v1 v6 v7), v5 v6 = v5 v7)) (fun v5 : @bool => v5) (fun v5 : @bool => conj (reflexivity v5) match v5 as v6 in bool return (forall (v7 : @bool) (v8 : v1 v6 v7), v6 = v7) with | true => fun v6 : @bool => match v6 as v7 in bool return (forall v8 : v1 (@true) v7, @true = v7) with | true => fun v7 : v1 (@true) (@true) => eq_refl | false => fun v7 : v1 (@true) (@false) => False_ind (@true = @false) (v4 v7) end | false => fun v6 : @bool => match v6 as v7 in bool return (forall v8 : v1 (@false) v7, @false = v7) with | true => fun v7 : v1 (@false) (@true) => let v8 : v1 (@true) (@false) := symmetry v7 in False_ind (@false = @true) (v4 v8) | false => fun v7 : v1 (@false) (@false) => eq_refl end end)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Logic.ClassicalFacts.excluded_middle_iff_representative_boolean_partition	100	0.073712	1	1	0	synth with cache (only 1: refine (conj (fun (v0 : @excluded_middle) (v1 : forall v1 v2 : @bool, Prop) (v2 : Equivalence v1) => excluded_middle_imp_representative_boolean_partition v0 v1 v2) (fun v0 : forall (v0 : forall v0 v1 : @bool, Prop) (v1 : Equivalence v0), exists v2 : forall v2 : @bool, @bool, forall v3 : @bool, v0 v3 (v2 v3) /\ (forall (v4 : @bool) (v5 : v0 v3 v4), v2 v3 = v2 v4) => representative_boolean_partition_imp_excluded_middle v0))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation.Permutation_nil	100	0.089839	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@A)) (v1 : Permutation [] v0) => let v2 : list (@A) := [] in let v3 : v2 = [] := eq_refl in Permutation_ind (fun v4 v5 : list (@A) => forall v6 : v4 = [], v5 = []) (fun v4 : [] = [] => v4) (fun (v4 : @A) (v5 v6 : list (@A)) (v7 : Permutation v5 v6) (v8 : forall v8 : v5 = [], v6 = []) (v9 : v4 :: v5 = []) => let v10 : @False := eq_ind (v4 :: v5) (fun v10 : list (@A) => match v10 as v11 in (list _) return Prop with | [] => @False | v11 :: v12 => (fun (v11 : @A) (v12 : list (@A)) => @True) v11 v12 end) (@I) [] v9 in False_ind (v4 :: v6 = []) v10) (fun (v4 v5 : @A) (v6 : list (@A)) (v7 : v5 :: v4 :: v6 = []) => let v8 : @False := eq_ind (v5 :: v4 :: v6) (fun v8 : list (@A) => match v8 as v9 in (list _) return Prop with | [] => @False | v9 :: v10 => (fun (v9 : @A) (v10 : list (@A)) => @True) v9 v10 end) (@I) [] v7 in False_ind (v4 :: v5 :: v6 = []) v8) (fun (v4 v5 v6 : list (@A)) (v7 : Permutation v4 v5) (v8 : forall v8 : v4 = [], v5 = []) (v9 : Permutation v5 v6) (v10 : forall v10 : v5 = [], v6 = []) (v11 : v4 = []) => v10 (v8 v11)) v1 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation.Permutation_nil_cons	100	0.055897	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@A)) (v1 : @A) => (fun v2 : Permutation [] (v1 :: v0) => let v3 : v1 :: v0 = [] := Permutation_nil v2 in let v4 : @False := eq_ind (v1 :: v0) (fun v4 : list (@A) => match v4 as v5 in (list _) return Prop with | [] => @False | v5 :: v6 => (fun (v5 : @A) (v6 : list (@A)) => @True) v5 v6 end) (@I) [] v3 in False_ind (@False) v4) : ~ Permutation [] (v1 :: v0))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation.Permutation_refl	100	0.029064	1	1	0	synth with cache (only 1: refine (fun v0 : list (@A) => list_ind (fun v1 : list (@A) => Permutation v1 v1) (@perm_nil) (fun (v1 : @A) (v2 : list (@A)) (v3 : Permutation v2 v2) => perm_skip v1 v3) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation.Permutation_sym	100	0.046914	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : list (@A)) (v2 : Permutation v0 v1) => Permutation_ind (fun v3 v4 : list (@A) => Permutation v4 v3) (@perm_nil) (fun (v3 : @A) (v4 v5 : list (@A)) (v6 : Permutation v4 v5) (v7 : Permutation v5 v4) => perm_skip v3 v7) (fun (v3 v4 : @A) (v5 : list (@A)) => perm_swap v4 v3 v5) (fun (v3 v4 v5 : list (@A)) (v6 : Permutation v3 v4) (v7 : Permutation v4 v3) (v8 : Permutation v4 v5) (v9 : Permutation v5 v4) => perm_trans v9 v7) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation.Permutation_trans	100	0.035340	1	1	0	synth with cache (only 1: refine @perm_trans).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_cons	100	0.056468	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : Type => (fun (v1 v2 : v0) (v3 : v1 = v2) => (fun (v4 v5 : list v0) (v6 : Permutation v4 v5) => eq_ind_r (fun v7 : v0 => Permutation (v7 :: v4) (v2 :: v5)) (perm_skip v2 v6) v3) : (Permutation (A:=v0) ==> Permutation (A:=v0))%signature (cons v1) (cons v2)) : Proper (eq ==> Permutation (A:=v0) ==> Permutation (A:=v0)) cons)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_in	100	0.105725	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : list (@A)) (v2 : @A) (v3 : Permutation v0 v1) => Permutation_ind (fun v4 v5 : list (@A) => forall v6 : In v2 v4, In v2 v5) ((fun v4 : @False => False_ind (@False) v4) : forall v4 : In v2 [], In v2 []) (fun (v4 : @A) (v5 v6 : list (@A)) (v7 : Permutation v5 v6) (v8 : forall v8 : In v2 v5, In v2 v6) => (fun v9 : v4 = v2 \/ In v2 v5 => or_ind (fun v10 : v4 = v2 => or_introl v10) (fun v10 : In v2 v5 => let v11 : In v2 v6 := v8 v10 in or_intror v11) v9) : forall v9 : In v2 (v4 :: v5), In v2 (v4 :: v6)) (fun (v4 v5 : @A) (v6 : list (@A)) => (fun v7 : v5 = v2 \/ v4 = v2 \/ In v2 v6 => or_ind (fun v8 : v5 = v2 => or_intror (or_introl v8)) (fun v8 : v4 = v2 \/ In v2 v6 => or_ind (fun v9 : v4 = v2 => or_introl v9) (fun v9 : In v2 v6 => or_intror (or_intror v9)) v8) v7) : forall v7 : In v2 (v5 :: v4 :: v6), In v2 (v4 :: v5 :: v6)) (fun (v4 v5 v6 : list (@A)) (v7 : Permutation v4 v5) (v8 : forall v8 : In v2 v4, In v2 v5) (v9 : Permutation v5 v6) (v10 : forall v10 : In v2 v5, In v2 v6) => (fun v11 : In v2 v4 => let v12 : In v2 v5 := v8 v11 in let v13 : In v2 v6 := v10 v12 in v13) : forall v11 : In v2 v4, In v2 v6) v3)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_in'	100	0.076908	1	1	0	synth with cache (only 1: refine (((((fun (v0 v1 : @A) (v2 : v0 = v1) (v3 v4 : list (@A)) (v5 : Permutation v3 v4) => eq_ind_r (fun v6 : @A => (forall v7 : In v6 v3, In v1 v4) /\ (forall v7 : In v1 v4, In v6 v3)) (conj (fun v6 : In v1 v3 => Permutation_in v1 v5 v6) (fun v6 : In v1 v4 => Permutation_in v1 (Permutation_sym v5) v6)) v2) : forall (v0 v1 : @A) (v2 : v0 = v1) (v3 v4 : list (@A)) (v5 : Permutation v3 v4), In v0 v3 <-> In v1 v4) : forall (v0 v1 : @A) (v2 : v0 = v1), (Permutation (A:=@A) ==> @iff)%signature (In v0) (In v1)) : (eq ==> Permutation (A:=@A) ==> @iff)%signature (In (A:=@A)) (In (A:=@A))) : Proper (eq ==> Permutation (A:=@A) ==> @iff) (In (A:=@A)))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app_tail	100	0.084708	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : list (@A)) (v3 : Permutation v0 v1) => Permutation_ind (fun v4 v5 : list (@A) => Permutation (v4 ++ v2) (v5 ++ v2)) (Permutation_refl v2 : Permutation ([] ++ v2) ([] ++ v2)) (fun (v4 : @A) (v5 v6 : list (@A)) (v7 : Permutation v5 v6) (v8 : Permutation (v5 ++ v2) (v6 ++ v2)) => Permutation_sym (Permutation_sym (perm_skip v4 v8)) : Permutation ((v4 :: v5) ++ v2) ((v4 :: v6) ++ v2)) (fun (v4 v5 : @A) (v6 : list (@A)) => perm_swap v4 v5 (v6 ++ v2) : Permutation ((v5 :: v4 :: v6) ++ v2) ((v4 :: v5 :: v6) ++ v2)) (fun (v4 v5 v6 : list (@A)) (v7 : Permutation v4 v5) (v8 : Permutation (v4 ++ v2) (v5 ++ v2)) (v9 : Permutation v5 v6) (v10 : Permutation (v5 ++ v2) (v6 ++ v2)) => Permutation_trans v8 v10 : Permutation (v4 ++ v2) (v6 ++ v2)) v3)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app_head	100	0.078314	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : list (@A)) (v3 : Permutation v1 v2) => list_ind (fun v4 : list (@A) => Permutation (v4 ++ v1) (v4 ++ v2)) v3 (fun (v4 : @A) (v5 : list (@A)) (v6 : Permutation (v5 ++ v1) (v5 ++ v2)) => eq_ind (v4 :: v5 ++ v1) (fun v7 : list (@A) => Permutation v7 ((v4 :: v5) ++ v2)) (eq_ind (v4 :: v5 ++ v2) (fun v7 : list (@A) => Permutation (v4 :: v5 ++ v1) v7) (perm_skip v4 v6) ((v4 :: v5) ++ v2) (app_comm_cons v5 v2 v4)) ((v4 :: v5) ++ v1) (app_comm_cons v5 v1 v4)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app	100	0.218526	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : list (@A)) (v4 : Permutation v0 v2) (v5 : Permutation v1 v3) => Permutation_ind (fun v6 v7 : list (@A) => Permutation (v6 ++ v1) (v7 ++ v3)) v5 (fun (v6 : @A) (v7 v8 : list (@A)) (v9 : Permutation v7 v8) (v10 : Permutation (v7 ++ v1) (v8 ++ v3)) => eq_ind (v6 :: v7 ++ v1) (fun v11 : list (@A) => Permutation v11 ((v6 :: v8) ++ v3)) (eq_ind (v6 :: v8 ++ v3) (fun v11 : list (@A) => Permutation (v6 :: v7 ++ v1) v11) (Permutation_sym (Permutation_sym (perm_skip v6 v10))) ((v6 :: v8) ++ v3) (app_comm_cons v8 v3 v6)) ((v6 :: v7) ++ v1) (app_comm_cons v7 v1 v6)) (fun (v6 v7 : @A) (v8 : list (@A)) => eq_ind (v7 :: (v6 :: v8) ++ v1) (fun v9 : list (@A) => Permutation v9 ((v6 :: v7 :: v8) ++ v3)) (eq_ind (v6 :: v8 ++ v1) (fun v9 : list (@A) => Permutation (v7 :: v9) ((v6 :: v7 :: v8) ++ v3)) (eq_ind (v6 :: (v7 :: v8) ++ v3) (fun v9 : list (@A) => Permutation (v7 :: v6 :: v8 ++ v1) v9) (eq_ind (v7 :: v8 ++ v3) (fun v9 : list (@A) => Permutation (v7 :: v6 :: v8 ++ v1) (v6 :: v9)) (Permutation_trans (perm_swap v6 v7 (v8 ++ v1)) (eq_ind_r (fun v9 : list (@A) => Permutation (v6 :: v9) (v6 :: v7 :: v8 ++ v3)) (eq_ind_r (fun v9 : list (@A) => Permutation v9 (v6 :: v7 :: v8 ++ v3)) (eq_ind_r (fun v9 : list (@A) => Permutation ((v6 :: v7 :: v8) ++ v1) (v6 :: v9)) (eq_ind_r (fun v9 : list (@A) => Permutation ((v6 :: v7 :: v8) ++ v1) v9) (Permutation_app_head (v6 :: v7 :: v8) v5) (app_comm_cons (v7 :: v8) v3 v6)) (app_comm_cons v8 v3 v7)) (app_comm_cons (v7 :: v8) v1 v6)) (app_comm_cons v8 v1 v7))) ((v7 :: v8) ++ v3) (app_comm_cons v8 v3 v7)) ((v6 :: v7 :: v8) ++ v3) (app_comm_cons (v7 :: v8) v3 v6)) ((v6 :: v8) ++ v1) (app_comm_cons v8 v1 v6)) ((v7 :: v6 :: v8) ++ v1) (app_comm_cons (v6 :: v8) v1 v7)) (fun (v6 v7 v8 : list (@A)) (v9 : Permutation v6 v7) (v10 : Permutation (v6 ++ v1) (v7 ++ v3)) (v11 : Permutation v7 v8) (v12 : Permutation (v7 ++ v1) (v8 ++ v3)) => Permutation_trans v10 (Permutation_app_tail v3 v11)) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app'	100	0.080349	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : list (@A)) (v2 : Permutation v0 v1) => (fun (v3 v4 : list (@A)) (v5 : Permutation v3 v4) => Permutation_app v2 v5) : (Permutation (A:=@A) ==> Permutation (A:=@A))%signature (app v0) (app v1)) : Proper (Permutation (A:=@A) ==> Permutation (A:=@A) ==> Permutation (A:=@A)) (app (A:=@A)))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_add_inside	100	0.108921	1	1	0	synth with cache (only 1: refine (fun (v0 : @A) (v1 v2 v3 v4 : list (@A)) (v5 : Permutation v1 v2) (v6 : Permutation v3 v4) => Permutation_app v5 (Permutation_sym (Permutation_sym (perm_skip v0 v6))))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_cons_append	100	0.381778	1	1
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app_comm	100	0.522565	1	1	0	synth with cache (only 1: refine (fun v0 : list (@A) => list_ind (fun v1 : list (@A) => forall v2 : list (@A), Permutation (v1 ++ v2) (v2 ++ v1)) ((fun v1 : list (@A) => eq_ind_r (fun v2 : list (@A) => Permutation v1 v2) (Permutation_refl v1) (app_nil_r v1)) : forall v1 : list (@A), Permutation ([] ++ v1) (v1 ++ [])) (fun (v1 : @A) (v2 : list (@A)) (v3 : forall v3 : list (@A), Permutation (v2 ++ v3) (v3 ++ v2)) => (fun v4 : list (@A) => (fun v5 : Permutation (v2 ++ v4) (v4 ++ v2) => subrelation_proper (PER_morphism (Equivalence_PER (Permutation_Equivalence (@A)))) (@tt) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (subrelation_respectful (subrelation_refl (Permutation (A:=@A))) (@iff_flip_impl_subrelation))) (v1 :: v2 ++ v4) (v1 :: v4 ++ v2) (Reflexive_partial_app_morphism (proper_normalizes_proper (forall (v6 : @A) (v7 : list (@A)), list (@A)) (flip_arrow (flip_atom (@A) (Basics.flip eq)) (flip_arrow (flip_atom (list (@A)) (Permutation (A:=@A))) (flip_atom (list (@A)) (Basics.flip (Permutation (A:=@A)))))) (proper_flip_proper (subrelation_proper (Permutation_cons (A:=@A)) (@tt) (subrelation_respectful (flip1 (subrelation_refl eq)) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (flip2 (subrelation_refl (Permutation (A:=@A))))))))) (reflexive_proper_proxy PreOrder_Reflexive v1) (v2 ++ v4) (v4 ++ v2) v5) (v4 ++ v1 :: v2) (v4 ++ v1 :: v2) (reflexive_proper_proxy Equivalence_Reflexive (v4 ++ v1 :: v2))) (v3 v4) (eq_ind_r (fun v5 : list (@A) => Permutation v5 (v4 ++ v1 :: v2)) ((fun v5 : Permutation (v1 :: v4) (v4 ++ [v1]) => subrelation_proper (PER_morphism (Equivalence_PER (Permutation_Equivalence (@A)))) (@tt) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (subrelation_respectful (subrelation_refl (Permutation (A:=@A))) (@iff_flip_impl_subrelation))) ((v1 :: v4) ++ v2) ((v4 ++ [v1]) ++ v2) (proper_normalizes_proper (forall v6 v7 : list (@A), list (@A)) (flip_arrow (flip_atom (list (@A)) (Permutation (A:=@A))) (flip_arrow (flip_atom (list (@A)) (Basics.flip (Permutation (A:=@A)))) (flip_atom (list (@A)) (Basics.flip (Permutation (A:=@A)))))) (proper_flip_proper (subrelation_proper (@Permutation_app') (@tt) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (subrelation_respectful (flip1 (subrelation_refl (Permutation (A:=@A)))) (flip2 (subrelation_refl (Permutation (A:=@A)))))))) (v1 :: v4) (v4 ++ [v1]) v5 v2 v2 (reflexive_proper_proxy PreOrder_Reflexive v2)) (v4 ++ v1 :: v2) (v4 ++ v1 :: v2) (reflexive_proper_proxy Equivalence_Reflexive (v4 ++ v1 :: v2))) (Permutation_cons_append v4 v1) (eq_ind (v4 ++ [v1] ++ v2) (fun v5 : list (@A) => Permutation v5 (v4 ++ v1 :: v2)) (Permutation_refl (v4 ++ v1 :: v2)) ((v4 ++ [v1]) ++ v2) (app_assoc v4 [v1] v2))) (app_comm_cons v4 v2 v1))) : forall v4 : list (@A), Permutation ((v1 :: v2) ++ v4) (v4 ++ v1 :: v2)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_cons_app	100	0.459779	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : list (@A)) (v3 : @A) (v4 : Permutation v0 (v1 ++ v2)) => (fun v5 : Permutation v0 (v1 ++ v2) => subrelation_proper (PER_morphism (Equivalence_PER (Permutation_Equivalence (@A)))) (@tt) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (subrelation_respectful (subrelation_refl (Permutation (A:=@A))) (@iff_flip_impl_subrelation))) (v3 :: v0) (v3 :: v1 ++ v2) (Reflexive_partial_app_morphism (proper_normalizes_proper (forall (v6 : @A) (v7 : list (@A)), list (@A)) (flip_arrow (flip_atom (@A) (Basics.flip eq)) (flip_arrow (flip_atom (list (@A)) (Permutation (A:=@A))) (flip_atom (list (@A)) (Basics.flip (Permutation (A:=@A)))))) (proper_flip_proper (subrelation_proper (Permutation_cons (A:=@A)) (@tt) (subrelation_respectful (flip1 (subrelation_refl eq)) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (flip2 (subrelation_refl (Permutation (A:=@A))))))))) (reflexive_proper_proxy PreOrder_Reflexive v3) v0 (v1 ++ v2) v5) (v1 ++ v3 :: v2) (v1 ++ v3 :: v2) (reflexive_proper_proxy Equivalence_Reflexive (v1 ++ v3 :: v2))) v4 (eq_ind_r (fun v5 : list (@A) => Permutation v5 (v1 ++ v3 :: v2)) ((fun v5 : Permutation (v3 :: v1) (v1 ++ [v3]) => subrelation_proper (PER_morphism (Equivalence_PER (Permutation_Equivalence (@A)))) (@tt) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (subrelation_respectful (subrelation_refl (Permutation (A:=@A))) (@iff_flip_impl_subrelation))) ((v3 :: v1) ++ v2) ((v1 ++ [v3]) ++ v2) (proper_normalizes_proper (forall v6 v7 : list (@A), list (@A)) (flip_arrow (flip_atom (list (@A)) (Permutation (A:=@A))) (flip_arrow (flip_atom (list (@A)) (Basics.flip (Permutation (A:=@A)))) (flip_atom (list (@A)) (Basics.flip (Permutation (A:=@A)))))) (proper_flip_proper (subrelation_proper (@Permutation_app') (@tt) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (subrelation_respectful (flip1 (subrelation_refl (Permutation (A:=@A)))) (flip2 (subrelation_refl (Permutation (A:=@A)))))))) (v3 :: v1) (v1 ++ [v3]) v5 v2 v2 (reflexive_proper_proxy PreOrder_Reflexive v2)) (v1 ++ v3 :: v2) (v1 ++ v3 :: v2) (reflexive_proper_proxy Equivalence_Reflexive (v1 ++ v3 :: v2))) (Permutation_cons_append v1 v3) (eq_ind (v1 ++ [v3] ++ v2) (fun v5 : list (@A) => Permutation v5 (v1 ++ v3 :: v2)) (Permutation_refl (v1 ++ v3 :: v2)) ((v1 ++ [v3]) ++ v2) (app_assoc v1 [v3] v2))) (app_comm_cons v1 v2 v3)))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_Add	100	0.023314	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_middle	100	0.052956	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : list (@A)) (v2 : @A) => Permutation_cons_app v0 v1 v2 (Permutation_refl (v0 ++ v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_rev	100	0.251923	1	1	0	synth with cache (only 1: refine (fun v0 : list (@A) => list_ind (fun v1 : list (@A) => Permutation v1 (rev v1)) (perm_nil (@A) : Permutation [] (rev [])) (fun (v1 : @A) (v2 : list (@A)) (v3 : Permutation v2 (rev v2)) => (fun v4 : Permutation v2 (rev v2) => subrelation_proper (PER_morphism (Equivalence_PER (Permutation_Equivalence (@A)))) (@tt) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (subrelation_respectful (subrelation_refl (Permutation (A:=@A))) (@iff_flip_impl_subrelation))) (v1 :: v2) (v1 :: rev v2) (Reflexive_partial_app_morphism (proper_normalizes_proper (forall (v5 : @A) (v6 : list (@A)), list (@A)) (flip_arrow (flip_atom (@A) (Basics.flip eq)) (flip_arrow (flip_atom (list (@A)) (Permutation (A:=@A))) (flip_atom (list (@A)) (Basics.flip (Permutation (A:=@A)))))) (proper_flip_proper (subrelation_proper (Permutation_cons (A:=@A)) (@tt) (subrelation_respectful (flip1 (subrelation_refl eq)) (subrelation_respectful (subrelation_symmetric (Permutation (A:=@A)) Equivalence_Symmetric) (flip2 (subrelation_refl (Permutation (A:=@A))))))))) (reflexive_proper_proxy PreOrder_Reflexive v1) v2 (rev v2) v4) (rev v2 ++ [v1]) (rev v2 ++ [v1]) (reflexive_proper_proxy Equivalence_Reflexive (rev v2 ++ [v1]))) v3 (Permutation_cons_append (rev v2) v1) : Permutation (v1 :: v2) (rev (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_rev'	100	0.094094	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : list (@A)) (v2 : Permutation v0 v1) => (fun v3 : Permutation v0 (rev v0) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (rev v0) v0 (symmetry v3) (rev v1) (rev v1) (eq_proper_proxy (rev v1))) (Permutation_rev v0) ((fun v3 : Permutation v1 (rev v1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (Permutation_Equivalence (@A))) (rev v1) v1 (symmetry v3)) (Permutation_rev v1) v2)) : Proper (Permutation (A:=@A) ==> Permutation (A:=@A)) (rev (A:=@A)))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_length	100	0.091040	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : list (@A)) (v2 : Permutation v0 v1) => Permutation_ind (fun v3 v4 : list (@A) => length v3 = length v4) (eq_refl : length [] = length []) (fun (v3 : @A) (v4 v5 : list (@A)) (v6 : Permutation v4 v5) (v7 : length v4 = length v5) => f_equal_nat (@nat) (@S) (length v4) (length v5) v7 : length (v3 :: v4) = length (v3 :: v5)) (fun (v3 v4 : @A) (v5 : list (@A)) => eq_refl : length (v4 :: v3 :: v5) = length (v3 :: v4 :: v5)) (fun (v3 v4 v5 : list (@A)) (v6 : Permutation v3 v4) (v7 : length v3 = length v4) (v8 : Permutation v4 v5) (v9 : length v4 = length v5) => eq_trans v7 v9 : length v3 = length v5) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_length'	100	0.051205	1	1	0	synth with cache (only 1: refine @Permutation_length).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_ind_bis	100	0.214221	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 v1 : list (@A), Prop) (v1 : v0 [] []) (v2 : forall (v2 : @A) (v3 v4 : list (@A)) (v5 : Permutation v3 v4) (v6 : v0 v3 v4), v0 (v2 :: v3) (v2 :: v4)) (v3 : forall (v3 v4 : @A) (v5 v6 : list (@A)) (v7 : Permutation v5 v6) (v8 : v0 v5 v6), v0 (v4 :: v3 :: v5) (v3 :: v4 :: v6)) (v4 : forall (v4 v5 v6 : list (@A)) (v7 : Permutation v4 v5) (v8 : v0 v4 v5) (v9 : Permutation v5 v6) (v10 : v0 v5 v6), v0 v4 v6) (v5 v6 : list (@A)) (v7 : Permutation v5 v6) => Permutation_ind (fun v8 v9 : list (@A) => v0 v8 v9) v1 (fun (v8 : @A) (v9 v10 : list (@A)) (v11 : Permutation v9 v10) (v12 : v0 v9 v10) => v2 v8 v9 v10 v11 v12) (fun (v8 v9 : @A) (v10 : list (@A)) => v4 (v9 :: v8 :: v10) (v8 :: v9 :: v10) (v8 :: v9 :: v10) (perm_swap v8 v9 v10) (v3 v8 v9 v10 v10 (Permutation_refl v10) (list_ind (fun v11 : list (@A) => v0 v11 v11) v1 (fun (v11 : @A) (v12 : list (@A)) (v13 : v0 v12 v12) => v2 v11 v12 v12 (Permutation_refl v12) v13) v10)) (Permutation_refl (v8 :: v9 :: v10)) (v2 v8 (v9 :: v10) (v9 :: v10) (Permutation_refl (v9 :: v10)) (v2 v9 v10 v10 (Permutation_refl v10) (list_ind (fun v11 : list (@A) => v0 v11 v11) v1 (fun (v11 : @A) (v12 : list (@A)) (v13 : v0 v12 v12) => v2 v11 v12 v12 (Permutation_refl v12) v13) v10)))) (fun (v8 v9 v10 : list (@A)) (v11 : Permutation v8 v9) (v12 : v0 v8 v9) (v13 : Permutation v9 v10) (v14 : v0 v9 v10) => v4 v8 v9 v10 v11 v12 v13 v14) v7)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_nil_app_cons	100	0.126031	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : list (@A)) (v2 : @A) => (fun v3 : Permutation [] (v0 ++ v2 :: v1) => let v4 : v0 ++ v2 :: v1 = [] := Permutation_nil v3 in match v0 as v5 in (list _) return (forall v6 : v5 ++ v2 :: v1 = [], @False) with | [] => fun v5 : [] ++ v2 :: v1 = [] => let v6 : @False := eq_ind ([] ++ v2 :: v1) (fun v6 : list (@A) => match v6 as v7 in (list _) return Prop with | [] => @False | v7 :: v8 => (fun (v7 : @A) (v8 : list (@A)) => @True) v7 v8 end) (@I) [] v5 in False_ind (@False) v6 | v5 :: v6 => (fun (v5 : @A) (v6 : list (@A)) (v7 : (v5 :: v6) ++ v2 :: v1 = []) => let v8 : @False := eq_ind ((v5 :: v6) ++ v2 :: v1) (fun v8 : list (@A) => match v8 as v9 in (list _) return Prop with | [] => @False | v9 :: v10 => (fun (v9 : @A) (v10 : list (@A)) => @True) v9 v10 end) (@I) [] v7 in False_ind (@False) v8) v5 v6 end v4) : ~ Permutation [] (v0 ++ v2 :: v1))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_Add_inv	100	0.021319	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app_inv	100	0.021601	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_cons_inv	100	0.016330	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_cons_app_inv	100	0.023283	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app_inv_l	100	0.090209	1	1	0	synth with cache (only 1: refine (fun v0 : list (@A) => list_ind (fun v1 : list (@A) => forall (v2 v3 : list (@A)) (v4 : Permutation (v1 ++ v2) (v1 ++ v3)), Permutation v2 v3) ((fun (v1 v2 : list (@A)) (v3 : Permutation v1 v2) => v3) : forall (v1 v2 : list (@A)) (v3 : Permutation ([] ++ v1) ([] ++ v2)), Permutation v1 v2) (fun (v1 : @A) (v2 : list (@A)) (v3 : forall (v3 v4 : list (@A)) (v5 : Permutation (v2 ++ v3) (v2 ++ v4)), Permutation v3 v4) => (fun (v4 v5 : list (@A)) (v6 : Permutation (v1 :: v2 ++ v4) (v1 :: v2 ++ v5)) => v3 v4 v5 (Permutation_cons_inv v6)) : forall (v4 v5 : list (@A)) (v6 : Permutation ((v1 :: v2) ++ v4) ((v1 :: v2) ++ v5)), Permutation v4 v5) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_app_inv_r	100	0.020670	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_length_1_inv	100	0.272037	1	1	0	synth with cache (only 1: refine (fun (v0 : @A) (v1 : list (@A)) (v2 : Permutation [v0] v1) => let v3 : list (@A) := [v0] in let v4 : v3 = [v0] := eq_refl in Permutation_ind (fun v5 v6 : list (@A) => forall v7 : v5 = [v0], v6 = [v0]) (fun v5 : [] = [v0] => let v6 : @False := eq_ind [] (fun v6 : list (@A) => match v6 as v7 in (list _) return Prop with | [] => @True | v7 :: v8 => (fun (v7 : @A) (v8 : list (@A)) => @False) v7 v8 end) (@I) [v0] v5 in False_ind ([] = [v0]) v6) (fun (v5 : @A) (v6 v7 : list (@A)) (v8 : Permutation v6 v7) (v9 : forall v9 : v6 = [v0], v7 = [v0]) (v10 : v5 :: v6 = [v0]) => let v11 : v6 = [] := f_equal (fun v11 : list (@A) => match v11 as v12 in (list _) return (list (@A)) with | [] => v6 | v12 :: v13 => (fun (v12 : @A) (v13 : list (@A)) => v13) v12 v13 end) v10 in (let v12 : v5 = v0 := f_equal (fun v12 : list (@A) => match v12 as v13 in (list _) return (@A) with | [] => v5 | v13 :: v14 => (fun (v13 : @A) (v14 : list (@A)) => v13) v13 v14 end) v10 in (fun (v13 : v5 = v0) (v14 : v6 = []) => eq_ind_r (fun v15 : @A => v15 :: v7 = [v0]) (eq_ind_r (fun v15 : list (@A) => forall (v16 : Permutation v15 v7) (v17 : forall v17 : v15 = [v0], v7 = [v0]), v0 :: v7 = [v0]) (fun (v15 : Permutation [] v7) (v16 : forall v16 : [] = [v0], v7 = [v0]) => let v17 : v7 = [] := Permutation_nil v15 in eq_ind_r (fun v18 : list (@A) => forall v19 : forall v19 : [] = [v0], v18 = [v0], v0 :: v18 = [v0]) (fun v18 : forall v18 : [] = [v0], [] = [v0] => eq_refl) v17 v16) v14 v8 v9) v13) v12) v11) (fun (v5 v6 : @A) (v7 : list (@A)) (v8 : v6 :: v5 :: v7 = [v0]) => let v9 : @False := eq_ind (v6 :: v5 :: v7) (fun v9 : list (@A) => match v9 as v10 in (list _) return Prop with | [] => @False | v10 :: v11 => (fun (v10 : @A) (v11 : list (@A)) => match v11 as v12 in (list _) return Prop with | [] => @False | v12 :: v13 => (fun (v12 : @A) (v13 : list (@A)) => @True) v12 v13 end) v10 v11 end) (@I) [v0] v8 in False_ind (v5 :: v6 :: v7 = [v0]) v9) (fun (v5 v6 v7 : list (@A)) (v8 : Permutation v5 v6) (v9 : forall v9 : v5 = [v0], v6 = [v0]) (v10 : Permutation v6 v7) (v11 : forall v11 : v6 = [v0], v7 = [v0]) (v12 : v5 = [v0]) => v11 (v9 v12)) v2 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_length_1	100	0.077348	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @A) (v2 : Permutation [v0] [v1]) => let v3 : [v1] = [v0] := Permutation_length_1_inv v2 in let v4 : v1 = v0 := f_equal (fun v4 : list (@A) => match v4 as v5 in (list _) return (@A) with | [] => v1 | v5 :: v6 => (fun (v5 : @A) (v6 : list (@A)) => v5) v5 v6 end) v3 in (fun v5 : v1 = v0 => eq_ind_r (fun v6 : @A => v0 = v6) eq_refl v5) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_length_2_inv	100	0.503701	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @A) (v2 : list (@A)) (v3 : Permutation [v0; v1] v2) => let v4 : list (@A) := [v0; v1] in let v5 : v4 = [v0; v1] := eq_refl in Permutation_ind (fun v6 v7 : list (@A) => forall (v8 v9 : @A) (v10 : v6 = [v8; v9]), v7 = [v8; v9] \/ v7 = [v9; v8]) (fun (v6 v7 : @A) (v8 : [] = [v6; v7]) => let v9 : @False := eq_ind [] (fun v9 : list (@A) => match v9 as v10 in (list _) return Prop with | [] => @True | v10 :: v11 => (fun (v10 : @A) (v11 : list (@A)) => @False) v10 v11 end) (@I) [v6; v7] v8 in False_ind ([] = [v6; v7] \/ [] = [v7; v6]) v9) (fun (v6 : @A) (v7 v8 : list (@A)) (v9 : Permutation v7 v8) (v10 : forall (v10 v11 : @A) (v12 : v7 = [v10; v11]), v8 = [v10; v11] \/ v8 = [v11; v10]) (v11 v12 : @A) (v13 : v6 :: v7 = [v11; v12]) => let v14 : v7 = [v12] := f_equal (fun v14 : list (@A) => match v14 as v15 in (list _) return (list (@A)) with | [] => v7 | v15 :: v16 => (fun (v15 : @A) (v16 : list (@A)) => v16) v15 v16 end) v13 in (let v15 : v6 = v11 := f_equal (fun v15 : list (@A) => match v15 as v16 in (list _) return (@A) with | [] => v6 | v16 :: v17 => (fun (v16 : @A) (v17 : list (@A)) => v16) v16 v17 end) v13 in (fun (v16 : v6 = v11) (v17 : v7 = [v12]) => eq_ind_r (fun v18 : @A => v18 :: v8 = [v11; v12] \/ v18 :: v8 = [v12; v11]) (eq_ind_r (fun v18 : list (@A) => forall (v19 : Permutation v18 v8) (v20 : forall (v20 v21 : @A) (v22 : v18 = [v20; v21]), v8 = [v20; v21] \/ v8 = [v21; v20]), v11 :: v8 = [v11; v12] \/ v11 :: v8 = [v12; v11]) (fun (v18 : Permutation [v12] v8) (v19 : forall (v19 v20 : @A) (v21 : [v12] = [v19; v20]), v8 = [v19; v20] \/ v8 = [v20; v19]) => let v20 : v8 = [v12] := Permutation_length_1_inv v18 in eq_ind_r (fun v21 : list (@A) => forall v22 : forall (v22 v23 : @A) (v24 : [v12] = [v22; v23]), v21 = [v22; v23] \/ v21 = [v23; v22], v11 :: v21 = [v11; v12] \/ v11 :: v21 = [v12; v11]) (fun v21 : forall (v21 v22 : @A) (v23 : [v12] = [v21; v22]), [v12] = [v21; v22] \/ [v12] = [v22; v21] => or_introl eq_refl) v20 v19) v17 v9 v10) v16) v15) v14) (fun (v6 v7 : @A) (v8 : list (@A)) (v9 v10 : @A) (v11 : v7 :: v6 :: v8 = [v9; v10]) => let v12 : v8 = [] := f_equal (fun v12 : list (@A) => match v12 as v13 in (list _) return (list (@A)) with | [] => v8 | v13 :: v14 => (fun (v13 : @A) (v14 : list (@A)) => match v14 as v15 in (list _) return (list (@A)) with | [] => v8 | v15 :: v16 => (fun (v15 : @A) (v16 : list (@A)) => v16) v15 v16 end) v13 v14 end) v11 in (let v13 : v6 = v10 := f_equal (fun v13 : list (@A) => match v13 as v14 in (list _) return (@A) with | [] => v6 | v14 :: v15 => (fun (v14 : @A) (v15 : list (@A)) => match v15 as v16 in (list _) return (@A) with | [] => v6 | v16 :: v17 => (fun (v16 : @A) (v17 : list (@A)) => v16) v16 v17 end) v14 v15 end) v11 in (let v14 : v7 = v9 := f_equal (fun v14 : list (@A) => match v14 as v15 in (list _) return (@A) with | [] => v7 | v15 :: v16 => (fun (v15 : @A) (v16 : list (@A)) => v15) v15 v16 end) v11 in (fun (v15 : v7 = v9) (v16 : v6 = v10) (v17 : v8 = []) => eq_ind_r (fun v18 : @A => v6 :: v18 :: v8 = [v9; v10] \/ v6 :: v18 :: v8 = [v10; v9]) (eq_ind_r (fun v18 : @A => v18 :: v9 :: v8 = [v9; v10] \/ v18 :: v9 :: v8 = [v10; v9]) (eq_ind_r (fun v18 : list (@A) => v10 :: v9 :: v18 = [v9; v10] \/ v10 :: v9 :: v18 = [v10; v9]) (or_intror eq_refl) v17) v16) v15) v14) v13) v12) (fun (v6 v7 v8 : list (@A)) (v9 : Permutation v6 v7) (v10 : forall (v10 v11 : @A) (v12 : v6 = [v10; v11]), v7 = [v10; v11] \/ v7 = [v11; v10]) (v11 : Permutation v7 v8) (v12 : forall (v12 v13 : @A) (v14 : v7 = [v12; v13]), v8 = [v12; v13] \/ v8 = [v13; v12]) (v13 v14 : @A) (v15 : v6 = [v13; v14]) => let v16 : v7 = [v13; v14] \/ v7 = [v14; v13] := v10 v13 v14 v15 in match v16 as v17 in (_ \/ _) return (v8 = [v13; v14] \/ v8 = [v14; v13]) with | or_introl v17 => (fun v17 : v7 = [v13; v14] => let v18 : v8 = [v13; v14] \/ v8 = [v14; v13] := v12 v13 v14 v17 in match v18 as v19 in (_ \/ _) return (v8 = [v13; v14] \/ v8 = [v14; v13]) with | or_introl v19 => (fun v19 : v8 = [v13; v14] => or_introl v19) v19 | or_intror v19 => (fun v19 : v8 = [v14; v13] => or_intror v19) v19 end) v17 | or_intror v17 => (fun v17 : v7 = [v14; v13] => let v18 : v8 = [v14; v13] \/ v8 = [v13; v14] := v12 v14 v13 v17 in match v18 as v19 in (_ \/ _) return (v8 = [v13; v14] \/ v8 = [v14; v13]) with | or_introl v19 => (fun v19 : v8 = [v14; v13] => or_intror v19) v19 | or_intror v19 => (fun v19 : v8 = [v13; v14] => or_introl v19) v19 end) v17 end) v3 v0 v1 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_length_2	100	0.225087	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @A) (v4 : Permutation [v0; v1] [v2; v3]) => let v5 : [v2; v3] = [v0; v1] \/ [v2; v3] = [v1; v0] := Permutation_length_2_inv v4 in match v5 as v6 in (_ \/ _) return (v0 = v2 /\ v1 = v3 \/ v0 = v3 /\ v1 = v2) with | or_introl v6 => (fun v6 : [v2; v3] = [v0; v1] => let v7 : v3 = v1 := f_equal (fun v7 : list (@A) => match v7 as v8 in (list _) return (@A) with | [] => v3 | v8 :: v9 => (fun (v8 : @A) (v9 : list (@A)) => match v9 as v10 in (list _) return (@A) with | [] => v3 | v10 :: v11 => (fun (v10 : @A) (v11 : list (@A)) => v10) v10 v11 end) v8 v9 end) v6 in (let v8 : v2 = v0 := f_equal (fun v8 : list (@A) => match v8 as v9 in (list _) return (@A) with | [] => v2 | v9 :: v10 => (fun (v9 : @A) (v10 : list (@A)) => v9) v9 v10 end) v6 in (fun (v9 : v2 = v0) (v10 : v3 = v1) => eq_ind_r (fun v11 : @A => v0 = v11 /\ v1 = v3 \/ v0 = v3 /\ v1 = v11) (eq_ind_r (fun v11 : @A => v0 = v0 /\ v1 = v11 \/ v0 = v11 /\ v1 = v0) (or_introl (conj eq_refl eq_refl)) v10) v9) v8) v7) v6 | or_intror v6 => (fun v6 : [v2; v3] = [v1; v0] => let v7 : v3 = v0 := f_equal (fun v7 : list (@A) => match v7 as v8 in (list _) return (@A) with | [] => v3 | v8 :: v9 => (fun (v8 : @A) (v9 : list (@A)) => match v9 as v10 in (list _) return (@A) with | [] => v3 | v10 :: v11 => (fun (v10 : @A) (v11 : list (@A)) => v10) v10 v11 end) v8 v9 end) v6 in (let v8 : v2 = v1 := f_equal (fun v8 : list (@A) => match v8 as v9 in (list _) return (@A) with | [] => v2 | v9 :: v10 => (fun (v9 : @A) (v10 : list (@A)) => v9) v9 v10 end) v6 in (fun (v9 : v2 = v1) (v10 : v3 = v0) => eq_ind_r (fun v11 : @A => v0 = v11 /\ v1 = v3 \/ v0 = v3 /\ v1 = v11) (eq_ind_r (fun v11 : @A => v0 = v1 /\ v1 = v11 \/ v0 = v11 /\ v1 = v1) (or_intror (conj eq_refl eq_refl)) v10) v9) v8) v7) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.NoDup_Permutation	100	0.020560	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.NoDup_Permutation_bis	100	0.020631	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_NoDup	100	0.021218	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_properties.Permutation_NoDup'	100	0.068376	1	1	0	synth with cache (only 1: refine ((((fun (v0 v1 : list (@A)) (v2 : Permutation v0 v1) => conj (fun v3 : NoDup v0 => Permutation_NoDup v2 v3) (fun v3 : NoDup v1 => Permutation_NoDup (Permutation_sym v2) v3)) : forall (v0 v1 : list (@A)) (v2 : Permutation v0 v1), NoDup v0 <-> NoDup v1) : (Permutation (A:=@A) ==> @iff)%signature (NoDup (A:=@A)) (NoDup (A:=@A))) : Proper (Permutation (A:=@A) ==> @iff) (NoDup (A:=@A)))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_map.Permutation_map	100	0.018813	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_map.Permutation_map'	100	0.054110	1	1	0	synth with cache (only 1: refine @Permutation_map).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.nat_bijection_Permutation	100	0.258390	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @nat) (v1 : forall v1 : @nat, @nat) (v2 : bFun v0 v1) (v3 : Injective v1) => NoDup_Permutation_bis (Injective_map_NoDup v3 (seq_NoDup v0 0)) (seq_NoDup v0 0) (eq_ind_r (fun v4 : @nat => length (seq 0 v0) <= v4) (le_n (length (seq 0 v0))) (map_length v1 (seq 0 v0))) ((fun v4 : @nat => (fun v5 : In v4 (map v1 (seq 0 v0)) <-> (exists v5 : @nat, v1 v5 = v4 /\ In v5 (seq 0 v0)) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (In v4 (map v1 (seq 0 v0))) (exists v6 : @nat, v1 v6 = v4 /\ In v6 (seq 0 v0)) v5 (In v4 (seq 0 v0)) (In v4 (seq 0 v0)) (reflexive_proper_proxy (@iff_Reflexive) (In v4 (seq 0 v0)))) (in_map_iff v1 (seq 0 v0) v4) (fun v5 : exists v5 : @nat, v1 v5 = v4 /\ In v5 (seq 0 v0) => match v5 as v6 in (ex _) return (In v4 (seq 0 v0)) with | ex_intro _ v6 v7 => (fun (v6 : @nat) (v7 : v1 v6 = v4 /\ In v6 (seq 0 v0)) => match v7 as v8 in (_ /\ _) return (In v4 (seq 0 v0)) with | conj v8 v9 => (fun (v8 : v1 v6 = v4) (v9 : In v6 (seq 0 v0)) => eq_ind (v1 v6) (fun v10 : @nat => In v10 (seq 0 v0)) ((fun v10 : In (v1 v6) (seq 0 v0) <-> 0 <= v1 v6 < 0 + v0 => iff_flip_impl_subrelation (In (v1 v6) (seq 0 v0)) (0 <= v1 v6 < 0 + v0) v10) (in_seq v0 0 (v1 v6)) (match (fun v10 : In v6 (seq 0 v0) <-> 0 <= v6 < 0 + v0 => iff_impl_subrelation (In v6 (seq 0 v0)) (0 <= v6 < 0 + v0) v10) (in_seq v0 0 v6) v9 as v10 in (_ /\ _) return (0 <= v1 v6 < v0) with | conj v10 v11 => (fun (v10 : 0 <= v6) (v11 : v6 < v0) => conj (PeanoNat.Nat.le_0_l (v1 v6)) (v2 v6 v11)) v10 v11 end : 0 <= v1 v6 < 0 + v0)) v4 v8) v8 v9 end) v6 v7 end)) : incl (map v1 (seq 0 v0)) (seq 0 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_alt.adapt_injective	100	0.032848	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_alt.adapt_ok	100	0.049010	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_alt.Permutation_nth_error	100	0.068242	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_alt.Permutation_nth_error_bis	100	0.076309	2	2
coq-tactician-stdlib.8.11.dev	Coq.Sorting.Permutation.Permutation_alt.Permutation_nth	100	0.064103	2	2
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inf_iff	100	0.220615	1	1	0	synth with cache (only 1: refine (fun (v0 : @X.t) (v1 : list (@X.t)) => conj (fun v2 : HdRel (@X.lt) v0 v1 => match v2 as v4 in (HdRel _ _ v3) return (inf v0 v3 = @true) with | HdRel_nil _ _ => Logic.eq_refl : inf v0 nil = @true | HdRel_cons _ _ v3 v4 v5 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : X.lt v0 v3) => eq_ind_r (fun v6 : @comparison => match v6 as v7 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) Logic.eq_refl ((fun v6 : X.compare v0 v3 = @Lt <-> X.lt v0 v3 => iff_impl_subrelation (X.lt v0 v3) (X.compare v0 v3 = @Lt) (symmetry v6)) (compare_lt_iff v0 v3) v5) : inf v0 (v3 :: v4) = @true) v3 v4 v5 end) (fun v2 : inf v0 v1 = @true => match v1 as v3 in (list _) return (forall v4 : inf v0 v3 = @true, HdRel (@X.lt) v0 v3) with | nil => fun v3 : inf v0 nil = @true => HdRel_nil (@X.lt) v0 : HdRel (@X.lt) v0 nil | v3 :: v4 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : inf v0 (v3 :: v4) = @true) => (match X.compare v0 v3 as v6 in comparison return (forall (v7 : X.compare v0 v3 = v6) (v8 : match v6 as v8 in comparison return (@bool) with | Lt => @true | _ => @false end = @true), HdRel (@X.lt) v0 (v3 :: v4)) with | Eq => fun (v6 : X.compare v0 v3 = @Eq) (v7 : @false = @true) => let v8 : @False := eq_ind (@false) (fun v8 : @bool => match v8 as v9 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v7 in False_ind (HdRel (@X.lt) v0 (v3 :: v4)) v8 | Lt => fun (v6 : X.compare v0 v3 = @Lt) (v7 : @true = @true) => HdRel_cons (@X.lt) v0 v3 v4 ((fun v8 : X.compare v0 v3 = @Lt <-> X.lt v0 v3 => iff_impl_subrelation (X.compare v0 v3 = @Lt) (X.lt v0 v3) v8) (compare_lt_iff v0 v3) v6) | Gt => fun (v6 : X.compare v0 v3 = @Gt) (v7 : @false = @true) => let v8 : @False := eq_ind (@false) (fun v8 : @bool => match v8 as v9 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v7 in False_ind (HdRel (@X.lt) v0 (v3 :: v4)) v8 end : forall (v6 : X.compare v0 v3 = X.compare v0 v3) (v7 : match X.compare v0 v3 as v7 in comparison return (@bool) with | Lt => @true | _ => @false end = @true), HdRel (@X.lt) v0 (v3 :: v4)) Logic.eq_refl v5 : HdRel (@X.lt) v0 (v3 :: v4)) v3 v4 end v2))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.isok_iff	100	0.478042	1	1	0	synth with cache (only 1: refine (fun v0 : list (@X.t) => conj (fun v1 : Sorted (@X.lt) v0 => Sorted_ind (fun v2 : list (@X.t) => Ok v2) Logic.eq_refl (fun (v2 : @X.t) (v3 : list (@X.t)) (v4 : Sorted (@X.lt) v3) (v5 : Ok v3) (v6 : HdRel (@X.lt) v2 v3) => (fun v7 : inf v2 v3 && isok v3 = @true <-> inf v2 v3 = @true /\ isok v3 = @true => iff_flip_impl_subrelation (inf v2 v3 && isok v3 = @true) (inf v2 v3 = @true /\ isok v3 = @true) v7) (andb_true_iff (inf v2 v3) (isok v3)) (conj ((fun v7 : HdRel (@X.lt) v2 v3 <-> inf v2 v3 = @true => iff_impl_subrelation (HdRel (@X.lt) v2 v3) (inf v2 v3 = @true) v7) (inf_iff v2 v3) v6) v5)) v1) (fun v1 : Ok v0 => list_ind (fun v2 : list (@X.t) => forall v3 : Ok v2, Sorted (@X.lt) v2) (fun v2 : Ok nil => Sorted_nil (@X.lt)) (fun (v2 : @X.t) (v3 : list (@X.t)) (v4 : forall v4 : Ok v3, Sorted (@X.lt) v3) (v5 : Ok (v2 :: v3)) => match (fun v6 : HdRel (@X.lt) v2 v3 <-> inf v2 v3 = @true => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (inf v2 v3 = @true) (HdRel (@X.lt) v2 v3) (symmetry v6) (isok v3 = @true) (isok v3 = @true) (reflexive_proper_proxy (@iff_Reflexive) (isok v3 = @true))) (inf_iff v2 v3) ((fun v6 : inf v2 v3 && isok v3 = @true <-> inf v2 v3 = @true /\ isok v3 = @true => iff_impl_subrelation (inf v2 v3 && isok v3 = @true) (inf v2 v3 = @true /\ isok v3 = @true) v6) (andb_true_iff (inf v2 v3) (isok v3)) v5) as v6 in (_ /\ _) return (Sorted (@X.lt) (v2 :: v3)) with | conj v6 v7 => (fun (v6 : HdRel (@X.lt) v2 v3) (v7 : isok v3 = @true) => Sorted_cons (let v8 : Sorted (@X.lt) v3 := v4 v7 in v8) (let v8 : Sorted (@X.lt) v3 := v4 v7 in v6)) v6 v7 end) v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.isok_Ok	100	0.035541	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : list (@X.t)) (v1 : isok v0 = @true) => v1)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.mem_spec	100	0.567803	1	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.add_inf	100	0.426938	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : HdRel (@X.lt) v3 v1) (v5 : X.lt v3 v2), HdRel (@X.lt) v3 (add v2 v1)) ((fun (v1 v2 : @elt) (v3 : HdRel (@X.lt) v2 nil) (v4 : X.lt v2 v1) => HdRel_cons (@X.lt) v2 v1 nil v4 : HdRel (@X.lt) v2 (v1 :: nil)) : forall (v1 v2 : @elt) (v3 : HdRel (@X.lt) v2 nil) (v4 : X.lt v2 v1), HdRel (@X.lt) v2 (add v1 nil)) ((fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : HdRel (@X.lt) v4 v2) (v6 : X.lt v4 v3), HdRel (@X.lt) v4 (add v3 v2)) (v4 v5 : @elt) (v6 : HdRel (@X.lt) v5 (v1 :: v2)) (v7 : X.lt v5 v4) => let v8 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v9 : @comparison := X.compare v4 v1 in match v8 as v11 in (CompareSpec _ _ _ v10) return (HdRel (@X.lt) v5 match v10 as v12 in comparison return (list (@X.t)) with | Eq => v1 :: v2 | Lt => v4 :: v1 :: v2 | Gt => v1 :: add v4 v2 end) with | CompEq _ _ v10 => (fun v10 : X.eq v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2) := match v6 as v12 in (HdRel _ _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2)) with | HdRel_nil _ _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: v2)) v13) v11 | HdRel_cons _ _ v11 v12 v13 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : X.lt v5 v11) (v14 : v11 :: v12 = v1 :: v2) => (fun v15 : v11 :: v12 = v1 :: v2 => let v16 : v12 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v12 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v11 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v11 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v11 = v1 => let v19 : v11 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v12 = v2) (v22 : X.lt v5 v20), HdRel (@X.lt) v5 (v1 :: v2)) (fun v20 : v12 = v2 => let v21 : v12 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall v23 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: v2)) (fun v22 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 v2 v22 : HdRel (@X.lt) v5 (v1 :: v2)) v21) v19) v17) v16) v14 v13) v11 v12 v13 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v4 :: v1 :: v2) := match v6 as v12 in (HdRel _ _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v4 :: v1 :: v2)) with | HdRel_nil _ _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v4 :: v1 :: v2)) v13) v11 | HdRel_cons _ _ v11 v12 v13 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : X.lt v5 v11) (v14 : v11 :: v12 = v1 :: v2) => (fun v15 : v11 :: v12 = v1 :: v2 => let v16 : v12 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v12 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v11 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v11 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v11 = v1 => let v19 : v11 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v12 = v2) (v22 : X.lt v5 v20), HdRel (@X.lt) v5 (v4 :: v1 :: v2)) (fun v20 : v12 = v2 => let v21 : v12 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall v23 : X.lt v5 v1, HdRel (@X.lt) v5 (v4 :: v1 :: v2)) (fun v22 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v4 (v1 :: v2) v7 : HdRel (@X.lt) v5 (v4 :: v1 :: v2)) v21) v19) v17) v16) v14 v13) v11 v12 v13 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v1 v4 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: add v4 v2) := match v6 as v12 in (HdRel _ _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: add v4 v2)) with | HdRel_nil _ _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: add v4 v2)) v13) v11 | HdRel_cons _ _ v11 v12 v13 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : X.lt v5 v11) (v14 : v11 :: v12 = v1 :: v2) => (fun v15 : v11 :: v12 = v1 :: v2 => let v16 : v12 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v12 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v11 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v11 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v11 = v1 => let v19 : v11 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v12 = v2) (v22 : X.lt v5 v20), HdRel (@X.lt) v5 (v1 :: add v4 v2)) (fun v20 : v12 = v2 => let v21 : v12 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall v23 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: add v4 v2)) (fun v22 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 (add v4 v2) v22 : HdRel (@X.lt) v5 (v1 :: add v4 v2)) v21) v19) v17) v16) v14 v13) v11 v12 v13 end in v11 Logic.eq_refl) v10 end) : forall (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : HdRel (@X.lt) v4 v2) (v6 : X.lt v4 v3), HdRel (@X.lt) v4 (add v3 v2)) (v4 v5 : @elt) (v6 : HdRel (@X.lt) v5 (v1 :: v2)) (v7 : X.lt v5 v4), HdRel (@X.lt) v5 (add v4 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.add_ok	100	0.426709	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @t) (v1 : @X.t) => (fun v2 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v2) (Ok (add v1 v0)) (Ok (add v1 v0)) (reflexive_proper_proxy (@iff_Reflexive) (Ok (add v1 v0)))) (isok_iff v0) ((fun v2 : Sorted (@X.lt) (add v1 v0) <-> Ok (add v1 v0) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v0)) (Ok (add v1 v0)) (Sorted (@X.lt) (add v1 v0)) (symmetry v2)) (isok_iff (add v1 v0)) ((fun v2 : @t => list_ind (fun v3 : list (@elt) => forall (v4 : @X.t) (v5 : Sorted (@X.lt) v3), Sorted (@X.lt) (add v4 v3)) ((fun (v3 : @X.t) (v4 : Sorted (@X.lt) nil) => Sorted_cons v4 (HdRel_nil (@X.lt) v3) : Sorted (@X.lt) (v3 :: nil)) : forall (v3 : @X.t) (v4 : Sorted (@X.lt) nil), Sorted (@X.lt) (add v3 nil)) ((fun (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : @X.t) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (add v5 v4)) (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)) => let v8 : CompareSpec (X.eq v6 v3) (X.lt v6 v3) (X.lt v3 v6) (X.compare v6 v3) := X.compare_spec v6 v3 in let v9 : @comparison := X.compare v6 v3 in match v8 as v11 in (CompareSpec _ _ _ v10) return (Sorted (@X.lt) match v10 as v12 in comparison return (list (@X.t)) with | Eq => v3 :: v4 | Lt => v6 :: v3 :: v4 | Gt => v3 :: add v6 v4 end) with | CompEq _ _ v10 => (fun v10 : X.eq v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons v23 v24) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v6 :: v3 :: v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v6 :: v3 :: v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v6 :: v3 :: v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v6 :: v3 :: v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v6 :: v3 :: v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons (Sorted_cons v23 v24) (HdRel_cons (@X.lt) v6 v3 v4 v10)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v3 v6 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: add v6 v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: add v6 v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: add v6 v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: add v6 v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: add v6 v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons (v5 v6 v23) (add_inf v24 v10)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 end) : forall (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : @X.t) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (add v5 v4)) (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)), Sorted (@X.lt) (add v6 (v3 :: v4))) v2) v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.add_spec	100	1.866042	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : Ok v1), InA (@X.eq) v3 (add v2 v1) <-> X.eq v3 v2 \/ InA (@X.eq) v3 v1) ((fun (v1 v2 : @elt) (v3 : Ok nil) => conj (fun v4 : InA (@X.eq) v2 (v1 :: nil) => let v5 : forall v5 : v1 :: nil = v1 :: nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil := match v4 as v6 in (InA _ _ v5) return (forall v7 : v5 = v1 :: nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil) with | @InA_cons_hd _ _ _ v5 v6 v7 => (fun (v5 : @X.t) (v6 : list (@X.t)) (v7 : X.eq v2 v5) (v8 : v5 :: v6 = v1 :: nil) => (fun v9 : v5 :: v6 = v1 :: nil => let v10 : v6 = nil := f_equal (fun v10 : list (@X.t) => match v10 as v11 in (list _) return (list (@X.t)) with | nil => v6 | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => v12) v11 v12 end) v9 in (let v11 : v5 = v1 := f_equal (fun v11 : list (@X.t) => match v11 as v12 in (list _) return (@X.t) with | nil => v5 | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => v12) v12 v13 end) v9 in (fun v12 : v5 = v1 => let v13 : v5 = v1 := v12 in eq_ind_r (fun v14 : @X.t => forall (v15 : v6 = nil) (v16 : X.eq v2 v14), X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v14 : v6 = nil => let v15 : v6 = nil := v14 in eq_ind_r (fun v16 : list (@X.t) => forall v17 : X.eq v2 v1, X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v16 : X.eq v2 v1 => or_introl v16) v15) v13) v11) v10) v8 v7) v5 v6 v7 | @InA_cons_tl _ _ _ v5 v6 v7 => (fun (v5 : @X.t) (v6 : list (@X.t)) (v7 : InA (@X.eq) v2 v6) (v8 : v5 :: v6 = v1 :: nil) => (fun v9 : v5 :: v6 = v1 :: nil => let v10 : v6 = nil := f_equal (fun v10 : list (@X.t) => match v10 as v11 in (list _) return (list (@X.t)) with | nil => v6 | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => v12) v11 v12 end) v9 in (let v11 : v5 = v1 := f_equal (fun v11 : list (@X.t) => match v11 as v12 in (list _) return (@X.t) with | nil => v5 | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => v12) v12 v13 end) v9 in (fun v12 : v5 = v1 => let v13 : v5 = v1 := v12 in eq_ind_r (fun v14 : @X.t => forall (v15 : v6 = nil) (v16 : InA (@X.eq) v2 v6), X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v14 : v6 = nil => let v15 : v6 = nil := v14 in eq_ind_r (fun v16 : list (@X.t) => forall v17 : InA (@X.eq) v2 v16, X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun v16 : InA (@X.eq) v2 nil => let v17 : forall v17 : nil = nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil := match v16 as v18 in (InA _ _ v17) return (forall v19 : v17 = nil, X.eq v2 v1 \/ InA (@X.eq) v2 nil) with | @InA_cons_hd _ _ _ v17 v18 v19 => (fun (v17 : @X.t) (v18 : list (@X.t)) (v19 : X.eq v2 v17) (v20 : v17 :: v18 = nil) => (fun v21 : v17 :: v18 = nil => let v22 : @False := eq_ind (v17 :: v18) (fun v22 : list (@X.t) => match v22 as v23 in (list _) return Prop with | nil => @False | v23 :: v24 => (fun (v23 : @X.t) (v24 : list (@X.t)) => @True) v23 v24 end) (@I) nil v21 in False_ind (forall v23 : X.eq v2 v17, X.eq v2 v1 \/ InA (@X.eq) v2 nil) v22) v20 v19) v17 v18 v19 | @InA_cons_tl _ _ _ v17 v18 v19 => (fun (v17 : @X.t) (v18 : list (@X.t)) (v19 : InA (@X.eq) v2 v18) (v20 : v17 :: v18 = nil) => (fun v21 : v17 :: v18 = nil => let v22 : @False := eq_ind (v17 :: v18) (fun v22 : list (@X.t) => match v22 as v23 in (list _) return Prop with | nil => @False | v23 :: v24 => (fun (v23 : @X.t) (v24 : list (@X.t)) => @True) v23 v24 end) (@I) nil v21 in False_ind (forall v23 : InA (@X.eq) v2 v18, X.eq v2 v1 \/ InA (@X.eq) v2 nil) v22) v20 v19) v17 v18 v19 end in v17 Logic.eq_refl) v15) v13) v11) v10) v8 v7) v5 v6 v7 end in v5 Logic.eq_refl) (fun v4 : X.eq v2 v1 \/ InA (@X.eq) v2 nil => or_ind (fun v5 : X.eq v2 v1 => InA_cons_hd (eqA:=@X.eq) (x:=v2) (y:=v1) nil v5 : InA (@X.eq) v2 (v1 :: nil)) (fun v5 : InA (@X.eq) v2 nil => InA_cons_tl v1 v5 : InA (@X.eq) v2 (v1 :: nil)) v4)) : forall (v1 v2 : @elt) (v3 : Ok nil), InA (@X.eq) v2 (add v1 nil) <-> X.eq v2 v1 \/ InA (@X.eq) v2 nil) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : Ok v2), InA (@X.eq) v4 (add v3 v2) <-> X.eq v4 v3 \/ InA (@X.eq) v4 v2) => (fun (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) => let v7 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v8 : @comparison := X.compare v4 v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (InA (@X.eq) v5 match v9 as v11 in comparison return (list (@X.t)) with | Eq => v1 :: v2 | Lt => v4 :: v1 :: v2 | Gt => v1 :: add v4 v2 end <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | CompEq _ _ v9 => (fun v9 : X.eq v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => subrelation_proper (PER_morphism (Equivalence_PER (@iff_equivalence))) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24)) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v1 => or_introl (OrderTac.not_neq_eq ((fun v26 : ~ X.eq v5 v4 => (fun v27 : ~ X.eq v1 v4 => (fun v28 : ~ X.eq v1 v1 => v28 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v27 v9)) (OrderTac.eq_neq (OrderTac.eq_sym v25) v26)) : ~ ~ X.eq v5 v4) : X.eq v5 v4)) (fun v25 : InA (@X.eq) v5 v2 => or_intror (or_intror v25)) v24) (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_introl (OrderTac.not_neq_eq ((fun v26 : ~ X.eq v5 v1 => (fun v27 : ~ X.eq v4 v1 => (fun v28 : ~ X.eq v1 v1 => v28 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v9) v27)) (OrderTac.eq_neq (OrderTac.eq_sym v25) v26)) : ~ ~ X.eq v5 v1) : X.eq v5 v1)) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_introl v26) (fun v26 : InA (@X.eq) v5 v2 => or_intror v26) v25) v24))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompLt _ _ v9 => (fun v9 : X.lt v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v4 :: v1 :: v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v5 (v4 :: v1 :: v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v24 (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (eq_proper_proxy (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)))) (InA_cons (@X.eq) v5 v4 (v1 :: v2)) ((fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => subrelation_proper (PER_morphism (Equivalence_PER (@iff_equivalence))) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24)) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_introl v25) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_intror (or_introl v26)) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24) (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_introl v25) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_intror (or_introl v26)) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24)))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompGt _ _ v9 => (fun v9 : X.lt v1 v4 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2) := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: add v4 v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 (add v4 v2) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v5 (v1 :: add v4 v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 (add v4 v2)) v24 (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (eq_proper_proxy (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)))) (InA_cons (@X.eq) v5 v1 (add v4 v2)) ((fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v4)) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24)) (InA_cons (@X.eq) v5 v1 v2) ((fun v24 : InA (@X.eq) v5 (add v4 v2) <-> X.eq v5 v4 \/ InA (@X.eq) v5 v2 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (X.eq v5 v1 \/ InA (@X.eq) v5 (add v4 v2)) (X.eq v5 v1 \/ X.eq v5 v4 \/ InA (@X.eq) v5 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v1)) (InA (@X.eq) v5 (add v4 v2)) (X.eq v5 v4 \/ InA (@X.eq) v5 v2) v24) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2) (eq_proper_proxy (X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2))) (v3 v4 v5 ((fun v24 : Sorted (@X.lt) v2 <-> Ok v2 => iff_flip_impl_subrelation (Ok v2) (Sorted (@X.lt) v2) (symmetry v24)) (isok_iff v2) v22 : Ok v2)) (conj (fun v24 : X.eq v5 v1 \/ X.eq v5 v4 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v1 => or_intror (or_introl v25)) (fun v25 : X.eq v5 v4 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v4 => or_introl v26) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24) (fun v24 : X.eq v5 v4 \/ X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v4 => or_intror (or_introl v25)) (fun v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v26 : X.eq v5 v1 => or_introl v26) (fun v26 : InA (@X.eq) v5 v2 => or_intror (or_intror v26)) v25) v24))))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 end) : forall (v4 v5 : @elt) (v6 : Ok (v1 :: v2)), InA (@X.eq) v5 (add v4 (v1 :: v2)) <-> X.eq v5 v4 \/ InA (@X.eq) v5 (v1 :: v2)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.remove_inf	100	1.187746	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : Ok v1) (v5 : HdRel (@X.lt) v3 v1), HdRel (@X.lt) v3 (remove v2 v1)) ((fun (v1 v2 : @elt) (v3 : Ok nil) (v4 : HdRel (@X.lt) v2 nil) => v4) : forall (v1 v2 : @elt) (v3 : Ok nil) (v4 : HdRel (@X.lt) v2 nil), HdRel (@X.lt) v2 (remove v1 nil)) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : Ok v2) (v6 : HdRel (@X.lt) v4 v2), HdRel (@X.lt) v4 (remove v3 v2)) => (fun (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) (v7 : HdRel (@X.lt) v5 (v1 :: v2)) => let v8 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v9 : @comparison := X.compare v4 v1 in match v8 as v11 in (CompareSpec _ _ _ v10) return (HdRel (@X.lt) v5 match v10 as v12 in comparison return (@t) with | Eq => v2 | Lt => v1 :: v2 | Gt => v1 :: remove v4 v2 end) with | CompEq _ _ v10 => (fun v10 : X.eq v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 v2 := match (fun v11 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v11)) (isok_iff (v1 :: v2)) v6 as v12 in (Sorted _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 v2) with | Sorted_nil _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 v2) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v1 :: v2) => (fun v16 : v11 :: v12 = v1 :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v1 => let v20 : v11 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v2) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), HdRel (@X.lt) v5 v2) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v1 v23), HdRel (@X.lt) v5 v2) (fun (v23 : Sorted (@X.lt) v2) (v24 : HdRel (@X.lt) v1 v2) => let v25 : forall v25 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 v2 := match v7 as v26 in (HdRel _ _ v25) return (forall v27 : v25 = v1 :: v2, HdRel (@X.lt) v5 v2) with | HdRel_nil _ _ => fun v25 : nil = v1 :: v2 => (fun v26 : nil = v1 :: v2 => let v27 : @False := eq_ind nil (fun v27 : list (@X.t) => match v27 as v28 in (list _) return Prop with | nil => @True | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => @False) v28 v29 end) (@I) (v1 :: v2) v26 in False_ind (HdRel (@X.lt) v5 v2) v27) v25 | HdRel_cons _ _ v25 v26 v27 => (fun (v25 : @X.t) (v26 : list (@X.t)) (v27 : X.lt v5 v25) (v28 : v25 :: v26 = v1 :: v2) => (fun v29 : v25 :: v26 = v1 :: v2 => let v30 : v26 = v2 := f_equal (fun v30 : list (@X.t) => match v30 as v31 in (list _) return (list (@X.t)) with | nil => v26 | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => v32) v31 v32 end) v29 in (let v31 : v25 = v1 := f_equal (fun v31 : list (@X.t) => match v31 as v32 in (list _) return (@X.t) with | nil => v25 | v32 :: v33 => (fun (v32 : @X.t) (v33 : list (@X.t)) => v32) v32 v33 end) v29 in (fun v32 : v25 = v1 => let v33 : v25 = v1 := v32 in eq_ind_r (fun v34 : @X.t => forall (v35 : v26 = v2) (v36 : X.lt v5 v34), HdRel (@X.lt) v5 v2) (fun v34 : v26 = v2 => let v35 : v26 = v2 := v34 in eq_ind_r (fun v36 : list (@X.t) => forall v37 : X.lt v5 v1, HdRel (@X.lt) v5 v2) (fun v36 : X.lt v5 v1 => Inf_lt v36 v24) v35) v33) v31) v30) v28 v27) v25 v26 v27 end in v25 Logic.eq_refl) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v4 v1 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2) := match (fun v11 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v11)) (isok_iff (v1 :: v2)) v6 as v12 in (Sorted _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2)) with | Sorted_nil _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: v2)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v1 :: v2) => (fun v16 : v11 :: v12 = v1 :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v1 => let v20 : v11 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v2) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), HdRel (@X.lt) v5 (v1 :: v2)) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v1 v23), HdRel (@X.lt) v5 (v1 :: v2)) (fun (v23 : Sorted (@X.lt) v2) (v24 : HdRel (@X.lt) v1 v2) => let v25 : forall v25 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2) := match v7 as v26 in (HdRel _ _ v25) return (forall v27 : v25 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: v2)) with | HdRel_nil _ _ => fun v25 : nil = v1 :: v2 => (fun v26 : nil = v1 :: v2 => let v27 : @False := eq_ind nil (fun v27 : list (@X.t) => match v27 as v28 in (list _) return Prop with | nil => @True | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => @False) v28 v29 end) (@I) (v1 :: v2) v26 in False_ind (HdRel (@X.lt) v5 (v1 :: v2)) v27) v25 | HdRel_cons _ _ v25 v26 v27 => (fun (v25 : @X.t) (v26 : list (@X.t)) (v27 : X.lt v5 v25) (v28 : v25 :: v26 = v1 :: v2) => (fun v29 : v25 :: v26 = v1 :: v2 => let v30 : v26 = v2 := f_equal (fun v30 : list (@X.t) => match v30 as v31 in (list _) return (list (@X.t)) with | nil => v26 | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => v32) v31 v32 end) v29 in (let v31 : v25 = v1 := f_equal (fun v31 : list (@X.t) => match v31 as v32 in (list _) return (@X.t) with | nil => v25 | v32 :: v33 => (fun (v32 : @X.t) (v33 : list (@X.t)) => v32) v32 v33 end) v29 in (fun v32 : v25 = v1 => let v33 : v25 = v1 := v32 in eq_ind_r (fun v34 : @X.t => forall (v35 : v26 = v2) (v36 : X.lt v5 v34), HdRel (@X.lt) v5 (v1 :: v2)) (fun v34 : v26 = v2 => let v35 : v26 = v2 := v34 in eq_ind_r (fun v36 : list (@X.t) => forall v37 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: v2)) (fun v36 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 v2 v36) v35) v33) v31) v30) v28 v27) v25 v26 v27 end in v25 Logic.eq_refl) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v1 v4 => let v11 : forall v11 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2) := match (fun v11 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v11)) (isok_iff (v1 :: v2)) v6 as v12 in (Sorted _ v11) return (forall v13 : v11 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2)) with | Sorted_nil _ => fun v11 : nil = v1 :: v2 => (fun v12 : nil = v1 :: v2 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v1 :: v2) v12 in False_ind (HdRel (@X.lt) v5 (v1 :: remove v4 v2)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v1 :: v2) => (fun v16 : v11 :: v12 = v1 :: v2 => let v17 : v12 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v1 => let v20 : v11 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v2) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun v21 : v12 = v2 => let v22 : v12 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v1 v23), HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun (v23 : Sorted (@X.lt) v2) (v24 : HdRel (@X.lt) v1 v2) => let v25 : forall v25 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2) := match v7 as v26 in (HdRel _ _ v25) return (forall v27 : v25 = v1 :: v2, HdRel (@X.lt) v5 (v1 :: remove v4 v2)) with | HdRel_nil _ _ => fun v25 : nil = v1 :: v2 => (fun v26 : nil = v1 :: v2 => let v27 : @False := eq_ind nil (fun v27 : list (@X.t) => match v27 as v28 in (list _) return Prop with | nil => @True | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => @False) v28 v29 end) (@I) (v1 :: v2) v26 in False_ind (HdRel (@X.lt) v5 (v1 :: remove v4 v2)) v27) v25 | HdRel_cons _ _ v25 v26 v27 => (fun (v25 : @X.t) (v26 : list (@X.t)) (v27 : X.lt v5 v25) (v28 : v25 :: v26 = v1 :: v2) => (fun v29 : v25 :: v26 = v1 :: v2 => let v30 : v26 = v2 := f_equal (fun v30 : list (@X.t) => match v30 as v31 in (list _) return (list (@X.t)) with | nil => v26 | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => v32) v31 v32 end) v29 in (let v31 : v25 = v1 := f_equal (fun v31 : list (@X.t) => match v31 as v32 in (list _) return (@X.t) with | nil => v25 | v32 :: v33 => (fun (v32 : @X.t) (v33 : list (@X.t)) => v32) v32 v33 end) v29 in (fun v32 : v25 = v1 => let v33 : v25 = v1 := v32 in eq_ind_r (fun v34 : @X.t => forall (v35 : v26 = v2) (v36 : X.lt v5 v34), HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun v34 : v26 = v2 => let v35 : v26 = v2 := v34 in eq_ind_r (fun v36 : list (@X.t) => forall v37 : X.lt v5 v1, HdRel (@X.lt) v5 (v1 :: remove v4 v2)) (fun v36 : X.lt v5 v1 => HdRel_cons (@X.lt) v5 v1 (remove v4 v2) v36) v35) v33) v31) v30) v28 v27) v25 v26 v27 end in v25 Logic.eq_refl) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 end) : forall (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) (v7 : HdRel (@X.lt) v5 (v1 :: v2)), HdRel (@X.lt) v5 (remove v4 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.remove_ok	100	0.716420	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @t) (v1 : @X.t) => (fun v2 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v2) (Ok (remove v1 v0)) (Ok (remove v1 v0)) (reflexive_proper_proxy (@iff_Reflexive) (Ok (remove v1 v0)))) (isok_iff v0) ((fun v2 : Sorted (@X.lt) (remove v1 v0) <-> Ok (remove v1 v0) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v0)) (Ok (remove v1 v0)) (Sorted (@X.lt) (remove v1 v0)) (symmetry v2)) (isok_iff (remove v1 v0)) ((fun v2 : @t => list_ind (fun v3 : list (@elt) => forall (v4 : @X.t) (v5 : Sorted (@X.lt) v3), Sorted (@X.lt) (remove v4 v3)) ((fun (v3 : @X.t) (v4 : Sorted (@X.lt) nil) => v4) : forall (v3 : @X.t) (v4 : Sorted (@X.lt) nil), Sorted (@X.lt) (remove v3 nil)) (fun (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : @X.t) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (remove v5 v4)) => (fun (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)) => let v8 : CompareSpec (X.eq v6 v3) (X.lt v6 v3) (X.lt v3 v6) (X.compare v6 v3) := X.compare_spec v6 v3 in let v9 : @comparison := X.compare v6 v3 in match v8 as v11 in (CompareSpec _ _ _ v10) return (Sorted (@X.lt) match v10 as v12 in comparison return (@t) with | Eq => v4 | Lt => v3 :: v4 | Gt => v3 :: remove v6 v4 end) with | CompEq _ _ v10 => (fun v10 : X.eq v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) v4 := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) v4) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) v4) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) v4) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) v4) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => v23) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompLt _ _ v10 => (fun v10 : X.lt v6 v3 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons v23 v24) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 | CompGt _ _ v10 => (fun v10 : X.lt v3 v6 => let v11 : forall v11 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (v3 :: remove v6 v4) := match v7 as v12 in (Sorted _ v11) return (forall v13 : v11 = v3 :: v4, Sorted (@X.lt) (v3 :: remove v6 v4)) with | Sorted_nil _ => fun v11 : nil = v3 :: v4 => (fun v12 : nil = v3 :: v4 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v3 :: v4) v12 in False_ind (Sorted (@X.lt) (v3 :: remove v6 v4)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v3 :: v4) => (fun v16 : v11 :: v12 = v3 :: v4 => let v17 : v12 = v4 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v3 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v3 => let v20 : v11 = v3 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v4) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), Sorted (@X.lt) (v3 :: remove v6 v4)) (fun v21 : v12 = v4 => let v22 : v12 = v4 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v3 v23), Sorted (@X.lt) (v3 :: remove v6 v4)) (fun (v23 : Sorted (@X.lt) v4) (v24 : HdRel (@X.lt) v3 v4) => Sorted_cons (v5 v6 v23) (remove_inf v6 ((fun v25 : Sorted (@X.lt) v4 <-> Ok v4 => iff_flip_impl_subrelation (Ok v4) (Sorted (@X.lt) v4) (symmetry v25)) (isok_iff v4) v23) v24)) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) v10 end) : forall (v6 : @X.t) (v7 : Sorted (@X.lt) (v3 :: v4)), Sorted (@X.lt) (remove v6 (v3 :: v4))) v2) v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.remove_spec	100	1.153581	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : Ok v1), InA (@X.eq) v3 (remove v2 v1) <-> InA (@X.eq) v3 v1 /\ ~ X.eq v3 v2) ((fun (v1 v2 : @elt) (v3 : Ok nil) => conj (fun v4 : InA (@X.eq) v2 nil => conj v4 ((fun v5 : X.eq v2 v1 => let v6 : forall v6 : nil = nil, @False := match v4 as v7 in (InA _ _ v6) return (forall v8 : v6 = nil, @False) with | @InA_cons_hd _ _ _ v6 v7 v8 => (fun (v6 : @X.t) (v7 : list (@X.t)) (v8 : X.eq v2 v6) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t) => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : X.eq v2 v6, @False) v11) v9 v8) v6 v7 v8 | @InA_cons_tl _ _ _ v6 v7 v8 => (fun (v6 : @X.t) (v7 : list (@X.t)) (v8 : InA (@X.eq) v2 v7) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t) => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : InA (@X.eq) v2 v7, @False) v11) v9 v8) v6 v7 v8 end in v6 Logic.eq_refl) : ~ X.eq v2 v1)) (fun v4 : InA (@X.eq) v2 nil /\ ~ X.eq v2 v1 => and_ind (fun (v5 : InA (@X.eq) v2 nil) (v6 : ~ X.eq v2 v1) => v5) v4)) : forall (v1 v2 : @elt) (v3 : Ok nil), InA (@X.eq) v2 (remove v1 nil) <-> InA (@X.eq) v2 nil /\ ~ X.eq v2 v1) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : Ok v2), InA (@X.eq) v4 (remove v3 v2) <-> InA (@X.eq) v4 v2 /\ ~ X.eq v4 v3) => (fun (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) => let v7 : CompareSpec (X.eq v4 v1) (X.lt v4 v1) (X.lt v1 v4) (X.compare v4 v1) := X.compare_spec v4 v1 in let v8 : @comparison := X.compare v4 v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (InA (@X.eq) v5 match v9 as v11 in comparison return (@t) with | Eq => v2 | Lt => v1 :: v2 | Gt => v1 :: remove v4 v2 end <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | CompEq _ _ v9 => (fun v9 : X.eq v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4 := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 v2 <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (~ X.eq v5 v4) (~ X.eq v5 v4) (reflexive_proper_proxy (@iff_Reflexive) (~ X.eq v5 v4)))) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : InA (@X.eq) v5 v2 => conj (or_intror v24) ((fun v25 : X.eq v5 v4 => (let v26 : X.lt v1 v5 := Sort_Inf_In v22 v23 v24 in (fun v27 : X.lt v1 v5 => False_ind (@False) ((fun v28 : X.lt v1 v4 => (fun v29 : X.lt v1 v1 => OrderTac.lt_irrefl v29) (OrderTac.lt_eq v28 v9)) (OrderTac.lt_eq v27 v25))) v26) : @False) : ~ X.eq v5 v4)) (fun v24 : (X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4 => and_ind (fun (v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2) (v26 : ~ X.eq v5 v4) => or_ind (fun v27 : X.eq v5 v1 => ListIn_In (l:=v2) (x:=v5) (False_ind (List.In v5 v2) ((fun v28 : ~ X.eq v1 v4 => (fun v29 : ~ X.eq v1 v1 => v29 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v28 v9)) (OrderTac.eq_neq (OrderTac.eq_sym v27) v26))) : InA (@X.eq) v5 v2) (fun v27 : InA (@X.eq) v5 v2 => v27) v25) v24))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompLt _ _ v9 => (fun v9 : X.lt v4 v1 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4 := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => subrelation_proper (PER_morphism (Equivalence_PER (@iff_equivalence))) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (~ X.eq v5 v4) (~ X.eq v5 v4) (reflexive_proper_proxy (@iff_Reflexive) (~ X.eq v5 v4)))) (InA_cons (@X.eq) v5 v1 v2) (conj (fun v24 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 => or_ind (fun v25 : X.eq v5 v1 => conj (or_introl v25) ((fun v26 : X.eq v5 v4 => diff_false_true (absurd_eq_true (@false) (diff_false_true (absurd_eq_true (@false) (False_ind (@False) ((fun v27 : X.eq v4 v1 => (fun v28 : X.lt v1 v1 => OrderTac.lt_irrefl v28) (OrderTac.eq_lt (OrderTac.eq_sym v27) v9)) (OrderTac.eq_trans (OrderTac.eq_sym v26) v25)))))) : @False) : ~ X.eq v5 v4)) (fun v25 : InA (@X.eq) v5 v2 => conj (or_intror v25) ((fun v26 : X.eq v5 v4 => (let v27 : X.lt v1 v5 := Sort_Inf_In v22 v23 v25 in (fun v28 : X.lt v1 v5 => False_ind (@False) ((fun v29 : X.lt v1 v4 => (fun v30 : X.lt v4 v4 => OrderTac.lt_irrefl v30) (OrderTac.lt_trans v9 v29)) (OrderTac.lt_eq v28 v26))) v27) : @False) : ~ X.eq v5 v4)) v24) (fun v24 : (X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4 => and_ind (fun (v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2) (v26 : ~ X.eq v5 v4) => or_ind (fun v27 : X.eq v5 v1 => or_introl v27) (fun v27 : InA (@X.eq) v5 v2 => or_intror v27) v25) v24))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 | CompGt _ _ v9 => (fun v9 : X.lt v1 v4 => let v10 : forall v10 : v1 :: v2 = v1 :: v2, InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4 := match (fun v10 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v10)) (isok_iff (v1 :: v2)) v6 as v11 in (Sorted _ v10) return (forall v12 : v10 = v1 :: v2, InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) with | Sorted_nil _ => fun v10 : nil = v1 :: v2 => (fun v11 : nil = v1 :: v2 => let v12 : @False := eq_ind nil (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @True | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @False) v13 v14 end) (@I) (v1 :: v2) v11 in False_ind (InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v12) v10 | @Sorted_cons _ _ v10 v11 v12 v13 => (fun (v10 : @X.t) (v11 : list (@X.t)) (v12 : Sorted (@X.lt) v11) (v13 : HdRel (@X.lt) v10 v11) (v14 : v10 :: v11 = v1 :: v2) => (fun v15 : v10 :: v11 = v1 :: v2 => let v16 : v11 = v2 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (list (@X.t)) with | nil => v11 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v18) v17 v18 end) v15 in (let v17 : v10 = v1 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (@X.t) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v18) v18 v19 end) v15 in (fun v18 : v10 = v1 => let v19 : v10 = v1 := v18 in eq_ind_r (fun v20 : @X.t => forall (v21 : v11 = v2) (v22 : Sorted (@X.lt) v11) (v23 : HdRel (@X.lt) v20 v11), InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun v20 : v11 = v2 => let v21 : v11 = v2 := v20 in eq_ind_r (fun v22 : list (@X.t) => forall (v23 : Sorted (@X.lt) v22) (v24 : HdRel (@X.lt) v1 v22), InA (@X.eq) v5 (v1 :: remove v4 v2) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (fun (v22 : Sorted (@X.lt) v2) (v23 : HdRel (@X.lt) v1 v2) => (fun v24 : InA (@X.eq) v5 (v1 :: remove v4 v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 (remove v4 v2) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v5 (v1 :: remove v4 v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 (remove v4 v2)) v24 (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) (eq_proper_proxy (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4))) (InA_cons (@X.eq) v5 v1 (remove v4 v2)) ((fun v24 : InA (@X.eq) v5 (v1 :: v2) <-> X.eq v5 v1 \/ InA (@X.eq) v5 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v5 (v1 :: v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2) v24 (~ X.eq v5 v4) (~ X.eq v5 v4) (reflexive_proper_proxy (@iff_Reflexive) (~ X.eq v5 v4)))) (InA_cons (@X.eq) v5 v1 v2) ((fun v24 : InA (@X.eq) v5 (remove v4 v2) <-> InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (X.eq v5 v1 \/ InA (@X.eq) v5 (remove v4 v2)) (X.eq v5 v1 \/ InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v5 v1)) (InA (@X.eq) v5 (remove v4 v2)) (InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4) v24) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4) (eq_proper_proxy ((X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4))) (v3 v4 v5 ((fun v24 : Sorted (@X.lt) v2 <-> Ok v2 => iff_flip_impl_subrelation (Ok v2) (Sorted (@X.lt) v2) (symmetry v24)) (isok_iff v2) v22 : Ok v2)) (conj (fun v24 : X.eq v5 v1 \/ InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4 => or_ind (fun v25 : X.eq v5 v1 => conj (or_introl v25) ((fun v26 : X.eq v5 v4 => diff_false_true (absurd_eq_true (@false) (diff_false_true (absurd_eq_true (@false) (False_ind (@False) ((fun v27 : X.eq v4 v1 => (fun v28 : X.lt v1 v1 => OrderTac.lt_irrefl v28) (OrderTac.lt_eq v9 v27)) (OrderTac.eq_trans (OrderTac.eq_sym v26) v25)))))) : @False) : ~ X.eq v5 v4)) (fun v25 : InA (@X.eq) v5 v2 /\ ~ X.eq v5 v4 => and_ind (fun (v26 : InA (@X.eq) v5 v2) (v27 : ~ X.eq v5 v4) => conj (or_intror v26) ((fun v28 : X.eq v5 v4 => let v29 : @False := v27 v28 in False_ind (@False) v29) : ~ X.eq v5 v4)) v25) v24) (fun v24 : (X.eq v5 v1 \/ InA (@X.eq) v5 v2) /\ ~ X.eq v5 v4 => and_ind (fun (v25 : X.eq v5 v1 \/ InA (@X.eq) v5 v2) (v26 : ~ X.eq v5 v4) => or_ind (fun v27 : X.eq v5 v1 => or_introl v27) (fun v27 : InA (@X.eq) v5 v2 => or_intror (conj v27 ((fun v28 : X.eq v5 v4 => let v29 : @False := v26 v28 in False_ind (@False) v29) : ~ X.eq v5 v4))) v25) v24))))) v21) v19) v17) v16) v14 v12 v13) v10 v11 v12 v13 end in v10 Logic.eq_refl) v9 end) : forall (v4 v5 : @elt) (v6 : Ok (v1 :: v2)), InA (@X.eq) v5 (remove v4 (v1 :: v2)) <-> InA (@X.eq) v5 (v1 :: v2) /\ ~ X.eq v5 v4) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.singleton_ok	100	0.058935	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @elt => ((fun v1 : Sorted (@X.lt) (v0 :: nil) <-> Ok (v0 :: nil) => iff_flip_impl_subrelation (Ok (v0 :: nil)) (Sorted (@X.lt) (v0 :: nil)) (symmetry v1)) (isok_iff (v0 :: nil)) (Sorted_cons (Sorted_nil (@X.lt)) (HdRel_nil (@X.lt) v0)) : Ok (v0 :: nil)) : Ok (singleton v0))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.singleton_spec	100	0.306159	1	1	0	synth with cache (only 1: refine (((fun v0 v1 : @elt => conj (fun v2 : InA (@X.eq) v1 (v0 :: nil) => let v3 : forall v3 : v0 :: nil = v0 :: nil, X.eq v1 v0 := match v2 as v4 in (InA _ _ v3) return (forall v5 : v3 = v0 :: nil, X.eq v1 v0) with | @InA_cons_hd _ _ _ v3 v4 v5 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : X.eq v1 v3) (v6 : v3 :: v4 = v0 :: nil) => (fun v7 : v3 :: v4 = v0 :: nil => let v8 : v4 = nil := f_equal (fun v8 : list (@X.t) => match v8 as v9 in (list _) return (list (@X.t)) with | nil => v4 | v9 :: v10 => (fun (v9 : @X.t) (v10 : list (@X.t)) => v10) v9 v10 end) v7 in (let v9 : v3 = v0 := f_equal (fun v9 : list (@X.t) => match v9 as v10 in (list _) return (@X.t) with | nil => v3 | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => v10) v10 v11 end) v7 in (fun v10 : v3 = v0 => let v11 : v3 = v0 := v10 in eq_ind_r (fun v12 : @X.t => forall (v13 : v4 = nil) (v14 : X.eq v1 v12), X.eq v1 v0) (fun v12 : v4 = nil => let v13 : v4 = nil := v12 in eq_ind_r (fun v14 : list (@X.t) => forall v15 : X.eq v1 v0, X.eq v1 v0) (fun v14 : X.eq v1 v0 => v14) v13) v11) v9) v8) v6 v5) v3 v4 v5 | @InA_cons_tl _ _ _ v3 v4 v5 => (fun (v3 : @X.t) (v4 : list (@X.t)) (v5 : InA (@X.eq) v1 v4) (v6 : v3 :: v4 = v0 :: nil) => (fun v7 : v3 :: v4 = v0 :: nil => let v8 : v4 = nil := f_equal (fun v8 : list (@X.t) => match v8 as v9 in (list _) return (list (@X.t)) with | nil => v4 | v9 :: v10 => (fun (v9 : @X.t) (v10 : list (@X.t)) => v10) v9 v10 end) v7 in (let v9 : v3 = v0 := f_equal (fun v9 : list (@X.t) => match v9 as v10 in (list _) return (@X.t) with | nil => v3 | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => v10) v10 v11 end) v7 in (fun v10 : v3 = v0 => let v11 : v3 = v0 := v10 in eq_ind_r (fun v12 : @X.t => forall (v13 : v4 = nil) (v14 : InA (@X.eq) v1 v4), X.eq v1 v0) (fun v12 : v4 = nil => let v13 : v4 = nil := v12 in eq_ind_r (fun v14 : list (@X.t) => forall v15 : InA (@X.eq) v1 v14, X.eq v1 v0) (fun v14 : InA (@X.eq) v1 nil => let v15 : forall v15 : nil = nil, X.eq v1 v0 := match v14 as v16 in (InA _ _ v15) return (forall v17 : v15 = nil, X.eq v1 v0) with | @InA_cons_hd _ _ _ v15 v16 v17 => (fun (v15 : @X.t) (v16 : list (@X.t)) (v17 : X.eq v1 v15) (v18 : v15 :: v16 = nil) => (fun v19 : v15 :: v16 = nil => let v20 : @False := eq_ind (v15 :: v16) (fun v20 : list (@X.t) => match v20 as v21 in (list _) return Prop with | nil => @False | v21 :: v22 => (fun (v21 : @X.t) (v22 : list (@X.t)) => @True) v21 v22 end) (@I) nil v19 in False_ind (forall v21 : X.eq v1 v15, X.eq v1 v0) v20) v18 v17) v15 v16 v17 | @InA_cons_tl _ _ _ v15 v16 v17 => (fun (v15 : @X.t) (v16 : list (@X.t)) (v17 : InA (@X.eq) v1 v16) (v18 : v15 :: v16 = nil) => (fun v19 : v15 :: v16 = nil => let v20 : @False := eq_ind (v15 :: v16) (fun v20 : list (@X.t) => match v20 as v21 in (list _) return Prop with | nil => @False | v21 :: v22 => (fun (v21 : @X.t) (v22 : list (@X.t)) => @True) v21 v22 end) (@I) nil v19 in False_ind (forall v21 : InA (@X.eq) v1 v16, X.eq v1 v0) v20) v18 v17) v15 v16 v17 end in v15 Logic.eq_refl) v13) v11) v9) v8) v6 v5) v3 v4 v5 end in v3 Logic.eq_refl) (fun v2 : X.eq v1 v0 => InA_cons_hd (eqA:=@X.eq) (x:=v1) (y:=v0) nil v2)) : forall v0 v1 : @elt, InA (@X.eq) v1 (v0 :: nil) <-> X.eq v1 v0) : forall v0 v1 : @elt, InA (@X.eq) v1 (singleton v0) <-> X.eq v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.union_inf	100	1.489980	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.union_ok	100	1.316167	1	2
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.union_spec	100	2.534265	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inter_inf	100	1.249767	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inter_ok	100	0.595855	1	2
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.inter_spec	100	1.899288	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.diff_inf	100	1.228196	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.diff_ok	100	0.842025	1	2
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.diff_spec	100	2.107239	0	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.equal_spec	100	1.520193	1	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.subset_spec	100	2.186153	1	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.empty_ok	100	0.015802	1	1	0	synth with cache (only 1: refine Logic.eq_refl).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.empty_spec	100	0.067716	1	1	0	synth with cache (only 1: refine (((fun v0 : @elt => (fun v1 : InA (@X.eq) v0 nil => let v2 : forall v2 : nil = nil, @False := match v1 as v3 in (InA _ _ v2) return (forall v4 : v2 = nil, @False) with | @InA_cons_hd _ _ _ v2 v3 v4 => (fun (v2 : @X.t) (v3 : list (@X.t)) (v4 : X.eq v0 v2) (v5 : v2 :: v3 = nil) => (fun v6 : v2 :: v3 = nil => let v7 : @False := eq_ind (v2 :: v3) (fun v7 : list (@X.t) => match v7 as v8 in (list _) return Prop with | nil => @False | v8 :: v9 => (fun (v8 : @X.t) (v9 : list (@X.t)) => @True) v8 v9 end) (@I) nil v6 in False_ind (forall v8 : X.eq v0 v2, @False) v7) v5 v4) v2 v3 v4 | @InA_cons_tl _ _ _ v2 v3 v4 => (fun (v2 : @X.t) (v3 : list (@X.t)) (v4 : InA (@X.eq) v0 v3) (v5 : v2 :: v3 = nil) => (fun v6 : v2 :: v3 = nil => let v7 : @False := eq_ind (v2 :: v3) (fun v7 : list (@X.t) => match v7 as v8 in (list _) return Prop with | nil => @False | v8 :: v9 => (fun (v8 : @X.t) (v9 : list (@X.t)) => @True) v8 v9 end) (@I) nil v6 in False_ind (forall v8 : InA (@X.eq) v0 v3, @False) v7) v5 v4) v2 v3 v4 end in v2 Logic.eq_refl) : ~ InA (@X.eq) v0 nil) : forall v0 : @elt, ~ InA (@X.eq) v0 (@empty)) : Empty (@empty))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.is_empty_spec	100	0.113386	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match v0 as v1 in (list _) return (is_empty v1 = @true <-> Empty v1) with | nil => conj (fun v1 : @true = @true => (fun v2 : @elt => (fun v3 : InA (@X.eq) v2 nil => let v4 : forall v4 : nil = nil, @False := match v3 as v5 in (InA _ _ v4) return (forall v6 : v4 = nil, @False) with | @InA_cons_hd _ _ _ v4 v5 v6 => (fun (v4 : @X.t) (v5 : list (@X.t)) (v6 : X.eq v2 v4) (v7 : v4 :: v5 = nil) => (fun v8 : v4 :: v5 = nil => let v9 : @False := eq_ind (v4 :: v5) (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @False | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @True) v10 v11 end) (@I) nil v8 in False_ind (forall v10 : X.eq v2 v4, @False) v9) v7 v6) v4 v5 v6 | @InA_cons_tl _ _ _ v4 v5 v6 => (fun (v4 : @X.t) (v5 : list (@X.t)) (v6 : InA (@X.eq) v2 v5) (v7 : v4 :: v5 = nil) => (fun v8 : v4 :: v5 = nil => let v9 : @False := eq_ind (v4 :: v5) (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @False | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @True) v10 v11 end) (@I) nil v8 in False_ind (forall v10 : InA (@X.eq) v2 v5, @False) v9) v7 v6) v4 v5 v6 end in v4 Logic.eq_refl) : ~ InA (@X.eq) v2 nil) : Empty nil) (fun v1 : Empty nil => Logic.eq_refl) : is_empty nil = @true <-> Empty nil | v1 :: v2 => (fun (v1 : @elt) (v2 : list (@elt)) => conj (fun v3 : @false = @true => (fun v4 : @elt => (fun v5 : InA (@X.eq) v4 (v1 :: v2) => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (@False) v6) : ~ InA (@X.eq) v4 (v1 :: v2)) : Empty (v1 :: v2)) (fun v3 : Empty (v1 :: v2) => False_ind (@false = @true) (v3 v1 (InA_cons_hd (eqA:=@X.eq) (x:=v1) (y:=v1) v2 (OrderTac.eq_refl v1)))) : is_empty (v1 :: v2) = @true <-> Empty (v1 :: v2)) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.elements_spec1	100	0.039202	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : @elt) => conj (fun v2 : InA (@X.eq) v1 (elements v0) => v2) (fun v2 : InA (@X.eq) v1 v0 => v2))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.elements_spec2	100	0.045973	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v1) (Sorted (@X.lt) (elements v0)) (Sorted (@X.lt) (elements v0)) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) (elements v0)))) (isok_iff v0) (fun v1 : Sorted (@X.lt) v0 => v1))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.elements_spec2w	100	0.048128	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v1) (NoDupA (@X.eq) (elements v0)) (NoDupA (@X.eq) (elements v0)) (reflexive_proper_proxy (@iff_Reflexive) (NoDupA (@X.eq) (elements v0)))) (isok_iff v0) (fun v1 : Sorted (@X.lt) v0 => Sort_NoDup v1))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.min_elt_spec1	100	0.112098	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match v0 as v1 in (list _) return (forall (v2 : @elt) (v3 : min_elt v1 = Some v2), InA (@X.eq) v2 v1) with | nil => (fun (v1 : @elt) (v2 : None = Some v1) => let v3 : forall v3 : Some v1 = Some v1, InA (@X.eq) v1 nil := match v2 as v4 in (_ = v3) return (forall v5 : v3 = Some v1, InA (@X.eq) v1 nil) with | Logic.eq_refl => fun v3 : None = Some v1 => (fun v4 : None = Some v1 => let v5 : @False := eq_ind None (fun v5 : option (@elt) => match v5 as v6 in (option _) return Prop with | Some v6 => (fun v6 : @elt => @False) v6 | None => @True end) (@I) (Some v1) v4 in False_ind (InA (@X.eq) v1 nil) v5) v3 end in v3 Logic.eq_refl) : forall (v1 : @elt) (v2 : min_elt nil = Some v1), InA (@X.eq) v1 nil | v1 :: v2 => (fun (v1 : @elt) (v2 : list (@elt)) => (fun (v3 : @elt) (v4 : Some v1 = Some v3) => let v5 : forall v5 : Some v3 = Some v3, InA (@X.eq) v3 (v1 :: v2) := match v4 as v6 in (_ = v5) return (forall v7 : v5 = Some v3, InA (@X.eq) v3 (v1 :: v2)) with | Logic.eq_refl => fun v5 : Some v1 = Some v3 => (fun v6 : Some v1 = Some v3 => let v7 : v1 = v3 := f_equal (fun v7 : option (@elt) => match v7 as v8 in (option _) return (@elt) with | Some v8 => (fun v8 : @elt => v8) v8 | None => v1 end) v6 in (fun v8 : v1 = v3 => let v9 : v1 = v3 := v8 in eq_ind_r (fun v10 : @elt => InA (@X.eq) v3 (v10 :: v2)) (InA_cons_hd (eqA:=@X.eq) (x:=v3) (y:=v3) v2 (OrderTac.eq_refl v3)) v9) v7) v5 end in v5 Logic.eq_refl) : forall (v3 : @elt) (v4 : min_elt (v1 :: v2) = Some v3), InA (@X.eq) v3 (v1 :: v2)) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.min_elt_spec2	100	0.467363	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 v3 : @elt) (v4 : Ok v1) (v5 : min_elt v1 = Some v2) (v6 : InA (@X.eq) v3 v1), ~ X.lt v3 v2) ((fun (v1 v2 : @elt) (v3 : Ok nil) (v4 : None = Some v1) => let v5 : forall (v5 : Some v1 = Some v1) (v6 : InA (@X.eq) v2 nil), ~ X.lt v2 v1 := match v4 as v6 in (_ = v5) return (forall (v7 : v5 = Some v1) (v8 : InA (@X.eq) v2 nil), ~ X.lt v2 v1) with | Logic.eq_refl => fun v5 : None = Some v1 => (fun v6 : None = Some v1 => let v7 : @False := eq_ind None (fun v7 : option (@elt) => match v7 as v8 in (option _) return Prop with | Some v8 => (fun v8 : @elt => @False) v8 | None => @True end) (@I) (Some v1) v6 in False_ind (forall v8 : InA (@X.eq) v2 nil, ~ X.lt v2 v1) v7) v5 end in v5 Logic.eq_refl) : forall (v1 v2 : @elt) (v3 : Ok nil) (v4 : min_elt nil = Some v1) (v5 : InA (@X.eq) v2 nil), ~ X.lt v2 v1) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 v4 : @elt) (v5 : Ok v2) (v6 : min_elt v2 = Some v3) (v7 : InA (@X.eq) v4 v2), ~ X.lt v4 v3) => (fun (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) (v7 : Some v1 = Some v4) => let v8 : forall (v8 : Some v4 = Some v4) (v9 : InA (@X.eq) v5 (v1 :: v2)), ~ X.lt v5 v4 := match v7 as v9 in (_ = v8) return (forall (v10 : v8 = Some v4) (v11 : InA (@X.eq) v5 (v1 :: v2)), ~ X.lt v5 v4) with | Logic.eq_refl => fun v8 : Some v1 = Some v4 => (fun v9 : Some v1 = Some v4 => let v10 : v1 = v4 := f_equal (fun v10 : option (@elt) => match v10 as v11 in (option _) return (@elt) with | Some v11 => (fun v11 : @elt => v11) v11 | None => v1 end) v9 in (fun v11 : v1 = v4 => let v12 : v1 = v4 := v11 in eq_ind_r (fun v13 : @elt => forall v14 : InA (@X.eq) v5 (v13 :: v2), ~ X.lt v5 v4) (eq_ind_r (fun v13 : @elt => forall (v14 : Ok (v13 :: v2)) (v15 : Some v13 = Some v4) (v16 : InA (@X.eq) v5 (v4 :: v2)), ~ X.lt v5 v4) (fun (v13 : Ok (v4 :: v2)) (v14 : Some v4 = Some v4) (v15 : InA (@X.eq) v5 (v4 :: v2)) => let v16 : forall v16 : v4 :: v2 = v4 :: v2, ~ X.lt v5 v4 := match v15 as v17 in (InA _ _ v16) return (forall v18 : v16 = v4 :: v2, ~ X.lt v5 v4) with | @InA_cons_hd _ _ _ v16 v17 v18 => (fun (v16 : @X.t) (v17 : list (@X.t)) (v18 : X.eq v5 v16) (v19 : v16 :: v17 = v4 :: v2) => (fun v20 : v16 :: v17 = v4 :: v2 => let v21 : v17 = v2 := f_equal (fun v21 : list (@X.t) => match v21 as v22 in (list _) return (list (@X.t)) with | nil => v17 | v22 :: v23 => (fun (v22 : @X.t) (v23 : list (@X.t)) => v23) v22 v23 end) v20 in (let v22 : v16 = v4 := f_equal (fun v22 : list (@X.t) => match v22 as v23 in (list _) return (@X.t) with | nil => v16 | v23 :: v24 => (fun (v23 : @X.t) (v24 : list (@X.t)) => v23) v23 v24 end) v20 in (fun v23 : v16 = v4 => let v24 : v16 = v4 := v23 in eq_ind_r (fun v25 : @X.t => forall (v26 : v17 = v2) (v27 : X.eq v5 v25), ~ X.lt v5 v4) (fun v25 : v17 = v2 => let v26 : v17 = v2 := v25 in eq_ind_r (fun v27 : list (@X.t) => forall v28 : X.eq v5 v4, ~ X.lt v5 v4) (fun v27 : X.eq v5 v4 => let v28 : forall v28 : v4 :: v2 = v4 :: v2, ~ X.lt v5 v4 := match (fun v28 : Sorted (@X.lt) (v4 :: v2) <-> Ok (v4 :: v2) => iff_impl_subrelation (Ok (v4 :: v2)) (Sorted (@X.lt) (v4 :: v2)) (symmetry v28)) (isok_iff (v4 :: v2)) v13 as v29 in (Sorted _ v28) return (forall v30 : v28 = v4 :: v2, ~ X.lt v5 v4) with | Sorted_nil _ => fun v28 : nil = v4 :: v2 => (fun v29 : nil = v4 :: v2 => let v30 : @False := eq_ind nil (fun v30 : list (@X.t) => match v30 as v31 in (list _) return Prop with | nil => @True | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => @False) v31 v32 end) (@I) (v4 :: v2) v29 in False_ind (~ X.lt v5 v4) v30) v28 | @Sorted_cons _ _ v28 v29 v30 v31 => (fun (v28 : @X.t) (v29 : list (@X.t)) (v30 : Sorted (@X.lt) v29) (v31 : HdRel (@X.lt) v28 v29) (v32 : v28 :: v29 = v4 :: v2) => (fun v33 : v28 :: v29 = v4 :: v2 => let v34 : v29 = v2 := f_equal (fun v34 : list (@X.t) => match v34 as v35 in (list _) return (list (@X.t)) with | nil => v29 | v35 :: v36 => (fun (v35 : @X.t) (v36 : list (@X.t)) => v36) v35 v36 end) v33 in (let v35 : v28 = v4 := f_equal (fun v35 : list (@X.t) => match v35 as v36 in (list _) return (@X.t) with | nil => v28 | v36 :: v37 => (fun (v36 : @X.t) (v37 : list (@X.t)) => v36) v36 v37 end) v33 in (fun v36 : v28 = v4 => let v37 : v28 = v4 := v36 in eq_ind_r (fun v38 : @X.t => forall (v39 : v29 = v2) (v40 : Sorted (@X.lt) v29) (v41 : HdRel (@X.lt) v38 v29), ~ X.lt v5 v4) (fun v38 : v29 = v2 => let v39 : v29 = v2 := v38 in eq_ind_r (fun v40 : list (@X.t) => forall (v41 : Sorted (@X.lt) v40) (v42 : HdRel (@X.lt) v4 v40), ~ X.lt v5 v4) (fun (v40 : Sorted (@X.lt) v2) (v41 : HdRel (@X.lt) v4 v2) => (fun v42 : X.lt v5 v4 => False_ind (@False) ((fun v43 : X.lt v4 v4 => OrderTac.lt_irrefl v43) (OrderTac.eq_lt (OrderTac.eq_sym v27) v42))) : ~ X.lt v5 v4) v39) v37) v35) v34) v32 v30 v31) v28 v29 v30 v31 end in v28 Logic.eq_refl) v26) v24) v22) v21) v19 v18) v16 v17 v18 | @InA_cons_tl _ _ _ v16 v17 v18 => (fun (v16 : @X.t) (v17 : list (@X.t)) (v18 : InA (@X.eq) v5 v17) (v19 : v16 :: v17 = v4 :: v2) => (fun v20 : v16 :: v17 = v4 :: v2 => let v21 : v17 = v2 := f_equal (fun v21 : list (@X.t) => match v21 as v22 in (list _) return (list (@X.t)) with | nil => v17 | v22 :: v23 => (fun (v22 : @X.t) (v23 : list (@X.t)) => v23) v22 v23 end) v20 in (let v22 : v16 = v4 := f_equal (fun v22 : list (@X.t) => match v22 as v23 in (list _) return (@X.t) with | nil => v16 | v23 :: v24 => (fun (v23 : @X.t) (v24 : list (@X.t)) => v23) v23 v24 end) v20 in (fun v23 : v16 = v4 => let v24 : v16 = v4 := v23 in eq_ind_r (fun v25 : @X.t => forall (v26 : v17 = v2) (v27 : InA (@X.eq) v5 v17), ~ X.lt v5 v4) (fun v25 : v17 = v2 => let v26 : v17 = v2 := v25 in eq_ind_r (fun v27 : list (@X.t) => forall v28 : InA (@X.eq) v5 v27, ~ X.lt v5 v4) (fun v27 : InA (@X.eq) v5 v2 => let v28 : forall v28 : v4 :: v2 = v4 :: v2, ~ X.lt v5 v4 := match (fun v28 : Sorted (@X.lt) (v4 :: v2) <-> Ok (v4 :: v2) => iff_impl_subrelation (Ok (v4 :: v2)) (Sorted (@X.lt) (v4 :: v2)) (symmetry v28)) (isok_iff (v4 :: v2)) v13 as v29 in (Sorted _ v28) return (forall v30 : v28 = v4 :: v2, ~ X.lt v5 v4) with | Sorted_nil _ => fun v28 : nil = v4 :: v2 => (fun v29 : nil = v4 :: v2 => let v30 : @False := eq_ind nil (fun v30 : list (@X.t) => match v30 as v31 in (list _) return Prop with | nil => @True | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => @False) v31 v32 end) (@I) (v4 :: v2) v29 in False_ind (~ X.lt v5 v4) v30) v28 | @Sorted_cons _ _ v28 v29 v30 v31 => (fun (v28 : @X.t) (v29 : list (@X.t)) (v30 : Sorted (@X.lt) v29) (v31 : HdRel (@X.lt) v28 v29) (v32 : v28 :: v29 = v4 :: v2) => (fun v33 : v28 :: v29 = v4 :: v2 => let v34 : v29 = v2 := f_equal (fun v34 : list (@X.t) => match v34 as v35 in (list _) return (list (@X.t)) with | nil => v29 | v35 :: v36 => (fun (v35 : @X.t) (v36 : list (@X.t)) => v36) v35 v36 end) v33 in (let v35 : v28 = v4 := f_equal (fun v35 : list (@X.t) => match v35 as v36 in (list _) return (@X.t) with | nil => v28 | v36 :: v37 => (fun (v36 : @X.t) (v37 : list (@X.t)) => v36) v36 v37 end) v33 in (fun v36 : v28 = v4 => let v37 : v28 = v4 := v36 in eq_ind_r (fun v38 : @X.t => forall (v39 : v29 = v2) (v40 : Sorted (@X.lt) v29) (v41 : HdRel (@X.lt) v38 v29), ~ X.lt v5 v4) (fun v38 : v29 = v2 => let v39 : v29 = v2 := v38 in eq_ind_r (fun v40 : list (@X.t) => forall (v41 : Sorted (@X.lt) v40) (v42 : HdRel (@X.lt) v4 v40), ~ X.lt v5 v4) (fun (v40 : Sorted (@X.lt) v2) (v41 : HdRel (@X.lt) v4 v2) => let v42 : X.lt v4 v5 := Sort_Inf_In v40 v41 v27 in (fun v43 : X.lt v4 v5 => (fun v44 : X.lt v5 v4 => False_ind (@False) ((fun v45 : X.lt v4 v4 => OrderTac.lt_irrefl v45) (OrderTac.lt_trans v43 v44))) : ~ X.lt v5 v4) v42) v39) v37) v35) v34) v32 v30 v31) v28 v29 v30 v31 end in v28 Logic.eq_refl) v26) v24) v22) v21) v19 v18) v16 v17 v18 end in v16 Logic.eq_refl) v11 v6 v7) v12) v10) v8 end in v8 Logic.eq_refl) : forall (v4 v5 : @elt) (v6 : Ok (v1 :: v2)) (v7 : min_elt (v1 :: v2) = Some v4) (v8 : InA (@X.eq) v5 (v1 :: v2)), ~ X.lt v5 v4) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.min_elt_spec3	100	0.115147	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match v0 as v1 in (list _) return (forall v2 : min_elt v1 = None, Empty v1) with | nil => ((fun (v1 : None = None) (v2 : @elt) => (fun v3 : InA (@X.eq) v2 nil => let v4 : forall v4 : nil = nil, @False := match v3 as v5 in (InA _ _ v4) return (forall v6 : v4 = nil, @False) with | @InA_cons_hd _ _ _ v4 v5 v6 => (fun (v4 : @X.t) (v5 : list (@X.t)) (v6 : X.eq v2 v4) (v7 : v4 :: v5 = nil) => (fun v8 : v4 :: v5 = nil => let v9 : @False := eq_ind (v4 :: v5) (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @False | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @True) v10 v11 end) (@I) nil v8 in False_ind (forall v10 : X.eq v2 v4, @False) v9) v7 v6) v4 v5 v6 | @InA_cons_tl _ _ _ v4 v5 v6 => (fun (v4 : @X.t) (v5 : list (@X.t)) (v6 : InA (@X.eq) v2 v5) (v7 : v4 :: v5 = nil) => (fun v8 : v4 :: v5 = nil => let v9 : @False := eq_ind (v4 :: v5) (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @False | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @True) v10 v11 end) (@I) nil v8 in False_ind (forall v10 : InA (@X.eq) v2 v5, @False) v9) v7 v6) v4 v5 v6 end in v4 Logic.eq_refl) : ~ InA (@X.eq) v2 nil) : forall v1 : None = None, Empty nil) : forall v1 : min_elt nil = None, Empty nil | v1 :: v2 => (fun (v1 : @elt) (v2 : list (@elt)) => ((fun (v3 : Some v1 = None) (v4 : @elt) => (fun v5 : InA (@X.eq) v4 (v1 :: v2) => let v6 : @False := eq_ind (Some v1) (fun v6 : option (@elt) => match v6 as v7 in (option _) return Prop with | Some v7 => (fun v7 : @elt => @True) v7 | None => @False end) (@I) None v3 in False_ind (@False) v6) : ~ InA (@X.eq) v4 (v1 :: v2)) : forall v3 : Some v1 = None, Empty (v1 :: v2)) : forall v3 : min_elt (v1 :: v2) = None, Empty (v1 :: v2)) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.max_elt_spec1	100	0.195518	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 : @elt) (v3 : max_elt v1 = Some v2), InA (@X.eq) v2 v1) (fun (v1 : @elt) (v2 : max_elt nil = Some v1) => let v3 : forall v3 : Some v1 = Some v1, InA (@X.eq) v1 nil := match v2 as v4 in (_ = v3) return (forall v5 : v3 = Some v1, InA (@X.eq) v1 nil) with | Logic.eq_refl => fun v3 : max_elt nil = Some v1 => (fun v4 : max_elt nil = Some v1 => let v5 : @False := eq_ind (max_elt nil) (fun v5 : option (@elt) => match v5 as v6 in (option _) return Prop with | Some v6 => (fun v6 : @elt => @False) v6 | None => @True end) (@I) (Some v1) v4 in False_ind (InA (@X.eq) v1 nil) v5) v3 end in v3 Logic.eq_refl) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : @elt) (v4 : max_elt v2 = Some v3), InA (@X.eq) v3 v2) => match v2 as v4 in (list _) return (forall (v5 : forall (v5 : @elt) (v6 : max_elt v4 = Some v5), InA (@X.eq) v5 v4) (v6 : @elt) (v7 : max_elt (v1 :: v4) = Some v6), InA (@X.eq) v6 (v1 :: v4)) with | nil => fun v4 : forall (v4 : @elt) (v5 : max_elt nil = Some v4), InA (@X.eq) v4 nil => (fun (v5 : @elt) (v6 : Some v1 = Some v5) => let v7 : forall v7 : Some v5 = Some v5, InA (@X.eq) v5 (v1 :: nil) := match v6 as v8 in (_ = v7) return (forall v9 : v7 = Some v5, InA (@X.eq) v5 (v1 :: nil)) with | Logic.eq_refl => fun v7 : Some v1 = Some v5 => (fun v8 : Some v1 = Some v5 => let v9 : v1 = v5 := f_equal (fun v9 : option (@elt) => match v9 as v10 in (option _) return (@elt) with | Some v10 => (fun v10 : @elt => v10) v10 | None => v1 end) v8 in (fun v10 : v1 = v5 => let v11 : v1 = v5 := v10 in eq_ind_r (fun v12 : @elt => InA (@X.eq) v5 (v12 :: nil)) (eq_ind_r (fun v12 : @elt => forall v13 : Some v12 = Some v5, InA (@X.eq) v5 (v5 :: nil)) (fun v12 : Some v5 = Some v5 => InA_cons_hd (eqA:=@X.eq) (x:=v5) (y:=v5) nil (OrderTac.eq_refl v5)) v10 v6) v11) v9) v7 end in v7 Logic.eq_refl) : forall (v5 : @elt) (v6 : max_elt (v1 :: nil) = Some v5), InA (@X.eq) v5 (v1 :: nil) | v4 :: v5 => (fun (v4 : @elt) (v5 : list (@elt)) (v6 : forall (v6 : @elt) (v7 : max_elt (v4 :: v5) = Some v6), InA (@X.eq) v6 (v4 :: v5)) (v7 : @elt) (v8 : max_elt (v1 :: v4 :: v5) = Some v7) => InA_cons_tl v1 (v6 v7 v8)) v4 v5 end v3) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.max_elt_spec2	100	1.851628	1	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.max_elt_spec3	100	0.192513	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall v2 : max_elt v1 = None, Empty v1) ((fun (v1 : max_elt nil = None) (v2 : @elt) => (fun v3 : InA (@X.eq) v2 nil => let v4 : forall v4 : nil = nil, @False := match v3 as v5 in (InA _ _ v4) return (forall v6 : v4 = nil, @False) with | @InA_cons_hd _ _ _ v4 v5 v6 => (fun (v4 : @X.t) (v5 : list (@X.t)) (v6 : X.eq v2 v4) (v7 : v4 :: v5 = nil) => (fun v8 : v4 :: v5 = nil => let v9 : @False := eq_ind (v4 :: v5) (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @False | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @True) v10 v11 end) (@I) nil v8 in False_ind (forall v10 : X.eq v2 v4, @False) v9) v7 v6) v4 v5 v6 | @InA_cons_tl _ _ _ v4 v5 v6 => (fun (v4 : @X.t) (v5 : list (@X.t)) (v6 : InA (@X.eq) v2 v5) (v7 : v4 :: v5 = nil) => (fun v8 : v4 :: v5 = nil => let v9 : @False := eq_ind (v4 :: v5) (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @False | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @True) v10 v11 end) (@I) nil v8 in False_ind (forall v10 : InA (@X.eq) v2 v5, @False) v9) v7 v6) v4 v5 v6 end in v4 Logic.eq_refl) : ~ InA (@X.eq) v2 nil) : forall v1 : max_elt nil = None, Empty nil) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall v3 : max_elt v2 = None, Empty v2) => match v2 as v4 in (list _) return (forall (v5 : forall v5 : max_elt v4 = None, Empty v4) (v6 : max_elt (v1 :: v4) = None), Empty (v1 :: v4)) with | nil => fun (v4 : forall v4 : max_elt nil = None, Empty nil) (v5 : max_elt (v1 :: nil) = None) => let v6 : forall v6 : None = None, Empty (v1 :: nil) := match v5 as v7 in (_ = v6) return (forall v8 : v6 = None, Empty (v1 :: nil)) with | Logic.eq_refl => fun v6 : max_elt (v1 :: nil) = None => (fun v7 : max_elt (v1 :: nil) = None => let v8 : @False := eq_ind (max_elt (v1 :: nil)) (fun v8 : option (@elt) => match v8 as v9 in (option _) return Prop with | Some v9 => (fun v9 : @elt => @True) v9 | None => @False end) (@I) None v7 in False_ind (Empty (v1 :: nil)) v8) v6 end in v6 Logic.eq_refl | v4 :: v5 => (fun (v4 : @elt) (v5 : list (@elt)) (v6 : forall v6 : max_elt (v4 :: v5) = None, Empty (v4 :: v5)) (v7 : max_elt (v1 :: v4 :: v5) = None) => False_ind (Empty (v1 :: v4 :: v5)) (v6 v7 v4 (InA_cons_hd (eqA:=@X.eq) (x:=v4) (y:=v4) v5 (OrderTac.eq_refl v4)))) v4 v5 end v3) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.choose_spec3	100	0.181634	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 v3 : @elt) (v4 : Ok v0) (v5 : Ok v1) (v6 : min_elt v0 = Some v2) (v7 : min_elt v1 = Some v3) (v8 : Equal v0 v1) => let v9 : ~ X.lt v2 v3 := min_elt_spec2 v5 v7 ((fun v9 : Equal v0 v1 => Reflexive_partial_app_morphism (subrelation_proper (InA_compat (@X.eq_equiv)) (@tt) (subrelation_respectful (subrelation_refl (@X.eq)) (subrelation_respectful (subrelation_refl (equivlistA (@X.eq))) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v2) v1 v0 (symmetry v9)) v8 (min_elt_spec1 (s:=v0) v6)) in let v10 : ~ X.lt v3 v2 := min_elt_spec2 v4 v6 ((fun v10 : Equal v0 v1 => Reflexive_partial_app_morphism (subrelation_proper (InA_compat (@X.eq_equiv)) (@tt) (subrelation_respectful (subrelation_refl (@X.eq)) (subrelation_respectful (subrelation_refl (equivlistA (@X.eq))) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v3) v0 v1 v10) v8 (min_elt_spec1 (s:=v1) v7)) in let v11 : OrderTac.OTF.le v2 v3 := OrderTac.not_gt_le v10 in let v12 : OrderTac.OTF.le v3 v2 := OrderTac.not_gt_le v9 in OrderTac.not_neq_eq ((fun v13 : ~ X.eq v2 v3 => (fun v14 : X.eq v3 v2 => (fun v15 : ~ X.eq v2 v2 => v15 (OrderTac.eq_refl v2)) (OrderTac.neq_eq v13 v14)) (OrderTac.le_antisym v12 v11)) : ~ ~ X.eq v2 v3)) : forall (v0 v1 : @t) (v2 v3 : @elt) (v4 : Ok v0) (v5 : Ok v1) (v6 : choose v0 = Some v2) (v7 : choose v1 = Some v3) (v8 : Equal v0 v1), X.eq v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.fold_spec	100	0.040595	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : Type) (v2 : v1) (v3 : forall (v3 : @elt) (v4 : v1), v1) => Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.cardinal_spec	100	0.031999	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : Ok v0) => Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.filter_inf	100	0.372839	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 : @elt) (v3 : forall v3 : @elt, @bool) (v4 : Ok v1) (v5 : HdRel (@X.lt) v2 v1), HdRel (@X.lt) v2 (filter v3 v1)) ((fun (v1 : @elt) (v2 : forall v2 : @elt, @bool) (v3 : Ok nil) (v4 : HdRel (@X.lt) v1 nil) => let v5 : @bool := v2 v1 in v4) : forall (v1 : @elt) (v2 : forall v2 : @elt, @bool) (v3 : Ok nil) (v4 : HdRel (@X.lt) v1 nil), HdRel (@X.lt) v1 (filter v2 nil)) ((fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : @elt) (v4 : forall v4 : @elt, @bool) (v5 : Ok v2) (v6 : HdRel (@X.lt) v3 v2), HdRel (@X.lt) v3 (filter v4 v2)) (v4 : @elt) (v5 : forall v5 : @elt, @bool) (v6 : Ok (v1 :: v2)) (v7 : HdRel (@X.lt) v4 (v1 :: v2)) => let v8 : forall v8 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v4 match v5 v1 as v9 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end := match (fun v8 : Sorted (@X.lt) (v1 :: v2) <-> Ok (v1 :: v2) => iff_impl_subrelation (Ok (v1 :: v2)) (Sorted (@X.lt) (v1 :: v2)) (symmetry v8)) (isok_iff (v1 :: v2)) v6 as v9 in (Sorted _ v8) return (forall v10 : v8 = v1 :: v2, HdRel (@X.lt) v4 match v5 v1 as v11 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) with | Sorted_nil _ => fun v8 : nil = v1 :: v2 => (fun v9 : nil = v1 :: v2 => let v10 : @False := eq_ind nil (fun v10 : list (@X.t) => match v10 as v11 in (list _) return Prop with | nil => @True | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => @False) v11 v12 end) (@I) (v1 :: v2) v9 in False_ind (HdRel (@X.lt) v4 match v5 v1 as v11 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) v10) v8 | @Sorted_cons _ _ v8 v9 v10 v11 => (fun (v8 : @X.t) (v9 : list (@X.t)) (v10 : Sorted (@X.lt) v9) (v11 : HdRel (@X.lt) v8 v9) (v12 : v8 :: v9 = v1 :: v2) => (fun v13 : v8 :: v9 = v1 :: v2 => let v14 : v9 = v2 := f_equal (fun v14 : list (@X.t) => match v14 as v15 in (list _) return (list (@X.t)) with | nil => v9 | v15 :: v16 => (fun (v15 : @X.t) (v16 : list (@X.t)) => v16) v15 v16 end) v13 in (let v15 : v8 = v1 := f_equal (fun v15 : list (@X.t) => match v15 as v16 in (list _) return (@X.t) with | nil => v8 | v16 :: v17 => (fun (v16 : @X.t) (v17 : list (@X.t)) => v16) v16 v17 end) v13 in (fun v16 : v8 = v1 => let v17 : v8 = v1 := v16 in eq_ind_r (fun v18 : @X.t => forall (v19 : v9 = v2) (v20 : Sorted (@X.lt) v9) (v21 : HdRel (@X.lt) v18 v9), HdRel (@X.lt) v4 match v5 v1 as v22 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) (fun v18 : v9 = v2 => let v19 : v9 = v2 := v18 in eq_ind_r (fun v20 : list (@X.t) => forall (v21 : Sorted (@X.lt) v20) (v22 : HdRel (@X.lt) v1 v20), HdRel (@X.lt) v4 match v5 v1 as v23 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) (fun (v20 : Sorted (@X.lt) v2) (v21 : HdRel (@X.lt) v1 v2) => let v22 : forall v22 : v1 :: v2 = v1 :: v2, HdRel (@X.lt) v4 match v5 v1 as v23 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end := match v7 as v23 in (HdRel _ _ v22) return (forall v24 : v22 = v1 :: v2, HdRel (@X.lt) v4 match v5 v1 as v25 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) with | HdRel_nil _ _ => fun v22 : nil = v1 :: v2 => (fun v23 : nil = v1 :: v2 => let v24 : @False := eq_ind nil (fun v24 : list (@X.t) => match v24 as v25 in (list _) return Prop with | nil => @True | v25 :: v26 => (fun (v25 : @X.t) (v26 : list (@X.t)) => @False) v25 v26 end) (@I) (v1 :: v2) v23 in False_ind (HdRel (@X.lt) v4 match v5 v1 as v25 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) v24) v22 | HdRel_cons _ _ v22 v23 v24 => (fun (v22 : @X.t) (v23 : list (@X.t)) (v24 : X.lt v4 v22) (v25 : v22 :: v23 = v1 :: v2) => (fun v26 : v22 :: v23 = v1 :: v2 => let v27 : v23 = v2 := f_equal (fun v27 : list (@X.t) => match v27 as v28 in (list _) return (list (@X.t)) with | nil => v23 | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => v29) v28 v29 end) v26 in (let v28 : v22 = v1 := f_equal (fun v28 : list (@X.t) => match v28 as v29 in (list _) return (@X.t) with | nil => v22 | v29 :: v30 => (fun (v29 : @X.t) (v30 : list (@X.t)) => v29) v29 v30 end) v26 in (fun v29 : v22 = v1 => let v30 : v22 = v1 := v29 in eq_ind_r (fun v31 : @X.t => forall (v32 : v23 = v2) (v33 : X.lt v4 v31), HdRel (@X.lt) v4 match v5 v1 as v34 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) (fun v31 : v23 = v2 => let v32 : v23 = v2 := v31 in eq_ind_r (fun v33 : list (@X.t) => forall v34 : X.lt v4 v1, HdRel (@X.lt) v4 match v5 v1 as v35 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) (fun v33 : X.lt v4 v1 => match v5 v1 as v34 in bool return (HdRel (@X.lt) v4 match v34 as v35 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end) with | true => HdRel_cons (@X.lt) v4 v1 (filter v5 v2) v33 | false => v3 v4 v5 ((fun v34 : Sorted (@X.lt) v2 <-> Ok v2 => iff_flip_impl_subrelation (Ok v2) (Sorted (@X.lt) v2) (symmetry v34)) (isok_iff v2) v20) (Inf_lt v33 v21) end) v32) v30) v28) v27) v25 v24) v22 v23 v24 end in v22 Logic.eq_refl) v19) v17) v15) v14) v12 v10 v11) v8 v9 v10 v11 end in v8 Logic.eq_refl) : forall (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : @elt) (v4 : forall v4 : @elt, @bool) (v5 : Ok v2) (v6 : HdRel (@X.lt) v3 v2), HdRel (@X.lt) v3 (filter v4 v2)) (v4 : @elt) (v5 : forall v5 : @elt, @bool) (v6 : Ok (v1 :: v2)) (v7 : HdRel (@X.lt) v4 (v1 :: v2)), HdRel (@X.lt) v4 (filter v5 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.filter_ok	100	0.284075	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @t) (v1 : forall v1 : @elt, @bool) => (fun v2 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v2) (Ok (filter v1 v0)) (Ok (filter v1 v0)) (reflexive_proper_proxy (@iff_Reflexive) (Ok (filter v1 v0)))) (isok_iff v0) ((fun v2 : Sorted (@X.lt) (filter v1 v0) <-> Ok (filter v1 v0) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v0)) (Ok (filter v1 v0)) (Sorted (@X.lt) (filter v1 v0)) (symmetry v2)) (isok_iff (filter v1 v0)) ((fun v2 : @t => list_ind (fun v3 : list (@elt) => forall (v4 : forall v4 : @elt, @bool) (v5 : Sorted (@X.lt) v3), Sorted (@X.lt) (filter v4 v3)) ((fun (v3 : forall v3 : @elt, @bool) (v4 : Sorted (@X.lt) nil) => v4) : forall (v3 : forall v3 : @elt, @bool) (v4 : Sorted (@X.lt) nil), Sorted (@X.lt) (filter v3 nil)) ((fun (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : forall v5 : @elt, @bool) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (filter v5 v4)) (v6 : forall v6 : @elt, @bool) (v7 : Sorted (@X.lt) (v3 :: v4)) => let v8 : forall v8 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) match v6 v3 as v9 in bool return (@t) with | true => v3 :: filter v6 v4 | false => filter v6 v4 end := match v7 as v9 in (Sorted _ v8) return (forall v10 : v8 = v3 :: v4, Sorted (@X.lt) match v6 v3 as v11 in bool return (@t) with | true => v3 :: filter v6 v4 | false => filter v6 v4 end) with | Sorted_nil _ => fun v8 : nil = v3 :: v4 => (fun v9 : nil = v3 :: v4 => let v10 : @False := eq_ind nil (fun v10 : list (@X.t) => match v10 as v11 in (list _) return Prop with | nil => @True | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => @False) v11 v12 end) (@I) (v3 :: v4) v9 in False_ind (Sorted (@X.lt) match v6 v3 as v11 in bool return (@t) with | true => v3 :: filter v6 v4 | false => filter v6 v4 end) v10) v8 | @Sorted_cons _ _ v8 v9 v10 v11 => (fun (v8 : @X.t) (v9 : list (@X.t)) (v10 : Sorted (@X.lt) v9) (v11 : HdRel (@X.lt) v8 v9) (v12 : v8 :: v9 = v3 :: v4) => (fun v13 : v8 :: v9 = v3 :: v4 => let v14 : v9 = v4 := f_equal (fun v14 : list (@X.t) => match v14 as v15 in (list _) return (list (@X.t)) with | nil => v9 | v15 :: v16 => (fun (v15 : @X.t) (v16 : list (@X.t)) => v16) v15 v16 end) v13 in (let v15 : v8 = v3 := f_equal (fun v15 : list (@X.t) => match v15 as v16 in (list _) return (@X.t) with | nil => v8 | v16 :: v17 => (fun (v16 : @X.t) (v17 : list (@X.t)) => v16) v16 v17 end) v13 in (fun v16 : v8 = v3 => let v17 : v8 = v3 := v16 in eq_ind_r (fun v18 : @X.t => forall (v19 : v9 = v4) (v20 : Sorted (@X.lt) v9) (v21 : HdRel (@X.lt) v18 v9), Sorted (@X.lt) match v6 v3 as v22 in bool return (@t) with | true => v3 :: filter v6 v4 | false => filter v6 v4 end) (fun v18 : v9 = v4 => let v19 : v9 = v4 := v18 in eq_ind_r (fun v20 : list (@X.t) => forall (v21 : Sorted (@X.lt) v20) (v22 : HdRel (@X.lt) v3 v20), Sorted (@X.lt) match v6 v3 as v23 in bool return (@t) with | true => v3 :: filter v6 v4 | false => filter v6 v4 end) (fun (v20 : Sorted (@X.lt) v4) (v21 : HdRel (@X.lt) v3 v4) => match v6 v3 as v22 in bool return (Sorted (@X.lt) match v22 as v23 in bool return (@t) with | true => v3 :: filter v6 v4 | false => filter v6 v4 end) with | true => Sorted_cons (v5 v6 v20) (filter_inf v6 ((fun v22 : Sorted (@X.lt) v4 <-> Ok v4 => iff_flip_impl_subrelation (Ok v4) (Sorted (@X.lt) v4) (symmetry v22)) (isok_iff v4) v20) v21) | false => v5 v6 v20 end) v19) v17) v15) v14) v12 v10 v11) v8 v9 v10 v11 end in v8 Logic.eq_refl) : forall (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : forall v5 : @elt, @bool) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (filter v5 v4)) (v6 : forall v6 : @elt, @bool) (v7 : Sorted (@X.lt) (v3 :: v4)), Sorted (@X.lt) (filter v6 (v3 :: v4))) v2) v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.filter_spec	100	0.512684	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 : @elt) (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3), InA (@X.eq) v2 (filter v3 v1) <-> InA (@X.eq) v2 v1 /\ v3 v2 = @true) ((fun (v1 : @elt) (v2 : forall v2 : @elt, @bool) (v3 : Proper (@X.eq ==> eq) v2) => conj (fun v4 : InA (@X.eq) v1 nil => conj v4 (let v5 : forall v5 : nil = nil, v2 v1 = @true := match v4 as v6 in (InA _ _ v5) return (forall v7 : v5 = nil, v2 v1 = @true) with | @InA_cons_hd _ _ _ v5 v6 v7 => (fun (v5 : @X.t) (v6 : list (@X.t)) (v7 : X.eq v1 v5) (v8 : v5 :: v6 = nil) => (fun v9 : v5 :: v6 = nil => let v10 : @False := eq_ind (v5 :: v6) (fun v10 : list (@X.t) => match v10 as v11 in (list _) return Prop with | nil => @False | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => @True) v11 v12 end) (@I) nil v9 in False_ind (forall v11 : X.eq v1 v5, v2 v1 = @true) v10) v8 v7) v5 v6 v7 | @InA_cons_tl _ _ _ v5 v6 v7 => (fun (v5 : @X.t) (v6 : list (@X.t)) (v7 : InA (@X.eq) v1 v6) (v8 : v5 :: v6 = nil) => (fun v9 : v5 :: v6 = nil => let v10 : @False := eq_ind (v5 :: v6) (fun v10 : list (@X.t) => match v10 as v11 in (list _) return Prop with | nil => @False | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => @True) v11 v12 end) (@I) nil v9 in False_ind (forall v11 : InA (@X.eq) v1 v6, v2 v1 = @true) v10) v8 v7) v5 v6 v7 end in v5 Logic.eq_refl)) (fun v4 : InA (@X.eq) v1 nil /\ v2 v1 = @true => and_ind (fun (v5 : InA (@X.eq) v1 nil) (v6 : v2 v1 = @true) => v5) v4)) : forall (v1 : @elt) (v2 : forall v2 : @elt, @bool) (v3 : Proper (@X.eq ==> eq) v2), InA (@X.eq) v1 (filter v2 nil) <-> InA (@X.eq) v1 nil /\ v2 v1 = @true) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : @elt) (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4), InA (@X.eq) v3 (filter v4 v2) <-> InA (@X.eq) v3 v2 /\ v4 v3 = @true) => (fun (v4 : @elt) (v5 : forall v5 : @elt, @bool) (v6 : Proper (@X.eq ==> eq) v5) => let v7 : @bool := v5 v1 in let v8 : v5 v1 = v7 := Logic.eq_refl in match v7 as v9 in bool return (forall v10 : v5 v1 = v9, InA (@X.eq) v4 match v9 as v11 in bool return (@t) with | true => v1 :: filter v5 v2 | false => filter v5 v2 end <-> InA (@X.eq) v4 (v1 :: v2) /\ v5 v4 = @true) with | true => fun v9 : v5 v1 = @true => (fun v10 : InA (@X.eq) v4 (v1 :: filter v5 v2) <-> X.eq v4 v1 \/ InA (@X.eq) v4 (filter v5 v2) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v4 (v1 :: filter v5 v2)) (X.eq v4 v1 \/ InA (@X.eq) v4 (filter v5 v2)) v10 (InA (@X.eq) v4 (v1 :: v2) /\ v5 v4 = @true) (InA (@X.eq) v4 (v1 :: v2) /\ v5 v4 = @true) (eq_proper_proxy (InA (@X.eq) v4 (v1 :: v2) /\ v5 v4 = @true))) (InA_cons (@X.eq) v4 v1 (filter v5 v2)) ((fun v10 : InA (@X.eq) v4 (v1 :: v2) <-> X.eq v4 v1 \/ InA (@X.eq) v4 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (InA (@X.eq) v4 (v1 :: v2) /\ v5 v4 = @true) ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v4 (v1 :: v2)) (X.eq v4 v1 \/ InA (@X.eq) v4 v2) v10 (v5 v4 = @true) (v5 v4 = @true) (reflexive_proper_proxy (@iff_Reflexive) (v5 v4 = @true)))) (InA_cons (@X.eq) v4 v1 v2) ((fun v10 : InA (@X.eq) v4 (filter v5 v2) <-> InA (@X.eq) v4 v2 /\ v5 v4 = @true => trans_co_eq_inv_impl_morphism (@iff_Transitive) (X.eq v4 v1 \/ InA (@X.eq) v4 (filter v5 v2)) (X.eq v4 v1 \/ InA (@X.eq) v4 v2 /\ v5 v4 = @true) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (X.eq v4 v1)) (InA (@X.eq) v4 (filter v5 v2)) (InA (@X.eq) v4 v2 /\ v5 v4 = @true) v10) ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true) ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true) (eq_proper_proxy ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true))) (v3 v4 v5 v6) (conj (fun v10 : X.eq v4 v1 \/ InA (@X.eq) v4 v2 /\ v5 v4 = @true => or_ind (fun v11 : X.eq v4 v1 => conj (or_introl v11) (let v12 : default_relation v4 v1 := v11 : default_relation v4 v1 in ((fun v13 : X.eq v4 v1 => trans_co_eq_inv_impl_morphism eq_Transitive (v5 v4) (v5 v1) (v6 v4 v1 v13) (@true) (@true) (eq_proper_proxy (@true)) v9) : forall v13 : default_relation v4 v1, v5 v4 = @true) v12)) (fun v11 : InA (@X.eq) v4 v2 /\ v5 v4 = @true => and_ind (fun (v12 : InA (@X.eq) v4 v2) (v13 : v5 v4 = @true) => conj (or_intror v12) v13) v11) v10) (fun v10 : (X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true => and_ind (fun (v11 : X.eq v4 v1 \/ InA (@X.eq) v4 v2) (v12 : v5 v4 = @true) => or_ind (fun v13 : X.eq v4 v1 => or_introl v13) (fun v13 : InA (@X.eq) v4 v2 => or_intror (conj v13 v12)) v11) v10)))) | false => fun v9 : v5 v1 = @false => (fun v10 : InA (@X.eq) v4 (v1 :: v2) <-> X.eq v4 v1 \/ InA (@X.eq) v4 v2 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (InA (@X.eq) v4 (v1 :: v2) /\ v5 v4 = @true) ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true) (Morphisms_Prop.and_iff_morphism (InA (@X.eq) v4 (v1 :: v2)) (X.eq v4 v1 \/ InA (@X.eq) v4 v2) v10 (v5 v4 = @true) (v5 v4 = @true) (reflexive_proper_proxy (@iff_Reflexive) (v5 v4 = @true)))) (InA_cons (@X.eq) v4 v1 v2) ((fun v10 : InA (@X.eq) v4 (filter v5 v2) <-> InA (@X.eq) v4 v2 /\ v5 v4 = @true => trans_co_eq_inv_impl_morphism (@iff_Transitive) (InA (@X.eq) v4 (filter v5 v2)) (InA (@X.eq) v4 v2 /\ v5 v4 = @true) v10 ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true) ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true) (eq_proper_proxy ((X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true))) (v3 v4 v5 v6) (conj (fun v10 : InA (@X.eq) v4 v2 /\ v5 v4 = @true => and_ind (fun (v11 : InA (@X.eq) v4 v2) (v12 : v5 v4 = @true) => conj (or_intror v11) v12) v10) (fun v10 : (X.eq v4 v1 \/ InA (@X.eq) v4 v2) /\ v5 v4 = @true => and_ind (fun (v11 : X.eq v4 v1 \/ InA (@X.eq) v4 v2) (v12 : v5 v4 = @true) => or_ind (fun v13 : X.eq v4 v1 => conj (let v14 : default_relation v1 v4 := OrderTac.not_neq_eq ((fun v14 : ~ X.eq v1 v4 => (fun v15 : ~ X.eq v1 v1 => v15 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v14 v13)) : ~ ~ X.eq v1 v4) : default_relation v1 v4 in ((fun v15 : X.eq v1 v4 => let v16 : @true = @false := Logic.eq_trans (Logic.eq_sym v12) (subrelation_proper (PER_morphism (Equivalence_PER eq_equivalence)) (@tt) (subrelation_respectful (subrelation_refl eq) (subrelation_respectful (subrelation_refl eq) (@iff_impl_subrelation))) (v5 v1) (v5 v4) (v6 v1 v4 v15) (@false) (@false) (eq_proper_proxy (@false)) v9) in let v17 : @False := eq_ind (@true) (fun v17 : @bool => match v17 as v18 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v16 in False_ind (InA (@X.eq) v4 v2) v17) : forall v15 : default_relation v1 v4, InA (@X.eq) v4 v2) v14) v12) (fun v13 : InA (@X.eq) v4 v2 => conj v13 v12) v11) v10))) end v8) : forall (v4 : @elt) (v5 : forall v5 : @elt, @bool) (v6 : Proper (@X.eq ==> eq) v5), InA (@X.eq) v4 (filter v5 (v1 :: v2)) <-> InA (@X.eq) v4 (v1 :: v2) /\ v5 v4 = @true) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.for_all_spec	100	0.669034	1	1	0	synth with cache (only 1: refine ((fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 : forall v2 : @elt, @bool) (v3 : Proper (@X.eq ==> eq) v2), for_all v2 v1 = @true <-> (forall (v4 : @X.t) (v5 : InA (@X.eq) v4 v1), v2 v4 = @true)) ((fun (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1) => conj (fun (v3 : @true = @true) (v4 : @X.t) (v5 : InA (@X.eq) v4 nil) => let v6 : forall v6 : nil = nil, v1 v4 = @true := match v5 as v7 in (InA _ _ v6) return (forall v8 : v6 = nil, v1 v4 = @true) with | @InA_cons_hd _ _ _ v6 v7 v8 => (fun (v6 : @X.t) (v7 : list (@X.t)) (v8 : X.eq v4 v6) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t) => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : X.eq v4 v6, v1 v4 = @true) v11) v9 v8) v6 v7 v8 | @InA_cons_tl _ _ _ v6 v7 v8 => (fun (v6 : @X.t) (v7 : list (@X.t)) (v8 : InA (@X.eq) v4 v7) (v9 : v6 :: v7 = nil) => (fun v10 : v6 :: v7 = nil => let v11 : @False := eq_ind (v6 :: v7) (fun v11 : list (@X.t) => match v11 as v12 in (list _) return Prop with | nil => @False | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => @True) v12 v13 end) (@I) nil v10 in False_ind (forall v12 : InA (@X.eq) v4 v7, v1 v4 = @true) v11) v9 v8) v6 v7 v8 end in v6 Logic.eq_refl) (fun v3 : forall (v3 : @X.t) (v4 : InA (@X.eq) v3 nil), v1 v3 = @true => Logic.eq_refl)) : forall (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), for_all v1 nil = @true <-> (forall (v3 : @X.t) (v4 : InA (@X.eq) v3 nil), v1 v3 = @true)) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3), for_all v3 v2 = @true <-> (forall (v5 : @X.t) (v6 : InA (@X.eq) v5 v2), v3 v5 = @true)) => (fun (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4) => let v6 : @bool := v4 v1 in let v7 : v4 v1 = v6 := Logic.eq_refl in match v6 as v8 in bool return (forall v9 : v4 v1 = v8, match v8 as v10 in bool return (@bool) with | true => for_all v4 v2 | false => @false end = @true <-> (forall (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2)), v4 v10 = @true)) with | true => fun v8 : v4 v1 = @true => (fun v9 : for_all v4 v2 = @true <-> (forall (v9 : @X.t) (v10 : InA (@X.eq) v9 v2), v4 v9 = @true) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (for_all v4 v2 = @true) (forall (v10 : @X.t) (v11 : InA (@X.eq) v10 v2), v4 v10 = @true) v9 (forall (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2)), v4 v10 = @true) (forall (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2)), v4 v10 = @true) (eq_proper_proxy (forall (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2)), v4 v10 = @true))) (v3 v4 v5) (conj (fun (v9 : forall (v9 : @X.t) (v10 : InA (@X.eq) v9 v2), v4 v9 = @true) (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2)) => let v12 : forall v12 : v1 :: v2 = v1 :: v2, v4 v10 = @true := match v11 as v13 in (InA _ _ v12) return (forall v14 : v12 = v1 :: v2, v4 v10 = @true) with | @InA_cons_hd _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : X.eq v10 v12) (v15 : v12 :: v13 = v1 :: v2) => (fun v16 : v12 :: v13 = v1 :: v2 => let v17 : v13 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = v2) (v23 : X.eq v10 v21), v4 v10 = @true) (fun v21 : v13 = v2 => let v22 : v13 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : X.eq v10 v1, v4 v10 = @true) (fun v23 : X.eq v10 v1 => let v24 : default_relation v10 v1 := v23 : default_relation v10 v1 in ((fun v25 : X.eq v10 v1 => trans_co_eq_inv_impl_morphism eq_Transitive (v4 v10) (v4 v1) (v5 v10 v1 v25) (@true) (@true) (eq_proper_proxy (@true)) v8) : forall v25 : default_relation v10 v1, v4 v10 = @true) v24) v22) v20) v18) v17) v15 v14) v12 v13 v14 | @InA_cons_tl _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : InA (@X.eq) v10 v13) (v15 : v12 :: v13 = v1 :: v2) => (fun v16 : v12 :: v13 = v1 :: v2 => let v17 : v13 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = v2) (v23 : InA (@X.eq) v10 v13), v4 v10 = @true) (fun v21 : v13 = v2 => let v22 : v13 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : InA (@X.eq) v10 v23, v4 v10 = @true) (fun v23 : InA (@X.eq) v10 v2 => v9 v10 v23) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 Logic.eq_refl) (fun (v9 : forall (v9 : @X.t) (v10 : InA (@X.eq) v9 (v1 :: v2)), v4 v9 = @true) (v10 : @X.t) (v11 : InA (@X.eq) v10 v2) => (fun v12 : forall v12 : Proper (@X.eq ==> eq) v4, for_all v4 v2 = @true <-> (forall (v13 : @X.t) (v14 : InA (@X.eq) v13 v2), v4 v13 = @true) => (fun v13 : for_all v4 v2 = @true <-> (forall (v13 : @X.t) (v14 : InA (@X.eq) v13 v2), v4 v13 = @true) => and_ind (fun (v14 : forall (v14 : for_all v4 v2 = @true) (v15 : @X.t) (v16 : InA (@X.eq) v15 v2), v4 v15 = @true) (v15 : forall v15 : forall (v15 : @X.t) (v16 : InA (@X.eq) v15 v2), v4 v15 = @true, for_all v4 v2 = @true) => let v16 : forall (v16 : @X.t) (v17 : InA (@X.eq) v16 v2), v4 v16 = @true := fun (v16 : @X.t) (v17 : InA (@X.eq) v16 v2) => (fun v18 : forall v18 : InA (@X.eq) v16 (v1 :: v2), v4 v16 = @true => v9 v16 (InA_cons_tl v1 v17)) (v9 v16) in (fun v17 : forall (v17 : @X.t) (v18 : InA (@X.eq) v17 v2), v4 v17 = @true => (fun v18 : for_all v4 v2 = @true => (fun v19 : forall (v19 : @X.t) (v20 : InA (@X.eq) v19 v2), v4 v19 = @true => (fun v20 : forall v20 : InA (@X.eq) v10 v2, v4 v10 = @true => (fun v21 : v4 v10 = @true => v21) (v20 v11)) (v19 v10)) (v14 v18)) (v15 v17)) v16) v13) (v12 v5)) (v3 v4))) | false => fun v8 : v4 v1 = @false => conj (fun (v9 : @false = @true) (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2)) => let v12 : @False := eq_ind (@false) (fun v12 : @bool => match v12 as v13 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v9 in False_ind (v4 v10 = @true) v12) (fun v9 : forall (v9 : @X.t) (v10 : InA (@X.eq) v9 (v1 :: v2)), v4 v9 = @true => let v10 : @true = @false := eq_ind (v4 v1) (fun v10 : @bool => v10 = @false) v8 (@true) (v9 v1 (InA_cons_hd (eqA:=@X.eq) (x:=v1) (y:=v1) v2 (OrderTac.eq_refl v1))) in Logic.eq_sym v10) end v7) : forall (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4), for_all v4 (v1 :: v2) = @true <-> (forall (v6 : @X.t) (v7 : InA (@X.eq) v6 (v1 :: v2)), v4 v6 = @true)) v0) : forall (v0 : @t) (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), for_all v1 v0 = @true <-> For_all (fun v3 : @elt => v1 v3 = @true) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.exists_spec	100	0.923520	1	1	0	synth with cache (only 1: refine ((fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 : forall v2 : @elt, @bool) (v3 : Proper (@X.eq ==> eq) v2), exists_ v2 v1 = @true <-> (exists v4 : @X.t, InA (@X.eq) v4 v1 /\ v2 v4 = @true)) ((fun (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1) => conj (fun v3 : @false = @true => let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (exists v5 : @X.t, InA (@X.eq) v5 nil /\ v1 v5 = @true) v4) (fun v3 : exists v3 : @X.t, InA (@X.eq) v3 nil /\ v1 v3 = @true => ex_ind (fun (v4 : @X.t) (v5 : InA (@X.eq) v4 nil /\ v1 v4 = @true) => and_ind (fun (v6 : InA (@X.eq) v4 nil) (v7 : v1 v4 = @true) => let v8 : forall v8 : nil = nil, @false = @true := match v6 as v9 in (InA _ _ v8) return (forall v10 : v8 = nil, @false = @true) with | @InA_cons_hd _ _ _ v8 v9 v10 => (fun (v8 : @X.t) (v9 : list (@X.t)) (v10 : X.eq v4 v8) (v11 : v8 :: v9 = nil) => (fun v12 : v8 :: v9 = nil => let v13 : @False := eq_ind (v8 :: v9) (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @False | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @True) v14 v15 end) (@I) nil v12 in False_ind (forall v14 : X.eq v4 v8, @false = @true) v13) v11 v10) v8 v9 v10 | @InA_cons_tl _ _ _ v8 v9 v10 => (fun (v8 : @X.t) (v9 : list (@X.t)) (v10 : InA (@X.eq) v4 v9) (v11 : v8 :: v9 = nil) => (fun v12 : v8 :: v9 = nil => let v13 : @False := eq_ind (v8 :: v9) (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @False | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @True) v14 v15 end) (@I) nil v12 in False_ind (forall v14 : InA (@X.eq) v4 v9, @false = @true) v13) v11 v10) v8 v9 v10 end in v8 Logic.eq_refl) v5) v3)) : forall (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), exists_ v1 nil = @true <-> (exists v3 : @X.t, InA (@X.eq) v3 nil /\ v1 v3 = @true)) (fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3), exists_ v3 v2 = @true <-> (exists v5 : @X.t, InA (@X.eq) v5 v2 /\ v3 v5 = @true)) => (fun (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4) => let v6 : @bool := v4 v1 in let v7 : v4 v1 = v6 := Logic.eq_refl in match v6 as v8 in bool return (forall v9 : v4 v1 = v8, match v8 as v10 in bool return (@bool) with | true => @true | false => exists_ v4 v2 end = @true <-> (exists v10 : @X.t, InA (@X.eq) v10 (v1 :: v2) /\ v4 v10 = @true)) with | true => fun v8 : v4 v1 = @true => conj (fun v9 : @true = @true => (fun v10 : forall v10 : Proper (@X.eq ==> eq) v4, exists_ v4 v2 = @true <-> (exists v11 : @X.t, InA (@X.eq) v11 v2 /\ v4 v11 = @true) => (fun v11 : exists_ v4 v2 = @true <-> (exists v11 : @X.t, InA (@X.eq) v11 v2 /\ v4 v11 = @true) => and_ind (fun (v12 : forall v12 : exists_ v4 v2 = @true, exists v13 : @X.t, InA (@X.eq) v13 v2 /\ v4 v13 = @true) (v13 : forall v13 : exists v13 : @X.t, InA (@X.eq) v13 v2 /\ v4 v13 = @true, exists_ v4 v2 = @true) => (fun v14 : forall (v14 : @X.t) (v15 : (fun v15 : @X.t => InA (@X.eq) v15 v2 /\ v4 v15 = @true) v14), exists_ v4 v2 = @true => ex_intro (fun v15 : @X.t => InA (@X.eq) v15 (v1 :: v2) /\ v4 v15 = @true) v1 (conj ((fun v15 : forall v15 : (fun v15 : @X.t => InA (@X.eq) v15 v2 /\ v4 v15 = @true) v1, exists_ v4 v2 = @true => (fun v16 : forall (v16 : InA (@X.eq) v1 v2) (v17 : v4 v1 = @true), exists_ v4 v2 = @true => ListIn_In (l:=v1 :: v2) (x:=v1) (in_eq v1 v2)) (fun (v16 : InA (@X.eq) v1 v2) (v17 : v4 v1 = @true) => v15 (conj v16 v17))) (v14 v1)) v8)) (fun (v14 : @X.t) (v15 : (fun v15 : @X.t => InA (@X.eq) v15 v2 /\ v4 v15 = @true) v14) => v13 (ex_intro (fun v16 : @X.t => InA (@X.eq) v16 v2 /\ v4 v16 = @true) v14 v15))) v11) (v10 v5)) (v3 v4)) (fun v9 : exists v9 : @X.t, InA (@X.eq) v9 (v1 :: v2) /\ v4 v9 = @true => ex_ind (fun (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2) /\ v4 v10 = @true) => and_ind (fun (v12 : InA (@X.eq) v10 (v1 :: v2)) (v13 : v4 v10 = @true) => Logic.eq_refl) v11) v9) | false => fun v8 : v4 v1 = @false => (fun v9 : exists_ v4 v2 = @true <-> (exists v9 : @X.t, InA (@X.eq) v9 v2 /\ v4 v9 = @true) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (exists_ v4 v2 = @true) (exists v10 : @X.t, InA (@X.eq) v10 v2 /\ v4 v10 = @true) v9 (exists v10 : @X.t, InA (@X.eq) v10 (v1 :: v2) /\ v4 v10 = @true) (exists v10 : @X.t, InA (@X.eq) v10 (v1 :: v2) /\ v4 v10 = @true) (eq_proper_proxy (exists v10 : @X.t, InA (@X.eq) v10 (v1 :: v2) /\ v4 v10 = @true))) (v3 v4 v5) (conj (fun v9 : exists v9 : @X.t, InA (@X.eq) v9 v2 /\ v4 v9 = @true => ex_ind (fun (v10 : @X.t) (v11 : InA (@X.eq) v10 v2 /\ v4 v10 = @true) => and_ind (fun (v12 : InA (@X.eq) v10 v2) (v13 : v4 v10 = @true) => (fun v14 : forall v14 : Proper (@X.eq ==> eq) v4, exists_ v4 v2 = @true <-> (exists v15 : @X.t, InA (@X.eq) v15 v2 /\ v4 v15 = @true) => (fun v15 : exists_ v4 v2 = @true <-> (exists v15 : @X.t, InA (@X.eq) v15 v2 /\ v4 v15 = @true) => and_ind (fun (v16 : forall v16 : exists_ v4 v2 = @true, exists v17 : @X.t, InA (@X.eq) v17 v2 /\ v4 v17 = @true) (v17 : forall v17 : exists v17 : @X.t, InA (@X.eq) v17 v2 /\ v4 v17 = @true, exists_ v4 v2 = @true) => (fun v18 : forall (v18 : @X.t) (v19 : (fun v19 : @X.t => InA (@X.eq) v19 v2 /\ v4 v19 = @true) v18), exists_ v4 v2 = @true => ex_intro (fun v19 : @X.t => InA (@X.eq) v19 (v1 :: v2) /\ v4 v19 = @true) v10 (conj ((fun v19 : forall v19 : (fun v19 : @X.t => InA (@X.eq) v19 v2 /\ v4 v19 = @true) v10, exists_ v4 v2 = @true => (fun v20 : forall (v20 : InA (@X.eq) v10 v2) (v21 : v4 v10 = @true), exists_ v4 v2 = @true => (fun v21 : forall v21 : v4 v10 = @true, exists_ v4 v2 = @true => (fun v22 : exists_ v4 v2 = @true => (fun v23 : exists v23 : @X.t, InA (@X.eq) v23 v2 /\ v4 v23 = @true => ex_ind (fun (v24 : @X.t) (v25 : InA (@X.eq) v24 v2 /\ v4 v24 = @true) => and_ind (fun (v26 : InA (@X.eq) v24 v2) (v27 : v4 v24 = @true) => InA_cons_tl v1 v12) v25) v23) (v16 v22)) (v21 v13)) (v20 v12)) (fun (v20 : InA (@X.eq) v10 v2) (v21 : v4 v10 = @true) => v19 (conj v20 v21))) (v18 v10)) v13)) (fun (v18 : @X.t) (v19 : (fun v19 : @X.t => InA (@X.eq) v19 v2 /\ v4 v19 = @true) v18) => v17 (ex_intro (fun v20 : @X.t => InA (@X.eq) v20 v2 /\ v4 v20 = @true) v18 v19))) v15) (v14 v5)) (v3 v4)) v11) v9) (fun v9 : exists v9 : @X.t, InA (@X.eq) v9 (v1 :: v2) /\ v4 v9 = @true => ex_ind (fun (v10 : @X.t) (v11 : InA (@X.eq) v10 (v1 :: v2) /\ v4 v10 = @true) => and_ind (fun (v12 : InA (@X.eq) v10 (v1 :: v2)) (v13 : v4 v10 = @true) => let v14 : forall v14 : v1 :: v2 = v1 :: v2, exists v15 : @X.t, InA (@X.eq) v15 v2 /\ v4 v15 = @true := match v12 as v15 in (InA _ _ v14) return (forall v16 : v14 = v1 :: v2, exists v17 : @X.t, InA (@X.eq) v17 v2 /\ v4 v17 = @true) with | @InA_cons_hd _ _ _ v14 v15 v16 => (fun (v14 : @X.t) (v15 : list (@X.t)) (v16 : X.eq v10 v14) (v17 : v14 :: v15 = v1 :: v2) => (fun v18 : v14 :: v15 = v1 :: v2 => let v19 : v15 = v2 := f_equal (fun v19 : list (@X.t) => match v19 as v20 in (list _) return (list (@X.t)) with | nil => v15 | v20 :: v21 => (fun (v20 : @X.t) (v21 : list (@X.t)) => v21) v20 v21 end) v18 in (let v20 : v14 = v1 := f_equal (fun v20 : list (@X.t) => match v20 as v21 in (list _) return (@X.t) with | nil => v14 | v21 :: v22 => (fun (v21 : @X.t) (v22 : list (@X.t)) => v21) v21 v22 end) v18 in (fun v21 : v14 = v1 => let v22 : v14 = v1 := v21 in eq_ind_r (fun v23 : @X.t => forall (v24 : v15 = v2) (v25 : X.eq v10 v23), exists v26 : @X.t, InA (@X.eq) v26 v2 /\ v4 v26 = @true) (fun v23 : v15 = v2 => let v24 : v15 = v2 := v23 in eq_ind_r (fun v25 : list (@X.t) => forall v26 : X.eq v10 v1, exists v27 : @X.t, InA (@X.eq) v27 v2 /\ v4 v27 = @true) (fun v25 : X.eq v10 v1 => let v26 : default_relation v1 v10 := OrderTac.not_neq_eq ((fun v26 : ~ X.eq v1 v10 => (fun v27 : ~ X.eq v1 v1 => v27 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v26 v25)) : ~ ~ X.eq v1 v10) : default_relation v1 v10 in ((fun v27 : X.eq v1 v10 => let v28 : @true = @false := Logic.eq_trans (Logic.eq_sym v13) (subrelation_proper (PER_morphism (Equivalence_PER eq_equivalence)) (@tt) (subrelation_respectful (subrelation_refl eq) (subrelation_respectful (subrelation_refl eq) (@iff_impl_subrelation))) (v4 v1) (v4 v10) (v5 v1 v10 v27) (@false) (@false) (eq_proper_proxy (@false)) v8) in let v29 : @False := eq_ind (@true) (fun v29 : @bool => match v29 as v30 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v28 in False_ind (exists v30 : @X.t, InA (@X.eq) v30 v2 /\ v4 v30 = @true) v29) : forall v27 : default_relation v1 v10, exists v28 : @X.t, InA (@X.eq) v28 v2 /\ v4 v28 = @true) v26) v24) v22) v20) v19) v17 v16) v14 v15 v16 | @InA_cons_tl _ _ _ v14 v15 v16 => (fun (v14 : @X.t) (v15 : list (@X.t)) (v16 : InA (@X.eq) v10 v15) (v17 : v14 :: v15 = v1 :: v2) => (fun v18 : v14 :: v15 = v1 :: v2 => let v19 : v15 = v2 := f_equal (fun v19 : list (@X.t) => match v19 as v20 in (list _) return (list (@X.t)) with | nil => v15 | v20 :: v21 => (fun (v20 : @X.t) (v21 : list (@X.t)) => v21) v20 v21 end) v18 in (let v20 : v14 = v1 := f_equal (fun v20 : list (@X.t) => match v20 as v21 in (list _) return (@X.t) with | nil => v14 | v21 :: v22 => (fun (v21 : @X.t) (v22 : list (@X.t)) => v21) v21 v22 end) v18 in (fun v21 : v14 = v1 => let v22 : v14 = v1 := v21 in eq_ind_r (fun v23 : @X.t => forall (v24 : v15 = v2) (v25 : InA (@X.eq) v10 v15), exists v26 : @X.t, InA (@X.eq) v26 v2 /\ v4 v26 = @true) (fun v23 : v15 = v2 => let v24 : v15 = v2 := v23 in eq_ind_r (fun v25 : list (@X.t) => forall v26 : InA (@X.eq) v10 v25, exists v27 : @X.t, InA (@X.eq) v27 v2 /\ v4 v27 = @true) (fun v25 : InA (@X.eq) v10 v2 => ex_intro (fun v26 : @X.t => InA (@X.eq) v26 v2 /\ v4 v26 = @true) v10 (conj v25 v13)) v24) v22) v20) v19) v17 v16) v14 v15 v16 end in v14 Logic.eq_refl) v11) v9)) end v7) : forall (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4), exists_ v4 (v1 :: v2) = @true <-> (exists v6 : @X.t, InA (@X.eq) v6 (v1 :: v2) /\ v4 v6 = @true)) v0) : forall (v0 : @t) (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), exists_ v1 v0 = @true <-> Exists (fun v3 : @elt => v1 v3 = @true) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.partition_inf1	100	0.568759	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : forall v1 : @elt, @bool) (v2 : @elt) => (fun v3 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v3) (forall v4 : HdRel (@X.lt) v2 v0, HdRel (@X.lt) v2 (fst (partition v1 v0))) (forall v4 : HdRel (@X.lt) v2 v0, HdRel (@X.lt) v2 (fst (partition v1 v0))) (reflexive_proper_proxy (@iff_Reflexive) (forall v4 : HdRel (@X.lt) v2 v0, HdRel (@X.lt) v2 (fst (partition v1 v0))))) (isok_iff v0) ((fun v3 : @t => list_ind (fun v4 : list (@elt) => forall (v5 : forall v5 : @elt, @bool) (v6 : @elt) (v7 : Sorted (@X.lt) v4) (v8 : HdRel (@X.lt) v6 v4), HdRel (@X.lt) v6 (fst (partition v5 v4))) ((fun (v4 : forall v4 : @elt, @bool) (v5 : @elt) (v6 : Sorted (@X.lt) nil) (v7 : HdRel (@X.lt) v5 nil) => let v8 : @bool := v4 v5 in v7) : forall (v4 : forall v4 : @elt, @bool) (v5 : @elt) (v6 : Sorted (@X.lt) nil) (v7 : HdRel (@X.lt) v5 nil), HdRel (@X.lt) v5 (fst (partition v4 nil))) ((fun (v4 : @elt) (v5 : list (@elt)) (v6 : forall (v6 : forall v6 : @elt, @bool) (v7 : @elt) (v8 : Sorted (@X.lt) v5) (v9 : HdRel (@X.lt) v7 v5), HdRel (@X.lt) v7 (fst (partition v6 v5))) (v7 : forall v7 : @elt, @bool) (v8 : @elt) (v9 : Sorted (@X.lt) (v4 :: v5)) (v10 : HdRel (@X.lt) v8 (v4 :: v5)) => let v11 : forall v11 : v4 :: v5 = v4 :: v5, HdRel (@X.lt) v8 (fst match partition v7 v5 as v12 in (_ * _)%type return (@t * @t) with | (v12, v13) => (fun v12 v13 : @t => match v7 v4 as v14 in bool return (@t * @t) with | true => (v4 :: v12, v13) | false => (v12, v4 :: v13) end) v12 v13 end) := match v9 as v12 in (Sorted _ v11) return (forall v13 : v11 = v4 :: v5, HdRel (@X.lt) v8 (fst match partition v7 v5 as v14 in (_ * _)%type return (@t * @t) with | (v14, v15) => (fun v14 v15 : @t => match v7 v4 as v16 in bool return (@t * @t) with | true => (v4 :: v14, v15) | false => (v14, v4 :: v15) end) v14 v15 end)) with | Sorted_nil _ => fun v11 : nil = v4 :: v5 => (fun v12 : nil = v4 :: v5 => let v13 : @False := eq_ind nil (fun v13 : list (@X.t) => match v13 as v14 in (list _) return Prop with | nil => @True | v14 :: v15 => (fun (v14 : @X.t) (v15 : list (@X.t)) => @False) v14 v15 end) (@I) (v4 :: v5) v12 in False_ind (HdRel (@X.lt) v8 (fst match partition v7 v5 as v14 in (_ * _)%type return (@t * @t) with | (v14, v15) => (fun v14 v15 : @t => match v7 v4 as v16 in bool return (@t * @t) with | true => (v4 :: v14, v15) | false => (v14, v4 :: v15) end) v14 v15 end)) v13) v11 | @Sorted_cons _ _ v11 v12 v13 v14 => (fun (v11 : @X.t) (v12 : list (@X.t)) (v13 : Sorted (@X.lt) v12) (v14 : HdRel (@X.lt) v11 v12) (v15 : v11 :: v12 = v4 :: v5) => (fun v16 : v11 :: v12 = v4 :: v5 => let v17 : v12 = v5 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v12 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v11 = v4 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v11 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v11 = v4 => let v20 : v11 = v4 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v12 = v5) (v23 : Sorted (@X.lt) v12) (v24 : HdRel (@X.lt) v21 v12), HdRel (@X.lt) v8 (fst match partition v7 v5 as v25 in (_ * _)%type return (@t * @t) with | (v25, v26) => (fun v25 v26 : @t => match v7 v4 as v27 in bool return (@t * @t) with | true => (v4 :: v25, v26) | false => (v25, v4 :: v26) end) v25 v26 end)) (fun v21 : v12 = v5 => let v22 : v12 = v5 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : Sorted (@X.lt) v23) (v25 : HdRel (@X.lt) v4 v23), HdRel (@X.lt) v8 (fst match partition v7 v5 as v26 in (_ * _)%type return (@t * @t) with | (v26, v27) => (fun v26 v27 : @t => match v7 v4 as v28 in bool return (@t * @t) with | true => (v4 :: v26, v27) | false => (v26, v4 :: v27) end) v26 v27 end)) (fun (v23 : Sorted (@X.lt) v5) (v24 : HdRel (@X.lt) v4 v5) => let v25 : forall v25 : v4 :: v5 = v4 :: v5, HdRel (@X.lt) v8 (fst match partition v7 v5 as v26 in (_ * _)%type return (@t * @t) with | (v26, v27) => (fun v26 v27 : @t => match v7 v4 as v28 in bool return (@t * @t) with | true => (v4 :: v26, v27) | false => (v26, v4 :: v27) end) v26 v27 end) := match v10 as v26 in (HdRel _ _ v25) return (forall v27 : v25 = v4 :: v5, HdRel (@X.lt) v8 (fst match partition v7 v5 as v28 in (_ * _)%type return (@t * @t) with | (v28, v29) => (fun v28 v29 : @t => match v7 v4 as v30 in bool return (@t * @t) with | true => (v4 :: v28, v29) | false => (v28, v4 :: v29) end) v28 v29 end)) with | HdRel_nil _ _ => fun v25 : nil = v4 :: v5 => (fun v26 : nil = v4 :: v5 => let v27 : @False := eq_ind nil (fun v27 : list (@X.t) => match v27 as v28 in (list _) return Prop with | nil => @True | v28 :: v29 => (fun (v28 : @X.t) (v29 : list (@X.t)) => @False) v28 v29 end) (@I) (v4 :: v5) v26 in False_ind (HdRel (@X.lt) v8 (fst match partition v7 v5 as v28 in (_ * _)%type return (@t * @t) with | (v28, v29) => (fun v28 v29 : @t => match v7 v4 as v30 in bool return (@t * @t) with | true => (v4 :: v28, v29) | false => (v28, v4 :: v29) end) v28 v29 end)) v27) v25 | HdRel_cons _ _ v25 v26 v27 => (fun (v25 : @X.t) (v26 : list (@X.t)) (v27 : X.lt v8 v25) (v28 : v25 :: v26 = v4 :: v5) => (fun v29 : v25 :: v26 = v4 :: v5 => let v30 : v26 = v5 := f_equal (fun v30 : list (@X.t) => match v30 as v31 in (list _) return (list (@X.t)) with | nil => v26 | v31 :: v32 => (fun (v31 : @X.t) (v32 : list (@X.t)) => v32) v31 v32 end) v29 in (let v31 : v25 = v4 := f_equal (fun v31 : list (@X.t) => match v31 as v32 in (list _) return (@X.t) with | nil => v25 | v32 :: v33 => (fun (v32 : @X.t) (v33 : list (@X.t)) => v32) v32 v33 end) v29 in (fun v32 : v25 = v4 => let v33 : v25 = v4 := v32 in eq_ind_r (fun v34 : @X.t => forall (v35 : v26 = v5) (v36 : X.lt v8 v34), HdRel (@X.lt) v8 (fst match partition v7 v5 as v37 in (_ * _)%type return (@t * @t) with | (v37, v38) => (fun v37 v38 : @t => match v7 v4 as v39 in bool return (@t * @t) with | true => (v4 :: v37, v38) | false => (v37, v4 :: v38) end) v37 v38 end)) (fun v34 : v26 = v5 => let v35 : v26 = v5 := v34 in eq_ind_r (fun v36 : list (@X.t) => forall v37 : X.lt v8 v4, HdRel (@X.lt) v8 (fst match partition v7 v5 as v38 in (_ * _)%type return (@t * @t) with | (v38, v39) => (fun v38 v39 : @t => match v7 v4 as v40 in bool return (@t * @t) with | true => (v4 :: v38, v39) | false => (v38, v4 :: v39) end) v38 v39 end)) (fun v36 : X.lt v8 v4 => match v7 v4 as v37 in bool return (forall v38 : forall v38 : HdRel (@X.lt) v8 v5, HdRel (@X.lt) v8 (fst (partition v7 v5)), HdRel (@X.lt) v8 (fst match partition v7 v5 as v39 in (_ * _)%type return (@t * @t) with | (v39, v40) => (fun v39 v40 : @t => match v37 as v41 in bool return (@t * @t) with | true => (v4 :: v39, v40) | false => (v39, v4 :: v40) end) v39 v40 end)) with | true => match partition v7 v5 as v37 in (_ * _)%type return (forall v38 : forall v38 : HdRel (@X.lt) v8 v5, HdRel (@X.lt) v8 (fst v37), HdRel (@X.lt) v8 (fst match v37 as v39 in (_ * _)%type return (@t * @t) with | (v39, v40) => (fun v39 v40 : @t => (v4 :: v39, v40)) v39 v40 end)) with | (v37, v38) => ((fun (v37 v38 : @t) (v39 : forall v39 : HdRel (@X.lt) v8 v5, HdRel (@X.lt) v8 v37) => HdRel_cons (@X.lt) v8 v4 v37 v36) : forall (v37 v38 : @t) (v39 : forall v39 : HdRel (@X.lt) v8 v5, HdRel (@X.lt) v8 (fst (v37, v38))), HdRel (@X.lt) v8 (fst (v4 :: v37, v38))) v37 v38 end | false => match partition v7 v5 as v37 in (_ * _)%type return (forall v38 : forall v38 : HdRel (@X.lt) v8 v5, HdRel (@X.lt) v8 (fst v37), HdRel (@X.lt) v8 (fst match v37 as v39 in (_ * _)%type return (@t * @t) with | (v39, v40) => (fun v39 v40 : @t => (v39, v4 :: v40)) v39 v40 end)) with | (v37, v38) => ((fun (v37 v38 : @t) (v39 : forall v39 : HdRel (@X.lt) v8 v5, HdRel (@X.lt) v8 v37) => v39 (Inf_lt v36 v24)) : forall (v37 v38 : @t) (v39 : forall v39 : HdRel (@X.lt) v8 v5, HdRel (@X.lt) v8 (fst (v37, v38))), HdRel (@X.lt) v8 (fst (v37, v4 :: v38))) v37 v38 end end (v6 v7 v8 v23)) v35) v33) v31) v30) v28 v27) v25 v26 v27 end in v25 Logic.eq_refl) v22) v20) v18) v17) v15 v13 v14) v11 v12 v13 v14 end in v11 Logic.eq_refl) : forall (v4 : @elt) (v5 : list (@elt)) (v6 : forall (v6 : forall v6 : @elt, @bool) (v7 : @elt) (v8 : Sorted (@X.lt) v5) (v9 : HdRel (@X.lt) v7 v5), HdRel (@X.lt) v7 (fst (partition v6 v5))) (v7 : forall v7 : @elt, @bool) (v8 : @elt) (v9 : Sorted (@X.lt) (v4 :: v5)) (v10 : HdRel (@X.lt) v8 (v4 :: v5)), HdRel (@X.lt) v8 (fst (partition v7 (v4 :: v5)))) v3) v0 v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.partition_inf2	100	0.785872	1	1
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.partition_ok1	100	0.573322	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @t) (v1 : forall v1 : @elt, @bool) => (fun v2 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v2) (Ok (fst (partition v1 v0))) (Ok (fst (partition v1 v0))) (reflexive_proper_proxy (@iff_Reflexive) (Ok (fst (partition v1 v0))))) (isok_iff v0) ((fun v2 : Sorted (@X.lt) (fst (partition v1 v0)) <-> Ok (fst (partition v1 v0)) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v0)) (Ok (fst (partition v1 v0))) (Sorted (@X.lt) (fst (partition v1 v0))) (symmetry v2)) (isok_iff (fst (partition v1 v0))) ((fun v2 : @t => list_ind (fun v3 : list (@elt) => forall (v4 : forall v4 : @elt, @bool) (v5 : Sorted (@X.lt) v3), Sorted (@X.lt) (fst (partition v4 v3))) ((fun (v3 : forall v3 : @elt, @bool) (v4 : Sorted (@X.lt) nil) => v4) : forall (v3 : forall v3 : @elt, @bool) (v4 : Sorted (@X.lt) nil), Sorted (@X.lt) (fst (partition v3 nil))) ((fun (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : forall v5 : @elt, @bool) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (fst (partition v5 v4))) (v6 : forall v6 : @elt, @bool) (v7 : Sorted (@X.lt) (v3 :: v4)) => let v8 : forall v8 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (fst match partition v6 v4 as v9 in (_ * _)%type return (@t * @t) with | (v9, v10) => (fun v9 v10 : @t => match v6 v3 as v11 in bool return (@t * @t) with | true => (v3 :: v9, v10) | false => (v9, v3 :: v10) end) v9 v10 end) := match v7 as v9 in (Sorted _ v8) return (forall v10 : v8 = v3 :: v4, Sorted (@X.lt) (fst match partition v6 v4 as v11 in (_ * _)%type return (@t * @t) with | (v11, v12) => (fun v11 v12 : @t => match v6 v3 as v13 in bool return (@t * @t) with | true => (v3 :: v11, v12) | false => (v11, v3 :: v12) end) v11 v12 end)) with | Sorted_nil _ => fun v8 : nil = v3 :: v4 => (fun v9 : nil = v3 :: v4 => let v10 : @False := eq_ind nil (fun v10 : list (@X.t) => match v10 as v11 in (list _) return Prop with | nil => @True | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => @False) v11 v12 end) (@I) (v3 :: v4) v9 in False_ind (Sorted (@X.lt) (fst match partition v6 v4 as v11 in (_ * _)%type return (@t * @t) with | (v11, v12) => (fun v11 v12 : @t => match v6 v3 as v13 in bool return (@t * @t) with | true => (v3 :: v11, v12) | false => (v11, v3 :: v12) end) v11 v12 end)) v10) v8 | @Sorted_cons _ _ v8 v9 v10 v11 => (fun (v8 : @X.t) (v9 : list (@X.t)) (v10 : Sorted (@X.lt) v9) (v11 : HdRel (@X.lt) v8 v9) (v12 : v8 :: v9 = v3 :: v4) => (fun v13 : v8 :: v9 = v3 :: v4 => let v14 : v9 = v4 := f_equal (fun v14 : list (@X.t) => match v14 as v15 in (list _) return (list (@X.t)) with | nil => v9 | v15 :: v16 => (fun (v15 : @X.t) (v16 : list (@X.t)) => v16) v15 v16 end) v13 in (let v15 : v8 = v3 := f_equal (fun v15 : list (@X.t) => match v15 as v16 in (list _) return (@X.t) with | nil => v8 | v16 :: v17 => (fun (v16 : @X.t) (v17 : list (@X.t)) => v16) v16 v17 end) v13 in (fun v16 : v8 = v3 => let v17 : v8 = v3 := v16 in eq_ind_r (fun v18 : @X.t => forall (v19 : v9 = v4) (v20 : Sorted (@X.lt) v9) (v21 : HdRel (@X.lt) v18 v9), Sorted (@X.lt) (fst match partition v6 v4 as v22 in (_ * _)%type return (@t * @t) with | (v22, v23) => (fun v22 v23 : @t => match v6 v3 as v24 in bool return (@t * @t) with | true => (v3 :: v22, v23) | false => (v22, v3 :: v23) end) v22 v23 end)) (fun v18 : v9 = v4 => let v19 : v9 = v4 := v18 in eq_ind_r (fun v20 : list (@X.t) => forall (v21 : Sorted (@X.lt) v20) (v22 : HdRel (@X.lt) v3 v20), Sorted (@X.lt) (fst match partition v6 v4 as v23 in (_ * _)%type return (@t * @t) with | (v23, v24) => (fun v23 v24 : @t => match v6 v3 as v25 in bool return (@t * @t) with | true => (v3 :: v23, v24) | false => (v23, v3 :: v24) end) v23 v24 end)) (fun (v20 : Sorted (@X.lt) v4) (v21 : HdRel (@X.lt) v3 v4) => match v6 v3 as v22 in bool return (forall (v23 : forall (v23 : Ok v4) (v24 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (fst (partition v6 v4))) (v24 : Sorted (@X.lt) (fst (partition v6 v4))), Sorted (@X.lt) (fst match partition v6 v4 as v25 in (_ * _)%type return (@t * @t) with | (v25, v26) => (fun v25 v26 : @t => match v22 as v27 in bool return (@t * @t) with | true => (v3 :: v25, v26) | false => (v25, v3 :: v26) end) v25 v26 end)) with | true => match partition v6 v4 as v22 in (_ * _)%type return (forall (v23 : forall (v23 : Ok v4) (v24 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (fst v22)) (v24 : Sorted (@X.lt) (fst v22)), Sorted (@X.lt) (fst match v22 as v25 in (_ * _)%type return (@t * @t) with | (v25, v26) => (fun v25 v26 : @t => (v3 :: v25, v26)) v25 v26 end)) with | (v22, v23) => ((fun (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 v22) (v25 : Sorted (@X.lt) v22) => Sorted_cons v25 (v24 ((fun v26 : Sorted (@X.lt) v4 <-> Ok v4 => iff_flip_impl_subrelation (Ok v4) (Sorted (@X.lt) v4) (symmetry v26)) (isok_iff v4) v20) v21)) : forall (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (fst (v22, v23))) (v25 : Sorted (@X.lt) (fst (v22, v23))), Sorted (@X.lt) (fst (v3 :: v22, v23))) v22 v23 end | false => match partition v6 v4 as v22 in (_ * _)%type return (forall (v23 : forall (v23 : Ok v4) (v24 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (fst v22)) (v24 : Sorted (@X.lt) (fst v22)), Sorted (@X.lt) (fst match v22 as v25 in (_ * _)%type return (@t * @t) with | (v25, v26) => (fun v25 v26 : @t => (v25, v3 :: v26)) v25 v26 end)) with | (v22, v23) => ((fun (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 v22) (v25 : Sorted (@X.lt) v22) => v25) : forall (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (fst (v22, v23))) (v25 : Sorted (@X.lt) (fst (v22, v23))), Sorted (@X.lt) (fst (v22, v3 :: v23))) v22 v23 end end (partition_inf1 v6 (x:=v3)) (v5 v6 v20)) v19) v17) v15) v14) v12 v10 v11) v8 v9 v10 v11 end in v8 Logic.eq_refl) : forall (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : forall v5 : @elt, @bool) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (fst (partition v5 v4))) (v6 : forall v6 : @elt, @bool) (v7 : Sorted (@X.lt) (v3 :: v4)), Sorted (@X.lt) (fst (partition v6 (v3 :: v4)))) v2) v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.partition_ok2	100	0.469774	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @t) (v1 : forall v1 : @elt, @bool) => (fun v2 : Sorted (@X.lt) v0 <-> Ok v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v0) (Sorted (@X.lt) v0) (symmetry v2) (Ok (snd (partition v1 v0))) (Ok (snd (partition v1 v0))) (reflexive_proper_proxy (@iff_Reflexive) (Ok (snd (partition v1 v0))))) (isok_iff v0) ((fun v2 : Sorted (@X.lt) (snd (partition v1 v0)) <-> Ok (snd (partition v1 v0)) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v0)) (Ok (snd (partition v1 v0))) (Sorted (@X.lt) (snd (partition v1 v0))) (symmetry v2)) (isok_iff (snd (partition v1 v0))) ((fun v2 : @t => list_ind (fun v3 : list (@elt) => forall (v4 : forall v4 : @elt, @bool) (v5 : Sorted (@X.lt) v3), Sorted (@X.lt) (snd (partition v4 v3))) ((fun (v3 : forall v3 : @elt, @bool) (v4 : Sorted (@X.lt) nil) => v4) : forall (v3 : forall v3 : @elt, @bool) (v4 : Sorted (@X.lt) nil), Sorted (@X.lt) (snd (partition v3 nil))) ((fun (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : forall v5 : @elt, @bool) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (snd (partition v5 v4))) (v6 : forall v6 : @elt, @bool) (v7 : Sorted (@X.lt) (v3 :: v4)) => let v8 : forall v8 : v3 :: v4 = v3 :: v4, Sorted (@X.lt) (snd match partition v6 v4 as v9 in (_ * _)%type return (@t * @t) with | (v9, v10) => (fun v9 v10 : @t => match v6 v3 as v11 in bool return (@t * @t) with | true => (v3 :: v9, v10) | false => (v9, v3 :: v10) end) v9 v10 end) := match v7 as v9 in (Sorted _ v8) return (forall v10 : v8 = v3 :: v4, Sorted (@X.lt) (snd match partition v6 v4 as v11 in (_ * _)%type return (@t * @t) with | (v11, v12) => (fun v11 v12 : @t => match v6 v3 as v13 in bool return (@t * @t) with | true => (v3 :: v11, v12) | false => (v11, v3 :: v12) end) v11 v12 end)) with | Sorted_nil _ => fun v8 : nil = v3 :: v4 => (fun v9 : nil = v3 :: v4 => let v10 : @False := eq_ind nil (fun v10 : list (@X.t) => match v10 as v11 in (list _) return Prop with | nil => @True | v11 :: v12 => (fun (v11 : @X.t) (v12 : list (@X.t)) => @False) v11 v12 end) (@I) (v3 :: v4) v9 in False_ind (Sorted (@X.lt) (snd match partition v6 v4 as v11 in (_ * _)%type return (@t * @t) with | (v11, v12) => (fun v11 v12 : @t => match v6 v3 as v13 in bool return (@t * @t) with | true => (v3 :: v11, v12) | false => (v11, v3 :: v12) end) v11 v12 end)) v10) v8 | @Sorted_cons _ _ v8 v9 v10 v11 => (fun (v8 : @X.t) (v9 : list (@X.t)) (v10 : Sorted (@X.lt) v9) (v11 : HdRel (@X.lt) v8 v9) (v12 : v8 :: v9 = v3 :: v4) => (fun v13 : v8 :: v9 = v3 :: v4 => let v14 : v9 = v4 := f_equal (fun v14 : list (@X.t) => match v14 as v15 in (list _) return (list (@X.t)) with | nil => v9 | v15 :: v16 => (fun (v15 : @X.t) (v16 : list (@X.t)) => v16) v15 v16 end) v13 in (let v15 : v8 = v3 := f_equal (fun v15 : list (@X.t) => match v15 as v16 in (list _) return (@X.t) with | nil => v8 | v16 :: v17 => (fun (v16 : @X.t) (v17 : list (@X.t)) => v16) v16 v17 end) v13 in (fun v16 : v8 = v3 => let v17 : v8 = v3 := v16 in eq_ind_r (fun v18 : @X.t => forall (v19 : v9 = v4) (v20 : Sorted (@X.lt) v9) (v21 : HdRel (@X.lt) v18 v9), Sorted (@X.lt) (snd match partition v6 v4 as v22 in (_ * _)%type return (@t * @t) with | (v22, v23) => (fun v22 v23 : @t => match v6 v3 as v24 in bool return (@t * @t) with | true => (v3 :: v22, v23) | false => (v22, v3 :: v23) end) v22 v23 end)) (fun v18 : v9 = v4 => let v19 : v9 = v4 := v18 in eq_ind_r (fun v20 : list (@X.t) => forall (v21 : Sorted (@X.lt) v20) (v22 : HdRel (@X.lt) v3 v20), Sorted (@X.lt) (snd match partition v6 v4 as v23 in (_ * _)%type return (@t * @t) with | (v23, v24) => (fun v23 v24 : @t => match v6 v3 as v25 in bool return (@t * @t) with | true => (v3 :: v23, v24) | false => (v23, v3 :: v24) end) v23 v24 end)) (fun (v20 : Sorted (@X.lt) v4) (v21 : HdRel (@X.lt) v3 v4) => match v6 v3 as v22 in bool return (forall (v23 : forall (v23 : Ok v4) (v24 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (snd (partition v6 v4))) (v24 : Sorted (@X.lt) (snd (partition v6 v4))), Sorted (@X.lt) (snd match partition v6 v4 as v25 in (_ * _)%type return (@t * @t) with | (v25, v26) => (fun v25 v26 : @t => match v22 as v27 in bool return (@t * @t) with | true => (v3 :: v25, v26) | false => (v25, v3 :: v26) end) v25 v26 end)) with | true => match partition v6 v4 as v22 in (_ * _)%type return (forall (v23 : forall (v23 : Ok v4) (v24 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (snd v22)) (v24 : Sorted (@X.lt) (snd v22)), Sorted (@X.lt) (snd match v22 as v25 in (_ * _)%type return (@t * @t) with | (v25, v26) => (fun v25 v26 : @t => (v3 :: v25, v26)) v25 v26 end)) with | (v22, v23) => ((fun (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 v23) (v25 : Sorted (@X.lt) v23) => v25) : forall (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (snd (v22, v23))) (v25 : Sorted (@X.lt) (snd (v22, v23))), Sorted (@X.lt) (snd (v3 :: v22, v23))) v22 v23 end | false => match partition v6 v4 as v22 in (_ * _)%type return (forall (v23 : forall (v23 : Ok v4) (v24 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (snd v22)) (v24 : Sorted (@X.lt) (snd v22)), Sorted (@X.lt) (snd match v22 as v25 in (_ * _)%type return (@t * @t) with | (v25, v26) => (fun v25 v26 : @t => (v25, v3 :: v26)) v25 v26 end)) with | (v22, v23) => ((fun (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 v23) (v25 : Sorted (@X.lt) v23) => Sorted_cons v25 (v24 ((fun v26 : Sorted (@X.lt) v4 <-> Ok v4 => iff_flip_impl_subrelation (Ok v4) (Sorted (@X.lt) v4) (symmetry v26)) (isok_iff v4) v20) v21)) : forall (v22 v23 : @t) (v24 : forall (v24 : Ok v4) (v25 : HdRel (@X.lt) v3 v4), HdRel (@X.lt) v3 (snd (v22, v23))) (v25 : Sorted (@X.lt) (snd (v22, v23))), Sorted (@X.lt) (snd (v22, v3 :: v23))) v22 v23 end end (partition_inf2 v6 (x:=v3)) (v5 v6 v20)) v19) v17) v15) v14) v12 v10 v11) v8 v9 v10 v11 end in v8 Logic.eq_refl) : forall (v3 : @elt) (v4 : list (@elt)) (v5 : forall (v5 : forall v5 : @elt, @bool) (v6 : Sorted (@X.lt) v4), Sorted (@X.lt) (snd (partition v5 v4))) (v6 : forall v6 : @elt, @bool) (v7 : Sorted (@X.lt) (v3 :: v4)), Sorted (@X.lt) (snd (partition v6 (v3 :: v4)))) v2) v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.partition_spec1	100	1.000521	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 : forall v2 : @elt, @bool) (v3 : Proper (@X.eq ==> eq) v2), Equal (fst (partition v2 v1)) (filter v2 v1)) (((fun (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1) (v3 : @elt) => conj (fun v4 : InA (@X.eq) v3 nil => v4) (fun v4 : InA (@X.eq) v3 nil => v4)) : forall (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), Equal nil nil) : forall (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), Equal (fst (partition v1 nil)) (filter v1 nil)) (((fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3) (v5 : @elt), InA (@X.eq) v5 (fst (partition v3 v2)) <-> InA (@X.eq) v5 (filter v3 v2)) (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4) => (let v6 : @t * @t := partition v4 v2 in match v6 as v7 in (_ * _)%type return (forall (v8 : forall v8 : @elt, InA (@X.eq) v8 (fst v7) <-> InA (@X.eq) v8 (filter v4 v2)) (v9 : @elt), InA (@X.eq) v9 (fst match v7 as v10 in (_ * _)%type return (@t * @t) with | (v10, v11) => (fun v10 v11 : @t => match v4 v1 as v12 in bool return (@t * @t) with | true => (v1 :: v10, v11) | false => (v10, v1 :: v11) end) v10 v11 end) <-> InA (@X.eq) v9 match v4 v1 as v10 in bool return (@t) with | true => v1 :: filter v4 v2 | false => filter v4 v2 end) with | (v7, v8) => (fun v7 v8 : @t => (fun (v9 : forall v9 : @elt, InA (@X.eq) v9 v7 <-> InA (@X.eq) v9 (filter v4 v2)) (v10 : @elt) => match v4 v1 as v11 in bool return (InA (@X.eq) v10 (fst match v11 as v12 in bool return (@t * @t) with | true => (v1 :: v7, v8) | false => (v7, v1 :: v8) end) <-> InA (@X.eq) v10 match v11 as v12 in bool return (@t) with | true => v1 :: filter v4 v2 | false => filter v4 v2 end) with | true => conj (fun v11 : InA (@X.eq) v10 (v1 :: v7) => let v12 : forall v12 : v1 :: v7 = v1 :: v7, InA (@X.eq) v10 (v1 :: filter v4 v2) := match v11 as v13 in (InA _ _ v12) return (forall v14 : v12 = v1 :: v7, InA (@X.eq) v10 (v1 :: filter v4 v2)) with | @InA_cons_hd _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : X.eq v10 v12) (v15 : v12 :: v13 = v1 :: v7) => (fun v16 : v12 :: v13 = v1 :: v7 => let v17 : v13 = v7 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = v7) (v23 : X.eq v10 v21), InA (@X.eq) v10 (v1 :: filter v4 v2)) (fun v21 : v13 = v7 => let v22 : v13 = v7 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : X.eq v10 v1, InA (@X.eq) v10 (v1 :: filter v4 v2)) (fun v23 : X.eq v10 v1 => InA_cons_hd (eqA:=@X.eq) (x:=v10) (y:=v1) (filter v4 v2) v23) v22) v20) v18) v17) v15 v14) v12 v13 v14 | @InA_cons_tl _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : InA (@X.eq) v10 v13) (v15 : v12 :: v13 = v1 :: v7) => (fun v16 : v12 :: v13 = v1 :: v7 => let v17 : v13 = v7 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = v7) (v23 : InA (@X.eq) v10 v13), InA (@X.eq) v10 (v1 :: filter v4 v2)) (fun v21 : v13 = v7 => let v22 : v13 = v7 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : InA (@X.eq) v10 v23, InA (@X.eq) v10 (v1 :: filter v4 v2)) (fun v23 : InA (@X.eq) v10 v7 => InA_cons_tl v1 ((fun v24 : InA (@X.eq) v10 v7 <-> InA (@X.eq) v10 (filter v4 v2) => iff_flip_impl_subrelation (InA (@X.eq) v10 (filter v4 v2)) (InA (@X.eq) v10 v7) (symmetry v24)) (v9 v10) v23)) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 Logic.eq_refl) (fun v11 : InA (@X.eq) v10 (v1 :: filter v4 v2) => let v12 : forall v12 : v1 :: filter v4 v2 = v1 :: filter v4 v2, InA (@X.eq) v10 (v1 :: v7) := match v11 as v13 in (InA _ _ v12) return (forall v14 : v12 = v1 :: filter v4 v2, InA (@X.eq) v10 (v1 :: v7)) with | @InA_cons_hd _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : X.eq v10 v12) (v15 : v12 :: v13 = v1 :: filter v4 v2) => (fun v16 : v12 :: v13 = v1 :: filter v4 v2 => let v17 : v13 = filter v4 v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = filter v4 v2) (v23 : X.eq v10 v21), InA (@X.eq) v10 (v1 :: v7)) (fun v21 : v13 = filter v4 v2 => let v22 : v13 = filter v4 v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : X.eq v10 v1, InA (@X.eq) v10 (v1 :: v7)) (fun v23 : X.eq v10 v1 => InA_cons_hd (eqA:=@X.eq) (x:=v10) (y:=v1) v7 v23) v22) v20) v18) v17) v15 v14) v12 v13 v14 | @InA_cons_tl _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : InA (@X.eq) v10 v13) (v15 : v12 :: v13 = v1 :: filter v4 v2) => (fun v16 : v12 :: v13 = v1 :: filter v4 v2 => let v17 : v13 = filter v4 v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = filter v4 v2) (v23 : InA (@X.eq) v10 v13), InA (@X.eq) v10 (v1 :: v7)) (fun v21 : v13 = filter v4 v2 => let v22 : v13 = filter v4 v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : InA (@X.eq) v10 v23, InA (@X.eq) v10 (v1 :: v7)) (fun v23 : InA (@X.eq) v10 (filter v4 v2) => InA_cons_tl v1 ((fun v24 : InA (@X.eq) v10 v7 <-> InA (@X.eq) v10 (filter v4 v2) => iff_flip_impl_subrelation (InA (@X.eq) v10 v7) (InA (@X.eq) v10 (filter v4 v2)) v24) (v9 v10) v23)) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 Logic.eq_refl) : InA (@X.eq) v10 (fst (v1 :: v7, v8)) <-> InA (@X.eq) v10 (v1 :: filter v4 v2) | false => v9 v10 : InA (@X.eq) v10 (fst (v7, v1 :: v8)) <-> InA (@X.eq) v10 (filter v4 v2) end) : forall (v9 : forall v9 : @elt, InA (@X.eq) v9 (fst (v7, v8)) <-> InA (@X.eq) v9 (filter v4 v2)) (v10 : @elt), InA (@X.eq) v10 (fst match v4 v1 as v11 in bool return (@t * @t) with | true => (v1 :: v7, v8) | false => (v7, v1 :: v8) end) <-> InA (@X.eq) v10 match v4 v1 as v11 in bool return (@t) with | true => v1 :: filter v4 v2 | false => filter v4 v2 end) v7 v8 end) (v3 v4 v5)) : forall (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3), Equal (fst (partition v3 v2)) (filter v3 v2)) (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4), Equal (fst match partition v4 v2 as v6 in (_ * _)%type return (@t * @t) with | (v6, v7) => (fun v6 v7 : @t => match v4 v1 as v8 in bool return (@t * @t) with | true => (v1 :: v6, v7) | false => (v6, v1 :: v7) end) v6 v7 end) match v4 v1 as v6 in bool return (@t) with | true => v1 :: filter v4 v2 | false => filter v4 v2 end) : forall (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3), Equal (fst (partition v3 v2)) (filter v3 v2)) (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4), Equal (fst (partition v4 (v1 :: v2))) (filter v4 (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.ForNotations.partition_spec2	100	0.645777	1	1	0	synth with cache (only 1: refine (fun v0 : @t => list_ind (fun v1 : list (@elt) => forall (v2 : forall v2 : @elt, @bool) (v3 : Proper (@X.eq ==> eq) v2), Equal (snd (partition v2 v1)) (filter (fun v4 : @elt => negb (v2 v4)) v1)) (((fun (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1) (v3 : @elt) => conj (fun v4 : InA (@X.eq) v3 nil => v4) (fun v4 : InA (@X.eq) v3 nil => v4)) : forall (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), Equal nil nil) : forall (v1 : forall v1 : @elt, @bool) (v2 : Proper (@X.eq ==> eq) v1), Equal (snd (partition v1 nil)) (filter (fun v3 : @elt => negb (v1 v3)) nil)) (((fun (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3) (v5 : @elt), InA (@X.eq) v5 (snd (partition v3 v2)) <-> InA (@X.eq) v5 (filter (fun v6 : @elt => negb (v3 v6)) v2)) (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4) => (let v6 : @t * @t := partition v4 v2 in match v6 as v7 in (_ * _)%type return (forall (v8 : forall v8 : @elt, InA (@X.eq) v8 (snd v7) <-> InA (@X.eq) v8 (filter (fun v9 : @elt => negb (v4 v9)) v2)) (v9 : @elt), InA (@X.eq) v9 (snd match v7 as v10 in (_ * _)%type return (@t * @t) with | (v10, v11) => (fun v10 v11 : @t => match v4 v1 as v12 in bool return (@t * @t) with | true => (v1 :: v10, v11) | false => (v10, v1 :: v11) end) v10 v11 end) <-> InA (@X.eq) v9 match negb (v4 v1) as v10 in bool return (@t) with | true => v1 :: filter (fun v10 : @elt => negb (v4 v10)) v2 | false => filter (fun v10 : @elt => negb (v4 v10)) v2 end) with | (v7, v8) => (fun v7 v8 : @t => (fun (v9 : forall v9 : @elt, InA (@X.eq) v9 v8 <-> InA (@X.eq) v9 (filter (fun v10 : @elt => negb (v4 v10)) v2)) (v10 : @elt) => match v4 v1 as v11 in bool return (InA (@X.eq) v10 (snd match v11 as v12 in bool return (@t * @t) with | true => (v1 :: v7, v8) | false => (v7, v1 :: v8) end) <-> InA (@X.eq) v10 match negb v11 as v12 in bool return (@t) with | true => v1 :: filter (fun v12 : @elt => negb (v4 v12)) v2 | false => filter (fun v12 : @elt => negb (v4 v12)) v2 end) with | true => v9 v10 : InA (@X.eq) v10 (snd (v1 :: v7, v8)) <-> InA (@X.eq) v10 match negb (@true) as v11 in bool return (@t) with | true => v1 :: filter (fun v11 : @elt => negb (v4 v11)) v2 | false => filter (fun v11 : @elt => negb (v4 v11)) v2 end | false => conj (fun v11 : InA (@X.eq) v10 (v1 :: v8) => let v12 : forall v12 : v1 :: v8 = v1 :: v8, InA (@X.eq) v10 (v1 :: filter (fun v13 : @elt => negb (v4 v13)) v2) := match v11 as v13 in (InA _ _ v12) return (forall v14 : v12 = v1 :: v8, InA (@X.eq) v10 (v1 :: filter (fun v15 : @elt => negb (v4 v15)) v2)) with | @InA_cons_hd _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : X.eq v10 v12) (v15 : v12 :: v13 = v1 :: v8) => (fun v16 : v12 :: v13 = v1 :: v8 => let v17 : v13 = v8 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = v8) (v23 : X.eq v10 v21), InA (@X.eq) v10 (v1 :: filter (fun v24 : @elt => negb (v4 v24)) v2)) (fun v21 : v13 = v8 => let v22 : v13 = v8 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : X.eq v10 v1, InA (@X.eq) v10 (v1 :: filter (fun v25 : @elt => negb (v4 v25)) v2)) (fun v23 : X.eq v10 v1 => InA_cons_hd (eqA:=@X.eq) (x:=v10) (y:=v1) (filter (fun v24 : @elt => negb (v4 v24)) v2) v23) v22) v20) v18) v17) v15 v14) v12 v13 v14 | @InA_cons_tl _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : InA (@X.eq) v10 v13) (v15 : v12 :: v13 = v1 :: v8) => (fun v16 : v12 :: v13 = v1 :: v8 => let v17 : v13 = v8 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = v8) (v23 : InA (@X.eq) v10 v13), InA (@X.eq) v10 (v1 :: filter (fun v24 : @elt => negb (v4 v24)) v2)) (fun v21 : v13 = v8 => let v22 : v13 = v8 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : InA (@X.eq) v10 v23, InA (@X.eq) v10 (v1 :: filter (fun v25 : @elt => negb (v4 v25)) v2)) (fun v23 : InA (@X.eq) v10 v8 => InA_cons_tl v1 ((fun v24 : InA (@X.eq) v10 v8 <-> InA (@X.eq) v10 (filter (fun v24 : @elt => negb (v4 v24)) v2) => iff_flip_impl_subrelation (InA (@X.eq) v10 (filter (fun v25 : @elt => negb (v4 v25)) v2)) (InA (@X.eq) v10 v8) (symmetry v24)) (v9 v10) v23)) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 Logic.eq_refl) (fun v11 : InA (@X.eq) v10 (v1 :: filter (fun v11 : @elt => negb (v4 v11)) v2) => let v12 : forall v12 : v1 :: filter (fun v12 : @elt => negb (v4 v12)) v2 = v1 :: filter (fun v12 : @elt => negb (v4 v12)) v2, InA (@X.eq) v10 (v1 :: v8) := match v11 as v13 in (InA _ _ v12) return (forall v14 : v12 = v1 :: filter (fun v14 : @elt => negb (v4 v14)) v2, InA (@X.eq) v10 (v1 :: v8)) with | @InA_cons_hd _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : X.eq v10 v12) (v15 : v12 :: v13 = v1 :: filter (fun v15 : @elt => negb (v4 v15)) v2) => (fun v16 : v12 :: v13 = v1 :: filter (fun v16 : @elt => negb (v4 v16)) v2 => let v17 : v13 = filter (fun v17 : @elt => negb (v4 v17)) v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = filter (fun v22 : @elt => negb (v4 v22)) v2) (v23 : X.eq v10 v21), InA (@X.eq) v10 (v1 :: v8)) (fun v21 : v13 = filter (fun v21 : @elt => negb (v4 v21)) v2 => let v22 : v13 = filter (fun v22 : @elt => negb (v4 v22)) v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : X.eq v10 v1, InA (@X.eq) v10 (v1 :: v8)) (fun v23 : X.eq v10 v1 => InA_cons_hd (eqA:=@X.eq) (x:=v10) (y:=v1) v8 v23) v22) v20) v18) v17) v15 v14) v12 v13 v14 | @InA_cons_tl _ _ _ v12 v13 v14 => (fun (v12 : @X.t) (v13 : list (@X.t)) (v14 : InA (@X.eq) v10 v13) (v15 : v12 :: v13 = v1 :: filter (fun v15 : @elt => negb (v4 v15)) v2) => (fun v16 : v12 :: v13 = v1 :: filter (fun v16 : @elt => negb (v4 v16)) v2 => let v17 : v13 = filter (fun v17 : @elt => negb (v4 v17)) v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v13 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v12 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v12 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v12 = v1 => let v20 : v12 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v13 = filter (fun v22 : @elt => negb (v4 v22)) v2) (v23 : InA (@X.eq) v10 v13), InA (@X.eq) v10 (v1 :: v8)) (fun v21 : v13 = filter (fun v21 : @elt => negb (v4 v21)) v2 => let v22 : v13 = filter (fun v22 : @elt => negb (v4 v22)) v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall v24 : InA (@X.eq) v10 v23, InA (@X.eq) v10 (v1 :: v8)) (fun v23 : InA (@X.eq) v10 (filter (fun v23 : @elt => negb (v4 v23)) v2) => InA_cons_tl v1 ((fun v24 : InA (@X.eq) v10 v8 <-> InA (@X.eq) v10 (filter (fun v24 : @elt => negb (v4 v24)) v2) => iff_flip_impl_subrelation (InA (@X.eq) v10 v8) (InA (@X.eq) v10 (filter (fun v25 : @elt => negb (v4 v25)) v2)) v24) (v9 v10) v23)) v22) v20) v18) v17) v15 v14) v12 v13 v14 end in v12 Logic.eq_refl) : InA (@X.eq) v10 (snd (v7, v1 :: v8)) <-> InA (@X.eq) v10 match negb (@false) as v11 in bool return (@t) with | true => v1 :: filter (fun v11 : @elt => negb (v4 v11)) v2 | false => filter (fun v11 : @elt => negb (v4 v11)) v2 end end) : forall (v9 : forall v9 : @elt, InA (@X.eq) v9 (snd (v7, v8)) <-> InA (@X.eq) v9 (filter (fun v10 : @elt => negb (v4 v10)) v2)) (v10 : @elt), InA (@X.eq) v10 (snd match v4 v1 as v11 in bool return (@t * @t) with | true => (v1 :: v7, v8) | false => (v7, v1 :: v8) end) <-> InA (@X.eq) v10 match negb (v4 v1) as v11 in bool return (@t) with | true => v1 :: filter (fun v11 : @elt => negb (v4 v11)) v2 | false => filter (fun v11 : @elt => negb (v4 v11)) v2 end) v7 v8 end) (v3 v4 v5)) : forall (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3), Equal (snd (partition v3 v2)) (filter (fun v5 : @elt => negb (v3 v5)) v2)) (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4), Equal (snd match partition v4 v2 as v6 in (_ * _)%type return (@t * @t) with | (v6, v7) => (fun v6 v7 : @t => match v4 v1 as v8 in bool return (@t * @t) with | true => (v1 :: v6, v7) | false => (v6, v1 :: v7) end) v6 v7 end) match negb (v4 v1) as v6 in bool return (@t) with | true => v1 :: filter (fun v6 : @elt => negb (v4 v6)) v2 | false => filter (fun v6 : @elt => negb (v4 v6)) v2 end) : forall (v1 : @elt) (v2 : list (@elt)) (v3 : forall (v3 : forall v3 : @elt, @bool) (v4 : Proper (@X.eq ==> eq) v3), Equal (snd (partition v3 v2)) (filter (fun v5 : @elt => negb (v3 v5)) v2)) (v4 : forall v4 : @elt, @bool) (v5 : Proper (@X.eq ==> eq) v4), Equal (snd (partition v4 (v1 :: v2))) (filter (fun v6 : @elt => negb (v4 v6)) (v1 :: v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.In_compat	100	0.116630	1	1	0	synth with cache (only 1: refine (((((fun (v0 v1 : @X.t) (v2 : X.eq v0 v1) (v3 v4 : list (@X.t)) (v5 : v3 = v4) => (fun v6 : X.eq v0 v1 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (forall v7 : In v0 v3, In v1 v4) (forall v7 : In v1 v3, In v1 v4) (Morphisms_Prop.iff_iff_iff_impl_morphism (In v0 v3) (In v1 v3) (InA_compat (@X.eq_equiv) (x:=v0) (y:=v1) v6 (x0:=v3) (y0:=v3) (reflexive_proper_proxy Equivalence_Reflexive v3)) (In v1 v4) (In v1 v4) (reflexive_proper_proxy (@iff_Reflexive) (In v1 v4))) (forall v7 : In v1 v4, In v0 v3) (forall v7 : In v1 v4, In v1 v3) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v1 v4)) (In v0 v3) (In v1 v3) (InA_compat (@X.eq_equiv) (x:=v0) (y:=v1) v6 (x0:=v3) (y0:=v3) (reflexive_proper_proxy Equivalence_Reflexive v3)))) v2 (eq_ind_r (fun v6 : list (@X.t) => (forall v7 : In v1 v6, In v1 v4) /\ (forall v7 : In v1 v4, In v1 v6)) (conj (fun v6 : In v1 v4 => v6) (fun v6 : In v1 v4 => v6)) v5)) : forall (v0 v1 : @X.t) (v2 : X.eq v0 v1) (v3 v4 : list (@X.t)) (v5 : v3 = v4), In v0 v3 <-> In v1 v4) : forall (v0 v1 : @X.t) (v2 : X.eq v0 v1), (eq ==> @iff)%signature (In v0) (In v1)) : (@X.eq ==> eq ==> @iff)%signature (@In) (@In)) : Proper (@X.eq ==> eq ==> @iff) (@In))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.lt_strorder	100	0.491630	1	1	0	synth with cache (only 1: refine {| StrictOrder_Irreflexive := (fun v0 : list (@X.t) => (fun v1 : lt v0 v0 => match v1 as v2 in (ex _) return (@False) with | ex_intro _ v2 v3 => (fun (v2 : @t) (v3 : exists v3 : @t, Ok v2 /\ Ok v3 /\ eq v0 v2 /\ eq v0 v3 /\ L.lt v2 v3) => match v3 as v4 in (ex _) return (@False) with | ex_intro _ v4 v5 => (fun (v4 : @t) (v5 : Ok v2 /\ Ok v4 /\ eq v0 v2 /\ eq v0 v4 /\ L.lt v2 v4) => match v5 as v6 in (_ /\ _) return (@False) with | conj v6 v7 => (fun (v6 : Ok v2) (v7 : Ok v4 /\ eq v0 v2 /\ eq v0 v4 /\ L.lt v2 v4) => match v7 as v8 in (_ /\ _) return (@False) with | conj v8 v9 => (fun (v8 : Ok v4) (v9 : eq v0 v2 /\ eq v0 v4 /\ L.lt v2 v4) => match v9 as v10 in (_ /\ _) return (@False) with | conj v10 v11 => (fun (v10 : eq v0 v2) (v11 : eq v0 v4 /\ L.lt v2 v4) => match v11 as v12 in (_ /\ _) return (@False) with | conj v12 v13 => (fun (v12 : eq v0 v4) (v13 : L.lt v2 v4) => let v14 : eqlistA (@X.eq) v2 v4 := SortA_equivlistA_eqlistA (@X.eq_equiv) (@X.lt_strorder) (@X.lt_compat) ((fun v14 : Sorted (@X.lt) v2 <-> Ok v2 => iff_impl_subrelation (Ok v2) (Sorted (@X.lt) v2) (symmetry v14)) (isok_iff v2) v6) ((fun v14 : Sorted (@X.lt) v4 <-> Ok v4 => iff_impl_subrelation (Ok v4) (Sorted (@X.lt) v4) (symmetry v14)) (isok_iff v4) v8) (transitivity (symmetry v10) v12) in StrictOrder_Irreflexive v4 ((fun v15 : eqlistA (@X.eq) v2 v4 => subrelation_proper (@L.lt_compat') (@tt) (subrelation_respectful (subrelation_refl (eqlistA (@X.eq))) (subrelation_respectful (subrelation_refl (eqlistA (@X.eq))) (@iff_impl_subrelation))) v2 v4 v15 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) v14 v13)) v12 v13 end) v10 v11 end) v8 v9 end) v6 v7 end) v4 v5 end) v2 v3 end) : complement (@lt) v0 v0) : Irreflexive (@lt); StrictOrder_Transitive := (fun (v0 v1 v2 : list (@X.t)) (v3 : lt v0 v1) => match v3 as v4 in (ex _) return (forall v5 : lt v1 v2, lt v0 v2) with | ex_intro _ v4 v5 => (fun (v4 : @t) (v5 : exists v5 : @t, Ok v4 /\ Ok v5 /\ eq v0 v4 /\ eq v1 v5 /\ L.lt v4 v5) => match v5 as v6 in (ex _) return (forall v7 : lt v1 v2, lt v0 v2) with | ex_intro _ v6 v7 => (fun (v6 : @t) (v7 : Ok v4 /\ Ok v6 /\ eq v0 v4 /\ eq v1 v6 /\ L.lt v4 v6) => match v7 as v8 in (_ /\ _) return (forall v9 : lt v1 v2, lt v0 v2) with | conj v8 v9 => (fun (v8 : Ok v4) (v9 : Ok v6 /\ eq v0 v4 /\ eq v1 v6 /\ L.lt v4 v6) => match v9 as v10 in (_ /\ _) return (forall v11 : lt v1 v2, lt v0 v2) with | conj v10 v11 => (fun (v10 : Ok v6) (v11 : eq v0 v4 /\ eq v1 v6 /\ L.lt v4 v6) => match v11 as v12 in (_ /\ _) return (forall v13 : lt v1 v2, lt v0 v2) with | conj v12 v13 => (fun (v12 : eq v0 v4) (v13 : eq v1 v6 /\ L.lt v4 v6) => match v13 as v14 in (_ /\ _) return (forall v15 : lt v1 v2, lt v0 v2) with | conj v14 v15 => (fun (v14 : eq v1 v6) (v15 : L.lt v4 v6) (v16 : lt v1 v2) => match v16 as v17 in (ex _) return (lt v0 v2) with | ex_intro _ v17 v18 => (fun (v17 : @t) (v18 : exists v18 : @t, Ok v17 /\ Ok v18 /\ eq v1 v17 /\ eq v2 v18 /\ L.lt v17 v18) => match v18 as v19 in (ex _) return (lt v0 v2) with | ex_intro _ v19 v20 => (fun (v19 : @t) (v20 : Ok v17 /\ Ok v19 /\ eq v1 v17 /\ eq v2 v19 /\ L.lt v17 v19) => match v20 as v21 in (_ /\ _) return (lt v0 v2) with | conj v21 v22 => (fun (v21 : Ok v17) (v22 : Ok v19 /\ eq v1 v17 /\ eq v2 v19 /\ L.lt v17 v19) => match v22 as v23 in (_ /\ _) return (lt v0 v2) with | conj v23 v24 => (fun (v23 : Ok v19) (v24 : eq v1 v17 /\ eq v2 v19 /\ L.lt v17 v19) => match v24 as v25 in (_ /\ _) return (lt v0 v2) with | conj v25 v26 => (fun (v25 : eq v1 v17) (v26 : eq v2 v19 /\ L.lt v17 v19) => match v26 as v27 in (_ /\ _) return (lt v0 v2) with | conj v27 v28 => (fun (v27 : eq v2 v19) (v28 : L.lt v17 v19) => ex_intro (fun v29 : @t => exists v30 : @t, Ok v29 /\ Ok v30 /\ eq v0 v29 /\ eq v2 v30 /\ L.lt v29 v30) v4 (ex_intro (fun v29 : @t => Ok v4 /\ Ok v29 /\ eq v0 v4 /\ eq v2 v29 /\ L.lt v4 v29) v19 ((fun v29 : Sorted (@X.lt) v4 <-> Ok v4 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (Ok v4) (Sorted (@X.lt) v4) (symmetry v29) (Ok v19 /\ eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19) (Ok v19 /\ eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19) (reflexive_proper_proxy (@iff_Reflexive) (Ok v19 /\ eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19))) (isok_iff v4) ((fun v29 : Sorted (@X.lt) v19 <-> Ok v19 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (Sorted (@X.lt) v4)) (Ok v19 /\ eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19) (Sorted (@X.lt) v19 /\ eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19) (Morphisms_Prop.and_iff_morphism (Ok v19) (Sorted (@X.lt) v19) (symmetry v29) (eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19) (eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19) (reflexive_proper_proxy (@iff_Reflexive) (eq v0 v4 /\ eq v2 v19 /\ L.lt v4 v19)))) (isok_iff v19) (conj ((fun v29 : Sorted (@X.lt) v4 <-> Ok v4 => iff_impl_subrelation (Ok v4) (Sorted (@X.lt) v4) (symmetry v29)) (isok_iff v4) v8) (conj ((fun v29 : Sorted (@X.lt) v19 <-> Ok v19 => iff_impl_subrelation (Ok v19) (Sorted (@X.lt) v19) (symmetry v29)) (isok_iff v19) v23) (conj v12 (conj v27 (let v29 : eqlistA (@X.eq) v6 v17 := SortA_equivlistA_eqlistA (@X.eq_equiv) (@X.lt_strorder) (@X.lt_compat) ((fun v29 : Sorted (@X.lt) v6 <-> Ok v6 => iff_impl_subrelation (Ok v6) (Sorted (@X.lt) v6) (symmetry v29)) (isok_iff v6) v10) ((fun v29 : Sorted (@X.lt) v17 <-> Ok v17 => iff_impl_subrelation (Ok v17) (Sorted (@X.lt) v17) (symmetry v29)) (isok_iff v17) v21) (transitivity (symmetry v14) v25) in transitivity v15 ((fun v30 : eqlistA (@X.eq) v6 v17 => subrelation_proper (@L.lt_compat') (@tt) (subrelation_respectful (subrelation_refl (eqlistA (@X.eq))) (subrelation_respectful (subrelation_refl (eqlistA (@X.eq))) (@iff_flip_impl_subrelation))) v6 v17 v30 v19 v19 (reflexive_proper_proxy Equivalence_Reflexive v19)) v29 v28)))))))))) v27 v28 end) v25 v26 end) v23 v24 end) v21 v22 end) v19 v20 end) v17 v18 end) v14 v15 end) v12 v13 end) v10 v11 end) v8 v9 end) v6 v7 end) v4 v5 end) : Transitive (@lt) |}).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.lt_compat	100	0.296149	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : list (@X.t)) (v2 : eq v0 v1) => (fun (v3 v4 : list (@X.t)) (v5 : eq v3 v4) => conj (fun v6 : lt v0 v3 => match v6 as v7 in (ex _) return (lt v1 v4) with | ex_intro _ v7 v8 => (fun (v7 : @t) (v8 : exists v8 : @t, Ok v7 /\ Ok v8 /\ eq v0 v7 /\ eq v3 v8 /\ L.lt v7 v8) => match v8 as v9 in (ex _) return (lt v1 v4) with | ex_intro _ v9 v10 => (fun (v9 : @t) (v10 : Ok v7 /\ Ok v9 /\ eq v0 v7 /\ eq v3 v9 /\ L.lt v7 v9) => match v10 as v11 in (_ /\ _) return (lt v1 v4) with | conj v11 v12 => (fun (v11 : Ok v7) (v12 : Ok v9 /\ eq v0 v7 /\ eq v3 v9 /\ L.lt v7 v9) => match v12 as v13 in (_ /\ _) return (lt v1 v4) with | conj v13 v14 => (fun (v13 : Ok v9) (v14 : eq v0 v7 /\ eq v3 v9 /\ L.lt v7 v9) => match v14 as v15 in (_ /\ _) return (lt v1 v4) with | conj v15 v16 => (fun (v15 : eq v0 v7) (v16 : eq v3 v9 /\ L.lt v7 v9) => match v16 as v17 in (_ /\ _) return (lt v1 v4) with | conj v17 v18 => (fun (v17 : eq v3 v9) (v18 : L.lt v7 v9) => ex_intro (fun v19 : @t => exists v20 : @t, Ok v19 /\ Ok v20 /\ eq v1 v19 /\ eq v4 v20 /\ L.lt v19 v20) v7 (ex_intro (fun v19 : @t => Ok v7 /\ Ok v19 /\ eq v1 v7 /\ eq v4 v19 /\ L.lt v7 v19) v9 (conj v11 (conj v13 (conj (transitivity (symmetry v2) v15) (conj (transitivity (symmetry v5) v17) v18)))))) v17 v18 end) v15 v16 end) v13 v14 end) v11 v12 end) v9 v10 end) v7 v8 end) (fun v6 : lt v1 v4 => match v6 as v7 in (ex _) return (lt v0 v3) with | ex_intro _ v7 v8 => (fun (v7 : @t) (v8 : exists v8 : @t, Ok v7 /\ Ok v8 /\ eq v1 v7 /\ eq v4 v8 /\ L.lt v7 v8) => match v8 as v9 in (ex _) return (lt v0 v3) with | ex_intro _ v9 v10 => (fun (v9 : @t) (v10 : Ok v7 /\ Ok v9 /\ eq v1 v7 /\ eq v4 v9 /\ L.lt v7 v9) => match v10 as v11 in (_ /\ _) return (lt v0 v3) with | conj v11 v12 => (fun (v11 : Ok v7) (v12 : Ok v9 /\ eq v1 v7 /\ eq v4 v9 /\ L.lt v7 v9) => match v12 as v13 in (_ /\ _) return (lt v0 v3) with | conj v13 v14 => (fun (v13 : Ok v9) (v14 : eq v1 v7 /\ eq v4 v9 /\ L.lt v7 v9) => match v14 as v15 in (_ /\ _) return (lt v0 v3) with | conj v15 v16 => (fun (v15 : eq v1 v7) (v16 : eq v4 v9 /\ L.lt v7 v9) => match v16 as v17 in (_ /\ _) return (lt v0 v3) with | conj v17 v18 => (fun (v17 : eq v4 v9) (v18 : L.lt v7 v9) => ex_intro (fun v19 : @t => exists v20 : @t, Ok v19 /\ Ok v20 /\ eq v0 v19 /\ eq v3 v20 /\ L.lt v19 v20) v7 (ex_intro (fun v19 : @t => Ok v7 /\ Ok v19 /\ eq v0 v7 /\ eq v3 v19 /\ L.lt v7 v19) v9 (conj v11 (conj v13 (conj (transitivity v2 v15) (conj (transitivity v5 v17) v18)))))) v17 v18 end) v15 v16 end) v13 v14 end) v11 v12 end) v9 v10 end) v7 v8 end)) : (@eq ==> @iff)%signature (lt v0) (lt v1)) : Proper (@eq ==> @eq ==> @iff) (@lt))).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.compare_spec_aux	100	0.381944	1	1	0	synth with cache (only 1: refine (fun v0 : list (@X.t) => list_ind (fun v1 : list (@X.t) => forall v2 : list (@X.t), CompSpec (@eq) (@L.lt) v1 v2 (compare v1 v2)) (fun v1 : list (@X.t) => match v1 as v2 in (list _) return (CompSpec (@eq) (@L.lt) nil v2 (compare nil v2)) with | nil => ((CompEq (L.lt nil nil) (L.lt nil nil) (reflexivity nil) : CompSpec (@eq) (@L.lt) nil nil (@Eq)) : CompSpec (@eq) (@L.lt) nil nil (@Eq)) : CompSpec (@eq) (@L.lt) nil nil (compare nil nil) | v2 :: v3 => (fun (v2 : @X.t) (v3 : list (@X.t)) => ((CompLt (eq nil (v2 :: v3)) (L.lt (v2 :: v3) nil) (L.lt_nil v2 v3 : L.lt nil (v2 :: v3)) : CompSpec (@eq) (@L.lt) nil (v2 :: v3) (@Lt)) : CompSpec (@eq) (@L.lt) nil (v2 :: v3) (@Lt)) : CompSpec (@eq) (@L.lt) nil (v2 :: v3) (compare nil (v2 :: v3))) v2 v3 end) (fun (v1 : @X.t) (v2 : list (@X.t)) (v3 : forall v3 : list (@X.t), CompSpec (@eq) (@L.lt) v2 v3 (compare v2 v3)) (v4 : list (@X.t)) => match v4 as v5 in (list _) return (CompSpec (@eq) (@L.lt) (v1 :: v2) v5 (compare (v1 :: v2) v5)) with | nil => ((CompGt (eq (v1 :: v2) nil) (L.lt (v1 :: v2) nil) (L.lt_nil v1 v2 : L.lt nil (v1 :: v2)) : CompSpec (@eq) (@L.lt) (v1 :: v2) nil (@Gt)) : CompSpec (@eq) (@L.lt) (v1 :: v2) nil (@Gt)) : CompSpec (@eq) (@L.lt) (v1 :: v2) nil (compare (v1 :: v2) nil) | v5 :: v6 => (fun (v5 : @X.t) (v6 : list (@X.t)) => (let v7 : CompareSpec (X.eq v1 v5) (X.lt v1 v5) (X.lt v5 v1) (X.compare v1 v5) := X.compare_spec v1 v5 in let v8 : @comparison := X.compare v1 v5 in match v7 as v10 in (CompareSpec _ _ _ v9) return (CompSpec (@eq) (@L.lt) (v1 :: v2) (v5 :: v6) match v9 as v11 in comparison return (@comparison) with | Eq => compare v2 v6 | Lt => @Lt | Gt => @Gt end) with | CompEq _ _ v9 => (fun v9 : X.eq v1 v5 => L.cons_CompSpec (c:=compare v2 v6) (l1:=v2) (l2:=v6) v9 (v3 v6)) v9 | CompLt _ _ v9 => (fun v9 : X.lt v1 v5 => CompLt (eq (v1 :: v2) (v5 :: v6)) (L.lt (v5 :: v6) (v1 :: v2)) (L.lt_cons_lt v2 v6 v9 : L.lt (v1 :: v2) (v5 :: v6)) : CompSpec (@eq) (@L.lt) (v1 :: v2) (v5 :: v6) (@Lt)) v9 | CompGt _ _ v9 => (fun v9 : X.lt v5 v1 => CompGt (eq (v1 :: v2) (v5 :: v6)) (L.lt (v1 :: v2) (v5 :: v6)) (L.lt_cons_lt v6 v2 v9 : L.lt (v5 :: v6) (v1 :: v2)) : CompSpec (@eq) (@L.lt) (v1 :: v2) (v5 :: v6) (@Gt)) v9 end) : CompSpec (@eq) (@L.lt) (v1 :: v2) (v5 :: v6) (compare (v1 :: v2) (v5 :: v6))) v5 v6 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeRaw.compare_spec	100	0.164774	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : Ok v0) (v3 : Ok v1) => let v4 : CompareSpec (eq v0 v1) (L.lt v0 v1) (L.lt v1 v0) (compare v0 v1) := compare_spec_aux v0 v1 in let v5 : @comparison := compare v0 v1 in match v4 as v7 in (CompareSpec _ _ _ v6) return (CompSpec (@eq) (@lt) v0 v1 v6) with | CompEq _ _ v6 => (fun v6 : eq v0 v1 => CompEq (lt v0 v1) (lt v1 v0) v6) v6 | CompLt _ _ v6 => (fun v6 : L.lt v0 v1 => CompLt (eq v0 v1) (lt v1 v0) (ex_intro (fun v7 : @t => exists v8 : @t, Ok v7 /\ Ok v8 /\ eq v0 v7 /\ eq v1 v8 /\ L.lt v7 v8) v0 (ex_intro (fun v7 : @t => Ok v0 /\ Ok v7 /\ eq v0 v0 /\ eq v1 v7 /\ L.lt v0 v7) v1 (conj v2 (conj v3 (conj (fun v7 : @X.t => conj (fun v8 : InA (@X.eq) v7 v0 => v8) (fun v8 : InA (@X.eq) v7 v0 => v8)) (conj (fun v7 : @X.t => conj (fun v8 : InA (@X.eq) v7 v1 => v8) (fun v8 : InA (@X.eq) v7 v1 => v8)) v6))))))) v6 | CompGt _ _ v6 => (fun v6 : L.lt v1 v0 => CompGt (eq v0 v1) (lt v0 v1) (ex_intro (fun v7 : @t => exists v8 : @t, Ok v7 /\ Ok v8 /\ eq v1 v7 /\ eq v0 v8 /\ L.lt v7 v8) v1 (ex_intro (fun v7 : @t => Ok v1 /\ Ok v7 /\ eq v1 v1 /\ eq v0 v7 /\ L.lt v1 v7) v0 (conj v3 (conj v2 (conj (fun v7 : @X.t => conj (fun v8 : InA (@X.eq) v7 v1 => v8) (fun v8 : InA (@X.eq) v7 v1 => v8)) (conj (fun v7 : @X.t => conj (fun v8 : InA (@X.eq) v7 v0 => v8) (fun v8 : InA (@X.eq) v7 v0 => v8)) v6))))))) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeWithLeibniz.eq_leibniz_list	100	0.647182	1	1	0	synth with cache (only 1: refine (fun v0 : list (@X.t) => list_ind (fun v1 : list (@X.t) => forall (v2 : list (@X.t)) (v3 : eqlistA (@X.eq) v1 v2), v1 = v2) (fun v1 : list (@X.t) => match v1 as v2 in (list _) return (forall v3 : eqlistA (@X.eq) nil v2, nil = v2) with | nil => fun v2 : eqlistA (@X.eq) nil nil => let v3 : forall v3 v4 : nil = nil, nil = nil := match v2 as v5 in (eqlistA _ v3 v4) return (forall (v6 : v3 = nil) (v7 : v4 = nil), nil = nil) with | eqlistA_nil _ => fun v3 v4 : nil = nil => (fun v5 v6 : nil = nil => eq_refl) v3 v4 | @eqlistA_cons _ _ v3 v4 v5 v6 v7 v8 => (fun (v3 v4 : @X.t) (v5 v6 : list (@X.t)) (v7 : X.eq v3 v4) (v8 : eqlistA (@X.eq) v5 v6) (v9 : v3 :: v5 = nil) (v10 : v4 :: v6 = nil) => (fun v11 : v3 :: v5 = nil => let v12 : @False := eq_ind (v3 :: v5) (fun v12 : list (@X.t) => match v12 as v13 in (list _) return Prop with | nil => @False | v13 :: v14 => (fun (v13 : @X.t) (v14 : list (@X.t)) => @True) v13 v14 end) (@I) nil v11 in False_ind (forall (v13 : v4 :: v6 = nil) (v14 : X.eq v3 v4) (v15 : eqlistA (@X.eq) v5 v6), nil = nil) v12) v9 v10 v7 v8) v3 v4 v5 v6 v7 v8 end in v3 eq_refl eq_refl | v2 :: v3 => (fun (v2 : @X.t) (v3 : list (@X.t)) (v4 : eqlistA (@X.eq) nil (v2 :: v3)) => let v5 : forall (v5 : nil = nil) (v6 : v2 :: v3 = v2 :: v3), nil = v2 :: v3 := match v4 as v7 in (eqlistA _ v5 v6) return (forall (v8 : v5 = nil) (v9 : v6 = v2 :: v3), nil = v2 :: v3) with | eqlistA_nil _ => fun (v5 : nil = nil) (v6 : nil = v2 :: v3) => (fun (v7 : nil = nil) (v8 : nil = v2 :: v3) => let v9 : @False := eq_ind nil (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @True | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @False) v10 v11 end) (@I) (v2 :: v3) v8 in False_ind (nil = v2 :: v3) v9) v5 v6 | @eqlistA_cons _ _ v5 v6 v7 v8 v9 v10 => (fun (v5 v6 : @X.t) (v7 v8 : list (@X.t)) (v9 : X.eq v5 v6) (v10 : eqlistA (@X.eq) v7 v8) (v11 : v5 :: v7 = nil) (v12 : v6 :: v8 = v2 :: v3) => (fun v13 : v5 :: v7 = nil => let v14 : @False := eq_ind (v5 :: v7) (fun v14 : list (@X.t) => match v14 as v15 in (list _) return Prop with | nil => @False | v15 :: v16 => (fun (v15 : @X.t) (v16 : list (@X.t)) => @True) v15 v16 end) (@I) nil v13 in False_ind (forall (v15 : v6 :: v8 = v2 :: v3) (v16 : X.eq v5 v6) (v17 : eqlistA (@X.eq) v7 v8), nil = v2 :: v3) v14) v11 v12 v9 v10) v5 v6 v7 v8 v9 v10 end in v5 eq_refl eq_refl) v2 v3 end) (fun (v1 : @X.t) (v2 : list (@X.t)) (v3 : forall (v3 : list (@X.t)) (v4 : eqlistA (@X.eq) v2 v3), v2 = v3) (v4 : list (@X.t)) => match v4 as v5 in (list _) return (forall v6 : eqlistA (@X.eq) (v1 :: v2) v5, v1 :: v2 = v5) with | nil => fun v5 : eqlistA (@X.eq) (v1 :: v2) nil => let v6 : forall (v6 : v1 :: v2 = v1 :: v2) (v7 : nil = nil), v1 :: v2 = nil := match v5 as v8 in (eqlistA _ v6 v7) return (forall (v9 : v6 = v1 :: v2) (v10 : v7 = nil), v1 :: v2 = nil) with | eqlistA_nil _ => fun (v6 : nil = v1 :: v2) (v7 : nil = nil) => (fun v8 : nil = v1 :: v2 => let v9 : @False := eq_ind nil (fun v9 : list (@X.t) => match v9 as v10 in (list _) return Prop with | nil => @True | v10 :: v11 => (fun (v10 : @X.t) (v11 : list (@X.t)) => @False) v10 v11 end) (@I) (v1 :: v2) v8 in False_ind (forall v10 : nil = nil, v1 :: v2 = nil) v9) v6 v7 | @eqlistA_cons _ _ v6 v7 v8 v9 v10 v11 => (fun (v6 v7 : @X.t) (v8 v9 : list (@X.t)) (v10 : X.eq v6 v7) (v11 : eqlistA (@X.eq) v8 v9) (v12 : v6 :: v8 = v1 :: v2) (v13 : v7 :: v9 = nil) => (fun v14 : v6 :: v8 = v1 :: v2 => let v15 : v8 = v2 := f_equal (fun v15 : list (@X.t) => match v15 as v16 in (list _) return (list (@X.t)) with | nil => v8 | v16 :: v17 => (fun (v16 : @X.t) (v17 : list (@X.t)) => v17) v16 v17 end) v14 in (let v16 : v6 = v1 := f_equal (fun v16 : list (@X.t) => match v16 as v17 in (list _) return (@X.t) with | nil => v6 | v17 :: v18 => (fun (v17 : @X.t) (v18 : list (@X.t)) => v17) v17 v18 end) v14 in (fun v17 : v6 = v1 => let v18 : v6 = v1 := v17 in eq_ind_r (fun v19 : @X.t => forall (v20 : v8 = v2) (v21 : v7 :: v9 = nil) (v22 : X.eq v19 v7) (v23 : eqlistA (@X.eq) v8 v9), v1 :: v2 = nil) (fun v19 : v8 = v2 => let v20 : v8 = v2 := v19 in eq_ind_r (fun v21 : list (@X.t) => forall (v22 : v7 :: v9 = nil) (v23 : X.eq v1 v7) (v24 : eqlistA (@X.eq) v21 v9), v1 :: v2 = nil) (fun v21 : v7 :: v9 = nil => let v22 : @False := eq_ind (v7 :: v9) (fun v22 : list (@X.t) => match v22 as v23 in (list _) return Prop with | nil => @False | v23 :: v24 => (fun (v23 : @X.t) (v24 : list (@X.t)) => @True) v23 v24 end) (@I) nil v21 in False_ind (forall (v23 : X.eq v1 v7) (v24 : eqlistA (@X.eq) v2 v9), v1 :: v2 = nil) v22) v20) v18) v16) v15) v12 v13 v10 v11) v6 v7 v8 v9 v10 v11 end in v6 eq_refl eq_refl | v5 :: v6 => (fun (v5 : @X.t) (v6 : list (@X.t)) (v7 : eqlistA (@X.eq) (v1 :: v2) (v5 :: v6)) => let v8 : forall (v8 : v1 :: v2 = v1 :: v2) (v9 : v5 :: v6 = v5 :: v6), v1 :: v2 = v5 :: v6 := match v7 as v10 in (eqlistA _ v8 v9) return (forall (v11 : v8 = v1 :: v2) (v12 : v9 = v5 :: v6), v1 :: v2 = v5 :: v6) with | eqlistA_nil _ => fun (v8 : nil = v1 :: v2) (v9 : nil = v5 :: v6) => (fun v10 : nil = v1 :: v2 => let v11 : @False := eq_ind nil (fun v11 : list (@X.t) => match v11 as v12 in (list _) return Prop with | nil => @True | v12 :: v13 => (fun (v12 : @X.t) (v13 : list (@X.t)) => @False) v12 v13 end) (@I) (v1 :: v2) v10 in False_ind (forall v12 : nil = v5 :: v6, v1 :: v2 = v5 :: v6) v11) v8 v9 | @eqlistA_cons _ _ v8 v9 v10 v11 v12 v13 => (fun (v8 v9 : @X.t) (v10 v11 : list (@X.t)) (v12 : X.eq v8 v9) (v13 : eqlistA (@X.eq) v10 v11) (v14 : v8 :: v10 = v1 :: v2) (v15 : v9 :: v11 = v5 :: v6) => (fun v16 : v8 :: v10 = v1 :: v2 => let v17 : v10 = v2 := f_equal (fun v17 : list (@X.t) => match v17 as v18 in (list _) return (list (@X.t)) with | nil => v10 | v18 :: v19 => (fun (v18 : @X.t) (v19 : list (@X.t)) => v19) v18 v19 end) v16 in (let v18 : v8 = v1 := f_equal (fun v18 : list (@X.t) => match v18 as v19 in (list _) return (@X.t) with | nil => v8 | v19 :: v20 => (fun (v19 : @X.t) (v20 : list (@X.t)) => v19) v19 v20 end) v16 in (fun v19 : v8 = v1 => let v20 : v8 = v1 := v19 in eq_ind_r (fun v21 : @X.t => forall (v22 : v10 = v2) (v23 : v9 :: v11 = v5 :: v6) (v24 : X.eq v21 v9) (v25 : eqlistA (@X.eq) v10 v11), v1 :: v2 = v5 :: v6) (fun v21 : v10 = v2 => let v22 : v10 = v2 := v21 in eq_ind_r (fun v23 : list (@X.t) => forall (v24 : v9 :: v11 = v5 :: v6) (v25 : X.eq v1 v9) (v26 : eqlistA (@X.eq) v23 v11), v1 :: v2 = v5 :: v6) (fun v23 : v9 :: v11 = v5 :: v6 => let v24 : v11 = v6 := f_equal (fun v24 : list (@X.t) => match v24 as v25 in (list _) return (list (@X.t)) with | nil => v11 | v25 :: v26 => (fun (v25 : @X.t) (v26 : list (@X.t)) => v26) v25 v26 end) v23 in (let v25 : v9 = v5 := f_equal (fun v25 : list (@X.t) => match v25 as v26 in (list _) return (@X.t) with | nil => v9 | v26 :: v27 => (fun (v26 : @X.t) (v27 : list (@X.t)) => v26) v26 v27 end) v23 in (fun v26 : v9 = v5 => let v27 : v9 = v5 := v26 in eq_ind_r (fun v28 : @X.t => forall (v29 : v11 = v6) (v30 : X.eq v1 v28) (v31 : eqlistA (@X.eq) v2 v11), v1 :: v2 = v5 :: v6) (fun v28 : v11 = v6 => let v29 : v11 = v6 := v28 in eq_ind_r (fun v30 : list (@X.t) => forall (v31 : X.eq v1 v5) (v32 : eqlistA (@X.eq) v2 v30), v1 :: v2 = v5 :: v6) (fun (v30 : X.eq v1 v5) (v31 : eqlistA (@X.eq) v2 v6) => let v32 : v2 = v6 := v3 v6 v31 in (let v33 : v1 = v5 := X.eq_leibniz (let v33 : X.eq v1 v5 = X.eq v1 v5 := eq_refl in eq_rect (X.eq v1 v5) (fun v34 : Prop => v34) v30 (X.eq v1 v5) v33) in (let v34 : @X.t = @X.t := eq_refl in (fun (v35 : @X.t = @X.t) (v36 : v1 = v5) (v37 : v2 = v6) => eq_trans (f_equal (fun v38 : forall v38 : list (@X.t), list (@X.t) => v38 v2) (eq_trans (f_equal (fun v38 : forall (v38 : @X.t) (v39 : list (@X.t)), list (@X.t) => v38 v1) eq_refl) (f_equal cons v36))) (f_equal (cons v5) v37)) v34) v33) v32) v29) v27) v25) v24) v22) v20) v18) v17) v14 v15 v12 v13) v8 v9 v10 v11 v12 v13 end in v8 eq_refl eq_refl) v5 v6 end) v0)).
coq-tactician-stdlib.8.11.dev	Coq.MSets.MSetList.MakeWithLeibniz.eq_leibniz	100	0.135965	1	1	0	synth with cache (only 1: refine (fun v0 : @t => match v0 as v1 in t_ return (forall (v2 : @t) (v3 : eq v1 v2), v1 = v2) with | {| this := v1; is_ok := v2 |} => (fun (v1 : @Raw.t) (v2 : Raw.Ok v1) (v3 : @t) => match v3 as v4 in t_ return (forall v5 : eq {| this := v1; is_ok := v2 |} v4, {| this := v1; is_ok := v2 |} = v4) with | {| this := v4; is_ok := v5 |} => (fun (v4 : @Raw.t) (v5 : Raw.Ok v4) (v6 : eq {| this := v1; is_ok := v2 |} {| this := v4; is_ok := v5 |}) => let v7 : eqlistA (@X.eq) v1 v4 := SortA_equivlistA_eqlistA (@X.eq_equiv) (@X.lt_strorder) (@X.lt_compat) ((fun v7 : Sorted (@X.lt) v1 <-> Raw.Ok v1 => iff_impl_subrelation (Raw.Ok v1) (Sorted (@X.lt) v1) (symmetry v7)) (Raw.isok_iff v1) v2) ((fun v7 : Sorted (@X.lt) v4 <-> Raw.Ok v4 => iff_impl_subrelation (Raw.Ok v4) (Sorted (@X.lt) v4) (symmetry v7)) (Raw.isok_iff v4) v5) v6 in let v8 : v1 = v4 := eq_leibniz_list v7 in eq_ind v1 (fun v9 : list (@X.t) => forall (v10 : Raw.Ok v9) (v11 : equivlistA (@X.eq) v1 v9), {| this := v1; is_ok := v2 |} = {| this := v9; is_ok := v10 |}) (fun (v9 : Raw.Ok v1) (v10 : equivlistA (@X.eq) v1 v1) => let v11 : v2 = v9 := Eqdep_dec.eq_proofs_unicity (fun v11 v12 : @bool => let v13 : {v11 = v12} + {v11 <> v12} := bool_dec v11 v12 in match v13 as v14 in ({_} + {_}) return (v11 = v12 \/ v11 <> v12) with | left v14 => (fun v14 : v11 = v12 => or_introl v14) v14 | right v14 => (fun v14 : v11 <> v12 => or_intror ((fun v15 : v11 = v12 => let v16 : @False := v14 v15 in False_ind (@False) v16) : v11 <> v12)) v14 end) v2 v9 in (let v12 : v1 = v1 := eq_refl in (fun (v13 : v1 = v1) (v14 : v2 = v9) => eq_trans (f_equal (fun v15 : forall v15 : Raw.Ok v1, @t_ => v15 v2) eq_refl) (f_equal (@Mkt v1) v14)) v12) v11) v4 v8 v5 v6) v4 v5 end) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.pow_pos_comm	100	2.828458	1	1
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.pow_pos_succ	100	1.551905	1	1
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.pow_pos_add	100	3.025062	1	1
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.pow_N_pow_N	100	0.102294	1	1	0	synth with cache (only 1: refine (fun (v0 : @R) (v1 : @N) => reflexivity (pow_N v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_mul_0_l	100	1.338206	1	1
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_mul_0_r	100	1.642130	1	1	0	synth with cache (only 1: refine (fun v0 : @R => let v1 : default_relation (v0 * 0) (v0 * (0 + 1) + - v0) := (fun v1 : v0 * (0 + 1) == v0 * 0 + v0 * 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * (0 + 1) + - v0) (v0 * 0 + v0 * 1 + - v0) (ring_plus_comp (v0 * (0 + 1)) (v0 * 0 + v0 * 1) v1 (- v0) (- v0) (reflexive_proper_proxy Equivalence_Reflexive (- v0)))) (ring_distr_r 0 1 v0) ((fun v1 : v0 * 1 == v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * 0 + v0 * 1 + - v0) (v0 * 0 + v0 + - v0) (ring_plus_comp (v0 * 0 + v0 * 1) (v0 * 0 + v0) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive (v0 * 0)) (v0 * 1) v0 v1) (- v0) (- v0) (reflexive_proper_proxy Equivalence_Reflexive (- v0)))) (ring_mul_1_r v0) ((fun v1 : v0 * 0 + (v0 + - v0) == v0 * 0 + v0 + - v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * 0 + v0 + - v0) (v0 * 0 + (v0 + - v0)) (symmetry v1)) (ring_add_assoc (v0 * 0) v0 (- v0)) ((fun v1 : v0 + - v0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * 0 + (v0 + - v0)) (v0 * 0 + 0) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive (v0 * 0)) (v0 + - v0) 0 v1)) (ring_opp_def v0) ((fun v1 : v0 * 0 + 0 == 0 + v0 * 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * 0 + 0) (0 + v0 * 0) v1) (ring_add_comm (v0 * 0) 0) ((fun v1 : 0 + v0 * 0 == v0 * 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (0 + v0 * 0) (v0 * 0) v1) (ring_add_0_l (v0 * 0)) (reflexivity (v0 * 0))))))) : default_relation (v0 * 0) (v0 * (0 + 1) + - v0) in ((fun v2 : v0 * 0 == v0 * (0 + 1) + - v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * 0) (v0 * (0 + 1) + - v0) v2 0 0 (eq_proper_proxy 0) ((fun v3 : 0 + 1 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * (0 + 1) + - v0) (v0 * 1 + - v0) (ring_plus_comp (v0 * (0 + 1)) (v0 * 1) (Reflexive_partial_app_morphism ring_mult_comp (reflexive_proper_proxy Equivalence_Reflexive v0) (0 + 1) 1 v3) (- v0) (- v0) (reflexive_proper_proxy Equivalence_Reflexive (- v0))) 0 0 (eq_proper_proxy 0)) (ring_add_0_l 1) ((fun v3 : v0 * 1 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * 1 + - v0) (v0 + - v0) (ring_plus_comp (v0 * 1) v0 v3 (- v0) (- v0) (reflexive_proper_proxy Equivalence_Reflexive (- v0))) 0 0 (eq_proper_proxy 0)) (ring_mul_1_r v0) ((fun v3 : v0 + - v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + - v0) 0 v3 0 0 (eq_proper_proxy 0)) (ring_opp_def v0) (reflexivity 0 : 0 == 0))))) : forall v2 : default_relation (v0 * 0) (v0 * (0 + 1) + - v0), v0 * 0 == 0) v1)).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_opp_mul_l	100	1.299067	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (fun v2 : 0 + - v0 * v1 == - v0 * v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (- v0 * v1) (0 + - v0 * v1) (symmetry v2)) (ring_add_0_l (- v0 * v1)) ((fun v2 : 0 + - v0 * v1 == - v0 * v1 + 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (0 + - v0 * v1) (- v0 * v1 + 0) v2) (ring_add_comm 0 (- v0 * v1)) ((fun v2 : v0 * v1 + - (v0 * v1) == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (- v0 * v1 + 0) (- v0 * v1 + (v0 * v1 + - (v0 * v1))) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive (- v0 * v1)) 0 (v0 * v1 + - (v0 * v1)) (symmetry v2))) (ring_opp_def (v0 * v1)) ((fun v2 : - v0 * v1 + (v0 * v1 + - (v0 * v1)) == - v0 * v1 + v0 * v1 + - (v0 * v1) => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (- v0 * v1 + (v0 * v1 + - (v0 * v1))) (- v0 * v1 + v0 * v1 + - (v0 * v1)) v2) (ring_add_assoc (- v0 * v1) (v0 * v1) (- (v0 * v1))) ((fun v2 : (- v0 + v0) * v1 == - v0 * v1 + v0 * v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (- v0 * v1 + v0 * v1 + - (v0 * v1)) ((- v0 + v0) * v1 + - (v0 * v1)) (ring_plus_comp (- v0 * v1 + v0 * v1) ((- v0 + v0) * v1) (symmetry v2) (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_distr_l (- v0) v0 v1) ((fun v2 : - v0 + v0 == v0 + - v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) ((- v0 + v0) * v1 + - (v0 * v1)) ((v0 + - v0) * v1 + - (v0 * v1)) (ring_plus_comp ((- v0 + v0) * v1) ((v0 + - v0) * v1) (ring_mult_comp (- v0 + v0) (v0 + - v0) v2 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_add_comm (- v0) v0) ((fun v2 : v0 + - v0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) ((v0 + - v0) * v1 + - (v0 * v1)) (0 * v1 + - (v0 * v1)) (ring_plus_comp ((v0 + - v0) * v1) (0 * v1) (ring_mult_comp (v0 + - v0) 0 v2 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_opp_def v0) ((fun v2 : 0 * v1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (0 * v1 + - (v0 * v1)) (0 + - (v0 * v1)) (ring_plus_comp (0 * v1) 0 v2 (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_mul_0_l v1) ((fun v2 : 0 + - (v0 * v1) == - (v0 * v1) => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (0 + - (v0 * v1)) (- (v0 * v1)) v2) (ring_add_0_l (- (v0 * v1))) (reflexivity (- (v0 * v1))))))))))))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_opp_mul_r	100	1.910805	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (fun v2 : 0 + v0 * - v1 == v0 * - v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * - v1) (0 + v0 * - v1) (symmetry v2)) (ring_add_0_l (v0 * - v1)) ((fun v2 : 0 + v0 * - v1 == v0 * - v1 + 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (0 + v0 * - v1) (v0 * - v1 + 0) v2) (ring_add_comm 0 (v0 * - v1)) ((fun v2 : v0 * v1 + - (v0 * v1) == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * - v1 + 0) (v0 * - v1 + (v0 * v1 + - (v0 * v1))) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive (v0 * - v1)) 0 (v0 * v1 + - (v0 * v1)) (symmetry v2))) (ring_opp_def (v0 * v1)) ((fun v2 : v0 * - v1 + (v0 * v1 + - (v0 * v1)) == v0 * - v1 + v0 * v1 + - (v0 * v1) => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * - v1 + (v0 * v1 + - (v0 * v1))) (v0 * - v1 + v0 * v1 + - (v0 * v1)) v2) (ring_add_assoc (v0 * - v1) (v0 * v1) (- (v0 * v1))) ((fun v2 : v0 * (- v1 + v1) == v0 * - v1 + v0 * v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * - v1 + v0 * v1 + - (v0 * v1)) (v0 * (- v1 + v1) + - (v0 * v1)) (ring_plus_comp (v0 * - v1 + v0 * v1) (v0 * (- v1 + v1)) (symmetry v2) (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_distr_r (- v1) v1 v0) ((fun v2 : - v1 + v1 == v1 + - v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * (- v1 + v1) + - (v0 * v1)) (v0 * (v1 + - v1) + - (v0 * v1)) (ring_plus_comp (v0 * (- v1 + v1)) (v0 * (v1 + - v1)) (Reflexive_partial_app_morphism ring_mult_comp (reflexive_proper_proxy Equivalence_Reflexive v0) (- v1 + v1) (v1 + - v1) v2) (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_add_comm (- v1) v1) ((fun v2 : v1 + - v1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * (v1 + - v1) + - (v0 * v1)) (v0 * 0 + - (v0 * v1)) (ring_plus_comp (v0 * (v1 + - v1)) (v0 * 0) (Reflexive_partial_app_morphism ring_mult_comp (reflexive_proper_proxy Equivalence_Reflexive v0) (v1 + - v1) 0 v2) (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_opp_def v1) ((fun v2 : v0 * 0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v0 * 0 + - (v0 * v1)) (0 + - (v0 * v1)) (ring_plus_comp (v0 * 0) 0 v2 (- (v0 * v1)) (- (v0 * v1)) (reflexive_proper_proxy Equivalence_Reflexive (- (v0 * v1))))) (ring_mul_0_r v0) ((fun v2 : 0 + - (v0 * v1) == - (v0 * v1) => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (0 + - (v0 * v1)) (- (v0 * v1)) v2) (ring_add_0_l (- (v0 * v1))) (reflexivity (- (v0 * v1))))))))))))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_opp_add	100	4.769103	1	1
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_opp_opp	100	0.908989	1	1	0	synth with cache (only 1: refine (fun v0 : @R => (fun v1 : 0 + - - v0 == - - v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (- - v0) (0 + - - v0) (symmetry v1) v0 v0 (eq_proper_proxy v0)) (ring_add_0_l (- - v0)) ((fun v1 : v0 + - v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 + - - v0) (v0 + - v0 + - - v0) (ring_plus_comp 0 (v0 + - v0) (symmetry v1) (- - v0) (- - v0) (reflexive_proper_proxy Equivalence_Reflexive (- - v0))) v0 v0 (eq_proper_proxy v0)) (ring_opp_def v0) ((fun v1 : v0 + (- v0 + - - v0) == v0 + - v0 + - - v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + - v0 + - - v0) (v0 + (- v0 + - - v0)) (symmetry v1) v0 v0 (eq_proper_proxy v0)) (ring_add_assoc v0 (- v0) (- - v0)) ((fun v1 : - v0 + - - v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + (- v0 + - - v0)) (v0 + 0) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive v0) (- v0 + - - v0) 0 v1) v0 v0 (eq_proper_proxy v0)) (ring_opp_def (- v0)) ((fun v1 : v0 + 0 == 0 + v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + 0) (0 + v0) v1 v0 v0 (eq_proper_proxy v0)) (ring_add_comm v0 0) ((fun v1 : 0 + v0 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 + v0) v0 v1 v0 v0 (eq_proper_proxy v0)) (ring_add_0_l v0) (reflexivity v0)))))))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_sub_ext	100	0.781193	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : v0 == v1) (v3 v4 : @R) (v5 : v3 == v4) => let v6 : default_relation (v0 - v3) (v0 + - v3) := (fun v6 : v0 - v3 == v0 + - v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 - v3) (v0 + - v3) v6 (v0 + - v3) (v0 + - v3) (eq_proper_proxy (v0 + - v3))) (ring_sub_def v0 v3) (reflexivity (v0 + - v3)) : default_relation (v0 - v3) (v0 + - v3) in ((fun v7 : v0 - v3 == v0 + - v3 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 - v3) (v0 + - v3) v7 (v1 - v4) (v1 - v4) (eq_proper_proxy (v1 - v4)) (let v8 : default_relation (v1 - v4) (v1 + - v4) := (fun v8 : v1 - v4 == v1 + - v4 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v1 - v4) (v1 + - v4) v8 (v1 + - v4) (v1 + - v4) (eq_proper_proxy (v1 + - v4))) (ring_sub_def v1 v4) (reflexivity (v1 + - v4)) : default_relation (v1 - v4) (v1 + - v4) in ((fun v9 : v1 - v4 == v1 + - v4 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v1 - v4) (v1 + - v4) v9 ((fun v10 : v0 == v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + - v3) (v1 + - v3) (ring_plus_comp v0 v1 v10 (- v3) (- v3) (reflexive_proper_proxy Equivalence_Reflexive (- v3))) (v1 + - v4) (v1 + - v4) (eq_proper_proxy (v1 + - v4))) v2 ((fun v10 : v3 == v4 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v1 + - v3) (v1 + - v4) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive v1) (- v3) (- v4) (ring_opp_comp v3 v4 v10)) (v1 + - v4) (v1 + - v4) (eq_proper_proxy (v1 + - v4))) v5 (reflexivity (v1 + - v4))))) : forall v9 : default_relation (v1 - v4) (v1 + - v4), v0 + - v3 == v1 - v4) v8)) : forall v7 : default_relation (v0 - v3) (v0 + - v3), v0 - v3 == v1 - v4) v6)).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_add_0_r	100	0.232396	1	1	0	synth with cache (only 1: refine (fun v0 : @R => (fun v1 : 0 + v0 == v0 + 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + 0) (0 + v0) (symmetry v1) v0 v0 (eq_proper_proxy v0)) (ring_add_comm 0 v0) ((fun v1 : 0 + v0 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 + v0) v0 v1 v0 v0 (eq_proper_proxy v0)) (ring_add_0_l v0) (reflexivity v0)))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_add_assoc1	100	0.315809	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => (fun v3 : v0 + (v1 + v2) == v0 + v1 + v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + v1 + v2) (v0 + (v1 + v2)) (symmetry v3) (v1 + v2 + v0) (v1 + v2 + v0) (eq_proper_proxy (v1 + v2 + v0))) (ring_add_assoc v0 v1 v2) ((fun v3 : v0 + (v1 + v2) == v1 + v2 + v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + (v1 + v2)) (v1 + v2 + v0) v3 (v1 + v2 + v0) (v1 + v2 + v0) (eq_proper_proxy (v1 + v2 + v0))) (ring_add_comm v0 (v1 + v2)) (reflexivity (v1 + v2 + v0))))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_add_assoc2	100	0.413890	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => (fun v3 : v1 + (v0 + v2) == v1 + v0 + v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v1 + v0 + v2) (v1 + (v0 + v2)) (symmetry v3) (v1 + v2 + v0) (v1 + v2 + v0) (eq_proper_proxy (v1 + v2 + v0))) (ring_add_assoc v1 v0 v2) ((fun v3 : v1 + (v2 + v0) == v1 + v2 + v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (v1 + v2 + v0) (v1 + (v2 + v0)) (symmetry v3)) (ring_add_assoc v1 v2 v0) ((fun v3 : v0 + v2 == v2 + v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v1 + (v0 + v2)) (v1 + (v2 + v0)) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive v1) (v0 + v2) (v2 + v0) v3) (v1 + (v2 + v0)) (v1 + (v2 + v0)) (eq_proper_proxy (v1 + (v2 + v0)))) (ring_add_comm v0 v2) (reflexivity (v1 + (v2 + v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Ncring.Ring.ring_opp_zero	100	0.526070	1	1	0	synth with cache (only 1: refine ((fun v0 : 0 * 0 == 0 => subrelation_proper (PER_morphism (Equivalence_PER ring_setoid)) (@tt) (subrelation_respectful (subrelation_refl _==_) (subrelation_respectful (subrelation_refl _==_) (@iff_flip_impl_subrelation))) (- 0) (- (0 * 0)) (ring_opp_comp 0 (0 * 0) (symmetry v0)) 0 (0 * 0) (symmetry v0)) (ring_mul_0_r 0) ((fun v0 : - (0 * 0) == - 0 * 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (- (0 * 0)) (- 0 * 0) v0 (0 * 0) (0 * 0) (eq_proper_proxy (0 * 0))) (ring_opp_mul_l 0 0) ((fun v0 : - 0 * 0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (- 0 * 0) 0 v0 (0 * 0) (0 * 0) (eq_proper_proxy (0 * 0))) (ring_mul_0_r (- 0)) ((fun v0 : 0 * 0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (0 * 0) 0 v0) (ring_mul_0_r 0) (reflexivity 0)))))).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_infty	100	0.059214	1	1	0	synth with cache (only 1: refine (fun v0 : @N => N_ind (fun v1 : @N => forall v2 : Nplength v1 = @infty, v1 = 0%N) (fun v1 : Nplength 0 = @infty => eq_refl) ((fun (v1 : @positive) (v2 : ni (Pplength v1) = @infty) => let v3 : @False := eq_ind (ni (Pplength v1)) (fun v3 : @natinf => match v3 as v4 in natinf return Prop with | infty => @False | ni v4 => (fun v4 : @nat => @True) v4 end) (@I) (@infty) v2 in False_ind (N.pos v1 = 0%N) v3) : forall (v1 : @positive) (v2 : Nplength (N.pos v1) = @infty), N.pos v1 = 0%N) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_zeros	100	0.351374	0	1
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_one	100	0.267896	1	1	0	synth with cache (only 1: refine (fun v0 : @N => N_ind (fun v1 : @N => forall (v2 : @nat) (v3 : Nplength v1 = ni v2), BinNatDef.N.testbit_nat v1 v2 = @true) (fun (v1 : @nat) (v2 : Nplength 0 = ni v1) => let v3 : forall v3 : ni v1 = ni v1, BinNatDef.N.testbit_nat 0 v1 = @true := match v2 as v4 in (_ = v3) return (forall v5 : v3 = ni v1, BinNatDef.N.testbit_nat 0 v1 = @true) with | eq_refl => fun v3 : Nplength 0 = ni v1 => (fun v4 : Nplength 0 = ni v1 => let v5 : @False := eq_ind (Nplength 0) (fun v5 : @natinf => match v5 as v6 in natinf return Prop with | infty => @True | ni v6 => (fun v6 : @nat => @False) v6 end) (@I) (ni v1) v4 in False_ind (BinNatDef.N.testbit_nat 0 v1 = @true) v5) v3 end in v3 eq_refl) (fun v1 : @positive => positive_ind (fun v2 : @positive => forall (v3 : @nat) (v4 : Nplength (N.pos v2) = ni v3), BinNatDef.N.testbit_nat (N.pos v2) v3 = @true) (fun (v2 : @positive) (v3 : forall (v3 : @nat) (v4 : Nplength (N.pos v2) = ni v3), BinNatDef.N.testbit_nat (N.pos v2) v3 = @true) (v4 : @nat) (v5 : Nplength (N.pos v2~1) = ni v4) => let v6 : forall v6 : ni v4 = ni v4, BinNatDef.N.testbit_nat (N.pos v2~1) v4 = @true := match v5 as v7 in (_ = v6) return (forall v8 : v6 = ni v4, BinNatDef.N.testbit_nat (N.pos v2~1) v4 = @true) with | eq_refl => fun v6 : ni 0 = ni v4 => (fun v7 : ni 0 = ni v4 => let v8 : 0 = v4 := f_equal (fun v8 : @natinf => match v8 as v9 in natinf return (@nat) with | infty => 0 | ni v9 => (fun v9 : @nat => v9) v9 end) v7 in (fun v9 : 0 = v4 => let v10 : 0 = v4 := v9 in eq_ind 0 (fun v11 : @nat => BinNatDef.N.testbit_nat (N.pos v2~1) v11 = @true) eq_refl v4 v10) v8) v6 end in v6 eq_refl) (fun (v2 : @positive) (v3 : forall (v3 : @nat) (v4 : Nplength (N.pos v2) = ni v3), BinNatDef.N.testbit_nat (N.pos v2) v3 = @true) (v4 : @nat) (v5 : Nplength (N.pos v2~0) = ni v4) => let v6 : forall v6 : ni v4 = ni v4, BinNatDef.N.testbit_nat (N.pos v2~0) v4 = @true := match v5 as v7 in (_ = v6) return (forall v8 : v6 = ni v4, BinNatDef.N.testbit_nat (N.pos v2~0) v4 = @true) with | eq_refl => fun v6 : ni (S (Pplength v2)) = ni v4 => (fun v7 : ni (S (Pplength v2)) = ni v4 => let v8 : S (Pplength v2) = v4 := f_equal (fun v8 : @natinf => match v8 as v9 in natinf return (@nat) with | infty => S (Pplength v2) | ni v9 => (fun v9 : @nat => v9) v9 end) v7 in (fun v9 : S (Pplength v2) = v4 => let v10 : S (Pplength v2) = v4 := v9 in eq_ind (S (Pplength v2)) (fun v11 : @nat => BinNatDef.N.testbit_nat (N.pos v2~0) v11 = @true) (v3 (Pplength v2) eq_refl : BinNatDef.N.testbit_nat (N.pos v2~0) (S (Pplength v2)) = @true) v4 v10) v8) v6 end in v6 eq_refl) (fun (v2 : @nat) (v3 : Nplength 1 = ni v2) => let v4 : forall v4 : ni v2 = ni v2, BinNatDef.N.testbit_nat 1 v2 = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = ni v2, BinNatDef.N.testbit_nat 1 v2 = @true) with | eq_refl => fun v4 : ni 0 = ni v2 => (fun v5 : ni 0 = ni v2 => let v6 : 0 = v2 := f_equal (fun v6 : @natinf => match v6 as v7 in natinf return (@nat) with | infty => 0 | ni v7 => (fun v7 : @nat => v7) v7 end) v5 in (fun v7 : 0 = v2 => let v8 : 0 = v2 := v7 in eq_ind 0 (fun v9 : @nat => BinNatDef.N.testbit_nat 1 v9 = @true) eq_refl v2 v8) v6) v4 end in v4 eq_refl) v1) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_first_one	100	0.199316	0	1
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_idemp	100	0.425759	0	1
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_comm	100	0.124442	0	1
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_assoc	100	0.131894	1	1	0	synth with cache (only 1: refine (fun v0 : @natinf => natinf_ind (fun v1 : @natinf => forall v2 v3 : @natinf, ni_min (ni_min v1 v2) v3 = ni_min v1 (ni_min v2 v3)) (fun v1 v2 : @natinf => eq_refl) (fun (v1 : @nat) (v2 : @natinf) => natinf_ind (fun v3 : @natinf => forall v4 : @natinf, ni_min (ni_min (ni v1) v3) v4 = ni_min (ni v1) (ni_min v3 v4)) (fun v3 : @natinf => eq_refl) (fun (v3 : @nat) (v4 : @natinf) => natinf_ind (fun v5 : @natinf => ni_min (ni_min (ni v1) (ni v3)) v5 = ni_min (ni v1) (ni_min (ni v3) v5)) eq_refl ((fun v5 : @nat => let v6 : Init.Nat.min (Init.Nat.min v1 v3) v5 = Init.Nat.min v1 (Init.Nat.min v3 v5) := nat_ind (fun v6 : @nat => forall v7 v8 : @nat, Init.Nat.min (Init.Nat.min v6 v7) v8 = Init.Nat.min v6 (Init.Nat.min v7 v8)) (fun v6 v7 : @nat => eq_refl) (fun (v6 : @nat) (v7 : forall v7 v8 : @nat, Init.Nat.min (Init.Nat.min v6 v7) v8 = Init.Nat.min v6 (Init.Nat.min v7 v8)) (v8 v9 : @nat) => match v8 as v10 in nat return (Init.Nat.min (Init.Nat.min (S v6) v10) v9 = Init.Nat.min (S v6) (Init.Nat.min v10 v9)) with | 0 => eq_refl | S v10 => (fun v10 : @nat => match v9 as v11 in nat return (Init.Nat.min (Init.Nat.min (S v6) (S v10)) v11 = Init.Nat.min (S v6) (Init.Nat.min (S v10) v11)) with | 0 => eq_refl | S v11 => (fun v11 : @nat => f_equal_nat (@nat) (@S) (Init.Nat.min (Init.Nat.min v6 v10) v11) (Init.Nat.min v6 (Init.Nat.min v10 v11)) (v7 v10 v11) : Init.Nat.min (Init.Nat.min (S v6) (S v10)) (S v11) = Init.Nat.min (S v6) (Init.Nat.min (S v10) (S v11))) v11 end) v10 end) v1 v3 v5 in eq_ind_r (fun v7 : @nat => ni v7 = ni (Init.Nat.min v1 (Init.Nat.min v3 v5))) eq_refl v6) : forall v5 : @nat, ni_min (ni_min (ni v1) (ni v3)) (ni v5) = ni_min (ni v1) (ni_min (ni v3) (ni v5))) v4) v2) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_O_l	100	0.049855	1	1	0	synth with cache (only 1: refine (fun v0 : @natinf => natinf_ind (fun v1 : @natinf => ni_min (ni 0) v1 = ni 0) eq_refl (fun v1 : @nat => eq_refl) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_O_r	100	0.065864	1	1	0	synth with cache (only 1: refine (fun v0 : @natinf => eq_ind_r (fun v1 : @natinf => v1 = ni 0) (ni_min_O_l v0) (ni_min_comm v0 (ni 0)))).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_inf_l	100	0.059388	1	1	0	synth with cache (only 1: refine (fun v0 : @natinf => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_inf_r	100	0.040098	1	1	0	synth with cache (only 1: refine (fun v0 : @natinf => natinf_ind (fun v1 : @natinf => ni_min v1 (@infty) = v1) eq_refl (fun v1 : @nat => eq_refl) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_refl	100	0.049746	1	1	0	synth with cache (only 1: refine @ni_min_idemp).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_antisym	100	0.076116	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @natinf => eq_ind_r (fun v2 : @natinf => forall (v3 : v2 = v0) (v4 : ni_min v1 v0 = v1), v0 = v1) (fun v2 : ni_min v1 v0 = v0 => eq_ind_r (fun v3 : @natinf => forall v4 : v3 = v1, v0 = v1) (fun v3 : v0 = v1 => v3) v2) (ni_min_comm v0 v1)) : forall (v0 v1 : @natinf) (v2 : ni_le v0 v1) (v3 : ni_le v1 v0), v0 = v1)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_trans	100	0.058232	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 : @natinf) (v3 : ni_min v0 v1 = v0) (v4 : ni_min v1 v2 = v1) => eq_ind (ni_min v0 v1) (fun v5 : @natinf => ni_min v5 v2 = v5) (eq_ind_r (fun v5 : @natinf => v5 = ni_min v0 v1) (eq_ind_r (fun v5 : @natinf => ni_min v0 v5 = ni_min v0 v1) eq_refl v4) (ni_min_assoc v0 v1 v2)) v0 v3) : forall (v0 v1 v2 : @natinf) (v3 : ni_le v0 v1) (v4 : ni_le v1 v2), ni_le v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_min_1	100	0.051028	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @natinf => eq_ind_r (fun v2 : @natinf => ni_min v2 v0 = v2) (eq_ind_r (fun v2 : @natinf => v2 = ni_min v1 v0) (eq_ind_r (fun v2 : @natinf => ni_min v1 v2 = ni_min v1 v0) eq_refl (ni_min_idemp v0)) (ni_min_assoc v1 v0 v0)) (ni_min_comm v0 v1)) : forall v0 v1 : @natinf, ni_le (ni_min v0 v1) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_min_2	100	0.090104	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @natinf => eq_ind_r (fun v2 : @natinf => v2 = ni_min v0 v1) (eq_ind_r (fun v2 : @natinf => ni_min v0 v2 = ni_min v0 v1) eq_refl (ni_min_idemp v1)) (ni_min_assoc v0 v1 v1)) : forall v0 v1 : @natinf, ni_le (ni_min v0 v1) v1)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_min_case	100	0.139282	1	1	0	synth with cache (only 1: refine (fun v0 : @natinf => match v0 as v1 in natinf return (forall v2 : @natinf, ni_min v1 v2 = v1 \/ ni_min v1 v2 = v2) with | infty => fun v1 : @natinf => or_intror (ni_min_inf_l v1) | ni v1 => (fun (v1 : @nat) (v2 : @natinf) => match v2 as v3 in natinf return (ni_min (ni v1) v3 = ni v1 \/ ni_min (ni v1) v3 = v3) with | infty => or_introl (ni_min_inf_r (ni v1)) | ni v3 => (fun v3 : @nat => (let v4 : Init.Nat.min v1 v3 = v1 \/ Init.Nat.min v1 v3 = v3 := let v4 : {Init.Nat.min v1 v3 = v1} + {Init.Nat.min v1 v3 = v3} := Nat.min_dec v1 v3 in match v4 as v5 in ({_} + {_}) return (Init.Nat.min v1 v3 = v1 \/ Init.Nat.min v1 v3 = v3) with | left v5 => (fun v5 : Init.Nat.min v1 v3 = v1 => or_introl v5) v5 | right v5 => (fun v5 : Init.Nat.min v1 v3 = v3 => or_intror v5) v5 end in match v4 as v5 in (_ \/ _) return (ni (Init.Nat.min v1 v3) = ni v1 \/ ni (Init.Nat.min v1 v3) = ni v3) with | or_introl v5 => (fun v5 : Init.Nat.min v1 v3 = v1 => eq_ind_r (fun v6 : @nat => ni v6 = ni v1 \/ ni v6 = ni v3) (or_introl eq_refl) v5) v5 | or_intror v5 => (fun v5 : Init.Nat.min v1 v3 = v3 => eq_ind_r (fun v6 : @nat => ni v6 = ni v1 \/ ni v6 = ni v3) (or_intror eq_refl) v5) v5 end) : ni_min (ni v1) (ni v3) = ni v1 \/ ni_min (ni v1) (ni v3) = ni v3) v3 end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_total	100	0.113439	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @natinf => eq_ind_r (fun v2 : @natinf => ni_min v0 v1 = v0 \/ v2 = v1) (ni_min_case v0 v1) (ni_min_comm v1 v0)) : forall v0 v1 : @natinf, ni_le v0 v1 \/ ni_le v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_min_induc	100	0.157802	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @natinf) (v3 : ni_le v2 v0) (v4 : ni_le v2 v1) (v5 : forall (v5 : @natinf) (v6 : ni_le v5 v0) (v7 : ni_le v5 v1), ni_le v5 v2) => match ni_min_case v0 v1 as v6 in (_ \/ _) return (ni_min v0 v1 = v2) with | or_introl v6 => (fun v6 : ni_min v0 v1 = v0 => eq_ind_r (fun v7 : @natinf => v7 = v2) (ni_le_antisym v0 v2 (v5 v0 (ni_le_refl v0) v6) v3) v6) v6 | or_intror v6 => (fun v6 : ni_min v0 v1 = v1 => eq_ind_r (fun v7 : @natinf => v7 = v2) (ni_le_antisym v1 v2 (v5 v1 (eq_ind_r (fun v7 : @natinf => v7 = v1) v6 (ni_min_comm v1 v0) : ni_le v1 v0) (ni_le_refl v1)) v4) v6) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.le_ni_le	100	0.045908	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @nat) (v2 : v0 <= v1) => (eq_ind_r (fun v3 : @nat => ni v3 = ni v0) eq_refl (Peano.min_l v0 v1 v2) : ni_min (ni v0) (ni v1) = ni v0) : ni_le (ni v0) (ni v1))).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.ni_le_le	100	0.090717	0	1
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_lb	100	0.091609	1	1	0	synth with cache (only 1: refine (fun v0 : @N => N_ind (fun v1 : @N => forall (v2 : @nat) (v3 : forall (v3 : @nat) (v4 : v3 < v2), BinNatDef.N.testbit_nat v1 v3 = @false), ni_le (ni v2) (Nplength v1)) (fun (v1 : @nat) (v2 : forall (v2 : @nat) (v3 : v2 < v1), BinNatDef.N.testbit_nat 0 v2 = @false) => ni_min_inf_r (ni v1)) (fun (v1 : @positive) (v2 : @nat) (v3 : forall (v3 : @nat) (v4 : v3 < v2), BinNatDef.N.testbit_nat (N.pos v1) v3 = @false) => le_ni_le v2 (Pplength v1) match Nat.le_gt_cases v2 (Pplength v1) as v4 in (_ \/ _) return (v2 <= Pplength v1) with | or_introl v4 => (fun v4 : v2 <= Pplength v1 => v4) v4 | or_intror v4 => (fun v4 : Pplength v1 < v2 => False_ind (v2 <= Pplength v1) (eq_ind_r (fun v5 : @bool => v5 <> @false) ((fun v5 : @true = @false => let v6 : @False := eq_ind (@true) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v5 in False_ind (@False) v6) : @true <> @false) (Nplength_one (N.pos v1) (Pplength v1) eq_refl) (v3 (Pplength v1) v4))) v4 end : ni_le (ni v2) (Nplength (N.pos v1))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_ub	100	0.088376	1	1	0	synth with cache (only 1: refine (fun v0 : @N => N_ind (fun v1 : @N => forall (v2 : @nat) (v3 : BinNatDef.N.testbit_nat v1 v2 = @true), ni_le (Nplength v1) (ni v2)) (fun (v1 : @nat) (v2 : BinNatDef.N.testbit_nat 0 v1 = @true) => let v3 : @False := eq_ind (BinNatDef.N.testbit_nat 0 v1) (fun v3 : @bool => match v3 as v4 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v2 in False_ind (ni_le (Nplength 0) (ni v1)) v3) (fun (v1 : @positive) (v2 : @nat) (v3 : BinNatDef.N.testbit_nat (N.pos v1) v2 = @true) => le_ni_le (Pplength v1) v2 match Nat.le_gt_cases (Pplength v1) v2 as v4 in (_ \/ _) return (Pplength v1 <= v2) with | or_introl v4 => (fun v4 : Pplength v1 <= v2 => v4) v4 | or_intror v4 => (fun v4 : v2 < Pplength v1 => False_ind (Pplength v1 <= v2) (eq_ind_r (fun v5 : @bool => v5 <> @true) ((fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@False) v6) : @false <> @true) (Nplength_zeros (N.pos v1) (Pplength v1) eq_refl v2 v4) v3)) v4 end : ni_le (Nplength (N.pos v1)) (ni v2)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Npdist_eq_1	100	0.040681	1	1	0	synth with cache (only 1: refine (fun v0 : @N => eq_ind_r (fun v1 : @N => Nplength v1 = @infty) eq_refl (N.lxor_nilpotent v0) : Npdist v0 v0 = @infty)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Npdist_eq_2	100	0.048668	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @N) (v2 : Npdist v0 v1 = @infty) => N.lxor_eq v0 v1 (Nplength_infty (BinNatDef.N.lxor v0 v1) v2))).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Npdist_comm	100	0.044998	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @N => eq_ind_r (fun v2 : @N => Nplength v2 = Nplength (BinNatDef.N.lxor v1 v0)) eq_refl (N.lxor_comm v0 v1)) : forall v0 v1 : @N, Npdist v0 v1 = Npdist v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_ultra_1	100	0.191425	1	1	0	synth with cache (only 1: refine (fun v0 : @N => N_ind (fun v1 : @N => forall (v2 : @N) (v3 : ni_le (Nplength v1) (Nplength v2)), ni_le (Nplength v1) (Nplength (BinNatDef.N.lxor v1 v2))) (fun (v1 : @N) (v2 : ni_le (Nplength 0) (Nplength v1)) => let v3 : Nplength v1 = @infty := eq_ind (ni_min (@infty) (Nplength v1)) (fun v3 : @natinf => v3 = @infty) v2 (Nplength v1) (ni_min_inf_l (Nplength v1)) in eq_ind_r (fun v4 : @N => ni_le (Nplength 0) (Nplength (BinNatDef.N.lxor 0 v4))) (ni_le_refl (@infty) : ni_le (Nplength 0) (Nplength (BinNatDef.N.lxor 0 0))) (Nplength_infty v1 v3)) (fun (v1 : @positive) (v2 : @N) (v3 : ni_le (Nplength (N.pos v1)) (Nplength v2)) => Nplength_lb (BinNatDef.N.lxor (N.pos v1) v2) (Pplength v1) (fun (v4 : @nat) (v5 : v4 < Pplength v1) => let v6 : forall (v6 : @N) (v7 : BinNatDef.N.lxor (N.pos v1) v2 = v6), BinNatDef.N.testbit_nat v6 v4 = @false := fun v6 : @N => match v6 as v7 in N return (forall v8 : BinNatDef.N.lxor (N.pos v1) v2 = v7, BinNatDef.N.testbit_nat v7 v4 = @false) with | 0%N => fun v7 : BinNatDef.N.lxor (N.pos v1) v2 = 0%N => eq_refl | N.pos v7 => (fun (v7 : @positive) (v8 : BinNatDef.N.lxor (N.pos v1) v2 = N.pos v7) => eq_ind (BinNatDef.N.lxor (N.pos v1) v2) (fun v9 : @N => BinNatDef.N.testbit_nat v9 v4 = @false) (eq_ind_r (fun v9 : @bool => v9 = @false) (eq_ind_r (fun v9 : @bool => xorb v9 (BinNatDef.N.testbit_nat v2 v4) = @false) (match v2 as v9 in N return (forall (v10 : ni_le (Nplength (N.pos v1)) (Nplength v9)) (v11 : BinNatDef.N.lxor (N.pos v1) v9 = N.pos v7), xorb (@false) (BinNatDef.N.testbit_nat v9 v4) = @false) with | 0%N => fun (v9 : ni_le (Nplength (N.pos v1)) (Nplength 0)) (v10 : BinNatDef.N.lxor (N.pos v1) 0 = N.pos v7) => eq_refl | N.pos v9 => (fun (v9 : @positive) (v10 : ni_le (Nplength (N.pos v1)) (Nplength (N.pos v9))) (v11 : BinNatDef.N.lxor (N.pos v1) (N.pos v9) = N.pos v7) => let v12 : BinNatDef.N.testbit_nat (N.pos v9) v4 = @false := Nplength_zeros (N.pos v9) (Pplength v9) eq_refl v4 (Nat.lt_le_trans v4 (Pplength v1) (Pplength v9) v5 (ni_le_le (Pplength v1) (Pplength v9) v10)) in eq_ind_r (fun v13 : @bool => xorb (@false) v13 = @false) eq_refl v12) v9 end v3 v8) (Nplength_zeros (N.pos v1) (Pplength v1) eq_refl v4 v5)) (Nxor_semantics (N.pos v1) v2 v4)) (N.pos v7) v8) v7 end in v6 (BinNatDef.N.lxor (N.pos v1) v2) eq_refl) : ni_le (Nplength (N.pos v1)) (Nplength (BinNatDef.N.lxor (N.pos v1) v2))) v0)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Nplength_ultra	100	0.081371	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @N => let v2 : ni_le (Nplength v0) (Nplength v1) \/ ni_le (Nplength v1) (Nplength v0) := ni_le_total (Nplength v0) (Nplength v1) in match v2 as v3 in (_ \/ _) return (ni_le (ni_min (Nplength v0) (Nplength v1)) (Nplength (BinNatDef.N.lxor v0 v1))) with | or_introl v3 => (fun v3 : ni_le (Nplength v0) (Nplength v1) => let v4 : ni_min (Nplength v0) (Nplength v1) = Nplength v0 := v3 in eq_ind_r (fun v5 : @natinf => ni_le v5 (Nplength (BinNatDef.N.lxor v0 v1))) (Nplength_ultra_1 v0 v1 v3) v4) v3 | or_intror v3 => (fun v3 : ni_le (Nplength v1) (Nplength v0) => let v4 : ni_min (Nplength v0) (Nplength v1) = Nplength v1 := eq_ind_r (fun v4 : @natinf => v4 = Nplength v1) v3 (ni_min_comm (Nplength v0) (Nplength v1)) in eq_ind_r (fun v5 : @natinf => ni_le v5 (Nplength (BinNatDef.N.lxor v0 v1))) (eq_ind_r (fun v5 : @N => ni_le (Nplength v1) (Nplength v5)) (Nplength_ultra_1 v1 v0 v3) (N.lxor_comm v0 v1)) v4) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.NArith.Ndist.Npdist_ultra	100	0.085876	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @N => (let v3 : BinNatDef.N.lxor (BinNatDef.N.lxor v0 v2) (BinNatDef.N.lxor v2 v1) = BinNatDef.N.lxor v0 v1 := eq_ind_r (fun v3 : @N => v3 = BinNatDef.N.lxor v0 v1) (eq_ind (BinNatDef.N.lxor (BinNatDef.N.lxor v2 v2) v1) (fun v3 : @N => BinNatDef.N.lxor v0 v3 = BinNatDef.N.lxor v0 v1) (eq_ind_r (fun v3 : @N => BinNatDef.N.lxor v0 (BinNatDef.N.lxor v3 v1) = BinNatDef.N.lxor v0 v1) (eq_ind_r (fun v3 : @N => BinNatDef.N.lxor v0 v3 = BinNatDef.N.lxor v0 v1) eq_refl (N.lxor_0_l v1)) (N.lxor_nilpotent v2)) (BinNatDef.N.lxor v2 (BinNatDef.N.lxor v2 v1)) (N.lxor_assoc v2 v2 v1)) (N.lxor_assoc v0 v2 (BinNatDef.N.lxor v2 v1)) in (fun v4 : BinNatDef.N.lxor (BinNatDef.N.lxor v0 v2) (BinNatDef.N.lxor v2 v1) = BinNatDef.N.lxor v0 v1 => eq_ind (BinNatDef.N.lxor (BinNatDef.N.lxor v0 v2) (BinNatDef.N.lxor v2 v1)) (fun v5 : @N => ni_le (ni_min (Nplength (BinNatDef.N.lxor v0 v2)) (Nplength (BinNatDef.N.lxor v2 v1))) (Nplength v5)) (Nplength_ultra (BinNatDef.N.lxor v0 v2) (BinNatDef.N.lxor v2 v1)) (BinNatDef.N.lxor v0 v1) v4) v3) : ni_le (ni_min (Npdist v0 v2) (Npdist v2 v1)) (Npdist v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Unsigned.of_to	100	0.060691	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @N => match v0 as v1 in N return (BinNatDef.N.of_uint (BinNatDef.N.to_uint v1) = v1) with | 0%N => eq_refl | N.pos v1 => (fun v1 : @positive => Unsigned.of_to v1) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Unsigned.to_of	100	0.059908	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @uint => Unsigned.to_of v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Unsigned.to_uint_inj	100	0.107972	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @N) (v2 : BinNatDef.N.to_uint v0 = BinNatDef.N.to_uint v1) => eq_ind (BinNatDef.N.of_uint (BinNatDef.N.to_uint v0)) (fun v3 : @N => v3 = v1) (eq_ind (BinNatDef.N.of_uint (BinNatDef.N.to_uint v1)) (fun v3 : @N => BinNatDef.N.of_uint (BinNatDef.N.to_uint v0) = v3) (eq_ind_r (fun v3 : @uint => BinNatDef.N.of_uint v3 = BinNatDef.N.of_uint (BinNatDef.N.to_uint v1)) eq_refl v2) v1 (of_to v1)) v0 (of_to v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Unsigned.to_uint_surj	100	0.076824	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @uint => ex_intro (fun v1 : @N => BinNatDef.N.to_uint v1 = unorm v0) (BinNatDef.N.of_uint v0) (to_of v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Unsigned.of_uint_norm	100	0.074843	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @uint => uint_ind (fun v1 : @uint => BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) eq_refl (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => v2) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) (fun (v1 : @uint) (v2 : BinNatDef.N.of_uint (unorm v1) = BinNatDef.N.of_uint v1) => eq_refl) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Unsigned.of_inj	100	0.070730	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @uint) (v2 : BinNatDef.N.of_uint v0 = BinNatDef.N.of_uint v1) => eq_ind (BinNatDef.N.to_uint (BinNatDef.N.of_uint v0)) (fun v3 : @uint => v3 = unorm v1) (eq_ind (BinNatDef.N.to_uint (BinNatDef.N.of_uint v1)) (fun v3 : @uint => BinNatDef.N.to_uint (BinNatDef.N.of_uint v0) = v3) (let v3 : BinNatDef.N.of_uint v0 = BinNatDef.N.of_uint v1 := v2 in (fun v4 : BinNatDef.N.of_uint v0 = BinNatDef.N.of_uint v1 => eq_trans (f_equal (fun v5 : forall v5 : @N, @uint => v5 (BinNatDef.N.of_uint v0)) eq_refl) (f_equal (@BinNatDef.N.to_uint) v4)) v3) (unorm v1) (to_of v1)) (unorm v0) (to_of v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Unsigned.of_iff	100	0.064521	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @uint => conj (of_inj v0 v1) (fun v2 : unorm v0 = unorm v1 => eq_ind (BinNatDef.N.of_uint (unorm v0)) (fun v3 : @N => v3 = BinNatDef.N.of_uint v1) (eq_ind_r (fun v3 : @uint => BinNatDef.N.of_uint v3 = BinNatDef.N.of_uint v1) (of_uint_norm v1) v2) (BinNatDef.N.of_uint v0) (of_uint_norm v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Signed.of_to	100	0.081144	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @N => (((let v1 : BinPosDef.Pos.of_uint (unorm (BinNatDef.N.to_uint v0)) = v0 := eq_ind_r (fun v1 : @N => v1 = v0) (Unsigned.of_to v0) (Unsigned.of_uint_norm (BinNatDef.N.to_uint v0)) in (let v2 : @N = @N := eq_refl in (fun (v3 : @N = @N) (v4 : BinPosDef.Pos.of_uint (unorm (BinNatDef.N.to_uint v0)) = v0) => eq_trans (f_equal (fun v5 : forall v5 : @N, option (@N) => v5 (BinPosDef.Pos.of_uint (unorm (BinNatDef.N.to_uint v0)))) eq_refl) (f_equal Some v4)) v2) v1) : match norm (Pos (BinNatDef.N.to_uint v0)) as v1 in int return (option (@N)) with | Pos v1 => (fun v1 : @uint => Some (BinPosDef.Pos.of_uint v1)) v1 | Neg v1 => (fun v1 : @uint => None) v1 end = Some v0) : BinNatDef.N.of_int (Pos (BinNatDef.N.to_uint v0)) = Some v0) : BinNatDef.N.of_int (BinNatDef.N.to_int v0) = Some v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Signed.to_of	100	0.317089	1	2
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Signed.to_int_inj	100	0.065724	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @N) (v2 : BinNatDef.N.to_int v0 = BinNatDef.N.to_int v1) => let v3 : Some v0 = Some v1 := eq_ind (BinNatDef.N.of_int (BinNatDef.N.to_int v0)) (fun v3 : option (@N) => v3 = Some v1) (eq_ind (BinNatDef.N.of_int (BinNatDef.N.to_int v1)) (fun v3 : option (@N) => BinNatDef.N.of_int (BinNatDef.N.to_int v0) = v3) (eq_ind_r (fun v3 : @int => BinNatDef.N.of_int v3 = BinNatDef.N.of_int (BinNatDef.N.to_int v1)) eq_refl v2) (Some v1) (of_to v1)) (Some v0) (of_to v0) in let v4 : v0 = v1 := f_equal (fun v4 : option (@N) => match v4 as v5 in (option _) return (@N) with | Some v5 => (fun v5 : @N => v5) v5 | None => v0 end) v3 in (fun v5 : v0 = v1 => v5) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Signed.to_int_pos_surj	100	0.051763	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @uint => ex_intro (fun v1 : @N => BinNatDef.N.to_int v1 = norm (Pos v0)) (BinNatDef.N.of_uint v0) (eq_ind_r (fun v1 : @uint => Pos v1 = norm (Pos v0)) eq_refl (Unsigned.to_of v0) : BinNatDef.N.to_int (BinNatDef.N.of_uint v0) = norm (Pos v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Signed.of_int_norm	100	0.074504	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @int => eq_ind_r (fun v1 : @int => match v1 as v2 in int return (option (@N)) with | Pos v2 => (fun v2 : @uint => Some (BinPosDef.Pos.of_uint v2)) v2 | Neg v2 => (fun v2 : @uint => None) v2 end = match norm v0 as v2 in int return (option (@N)) with | Pos v2 => (fun v2 : @uint => Some (BinPosDef.Pos.of_uint v2)) v2 | Neg v2 => (fun v2 : @uint => None) v2 end) eq_refl (norm_invol v0) : BinNatDef.N.of_int (norm v0) = BinNatDef.N.of_int v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.DecimalN.Signed.of_inj_pos	100	0.157421	1	2
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_sound	100	0.041468	1	1	0	synth with cache (only 1: refine (fun (v0 : Prop) (v1 : Decidable v0) (v2 : Decidable_witness = @true) => let v3 : Decidable_witness = @true <-> v0 := Decidable_spec in match v3 as v4 in (_ /\ _) return v0 with | conj v4 v5 => (fun (v4 : forall v4 : Decidable_witness = @true, v0) (v5 : forall v5 : v0, Decidable_witness = @true) => v4 v2) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_complete	100	0.042934	1	1	0	synth with cache (only 1: refine (fun (v0 : Prop) (v1 : Decidable v0) (v2 : v0) => let v3 : Decidable_witness = @true <-> v0 := Decidable_spec in match v3 as v4 in (_ /\ _) return (Decidable_witness = @true) with | conj v4 v5 => (fun (v4 : forall v4 : Decidable_witness = @true, v0) (v5 : forall v5 : v0, Decidable_witness = @true) => v5 v2) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_sound_alt	100	0.066798	1	1	0	synth with cache (only 1: refine (fun (v0 : Prop) (v1 : Decidable v0) => match v1 as v2 in (Decidable _) return (forall v3 : ~ v0, Decidable_witness = @false) with | {| Decidable_witness := v2; Decidable_spec := v3 |} => (fun (v2 : @bool) (v3 : v2 = @true <-> v0) (v4 : ~ v0) => match v2 as v5 in bool return (forall v6 : v5 = @true <-> v0, v5 = @false) with | true => fun v5 : @true = @true <-> v0 => and_ind (fun (v6 : forall v6 : @true = @true, v0) (v7 : forall v7 : v0, @true = @true) => let v8 : v0 := let v8 : @true = @true := eq_refl in v6 v8 in (fun v9 : v0 => let v10 : @False := v4 v9 in let v11 : @true = @true := v7 v9 in False_ind (@true = @false) v10) v8) v5 | false => fun v5 : @false = @true <-> v0 => and_ind (fun (v6 : forall v6 : @false = @true, v0) (v7 : forall v7 : v0, @false = @true) => eq_refl) v5 end v3 : Decidable_witness = @false) v2 v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_complete_alt	100	0.060670	1	1	0	synth with cache (only 1: refine (fun (v0 : Prop) (v1 : Decidable v0) => match v1 as v2 in (Decidable _) return (forall v3 : Decidable_witness = @false, ~ v0) with | {| Decidable_witness := v2; Decidable_spec := v3 |} => (fun (v2 : @bool) (v3 : v2 = @true <-> v0) (v4 : Decidable_witness = @false) => (fun v5 : v0 => and_ind (fun (v6 : forall v6 : v2 = @true, v0) (v7 : forall v7 : v0, v2 = @true) => let v8 : v2 = @true := v7 v5 in let v9 : v0 := v6 v8 in (let v10 : @true = @false := eq_trans (eq_sym v8) v4 in let v11 : @False := eq_ind (@true) (fun v11 : @bool => match v11 as v12 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v10 in False_ind (@False) v11) : @False) v3 : @False) : ~ v0) v2 v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_eq_bool_obligation_1	100	0.039564	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @bool => eqb_true_iff v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_eq_nat_obligation_1	100	0.050424	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => Nat.eqb_eq v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_le_nat_obligation_1	100	0.037037	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => Nat.leb_le v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Classes.DecidableClass.Decidable_eq_Z_obligation_1	100	0.046168	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => Z.eqb_eq v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetLogicalFacts.test_push	100	0.448722	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : decidable v0) (v4 : decidable v1) (v5 : ~ @True) (v6 : ~ @False) (v7 : ~ ~ v0) (v8 : forall v8 : ~ (v0 /\ v1), ~ v2) (v9 : v0 /\ v1 \/ ~ v2) (v10 : ~ (v0 /\ v1) \/ v2) (v11 : v2 \/ ~ (v0 /\ v1)) (v12 : ~ v2 \/ v0 /\ v1) (v13 : forall v13 : ~ v0, v2) (v14 : ~ ((forall v14 : v2, v0) \/ (forall v14 : v1, v2))) (v15 : ~ (v0 /\ v2)) (v16 : ~ (forall v16 : v0, v2)) => and_ind (fun (v17 : ~ (forall v17 : v2, v0)) (v18 : v1 /\ ~ v2) => and_ind (fun (v19 : v0) (v20 : ~ v2) => and_ind (fun (v21 : v1) (v22 : ~ v2) => or_ind (fun v23 : v0 => let v24 : ~ v2 := (fun v24 : (forall v24 : v0 /\ v2, @False) <-> (forall (v24 : v0) (v25 : v2), @False) => iff_impl_subrelation (forall v25 : v0 /\ v2, @False) (forall (v25 : v0) (v26 : v2), @False) v24) (not_and_iff v0 v2) v15 ((fun v24 : (forall v24 : forall v24 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v25 : forall v25 : v0, @False, @False) v0 v24) (not_not_iff v0 v3) v7) in let v25 : forall (v25 : v0) (v26 : v1), v2 := fun (v25 : v0) (v26 : v1) => (fun v27 : (forall v27 : v0 /\ v1, @False) \/ v2 <-> (forall v27 : v0 /\ v1, v2) => iff_impl_subrelation ((forall v28 : v0 /\ v1, @False) \/ v2) (forall v28 : v0 /\ v1, v2) v27) (or_not_l_iff_1 (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v10 (conj v25 v26) in let v26 : forall v26 : v1, v2 := v25 ((fun v26 : (forall v26 : forall v26 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v27 : forall v27 : v0, @False, @False) v0 v26) (not_not_iff v0 v3) v7) in let v27 : v2 := v26 v21 in let v28 : v0 /\ v1 := (fun v28 : (forall (v28 : forall v28 : v0 /\ v1, @False) (v29 : v2), @False) <-> (forall v28 : v2, v0 /\ v1) => iff_impl_subrelation (forall (v29 : forall v29 : v0 /\ v1, @False) (v30 : v2), @False) (forall v29 : v2, v0 /\ v1) v28) (contrapositive (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v8 v27 in and_ind (fun (v29 : v0) (v30 : v1) => let v31 : v0 /\ v1 := (fun v31 : v0 /\ v1 \/ (forall v31 : v2, @False) <-> (forall v31 : v2, v0 /\ v1) => iff_impl_subrelation (v0 /\ v1 \/ (forall v32 : v2, @False)) (forall v32 : v2, v0 /\ v1) v31) (or_not_r_iff_1 (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v9 v27 in and_ind (fun (v32 : v0) (v33 : v1) => let v34 : v0 /\ v1 := (fun v34 : (forall v34 : v2, @False) \/ v0 /\ v1 <-> (forall v34 : v2, v0 /\ v1) => iff_impl_subrelation ((forall v35 : v2, @False) \/ v0 /\ v1) (forall v35 : v2, v0 /\ v1) v34) (or_not_l_iff_2 v2 (v0 /\ v1) (dec_and v0 v1 v3 v4)) v12 v27 in and_ind (fun (v35 : v0) (v36 : v1) => let v37 : @False := v20 v27 in let v38 : @False := v22 v27 in let v39 : @False := v24 v27 in let v40 : forall (v40 : v0) (v41 : v1), v2 := fun (v40 : v0) (v41 : v1) => (fun v42 : v2 \/ (forall v42 : v0 /\ v1, @False) <-> (forall v42 : v0 /\ v1, v2) => iff_impl_subrelation (v2 \/ (forall v43 : v0 /\ v1, @False)) (forall v43 : v0 /\ v1, v2) v42) (or_not_r_iff_2 v2 (v0 /\ v1) (dec_and v0 v1 v3 v4)) v11 (conj v40 v41) in let v41 : forall v41 : v1, v2 := v40 ((fun v41 : (forall v41 : forall v41 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v42 : forall v42 : v0, @False, @False) v0 v41) (not_not_iff v0 v3) v7) in let v42 : v2 := v41 v21 in @I) v34) v31) v28) (fun v23 : v2 => let v24 : ~ v2 := (fun v24 : (forall v24 : v0 /\ v2, @False) <-> (forall (v24 : v0) (v25 : v2), @False) => iff_impl_subrelation (forall v25 : v0 /\ v2, @False) (forall (v25 : v0) (v26 : v2), @False) v24) (not_and_iff v0 v2) v15 ((fun v24 : (forall v24 : forall v24 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v25 : forall v25 : v0, @False, @False) v0 v24) (not_not_iff v0 v3) v7) in let v25 : v0 /\ v1 := (fun v25 : (forall (v25 : forall v25 : v0 /\ v1, @False) (v26 : v2), @False) <-> (forall v25 : v2, v0 /\ v1) => iff_impl_subrelation (forall (v26 : forall v26 : v0 /\ v1, @False) (v27 : v2), @False) (forall v26 : v2, v0 /\ v1) v25) (contrapositive (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v8 v23 in and_ind (fun (v26 : v0) (v27 : v1) => let v28 : v0 /\ v1 := (fun v28 : v0 /\ v1 \/ (forall v28 : v2, @False) <-> (forall v28 : v2, v0 /\ v1) => iff_impl_subrelation (v0 /\ v1 \/ (forall v29 : v2, @False)) (forall v29 : v2, v0 /\ v1) v28) (or_not_r_iff_1 (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v9 v23 in and_ind (fun (v29 : v0) (v30 : v1) => let v31 : v0 /\ v1 := (fun v31 : (forall v31 : v2, @False) \/ v0 /\ v1 <-> (forall v31 : v2, v0 /\ v1) => iff_impl_subrelation ((forall v32 : v2, @False) \/ v0 /\ v1) (forall v32 : v2, v0 /\ v1) v31) (or_not_l_iff_2 v2 (v0 /\ v1) (dec_and v0 v1 v3 v4)) v12 v23 in and_ind (fun (v32 : v0) (v33 : v1) => let v34 : @False := v20 v23 in let v35 : @False := v22 v23 in let v36 : @False := v24 v23 in let v37 : forall (v37 : v0) (v38 : v1), v2 := fun (v37 : v0) (v38 : v1) => (fun v39 : (forall v39 : v0 /\ v1, @False) \/ v2 <-> (forall v39 : v0 /\ v1, v2) => iff_impl_subrelation ((forall v40 : v0 /\ v1, @False) \/ v2) (forall v40 : v0 /\ v1, v2) v39) (or_not_l_iff_1 (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v10 (conj v37 v38) in let v38 : forall v38 : v1, v2 := v37 ((fun v38 : (forall v38 : forall v38 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v39 : forall v39 : v0, @False, @False) v0 v38) (not_not_iff v0 v3) v7) in let v39 : v2 := v38 v21 in let v40 : forall (v40 : v0) (v41 : v1), v2 := fun (v40 : v0) (v41 : v1) => (fun v42 : v2 \/ (forall v42 : v0 /\ v1, @False) <-> (forall v42 : v0 /\ v1, v2) => iff_impl_subrelation (v2 \/ (forall v43 : v0 /\ v1, @False)) (forall v43 : v0 /\ v1, v2) v42) (or_not_r_iff_2 v2 (v0 /\ v1) (dec_and v0 v1 v3 v4)) v11 (conj v40 v41) in let v41 : forall v41 : v1, v2 := v40 ((fun v41 : (forall v41 : forall v41 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v42 : forall v42 : v0, @False, @False) v0 v41) (not_not_iff v0 v3) v7) in let v42 : v2 := v41 v21 in @I) v31) v28) v25) ((fun v23 : (forall v23 : forall v23 : v0, @False, v2) <-> v0 \/ v2 => iff_impl_subrelation (forall v24 : forall v24 : v0, @False, v2) (v0 \/ v2) v23) (imp_not_l v0 v2 v3) v13)) v18) ((fun v19 : (forall v19 : forall v19 : v0, v2, @False) <-> v0 /\ (forall v19 : v2, @False) => iff_impl_subrelation (forall v20 : forall v20 : v0, v2, @False) (v0 /\ (forall v20 : v2, @False)) v19) (not_imp_iff v0 v2 v3) v16)) ((fun v17 : (forall v17 : forall v17 : v1, v2, @False) <-> v1 /\ (forall v17 : v2, @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (forall v18 : forall v18 : v2, v0, @False)) (forall v18 : forall v18 : v1, v2, @False) (v1 /\ (forall v18 : v2, @False)) v17) (not_imp_iff v1 v2 v4) ((fun v17 : (forall v17 : (forall v17 : v2, v0) \/ (forall v17 : v1, v2), @False) <-> (forall v17 : forall v17 : v2, v0, @False) /\ (forall v17 : forall v17 : v1, v2, @False) => iff_impl_subrelation (forall v18 : (forall v18 : v2, v0) \/ (forall v18 : v1, v2), @False) ((forall v18 : forall v18 : v2, v0, @False) /\ (forall v18 : forall v18 : v1, v2, @False)) v17) (not_or_iff (forall v17 : v2, v0) (forall v17 : v1, v2)) v14)) : @True)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetLogicalFacts.test_pull	100	0.340377	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : decidable v0) (v4 : decidable v1) (v5 : ~ @True) (v6 : ~ @False) (v7 : ~ ~ v0) (v8 : forall v8 : ~ (v0 /\ v1), ~ v2) (v9 : v0 /\ v1 \/ ~ v2) (v10 : ~ (v0 /\ v1) \/ v2) (v11 : v2 \/ ~ (v0 /\ v1)) (v12 : ~ v2 \/ v0 /\ v1) (v13 : forall v13 : ~ v0, v2) (v14 : ~ (forall v14 : v2, v0) /\ ~ (forall v14 : v1, v2)) (v15 : ~ v0 \/ ~ v2) (v16 : v0 /\ ~ v2) (v17 : ~ v2 /\ v0) => or_ind (fun v18 : v0 => let v19 : forall (v19 : v0) (v20 : v1), v2 := fun (v19 : v0) (v20 : v1) => (fun v21 : (forall v21 : v0 /\ v1, @False) \/ v2 <-> (forall v21 : v0 /\ v1, v2) => iff_impl_subrelation ((forall v22 : v0 /\ v1, @False) \/ v2) (forall v22 : v0 /\ v1, v2) v21) (or_not_l_iff_1 (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v10 (conj v19 v20) in let v20 : forall v20 : v1, v2 := v19 ((fun v20 : (forall v20 : forall v20 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v21 : forall v21 : v0, @False, @False) v0 v20) (not_not_iff v0 v3) v7) in let v21 : forall (v21 : v0) (v22 : v1), v2 := fun (v21 : v0) (v22 : v1) => (fun v23 : v2 \/ (forall v23 : v0 /\ v1, @False) <-> (forall v23 : v0 /\ v1, v2) => iff_impl_subrelation (v2 \/ (forall v24 : v0 /\ v1, @False)) (forall v24 : v0 /\ v1, v2) v23) (or_not_r_iff_2 v2 (v0 /\ v1) (dec_and v0 v1 v3 v4)) v11 (conj v21 v22) in let v22 : forall v22 : v1, v2 := v21 ((fun v22 : (forall v22 : forall v22 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v23 : forall v23 : v0, @False, @False) v0 v22) (not_not_iff v0 v3) v7) in let v23 : forall (v23 : v0) (v24 : v2), @False := fun (v23 : v0) (v24 : v2) => (fun v25 : (forall v25 : v0 /\ v2, @False) <-> (forall (v25 : v0) (v26 : v2), @False) => iff_impl_subrelation (forall (v26 : v0) (v27 : v2), @False) (forall v26 : v0 /\ v2, @False) (symmetry v25)) (not_and_iff v0 v2) ((fun v25 : (forall v25 : v0, @False) \/ (forall v25 : v2, @False) <-> (forall (v25 : v0) (v26 : v2), @False) => iff_impl_subrelation ((forall v26 : v0, @False) \/ (forall v26 : v2, @False)) (forall (v26 : v0) (v27 : v2), @False) v25) (or_not_l_iff_1 v0 (forall v25 : v2, @False) v3) v15) (conj v23 v24) in let v24 : forall v24 : v2, @False := v23 ((fun v24 : (forall v24 : forall v24 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v25 : forall v25 : v0, @False, @False) v0 v24) (not_not_iff v0 v3) v7) in let v25 : forall v25 : forall v25 : v2, v0, @False := fun v25 : forall v25 : v2, v0 => (fun v26 : (forall v26 : (forall v26 : v2, v0) \/ (forall v26 : v1, v2), @False) <-> (forall v26 : forall v26 : v2, v0, @False) /\ (forall v26 : forall v26 : v1, v2, @False) => iff_impl_subrelation ((forall v27 : forall v27 : v2, v0, @False) /\ (forall v27 : forall v27 : v1, v2, @False)) (forall v27 : (forall v27 : v2, v0) \/ (forall v27 : v1, v2), @False) (symmetry v26)) (not_or_iff (forall v26 : v2, v0) (forall v26 : v1, v2)) v14 (or_introl v25) in let v26 : forall v26 : forall v26 : v1, v2, @False := fun v26 : forall v26 : v1, v2 => (fun v27 : (forall v27 : (forall v27 : v2, v0) \/ (forall v27 : v1, v2), @False) <-> (forall v27 : forall v27 : v2, v0, @False) /\ (forall v27 : forall v27 : v1, v2, @False) => iff_impl_subrelation ((forall v28 : forall v28 : v2, v0, @False) /\ (forall v28 : forall v28 : v1, v2, @False)) (forall v28 : (forall v28 : v2, v0) \/ (forall v28 : v1, v2), @False) (symmetry v27)) (not_or_iff (forall v27 : v2, v0) (forall v27 : v1, v2)) v14 (or_intror v26) in let v27 : @False := v26 v20 in @I) (fun v18 : v2 => let v19 : v0 /\ v1 := (fun v19 : (forall (v19 : forall v19 : v0 /\ v1, @False) (v20 : v2), @False) <-> (forall v19 : v2, v0 /\ v1) => iff_impl_subrelation (forall (v20 : forall v20 : v0 /\ v1, @False) (v21 : v2), @False) (forall v20 : v2, v0 /\ v1) v19) (contrapositive (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v8 v18 in and_ind (fun (v20 : v0) (v21 : v1) => let v22 : v0 /\ v1 := (fun v22 : v0 /\ v1 \/ (forall v22 : v2, @False) <-> (forall v22 : v2, v0 /\ v1) => iff_impl_subrelation (v0 /\ v1 \/ (forall v23 : v2, @False)) (forall v23 : v2, v0 /\ v1) v22) (or_not_r_iff_1 (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v9 v18 in and_ind (fun (v23 : v0) (v24 : v1) => let v25 : v0 /\ v1 := (fun v25 : (forall v25 : v2, @False) \/ v0 /\ v1 <-> (forall v25 : v2, v0 /\ v1) => iff_impl_subrelation ((forall v26 : v2, @False) \/ v0 /\ v1) (forall v26 : v2, v0 /\ v1) v25) (or_not_l_iff_2 v2 (v0 /\ v1) (dec_and v0 v1 v3 v4)) v12 v18 in and_ind (fun (v26 : v0) (v27 : v1) => let v28 : forall (v28 : v0) (v29 : v1), v2 := fun (v28 : v0) (v29 : v1) => (fun v30 : (forall v30 : v0 /\ v1, @False) \/ v2 <-> (forall v30 : v0 /\ v1, v2) => iff_impl_subrelation ((forall v31 : v0 /\ v1, @False) \/ v2) (forall v31 : v0 /\ v1, v2) v30) (or_not_l_iff_1 (v0 /\ v1) v2 (dec_and v0 v1 v3 v4)) v10 (conj v28 v29) in let v29 : forall v29 : v1, v2 := v28 ((fun v29 : (forall v29 : forall v29 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v30 : forall v30 : v0, @False, @False) v0 v29) (not_not_iff v0 v3) v7) in let v30 : v2 := v29 v21 in let v31 : forall (v31 : v0) (v32 : v1), v2 := fun (v31 : v0) (v32 : v1) => (fun v33 : v2 \/ (forall v33 : v0 /\ v1, @False) <-> (forall v33 : v0 /\ v1, v2) => iff_impl_subrelation (v2 \/ (forall v34 : v0 /\ v1, @False)) (forall v34 : v0 /\ v1, v2) v33) (or_not_r_iff_2 v2 (v0 /\ v1) (dec_and v0 v1 v3 v4)) v11 (conj v31 v32) in let v32 : forall v32 : v1, v2 := v31 ((fun v32 : (forall v32 : forall v32 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v33 : forall v33 : v0, @False, @False) v0 v32) (not_not_iff v0 v3) v7) in let v33 : v2 := v32 v21 in let v34 : forall (v34 : v0) (v35 : v2), @False := fun (v34 : v0) (v35 : v2) => (fun v36 : (forall v36 : v0 /\ v2, @False) <-> (forall (v36 : v0) (v37 : v2), @False) => iff_impl_subrelation (forall (v37 : v0) (v38 : v2), @False) (forall v37 : v0 /\ v2, @False) (symmetry v36)) (not_and_iff v0 v2) ((fun v36 : (forall v36 : v0, @False) \/ (forall v36 : v2, @False) <-> (forall (v36 : v0) (v37 : v2), @False) => iff_impl_subrelation ((forall v37 : v0, @False) \/ (forall v37 : v2, @False)) (forall (v37 : v0) (v38 : v2), @False) v36) (or_not_l_iff_1 v0 (forall v36 : v2, @False) v3) v15) (conj v34 v35) in let v35 : forall v35 : v2, @False := v34 ((fun v35 : (forall v35 : forall v35 : v0, @False, @False) <-> v0 => iff_impl_subrelation (forall v36 : forall v36 : v0, @False, @False) v0 v35) (not_not_iff v0 v3) v7) in let v36 : @False := v35 v18 in let v37 : forall v37 : forall v37 : v2, v0, @False := fun v37 : forall v37 : v2, v0 => (fun v38 : (forall v38 : (forall v38 : v2, v0) \/ (forall v38 : v1, v2), @False) <-> (forall v38 : forall v38 : v2, v0, @False) /\ (forall v38 : forall v38 : v1, v2, @False) => iff_impl_subrelation ((forall v39 : forall v39 : v2, v0, @False) /\ (forall v39 : forall v39 : v1, v2, @False)) (forall v39 : (forall v39 : v2, v0) \/ (forall v39 : v1, v2), @False) (symmetry v38)) (not_or_iff (forall v38 : v2, v0) (forall v38 : v1, v2)) v14 (or_introl v37) in let v38 : forall v38 : forall v38 : v1, v2, @False := fun v38 : forall v38 : v1, v2 => (fun v39 : (forall v39 : (forall v39 : v2, v0) \/ (forall v39 : v1, v2), @False) <-> (forall v39 : forall v39 : v2, v0, @False) /\ (forall v39 : forall v39 : v1, v2, @False) => iff_impl_subrelation ((forall v40 : forall v40 : v2, v0, @False) /\ (forall v40 : forall v40 : v1, v2, @False)) (forall v40 : (forall v40 : v2, v0) \/ (forall v40 : v1, v2), @False) (symmetry v39)) (not_or_iff (forall v39 : v2, v0) (forall v39 : v1, v2)) v14 (or_intror v38) in @I) v25) v22) v19) ((fun v18 : (forall v18 : forall v18 : v0, @False, v2) <-> v0 \/ v2 => iff_impl_subrelation (forall v19 : forall v19 : v0, @False, v2) (v0 \/ v2) v18) (imp_not_l v0 v2 v3) v13) : @True)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideAuxiliary.eq_refl_iff	100	0.042882	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @E.t => conj (fun v1 : E.eq v0 v0 => @I) (fun v1 : @True => E.eq_refl v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideAuxiliary.dec_In	100	0.080716	1	1	0	synth with cache (only 1: refine ((fun (v0 : @elt) (v1 : @t) => match mem v0 v1 as v2 in bool return (forall v3 : In v0 v1 <-> v2 = @true, In v0 v1 \/ ~ In v0 v1) with | true => fun v2 : In v0 v1 <-> @true = @true => and_ind (fun (v3 : forall v3 : In v0 v1, @true = @true) (v4 : forall v4 : @true = @true, In v0 v1) => let v5 : In v0 v1 := let v5 : @true = @true := Logic.eq_refl in v4 v5 in (fun v6 : In v0 v1 => let v7 : @true = @true := v3 v6 in or_introl v6) v5) v2 | false => fun v2 : In v0 v1 <-> @false = @true => and_ind (fun (v3 : forall v3 : In v0 v1, @false = @true) (v4 : forall v4 : @false = @true, In v0 v1) => or_intror ((fun v5 : In v0 v1 => let v6 : @false = @true := v3 v5 in let v7 : In v0 v1 := v4 v6 in diff_false_true v6 : @False) : ~ In v0 v1)) v2 end (F.mem_iff v1 v0)) : forall (v0 : @elt) (v1 : @t), decidable (In v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideAuxiliary.dec_eq	100	0.053553	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @E.t => let v2 : {E.eq v0 v1} + {~ E.eq v0 v1} := E.eq_dec v0 v1 in match v2 as v3 in ({_} + {_}) return (E.eq v0 v1 \/ ~ E.eq v0 v1) with | left v3 => (fun v3 : E.eq v0 v1 => or_introl v3) v3 | right v3 => (fun v3 : ~ E.eq v0 v1 => or_intror v3) v3 end) : forall v0 v1 : @E.t, decidable (E.eq v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_eq_trans_1	100	0.090712	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 : @E.t) (v3 : @t) (v4 : E.eq v0 v1) (v5 : ~ ~ E.eq v2 v1) (v6 : In v0 v3) => (((((fun v7 : E.eq v2 v1 => subrelation_proper (@F.In_m) (@tt) (subrelation_respectful (subrelation_refl (@E.eq)) (subrelation_respectful (subrelation_refl (@Equal)) (@iff_flip_impl_subrelation))) v2 v1 v7 v3 v3 (reflexive_proper_proxy Equivalence_Reflexive v3)) ((fun v7 : (forall v7 : forall v7 : E.eq v2 v1, @False, @False) <-> E.eq v2 v1 => iff_impl_subrelation (forall v8 : forall v8 : E.eq v2 v1, @False, @False) (E.eq v2 v1) v7) (not_not_iff (E.eq v2 v1) (dec_eq v2 v1)) v5) ((fun v7 : E.eq v0 v1 => F.In_s_m v7 (x0:=v3) (y0:=v3) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v3)) v4 v6) : In v2 v3) : In v2 v3) : In v2 v3) : In v2 v3) : In v2 v3) : forall (v0 v1 v2 : @E.t) (v3 : @t) (v4 : E.eq v0 v1) (v5 : ~ ~ E.eq v2 v1) (v6 : In v0 v3), In v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_eq_trans_2	100	0.130481	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 : @elt) (v3 v4 : @t) (v5 : In v0 (singleton v1)) (v6 : ~ In v2 v3) (v7 : ~ ~ In v2 (add v1 v3)) (v8 : In v0 v4) => (((((let v9 : In v2 v3 \/ ~ In v2 v3 := dec_In v2 v3 in or_ind (fun v10 : E.eq v0 v2 => (fun v11 : E.eq v0 v2 => F.In_s_m v11 (x0:=v4) (y0:=v4) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v4)) v10 v8 : In v2 v4) (fun v10 : In v2 v3 => let v11 : @False := v6 v10 in False_ind (In v2 v4) v11) ((fun v10 : E.eq v1 v0 => subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v1 v2) (E.eq v0 v2) (PER_morphism (Equivalence_PER (@F.E_ST)) v1 v0 v10 v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2)) (In v2 v3) (In v2 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v3))) ((fun v10 : In v0 (singleton v1) <-> E.eq v1 v0 => iff_impl_subrelation (In v0 (singleton v1)) (E.eq v1 v0) v10) (F.singleton_iff v1 v0) v5) ((fun v10 : (forall v10 : forall v10 : E.eq v1 v2 \/ In v2 v3, @False, @False) <-> E.eq v1 v2 \/ In v2 v3 => iff_impl_subrelation (forall v11 : forall v11 : E.eq v1 v2 \/ In v2 v3, @False, @False) (E.eq v1 v2 \/ In v2 v3) v10) (not_not_iff (E.eq v1 v2 \/ In v2 v3) (dec_or (E.eq v1 v2) (In v2 v3) (dec_eq v1 v2) (dec_In v2 v3))) ((fun v10 : In v2 (add v1 v3) <-> E.eq v1 v2 \/ In v2 v3 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (forall v11 : In v2 (add v1 v3), @False) (forall v11 : E.eq v1 v2 \/ In v2 v3, @False) (Morphisms_Prop.iff_iff_iff_impl_morphism (In v2 (add v1 v3)) (E.eq v1 v2 \/ In v2 v3) v10 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.add_iff v3 v1 v2) v7)))) : In v2 v4) : In v2 v4) : In v2 v4) : In v2 v4) : In v2 v4) : forall (v0 v1 v2 : @elt) (v3 v4 : @t) (v5 : In v0 (singleton v1)) (v6 : ~ In v2 v3) (v7 : ~ ~ In v2 (add v1 v3)) (v8 : In v0 v4), In v2 v4)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_eq_neq_trans_1	100	0.114245	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 v3 : @E.t) (v4 : @t) (v5 : E.eq v1 v0) (v6 : ~ ~ E.eq v1 v2) (v7 : ~ E.eq v2 v3) (v8 : In v0 v4) => ((((fun v9 : In v0 (remove v3 v4) <-> In v0 v4 /\ ~ E.eq v3 v0 => iff_flip_impl_subrelation (In v0 (remove v3 v4)) (In v0 v4 /\ ~ E.eq v3 v0) v9) (F.remove_iff v4 v3 v0) (((let v9 : E.eq v0 v3 \/ ~ E.eq v0 v3 := dec_eq v0 v3 in let v10 : E.eq v3 v0 \/ ~ E.eq v3 v0 := dec_eq v3 v0 in conj v8 ((fun v11 : E.eq v3 v0 => (fun v12 : E.eq v2 v0 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)) (E.eq v2 v3) (E.eq v0 v3) (PER_morphism (Equivalence_PER (@F.E_ST)) v2 v0 v12 v3 v3 (reflexive_proper_proxy Equivalence_Reflexive v3))) ((fun v12 : E.eq v1 v2 => subrelation_proper (PER_morphism (Equivalence_PER (@F.E_ST))) (@tt) (subrelation_respectful (subrelation_refl (@E.eq)) (subrelation_respectful (subrelation_refl (@E.eq)) (@iff_impl_subrelation))) v1 v2 v12 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) ((fun v12 : (forall v12 : forall v12 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => iff_impl_subrelation (forall v13 : forall v13 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v12) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) v6) v5) v7 (E.eq_sym v11)) : ~ E.eq v3 v0)) : In v0 v4 /\ (forall v9 : E.eq v3 v0, @False)) : In v0 v4 /\ ~ E.eq v3 v0) : In v0 (remove v3 v4)) : In v0 (remove v3 v4)) : In v0 (remove v3 v4)) : In v0 (remove v3 v4)) : forall (v0 v1 v2 v3 : @E.t) (v4 : @t) (v5 : E.eq v1 v0) (v6 : ~ ~ E.eq v1 v2) (v7 : ~ E.eq v2 v3) (v8 : In v0 v4), In v0 (remove v3 v4))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_eq_neq_trans_2	100	0.390995	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 v3 : @elt) (v4 v5 v6 : @t) (v7 : In v1 (singleton v0)) (v8 : ~ In v1 v4) (v9 : In v1 (add v2 v4)) (v10 : In v2 v5) (v11 : In v2 (remove v3 v5)) (v12 : In v0 v6) => ((((fun v13 : In v0 (remove v3 v6) <-> In v0 v6 /\ ~ E.eq v3 v0 => iff_flip_impl_subrelation (In v0 (remove v3 v6)) (In v0 v6 /\ ~ E.eq v3 v0) v13) (F.remove_iff v6 v3 v0) (((fun v13 : E.eq v0 v1 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (In v0 v6) (In v1 v6) (F.In_m v13 (x0:=v6) (y0:=v6) (reflexive_proper_proxy Equivalence_Reflexive v6)) (~ E.eq v3 v0) (~ E.eq v3 v1) (Morphisms_Prop.not_iff_morphism (E.eq v3 v0) (E.eq v3 v1) (per_partial_app_morphism (Equivalence_PER (@F.E_ST)) v0 v1 v13))) ((fun v13 : In v1 (singleton v0) <-> E.eq v0 v1 => iff_impl_subrelation (In v1 (singleton v0)) (E.eq v0 v1) v13) (F.singleton_iff v0 v1) v7) (let v13 : E.eq v3 v2 \/ ~ E.eq v3 v2 := dec_eq v3 v2 in let v14 : In v1 v4 \/ ~ In v1 v4 := dec_In v1 v4 in let v15 : E.eq v3 v1 \/ ~ E.eq v3 v1 := dec_eq v3 v1 in and_ind (fun (v16 : In v2 v5) (v17 : ~ E.eq v3 v2) => or_ind (fun v18 : E.eq v2 v1 => or_ind (fun v19 : E.eq v3 v2 => or_ind (fun v20 : E.eq v3 v1 => let v21 : @False := v17 v19 in conj (False_ind (In v1 v6) v21) ((fun v22 : E.eq v3 v1 => False_ind (@False) v21) : ~ E.eq v3 v1)) (fun v20 : ~ E.eq v3 v1 => let v21 : @False := v17 v19 in conj (False_ind (In v1 v6) v21) ((fun v22 : E.eq v3 v1 => let v23 : @False := v20 v22 in False_ind (@False) v23) : ~ E.eq v3 v1)) v15) (fun v19 : ~ E.eq v3 v2 => or_ind (fun v20 : E.eq v3 v1 => conj ((fun v21 : E.eq v0 v1 => F.In_s_m v21 (x0:=v6) (y0:=v6) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v6)) ((fun v21 : In v1 (singleton v0) <-> E.eq v0 v1 => iff_impl_subrelation (In v1 (singleton v0)) (E.eq v0 v1) v21) (F.singleton_iff v0 v1) v7) v12) ((fun v21 : E.eq v3 v1 => (let v22 : @False := let v22 : @True := @I in (fun v23 : E.eq v1 v1 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v1 v1) (@True) v23 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (eq_refl_iff v1) ((fun v23 : E.eq v2 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v1 v2) (E.eq v1 v1) (per_partial_app_morphism (Equivalence_PER (@F.E_ST)) v2 v1 v23) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) v18 ((fun v23 : E.eq v3 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v3 v2) (E.eq v1 v2) (PER_morphism (Equivalence_PER (@F.E_ST)) v3 v1 v23 v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2)) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) v21 v17)) v22 in (fun v23 : @False => let v24 : @False := let v24 : @True := @I in (fun v25 : E.eq v1 v1 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v1 v1) (@True) v25 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (eq_refl_iff v1) ((fun v25 : E.eq v2 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v1 v2) (E.eq v1 v1) (per_partial_app_morphism (Equivalence_PER (@F.E_ST)) v2 v1 v25) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) v18 ((fun v25 : E.eq v3 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v3 v2) (E.eq v1 v2) (PER_morphism (Equivalence_PER (@F.E_ST)) v3 v1 v25 v2 v2 (reflexive_proper_proxy Equivalence_Reflexive v2)) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) v21 v19)) v24 in (fun v25 : @False => False_ind (@False) v25) v24) v22) : @False) : ~ E.eq v3 v1)) (fun v20 : ~ E.eq v3 v1 => conj ((fun v21 : E.eq v0 v1 => F.In_s_m v21 (x0:=v6) (y0:=v6) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v6)) ((fun v21 : In v1 (singleton v0) <-> E.eq v0 v1 => iff_impl_subrelation (In v1 (singleton v0)) (E.eq v0 v1) v21) (F.singleton_iff v0 v1) v7) v12) ((fun v21 : E.eq v3 v1 => let v22 : @False := v20 v21 in False_ind (@False) v22) : ~ E.eq v3 v1)) v15) v13) (fun v18 : In v1 v4 => or_ind (fun v19 : E.eq v3 v2 => or_ind (fun v20 : E.eq v3 v1 => let v21 : @False := v8 v18 in let v22 : @False := v17 v19 in conj (False_ind (In v1 v6) v22) ((fun v23 : E.eq v3 v1 => False_ind (@False) v22) : ~ E.eq v3 v1)) (fun v20 : ~ E.eq v3 v1 => let v21 : @False := v8 v18 in let v22 : @False := v17 v19 in conj (False_ind (In v1 v6) v22) ((fun v23 : E.eq v3 v1 => let v24 : @False := v20 v23 in False_ind (@False) v24) : ~ E.eq v3 v1)) v15) (fun v19 : ~ E.eq v3 v2 => or_ind (fun v20 : E.eq v3 v1 => let v21 : @False := v8 v18 in conj (False_ind (In v1 v6) v21) ((fun v22 : E.eq v3 v1 => False_ind (@False) v21) : ~ E.eq v3 v1)) (fun v20 : ~ E.eq v3 v1 => let v21 : @False := v8 v18 in conj (False_ind (In v1 v6) v21) ((fun v22 : E.eq v3 v1 => let v23 : @False := v20 v22 in False_ind (@False) v23) : ~ E.eq v3 v1)) v15) v13) ((fun v18 : In v1 (add v2 v4) <-> E.eq v2 v1 \/ In v1 v4 => iff_impl_subrelation (In v1 (add v2 v4)) (E.eq v2 v1 \/ In v1 v4) v18) (F.add_iff v4 v2 v1) v9)) ((fun v16 : In v2 (remove v3 v5) <-> In v2 v5 /\ ~ E.eq v3 v2 => iff_impl_subrelation (In v2 (remove v3 v5)) (In v2 v5 /\ ~ E.eq v3 v2) v16) (F.remove_iff v5 v3 v2) v11)) : In v0 v6 /\ (forall v13 : E.eq v3 v0, @False)) : In v0 v6 /\ ~ E.eq v3 v0) : In v0 (remove v3 v6)) : In v0 (remove v3 v6)) : In v0 (remove v3 v6)) : In v0 (remove v3 v6)) : forall (v0 v1 v2 v3 : @elt) (v4 v5 v6 : @t) (v7 : In v1 (singleton v0)) (v8 : ~ In v1 v4) (v9 : In v1 (add v2 v4)) (v10 : In v2 v5) (v11 : In v2 (remove v3 v5)) (v12 : In v0 v6), In v0 (remove v3 v6))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_In_singleton	100	0.048060	1	1	0	synth with cache (only 1: refine ((fun v0 : @elt => ((((fun v1 : In v0 (singleton v0) <-> E.eq v0 v0 => iff_flip_impl_subrelation (In v0 (singleton v0)) (E.eq v0 v0) v1) (F.singleton_iff v0 v0) ((fun v1 : E.eq v0 v0 <-> @True => iff_flip_impl_subrelation (E.eq v0 v0) (@True) v1) (eq_refl_iff v0) (@I : @True)) : In v0 (singleton v0)) : In v0 (singleton v0)) : In v0 (singleton v0)) : In v0 (singleton v0)) : forall v0 : @elt, In v0 (singleton v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_add_In	100	0.101876	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @elt) (v2 : @t) (v3 : In v0 (add v1 v2)) (v4 : ~ E.eq v0 v1) => (((((let v5 : E.eq v0 v1 \/ ~ E.eq v0 v1 := dec_eq v0 v1 in or_ind (fun v6 : E.eq v1 v0 => (let v7 : @False := let v7 : @True := @I in (fun v8 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v8 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (eq_refl_iff v0) ((fun v8 : E.eq v1 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v1) (E.eq v0 v0) (per_partial_app_morphism (Equivalence_PER (@F.E_ST)) v1 v0 v8) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) v6 v4) v7 in (fun v8 : @False => False_ind (In v0 v2) v8) v7) : In v0 v2) (fun v6 : In v0 v2 => v6) ((fun v6 : In v0 (add v1 v2) <-> E.eq v1 v0 \/ In v0 v2 => iff_impl_subrelation (In v0 (add v1 v2)) (E.eq v1 v0 \/ In v0 v2) v6) (F.add_iff v2 v1 v0) v3)) : In v0 v2) : In v0 v2) : In v0 v2) : In v0 v2) : In v0 v2) : forall (v0 v1 : @elt) (v2 : @t) (v3 : In v0 (add v1 v2)) (v4 : ~ E.eq v0 v1), In v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_Subset_add_remove	100	0.107904	1	1	0	synth with cache (only 1: refine ((fun (v0 : @elt) (v1 : @t) => (fun (v2 : @elt) (v3 : In v2 v1) => (((fun v4 : In v2 (add v0 (remove v0 v1)) <-> E.eq v0 v2 \/ In v2 (remove v0 v1) => iff_flip_impl_subrelation (In v2 (add v0 (remove v0 v1))) (E.eq v0 v2 \/ In v2 (remove v0 v1)) v4) (F.add_iff (remove v0 v1) v0 v2) ((fun v4 : In v2 (remove v0 v1) <-> In v2 v1 /\ ~ E.eq v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (E.eq v0 v2)) (In v2 (remove v0 v1)) (In v2 v1 /\ ~ E.eq v0 v2) v4) (F.remove_iff v1 v0 v2) (((let v4 : E.eq v0 v2 \/ ~ E.eq v0 v2 := dec_eq v0 v2 in or_ind (fun v5 : E.eq v0 v2 => or_introl v5) (fun v5 : ~ E.eq v0 v2 => or_intror (conj v3 ((fun v6 : E.eq v0 v2 => let v7 : @False := v5 v6 in False_ind (@False) v7) : ~ E.eq v0 v2))) v4) : E.eq v0 v2 \/ In v2 v1 /\ (forall v4 : E.eq v0 v2, @False)) : E.eq v0 v2 \/ In v2 v1 /\ ~ E.eq v0 v2)) : In v2 (add v0 (remove v0 v1))) : In v2 (add v0 (remove v0 v1))) : In v2 (add v0 (remove v0 v1))) : v1 [<=] add v0 (remove v0 v1)) : forall (v0 : @elt) (v1 : @t), v1 [<=] add v0 (remove v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_eq_disjunction	100	0.253539	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 v3 : @elt) (v4 : In v0 (add v1 (add v2 (singleton v3)))) => ((((or_ind (fun v5 : E.eq v1 v0 => or_introl ((fun v6 : E.eq v1 v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@F.E_ST)) v1 v0 v6) v5 ((fun v6 : E.eq v0 v0 <-> @True => iff_flip_impl_subrelation (E.eq v0 v0) (@True) v6) (eq_refl_iff v0) (@I)) : E.eq v0 v1)) (fun v5 : E.eq v2 v0 \/ E.eq v3 v0 => or_ind (fun v6 : E.eq v2 v0 => or_intror (or_introl ((fun v7 : E.eq v2 v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@F.E_ST)) v2 v0 v7) v6 ((fun v7 : E.eq v0 v0 <-> @True => iff_flip_impl_subrelation (E.eq v0 v0) (@True) v7) (eq_refl_iff v0) (@I)) : E.eq v0 v2))) (fun v6 : E.eq v3 v0 => or_intror (or_intror ((fun v7 : E.eq v3 v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@F.E_ST)) v3 v0 v7) v6 ((fun v7 : E.eq v0 v0 <-> @True => iff_flip_impl_subrelation (E.eq v0 v0) (@True) v7) (eq_refl_iff v0) (@I)) : E.eq v0 v3))) v5) ((fun v5 : In v0 (singleton v3) <-> E.eq v3 v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (E.eq v1 v0)) (E.eq v2 v0 \/ In v0 (singleton v3)) (E.eq v2 v0 \/ E.eq v3 v0) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (E.eq v2 v0)) (In v0 (singleton v3)) (E.eq v3 v0) v5)) (F.singleton_iff v3 v0) ((fun v5 : In v0 (add v2 (singleton v3)) <-> E.eq v2 v0 \/ In v0 (singleton v3) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (E.eq v1 v0)) (In v0 (add v2 (singleton v3))) (E.eq v2 v0 \/ In v0 (singleton v3)) v5) (F.add_iff (singleton v3) v2 v0) ((fun v5 : In v0 (add v1 (add v2 (singleton v3))) <-> E.eq v1 v0 \/ In v0 (add v2 (singleton v3)) => iff_impl_subrelation (In v0 (add v1 (add v2 (singleton v3)))) (E.eq v1 v0 \/ In v0 (add v2 (singleton v3))) v5) (F.add_iff (add v2 (singleton v3)) v1 v0) v4))) : E.eq v0 v1 \/ E.eq v0 v2 \/ E.eq v0 v3) : E.eq v0 v1 \/ E.eq v0 v2 \/ E.eq v0 v3) : E.eq v0 v1 \/ E.eq v0 v2 \/ E.eq v0 v3) : E.eq v0 v1 \/ E.eq v0 v2 \/ E.eq v0 v3) : E.eq v0 v1 \/ E.eq v0 v2 \/ E.eq v0 v3) : forall (v0 v1 v2 v3 : @elt) (v4 : In v0 (add v1 (add v2 (singleton v3)))), E.eq v0 v1 \/ E.eq v0 v2 \/ E.eq v0 v3)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_not_In_disj	100	0.309760	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @elt) (v2 v3 v4 v5 : @t) (v6 : ~ In v0 (union v2 (union v3 (union v4 (add v1 v5))))) => (((((let v7 : FSet_elt_Prop (In v0 (union v2 (union v3 (union v4 (add v1 v5))))) := In_elt_prop v0 (union v2 (union v3 (union v4 (add v1 v5)))) in fun v8 : In v0 v2 \/ In v0 v5 \/ E.eq v1 v0 => match v6 ((fun v9 : In v0 (union v2 (union v3 (union v4 (add v1 v5)))) <-> In v0 v2 \/ In v0 (union v3 (union v4 (add v1 v5))) => iff_flip_impl_subrelation (In v0 (union v2 (union v3 (union v4 (add v1 v5))))) (In v0 v2 \/ In v0 (union v3 (union v4 (add v1 v5)))) v9) (F.union_iff v2 (union v3 (union v4 (add v1 v5))) v0) ((fun v9 : In v0 (union v3 (union v4 (add v1 v5))) <-> In v0 v3 \/ In v0 (union v4 (add v1 v5)) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v2)) (In v0 (union v3 (union v4 (add v1 v5)))) (In v0 v3 \/ In v0 (union v4 (add v1 v5))) v9) (F.union_iff v3 (union v4 (add v1 v5)) v0) ((fun v9 : In v0 (union v4 (add v1 v5)) <-> In v0 v4 \/ In v0 (add v1 v5) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v2)) (In v0 v3 \/ In v0 (union v4 (add v1 v5))) (In v0 v3 \/ In v0 v4 \/ In v0 (add v1 v5)) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (In v0 (union v4 (add v1 v5))) (In v0 v4 \/ In v0 (add v1 v5)) v9)) (F.union_iff v4 (add v1 v5) v0) ((fun v9 : In v0 (add v1 v5) <-> E.eq v1 v0 \/ In v0 v5 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v2)) (In v0 v3 \/ In v0 v4 \/ In v0 (add v1 v5)) (In v0 v3 \/ In v0 v4 \/ E.eq v1 v0 \/ In v0 v5) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (In v0 v4 \/ In v0 (add v1 v5)) (In v0 v4 \/ E.eq v1 v0 \/ In v0 v5) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v4)) (In v0 (add v1 v5)) (E.eq v1 v0 \/ In v0 v5) v9))) (F.add_iff v5 v1 v0) (or_ind (fun v9 : In v0 v2 => or_introl v9) (fun v9 : In v0 v5 \/ E.eq v1 v0 => or_ind (fun v10 : In v0 v5 => or_intror (or_intror (or_intror (or_intror v10)))) (fun v10 : E.eq v1 v0 => or_intror (or_intror (or_intror (or_introl v10)))) v9) v8 : In v0 v2 \/ In v0 v3 \/ In v0 v4 \/ E.eq v1 v0 \/ In v0 v5))))) as v9 in False return (@False) with end) : ~ (In v0 v2 \/ In v0 v5 \/ E.eq v1 v0)) : forall v7 : In v0 v2 \/ In v0 v5 \/ E.eq v1 v0, @False) : ~ (In v0 v2 \/ In v0 v5 \/ E.eq v1 v0)) : ~ (In v0 v2 \/ In v0 v5 \/ E.eq v1 v0)) : ~ (In v0 v2 \/ In v0 v5 \/ E.eq v1 v0)) : forall (v0 v1 : @elt) (v2 v3 v4 v5 : @t) (v6 : ~ In v0 (union v2 (union v3 (union v4 (add v1 v5))))), ~ (In v0 v2 \/ In v0 v5 \/ E.eq v1 v0))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_not_In_conj	100	1.131699	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @elt) (v2 v3 v4 v5 : @t) (v6 : ~ In v0 (union v2 (union v3 (union v4 (add v1 v5))))) => (((fun v7 : (forall v7 : In v0 v5 \/ E.eq v1 v0, @False) <-> (forall v7 : In v0 v5, @False) /\ (forall v7 : E.eq v1 v0, @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (forall v8 : In v0 v2, @False)) ((forall v8 : In v0 v5, @False) /\ (forall v8 : E.eq v1 v0, @False)) (forall v8 : In v0 v5 \/ E.eq v1 v0, @False) (symmetry v7)) (not_or_iff (In v0 v5) (E.eq v1 v0)) ((fun v7 : (forall v7 : In v0 v2 \/ In v0 v5 \/ E.eq v1 v0, @False) <-> (forall v7 : In v0 v2, @False) /\ (forall v7 : In v0 v5 \/ E.eq v1 v0, @False) => iff_flip_impl_subrelation ((forall v8 : In v0 v2, @False) /\ (forall v8 : In v0 v5 \/ E.eq v1 v0, @False)) (forall v8 : In v0 v2 \/ In v0 v5 \/ E.eq v1 v0, @False) (symmetry v7)) (not_or_iff (In v0 v2) (In v0 v5 \/ E.eq v1 v0)) (((let v7 : FSet_elt_Prop (In v0 (union v2 (union v3 (union v4 (add v1 v5))))) := In_elt_prop v0 (union v2 (union v3 (union v4 (add v1 v5)))) in fun v8 : In v0 v2 \/ In v0 v5 \/ E.eq v1 v0 => match v6 ((fun v9 : In v0 (union v2 (union v3 (union v4 (add v1 v5)))) <-> In v0 v2 \/ In v0 (union v3 (union v4 (add v1 v5))) => iff_flip_impl_subrelation (In v0 (union v2 (union v3 (union v4 (add v1 v5))))) (In v0 v2 \/ In v0 (union v3 (union v4 (add v1 v5)))) v9) (F.union_iff v2 (union v3 (union v4 (add v1 v5))) v0) ((fun v9 : In v0 (union v3 (union v4 (add v1 v5))) <-> In v0 v3 \/ In v0 (union v4 (add v1 v5)) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v2)) (In v0 (union v3 (union v4 (add v1 v5)))) (In v0 v3 \/ In v0 (union v4 (add v1 v5))) v9) (F.union_iff v3 (union v4 (add v1 v5)) v0) ((fun v9 : In v0 (union v4 (add v1 v5)) <-> In v0 v4 \/ In v0 (add v1 v5) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v2)) (In v0 v3 \/ In v0 (union v4 (add v1 v5))) (In v0 v3 \/ In v0 v4 \/ In v0 (add v1 v5)) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (In v0 (union v4 (add v1 v5))) (In v0 v4 \/ In v0 (add v1 v5)) v9)) (F.union_iff v4 (add v1 v5) v0) ((fun v9 : In v0 (add v1 v5) <-> E.eq v1 v0 \/ In v0 v5 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v2)) (In v0 v3 \/ In v0 v4 \/ In v0 (add v1 v5)) (In v0 v3 \/ In v0 v4 \/ E.eq v1 v0 \/ In v0 v5) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (In v0 v4 \/ In v0 (add v1 v5)) (In v0 v4 \/ E.eq v1 v0 \/ In v0 v5) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v4)) (In v0 (add v1 v5)) (E.eq v1 v0 \/ In v0 v5) v9))) (F.add_iff v5 v1 v0) (or_ind (fun v9 : In v0 v2 => or_introl v9) (fun v9 : In v0 v5 \/ E.eq v1 v0 => or_ind (fun v10 : In v0 v5 => or_intror (or_intror (or_intror (or_intror v10)))) (fun v10 : E.eq v1 v0 => or_intror (or_intror (or_intror (or_introl v10)))) v9) v8 : In v0 v2 \/ In v0 v3 \/ In v0 v4 \/ E.eq v1 v0 \/ In v0 v5))))) as v9 in False return (@False) with end) : ~ (In v0 v2 \/ In v0 v5 \/ E.eq v1 v0)) : forall v7 : In v0 v2 \/ In v0 v5 \/ E.eq v1 v0, @False)) : ~ In v0 v2 /\ ~ In v0 v5 /\ ~ E.eq v1 v0) : ~ In v0 v2 /\ ~ In v0 v5 /\ ~ E.eq v1 v0) : ~ In v0 v2 /\ ~ In v0 v5 /\ ~ E.eq v1 v0) : forall (v0 v1 : @elt) (v2 v3 v4 v5 : @t) (v6 : ~ In v0 (union v2 (union v3 (union v4 (add v1 v5))))), ~ In v0 v2 /\ ~ In v0 v5 /\ ~ E.eq v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_iff_conj	100	0.316401	1	1	0	synth with cache (only 1: refine ((fun (v0 : @elt) (v1 : @E.t) (v2 v3 : @t) (v4 : (forall v4 : In v0 v3, E.eq v1 v0 \/ In v0 v2) /\ (forall v4 : E.eq v1 v0 \/ In v0 v2, In v0 v3)) => let v5 : (forall v5 : In v0 v3, E.eq v1 v0 \/ In v0 v2) /\ (forall v5 : E.eq v1 v0 \/ In v0 v2, In v0 v3) := v4 in (fun v6 : (forall v6 : In v0 v3, E.eq v1 v0 \/ In v0 v2) /\ (forall v6 : E.eq v1 v0 \/ In v0 v2, In v0 v3) => and_ind (fun (v7 : forall v7 : In v0 v3, E.eq v1 v0 \/ In v0 v2) (v8 : forall v8 : E.eq v1 v0 \/ In v0 v2, In v0 v3) => ((((fun v9 : In v0 (add v1 v2) <-> E.eq v1 v0 \/ In v0 v2 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (forall v10 : In v0 v3, In v0 (add v1 v2)) (forall v10 : In v0 v3, E.eq v1 v0 \/ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (In v0 (add v1 v2)) (E.eq v1 v0 \/ In v0 v2) v9) (forall v10 : In v0 (add v1 v2), In v0 v3) (forall v10 : E.eq v1 v0 \/ In v0 v2, In v0 v3) (Morphisms_Prop.iff_iff_iff_impl_morphism (In v0 (add v1 v2)) (E.eq v1 v0 \/ In v0 v2) v9 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)))) (F.add_iff v2 v1 v0) (conj v7 v8 : (forall v9 : In v0 v3, E.eq v1 v0 \/ In v0 v2) /\ (forall v9 : E.eq v1 v0 \/ In v0 v2, In v0 v3)) : (forall v9 : In v0 v3, In v0 (add v1 v2)) /\ (forall v9 : In v0 (add v1 v2), In v0 v3)) : (forall v9 : In v0 v3, In v0 (add v1 v2)) /\ (forall v9 : In v0 (add v1 v2), In v0 v3)) : (forall v9 : In v0 v3, In v0 (add v1 v2)) /\ (forall v9 : In v0 (add v1 v2), In v0 v3)) : (forall v9 : In v0 v3, In v0 (add v1 v2)) /\ (forall v9 : In v0 (add v1 v2), In v0 v3)) v6) v5) : forall (v0 : @elt) (v1 : @E.t) (v2 v3 : @t) (v4 : In v0 v3 <-> E.eq v1 v0 \/ In v0 v2), In v0 v3 <-> In v0 (add v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_set_ops_1	100	2.666910	1	1	0	synth with cache (only 1: refine ((fun (v0 : @elt) (v1 v2 v3 : @t) (v4 : singleton v0 [<=] v3) (v5 : Empty (union v1 v2)) (v6 : Empty (inter (diff v3 v1) (diff v3 v2))) => (((((let v7 : forall v7 : In v0 (inter (diff v3 v1) (diff v3 v2)), @False := v6 v0 in let v8 : forall v8 : In v0 (union v1 v2), @False := v5 v0 in let v9 : forall v9 : In v0 (singleton v0), In v0 v3 := v4 v0 in ((let v10 : In v0 v1 \/ ~ In v0 v1 := dec_In v0 v1 in let v11 : In v0 v2 \/ ~ In v0 v2 := dec_In v0 v2 in let v12 : In v0 v3 \/ ~ In v0 v3 := dec_In v0 v3 in (fun v13 : In v0 v3 => and_ind (fun (v14 : ~ In v0 v1) (v15 : ~ In v0 v2) => or_ind (fun v16 : In v0 v1 => or_ind (fun v17 : In v0 v2 => or_ind (fun v18 : In v0 v3 => let v19 : @False := v14 v16 in let v20 : @False := v15 v17 in let v21 : In v0 v3 := let v21 : @True := @I in (fun v22 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v22 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v22 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v22 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v21 in (fun v22 : In v0 v3 => let v23 : forall (v23 : In v0 v3) (v24 : ~ In v0 v1) (v25 : In v0 v3), In v0 v2 := fun (v23 : In v0 v3) (v24 : ~ In v0 v1) => (fun v25 : (forall v25 : forall v25 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v26 : In v0 v1, @False))) (forall (v26 : In v0 v3) (v27 : forall v27 : In v0 v2, @False), @False) (forall v26 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v26 : forall v26 : In v0 v2, @False, @False) (In v0 v2) v25)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v25 : (forall v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) <-> (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v26 : In v0 v1, @False))) (forall v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) (forall (v26 : In v0 v3) (v27 : forall v27 : In v0 v2, @False), @False) v25) (not_and_iff (In v0 v3) (forall v25 : In v0 v2, @False)) ((fun v25 : (forall v25 : (In v0 v3 /\ (forall v25 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) <-> (forall (v25 : In v0 v3 /\ (forall v25 : In v0 v1, @False)) (v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v26 : (In v0 v3 /\ (forall v26 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) (forall (v26 : In v0 v3 /\ (forall v26 : In v0 v1, @False)) (v27 : In v0 v3 /\ (forall v27 : In v0 v2, @False)), @False) v25) (not_and_iff (In v0 v3 /\ (forall v25 : In v0 v1, @False)) (In v0 v3 /\ (forall v25 : In v0 v2, @False))) ((fun v25 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v25) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v25 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v25 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v25 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v25 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v23 v24) in let v24 : forall (v24 : ~ In v0 v1) (v25 : In v0 v3), In v0 v2 := v23 v13 in False_ind (@False) v20) v21) (fun v18 : ~ In v0 v3 => let v19 : @False := v18 v13 in let v20 : @False := v14 v16 in let v21 : @False := v15 v17 in let v22 : In v0 v3 := let v22 : @True := @I in (fun v23 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v23 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v23 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v23 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v22 in (fun v23 : In v0 v3 => let v24 : forall (v24 : In v0 v3) (v25 : ~ In v0 v1) (v26 : In v0 v3), In v0 v2 := fun (v24 : In v0 v3) (v25 : ~ In v0 v1) => (fun v26 : (forall v26 : forall v26 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v27 : In v0 v1, @False))) (forall (v27 : In v0 v3) (v28 : forall v28 : In v0 v2, @False), @False) (forall v27 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v27 : forall v27 : In v0 v2, @False, @False) (In v0 v2) v26)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v26 : (forall v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) <-> (forall (v26 : In v0 v3) (v27 : forall v27 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v27 : In v0 v1, @False))) (forall v27 : In v0 v3 /\ (forall v27 : In v0 v2, @False), @False) (forall (v27 : In v0 v3) (v28 : forall v28 : In v0 v2, @False), @False) v26) (not_and_iff (In v0 v3) (forall v26 : In v0 v2, @False)) ((fun v26 : (forall v26 : (In v0 v3 /\ (forall v26 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) <-> (forall (v26 : In v0 v3 /\ (forall v26 : In v0 v1, @False)) (v27 : In v0 v3 /\ (forall v27 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v27 : (In v0 v3 /\ (forall v27 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v27 : In v0 v2, @False), @False) (forall (v27 : In v0 v3 /\ (forall v27 : In v0 v1, @False)) (v28 : In v0 v3 /\ (forall v28 : In v0 v2, @False)), @False) v26) (not_and_iff (In v0 v3 /\ (forall v26 : In v0 v1, @False)) (In v0 v3 /\ (forall v26 : In v0 v2, @False))) ((fun v26 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v26) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v26 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v26 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v26 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v26 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v24 v25) in let v25 : forall (v25 : ~ In v0 v1) (v26 : In v0 v3), In v0 v2 := v24 v13 in False_ind (@False) v21) v22) v12) (fun v17 : ~ In v0 v2 => or_ind (fun v18 : In v0 v3 => let v19 : @False := v14 v16 in let v20 : In v0 v3 := let v20 : @True := @I in (fun v21 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v21 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v21 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v21 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v20 in (fun v21 : In v0 v3 => let v22 : forall (v22 : In v0 v3) (v23 : ~ In v0 v1) (v24 : In v0 v3), In v0 v2 := fun (v22 : In v0 v3) (v23 : ~ In v0 v1) => (fun v24 : (forall v24 : forall v24 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v25 : In v0 v1, @False))) (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) (forall v25 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v25 : forall v25 : In v0 v2, @False, @False) (In v0 v2) v24)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v24 : (forall v24 : In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) <-> (forall (v24 : In v0 v3) (v25 : forall v25 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v25 : In v0 v1, @False))) (forall v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) v24) (not_and_iff (In v0 v3) (forall v24 : In v0 v2, @False)) ((fun v24 : (forall v24 : (In v0 v3 /\ (forall v24 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) <-> (forall (v24 : In v0 v3 /\ (forall v24 : In v0 v1, @False)) (v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v25 : (In v0 v3 /\ (forall v25 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) (forall (v25 : In v0 v3 /\ (forall v25 : In v0 v1, @False)) (v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False)), @False) v24) (not_and_iff (In v0 v3 /\ (forall v24 : In v0 v1, @False)) (In v0 v3 /\ (forall v24 : In v0 v2, @False))) ((fun v24 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v24) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v24 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v24 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v24 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v24 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v22 v23) in let v23 : forall (v23 : ~ In v0 v1) (v24 : In v0 v3), In v0 v2 := v22 v13 in False_ind (@False) v19) v20) (fun v18 : ~ In v0 v3 => let v19 : @False := v18 v13 in let v20 : @False := v14 v16 in let v21 : In v0 v3 := let v21 : @True := @I in (fun v22 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v22 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v22 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v22 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v21 in (fun v22 : In v0 v3 => let v23 : forall (v23 : In v0 v3) (v24 : ~ In v0 v1) (v25 : In v0 v3), In v0 v2 := fun (v23 : In v0 v3) (v24 : ~ In v0 v1) => (fun v25 : (forall v25 : forall v25 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v26 : In v0 v1, @False))) (forall (v26 : In v0 v3) (v27 : forall v27 : In v0 v2, @False), @False) (forall v26 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v26 : forall v26 : In v0 v2, @False, @False) (In v0 v2) v25)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v25 : (forall v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) <-> (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v26 : In v0 v1, @False))) (forall v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) (forall (v26 : In v0 v3) (v27 : forall v27 : In v0 v2, @False), @False) v25) (not_and_iff (In v0 v3) (forall v25 : In v0 v2, @False)) ((fun v25 : (forall v25 : (In v0 v3 /\ (forall v25 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) <-> (forall (v25 : In v0 v3 /\ (forall v25 : In v0 v1, @False)) (v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v26 : (In v0 v3 /\ (forall v26 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) (forall (v26 : In v0 v3 /\ (forall v26 : In v0 v1, @False)) (v27 : In v0 v3 /\ (forall v27 : In v0 v2, @False)), @False) v25) (not_and_iff (In v0 v3 /\ (forall v25 : In v0 v1, @False)) (In v0 v3 /\ (forall v25 : In v0 v2, @False))) ((fun v25 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v25) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v25 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v25 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v25 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v25 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v23 v24) in let v24 : forall (v24 : ~ In v0 v1) (v25 : In v0 v3), In v0 v2 := v23 v13 in False_ind (@False) v20) v21) v12) v11) (fun v16 : ~ In v0 v1 => or_ind (fun v17 : In v0 v2 => or_ind (fun v18 : In v0 v3 => let v19 : @False := v15 v17 in let v20 : In v0 v3 := let v20 : @True := @I in (fun v21 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v21 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v21 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v21 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v20 in (fun v21 : In v0 v3 => let v22 : forall (v22 : In v0 v3) (v23 : ~ In v0 v1) (v24 : In v0 v3), In v0 v2 := fun (v22 : In v0 v3) (v23 : ~ In v0 v1) => (fun v24 : (forall v24 : forall v24 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v25 : In v0 v1, @False))) (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) (forall v25 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v25 : forall v25 : In v0 v2, @False, @False) (In v0 v2) v24)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v24 : (forall v24 : In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) <-> (forall (v24 : In v0 v3) (v25 : forall v25 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v25 : In v0 v1, @False))) (forall v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) v24) (not_and_iff (In v0 v3) (forall v24 : In v0 v2, @False)) ((fun v24 : (forall v24 : (In v0 v3 /\ (forall v24 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) <-> (forall (v24 : In v0 v3 /\ (forall v24 : In v0 v1, @False)) (v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v25 : (In v0 v3 /\ (forall v25 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) (forall (v25 : In v0 v3 /\ (forall v25 : In v0 v1, @False)) (v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False)), @False) v24) (not_and_iff (In v0 v3 /\ (forall v24 : In v0 v1, @False)) (In v0 v3 /\ (forall v24 : In v0 v2, @False))) ((fun v24 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v24) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v24 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v24 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v24 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v24 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v22 v23) in let v23 : forall (v23 : ~ In v0 v1) (v24 : In v0 v3), In v0 v2 := v22 v13 in let v24 : forall v24 : In v0 v3, In v0 v2 := v23 v14 in let v25 : In v0 v2 := v24 v13 in False_ind (@False) v19) v20) (fun v18 : ~ In v0 v3 => let v19 : @False := v18 v13 in let v20 : @False := v15 v17 in let v21 : In v0 v3 := let v21 : @True := @I in (fun v22 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v22 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v22 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v22 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v21 in (fun v22 : In v0 v3 => let v23 : forall (v23 : In v0 v3) (v24 : ~ In v0 v1) (v25 : In v0 v3), In v0 v2 := fun (v23 : In v0 v3) (v24 : ~ In v0 v1) => (fun v25 : (forall v25 : forall v25 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v26 : In v0 v1, @False))) (forall (v26 : In v0 v3) (v27 : forall v27 : In v0 v2, @False), @False) (forall v26 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v26 : forall v26 : In v0 v2, @False, @False) (In v0 v2) v25)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v25 : (forall v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) <-> (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v26 : In v0 v1, @False))) (forall v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) (forall (v26 : In v0 v3) (v27 : forall v27 : In v0 v2, @False), @False) v25) (not_and_iff (In v0 v3) (forall v25 : In v0 v2, @False)) ((fun v25 : (forall v25 : (In v0 v3 /\ (forall v25 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) <-> (forall (v25 : In v0 v3 /\ (forall v25 : In v0 v1, @False)) (v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v26 : (In v0 v3 /\ (forall v26 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v26 : In v0 v2, @False), @False) (forall (v26 : In v0 v3 /\ (forall v26 : In v0 v1, @False)) (v27 : In v0 v3 /\ (forall v27 : In v0 v2, @False)), @False) v25) (not_and_iff (In v0 v3 /\ (forall v25 : In v0 v1, @False)) (In v0 v3 /\ (forall v25 : In v0 v2, @False))) ((fun v25 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v25) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v25 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v25 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v25 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v25 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v23 v24) in let v24 : forall (v24 : ~ In v0 v1) (v25 : In v0 v3), In v0 v2 := v23 v13 in let v25 : forall v25 : In v0 v3, In v0 v2 := v24 v14 in let v26 : In v0 v2 := v25 v13 in False_ind (@False) v20) v21) v12) (fun v17 : ~ In v0 v2 => or_ind (fun v18 : In v0 v3 => let v19 : In v0 v3 := let v19 : @True := @I in (fun v20 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v20 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v20 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v20 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v19 in (fun v20 : In v0 v3 => let v21 : forall (v21 : In v0 v3) (v22 : ~ In v0 v1) (v23 : In v0 v3), In v0 v2 := fun (v21 : In v0 v3) (v22 : ~ In v0 v1) => (fun v23 : (forall v23 : forall v23 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v24 : In v0 v1, @False))) (forall (v24 : In v0 v3) (v25 : forall v25 : In v0 v2, @False), @False) (forall v24 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v24 : forall v24 : In v0 v2, @False, @False) (In v0 v2) v23)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v23 : (forall v23 : In v0 v3 /\ (forall v23 : In v0 v2, @False), @False) <-> (forall (v23 : In v0 v3) (v24 : forall v24 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v24 : In v0 v1, @False))) (forall v24 : In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) (forall (v24 : In v0 v3) (v25 : forall v25 : In v0 v2, @False), @False) v23) (not_and_iff (In v0 v3) (forall v23 : In v0 v2, @False)) ((fun v23 : (forall v23 : (In v0 v3 /\ (forall v23 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v23 : In v0 v2, @False), @False) <-> (forall (v23 : In v0 v3 /\ (forall v23 : In v0 v1, @False)) (v24 : In v0 v3 /\ (forall v24 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v24 : (In v0 v3 /\ (forall v24 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) (forall (v24 : In v0 v3 /\ (forall v24 : In v0 v1, @False)) (v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False)), @False) v23) (not_and_iff (In v0 v3 /\ (forall v23 : In v0 v1, @False)) (In v0 v3 /\ (forall v23 : In v0 v2, @False))) ((fun v23 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v23) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v23 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v23 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v23 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v23 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v21 v22) in let v22 : forall (v22 : ~ In v0 v1) (v23 : In v0 v3), In v0 v2 := v21 v13 in let v23 : forall v23 : In v0 v3, In v0 v2 := v22 v14 in let v24 : In v0 v2 := v23 v13 in let v25 : @False := v15 v24 in let v26 : @False := v17 v24 in False_ind (@False) v26) v19) (fun v18 : ~ In v0 v3 => let v19 : @False := v18 v13 in let v20 : In v0 v3 := let v20 : @True := @I in (fun v21 : E.eq v0 v0 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v0 v0) (@True) v21 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (eq_refl_iff v0) ((fun v21 : In v0 (singleton v0) <-> E.eq v0 v0 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (singleton v0)) (E.eq v0 v0) v21 (In v0 v3) (In v0 v3) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3))) (F.singleton_iff v0 v0) v9) v20 in (fun v21 : In v0 v3 => let v22 : forall (v22 : In v0 v3) (v23 : ~ In v0 v1) (v24 : In v0 v3), In v0 v2 := fun (v22 : In v0 v3) (v23 : ~ In v0 v1) => (fun v24 : (forall v24 : forall v24 : In v0 v2, @False, @False) <-> In v0 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v25 : In v0 v1, @False))) (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) (forall v25 : In v0 v3, In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3)) (forall v25 : forall v25 : In v0 v2, @False, @False) (In v0 v2) v24)) (not_not_iff (In v0 v2) (dec_In v0 v2)) ((fun v24 : (forall v24 : In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) <-> (forall (v24 : In v0 v3) (v25 : forall v25 : In v0 v2, @False), @False) => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ (forall v25 : In v0 v1, @False))) (forall v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) (forall (v25 : In v0 v3) (v26 : forall v26 : In v0 v2, @False), @False) v24) (not_and_iff (In v0 v3) (forall v24 : In v0 v2, @False)) ((fun v24 : (forall v24 : (In v0 v3 /\ (forall v24 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v24 : In v0 v2, @False), @False) <-> (forall (v24 : In v0 v3 /\ (forall v24 : In v0 v1, @False)) (v25 : In v0 v3 /\ (forall v25 : In v0 v2, @False)), @False) => iff_impl_subrelation (forall v25 : (In v0 v3 /\ (forall v25 : In v0 v1, @False)) /\ In v0 v3 /\ (forall v25 : In v0 v2, @False), @False) (forall (v25 : In v0 v3 /\ (forall v25 : In v0 v1, @False)) (v26 : In v0 v3 /\ (forall v26 : In v0 v2, @False)), @False) v24) (not_and_iff (In v0 v3 /\ (forall v24 : In v0 v1, @False)) (In v0 v3 /\ (forall v24 : In v0 v2, @False))) ((fun v24 : In v0 (diff v3 v2) <-> In v0 v3 /\ ~ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 v3 /\ ~ In v0 v2) (Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (In v0 v3 /\ ~ In v0 v1)) (In v0 (diff v3 v2)) (In v0 v3 /\ ~ In v0 v2) v24) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v2 v0) ((fun v24 : In v0 (diff v3 v1) <-> In v0 v3 /\ ~ In v0 v1 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) ((In v0 v3 /\ ~ In v0 v1) /\ In v0 (diff v3 v2)) (Morphisms_Prop.and_iff_morphism (In v0 (diff v3 v1)) (In v0 v3 /\ ~ In v0 v1) v24 (In v0 (diff v3 v2)) (In v0 (diff v3 v2)) (reflexive_proper_proxy (@iff_Reflexive) (In v0 (diff v3 v2)))) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.diff_iff v3 v1 v0) ((fun v24 : In v0 (inter (diff v3 v1) (diff v3 v2)) <-> In v0 (diff v3 v1) /\ In v0 (diff v3 v2) => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (inter (diff v3 v1) (diff v3 v2))) (In v0 (diff v3 v1) /\ In v0 (diff v3 v2)) v24 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.inter_iff (diff v3 v1) (diff v3 v2) v0) v7))))) (conj v22 v23) in let v23 : forall (v23 : ~ In v0 v1) (v24 : In v0 v3), In v0 v2 := v22 v13 in let v24 : forall v24 : In v0 v3, In v0 v2 := v23 v14 in let v25 : In v0 v2 := v24 v13 in let v26 : @False := v15 v25 in let v27 : @False := v17 v25 in False_ind (@False) v27) v20) v12) v11) v10) ((fun v14 : (forall v14 : In v0 v1 \/ In v0 v2, @False) <-> (forall v14 : In v0 v1, @False) /\ (forall v14 : In v0 v2, @False) => iff_impl_subrelation (forall v15 : In v0 v1 \/ In v0 v2, @False) ((forall v15 : In v0 v1, @False) /\ (forall v15 : In v0 v2, @False)) v14) (not_or_iff (In v0 v1) (In v0 v2)) ((fun v14 : In v0 (union v1 v2) <-> In v0 v1 \/ In v0 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v0 (union v1 v2)) (In v0 v1 \/ In v0 v2) v14 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.union_iff v1 v2 v0) v8))) : ~ In v0 v3) : forall v10 : In v0 v3, @False) : forall v10 : In v0 v3, @False) : ~ In v0 v3) : forall v7 : In v0 v3, @False) : ~ In v0 v3) : ~ In v0 v3) : ~ In v0 v3) : forall (v0 : @elt) (v1 v2 v3 : @t) (v4 : singleton v0 [<=] v3) (v5 : Empty (union v1 v2)) (v6 : Empty (inter (diff v3 v1) (diff v3 v2))), ~ In v0 v3)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.eq_chain_test	100	0.776606	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 v3 : @elt) (v4 v5 v6 v7 : @t) (v8 : Empty v4) (v9 : In v1 (add v0 v4)) (v10 : In v2 v5) (v11 : ~ In v2 (remove v1 v5)) (v12 : ~ In v3 v6) (v13 : In v3 (add v2 v6)) (v14 : In v0 v7) => (fun (v15 : @elt) (v16 : In v15 (add v3 v7)) => (((let v17 : forall v17 : In v15 v4, @False := v8 v15 in let v18 : forall v18 : In v0 v4, @False := v8 v0 in let v19 : forall v19 : In v3 v4, @False := v8 v3 in let v20 : forall v20 : In v2 v4, @False := v8 v2 in let v21 : forall v21 : In v1 v4, @False := v8 v1 in (let v22 : In v1 v4 \/ ~ In v1 v4 := dec_In v1 v4 in let v23 : In v2 v4 \/ ~ In v2 v4 := dec_In v2 v4 in let v24 : In v3 v4 \/ ~ In v3 v4 := dec_In v3 v4 in let v25 : In v0 v4 \/ ~ In v0 v4 := dec_In v0 v4 in let v26 : In v15 v4 \/ ~ In v15 v4 := dec_In v15 v4 in let v27 : In v3 v6 \/ ~ In v3 v6 := dec_In v3 v6 in or_ind (fun v28 : E.eq v0 v1 => or_ind (fun v29 : E.eq v2 v3 => or_ind (fun v30 : E.eq v3 v15 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in (fun v32 : E.eq v0 v15 => F.In_s_m v32 (x0:=v7) (y0:=v7) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v7)) ((fun v32 : E.eq v2 v15 => trans_co_impl_morphism Equivalence_Transitive v2 v15 v32) ((fun v32 : E.eq v3 v15 => trans_co_impl_morphism Equivalence_Transitive v3 v15 v32) v30 v29) ((fun v32 : E.eq v1 v2 => trans_co_impl_morphism Equivalence_Transitive v1 v2 v32) v31 v28)) v14 : In v15 v7) (fun v30 : In v15 v7 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in v30) ((fun v30 : In v15 (add v3 v7) <-> E.eq v3 v15 \/ In v15 v7 => iff_impl_subrelation (In v15 (add v3 v7)) (E.eq v3 v15 \/ In v15 v7) v30) (F.add_iff v7 v3 v15) v16)) (fun v29 : In v3 v6 => or_ind (fun v30 : E.eq v3 v15 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in let v32 : @False := v12 v29 in False_ind (In v15 v7) v32) (fun v30 : In v15 v7 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in let v32 : @False := v12 v29 in False_ind (In v15 v7) v32) ((fun v30 : In v15 (add v3 v7) <-> E.eq v3 v15 \/ In v15 v7 => iff_impl_subrelation (In v15 (add v3 v7)) (E.eq v3 v15 \/ In v15 v7) v30) (F.add_iff v7 v3 v15) v16)) ((fun v29 : In v3 (add v2 v6) <-> E.eq v2 v3 \/ In v3 v6 => iff_impl_subrelation (In v3 (add v2 v6)) (E.eq v2 v3 \/ In v3 v6) v29) (F.add_iff v6 v2 v3) v13)) (fun v28 : In v1 v4 => or_ind (fun v29 : E.eq v2 v3 => or_ind (fun v30 : E.eq v3 v15 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in let v32 : @False := v21 v28 in False_ind (In v15 v7) v32) (fun v30 : In v15 v7 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in let v32 : @False := v21 v28 in False_ind (In v15 v7) v32) ((fun v30 : In v15 (add v3 v7) <-> E.eq v3 v15 \/ In v15 v7 => iff_impl_subrelation (In v15 (add v3 v7)) (E.eq v3 v15 \/ In v15 v7) v30) (F.add_iff v7 v3 v15) v16)) (fun v29 : In v3 v6 => or_ind (fun v30 : E.eq v3 v15 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in let v32 : @False := v21 v28 in let v33 : @False := v12 v29 in False_ind (In v15 v7) v33) (fun v30 : In v15 v7 => let v31 : E.eq v1 v2 := (fun v31 : (forall v31 : forall v31 : E.eq v1 v2, @False, @False) <-> E.eq v1 v2 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (In v2 v5)) (forall v32 : forall v32 : E.eq v1 v2, @False, @False) (E.eq v1 v2) v31) (not_not_iff (E.eq v1 v2) (dec_eq v1 v2)) ((fun v31 : (forall v31 : In v2 v5 /\ (forall v31 : E.eq v1 v2, @False), @False) <-> (forall (v31 : In v2 v5) (v32 : forall v32 : E.eq v1 v2, @False), @False) => iff_impl_subrelation (forall v32 : In v2 v5 /\ (forall v32 : E.eq v1 v2, @False), @False) (forall (v32 : In v2 v5) (v33 : forall v33 : E.eq v1 v2, @False), @False) v31) (not_and_iff (In v2 v5) (forall v31 : E.eq v1 v2, @False)) ((fun v31 : In v2 (remove v1 v5) <-> In v2 v5 /\ ~ E.eq v1 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (In v2 (remove v1 v5)) (In v2 v5 /\ ~ E.eq v1 v2) v31 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (F.remove_iff v5 v1 v2) v11)) v10 in let v32 : @False := v21 v28 in let v33 : @False := v12 v29 in False_ind (In v15 v7) v33) ((fun v30 : In v15 (add v3 v7) <-> E.eq v3 v15 \/ In v15 v7 => iff_impl_subrelation (In v15 (add v3 v7)) (E.eq v3 v15 \/ In v15 v7) v30) (F.add_iff v7 v3 v15) v16)) ((fun v29 : In v3 (add v2 v6) <-> E.eq v2 v3 \/ In v3 v6 => iff_impl_subrelation (In v3 (add v2 v6)) (E.eq v2 v3 \/ In v3 v6) v29) (F.add_iff v6 v2 v3) v13)) ((fun v28 : In v1 (add v0 v4) <-> E.eq v0 v1 \/ In v1 v4 => iff_impl_subrelation (In v1 (add v0 v4)) (E.eq v0 v1 \/ In v1 v4) v28) (F.add_iff v4 v0 v1) v9)) : In v15 v7) : In v15 v7) : In v15 v7) : In v15 v7) : add v3 v7 [<=] v7) : forall (v0 v1 v2 v3 : @elt) (v4 v5 v6 v7 : @t) (v8 : Empty v4) (v9 : In v1 (add v0 v4)) (v10 : In v2 v5) (v11 : ~ In v2 (remove v1 v5)) (v12 : ~ In v3 v6) (v13 : In v3 (add v2 v6)) (v14 : In v0 v7), add v3 v7 [<=] v7)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_too_complex	100	0.092860	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @E.t) (v2 : @elt) (v3 v4 : @t) (v5 : E.eq v0 v1) (v6 : forall v6 : In v0 (singleton v1), v3 [<=] v4) (v7 : In v2 v3) => ((fun v8 : v3 [<=] v4 => ((((let v9 : forall v9 : In v2 v3, In v2 v4 := v8 v2 in let v10 : forall v10 : In v0 v3, In v0 v4 := v8 v0 in let v11 : forall v11 : In v1 v3, In v1 v4 := v8 v1 in v9 v7 : In v2 v4) : In v2 v4) : In v2 v4) : In v2 v4) : In v2 v4) : forall v8 : v3 [<=] v4, In v2 v4) (v6 ((((((fun v8 : In v0 (singleton v1) <-> E.eq v1 v0 => iff_flip_impl_subrelation (In v0 (singleton v1)) (E.eq v1 v0) v8) (F.singleton_iff v1 v0) ((fun v8 : E.eq v0 v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@F.E_ST)) v0 v1 v8) v5 ((fun v8 : E.eq v1 v1 <-> @True => iff_flip_impl_subrelation (E.eq v1 v1) (@True) v8) (eq_refl_iff v1) (@I)) : E.eq v1 v0) : In v0 (singleton v1)) : In v0 (singleton v1)) : In v0 (singleton v1)) : In v0 (singleton v1)) : In v0 (singleton v1))))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.function_test_1	100	0.151270	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @t, @t) (v1 : forall v1 : @elt, @elt) (v2 v3 : @t) (v4 v5 : @elt) (v6 : v2 [=] v0 v3) (v7 : E.eq v4 (v1 (v1 v5))) (v8 : In v4 v2) => let v9 : @elt := v1 (v1 v5) in ((((let v10 : In v4 v2 <-> In v4 (v0 v3) := v6 v4 in let v11 : In v9 v2 <-> In v9 (v0 v3) := v6 v9 in and_ind (fun (v12 : forall v12 : In v9 v2, In v9 (v0 v3)) (v13 : forall v13 : In v9 (v0 v3), In v9 v2) => and_ind (fun (v14 : forall v14 : In v9 v2, In v9 (v0 v3)) (v15 : forall v15 : In v9 (v0 v3), In v9 v2) => let v16 : In v9 (v0 v3) := v12 ((fun v16 : E.eq v4 v9 => F.In_s_m v16 (x0:=v2) (y0:=v2) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v2)) v7 v8) in let v17 : In v9 (v0 v3) := v14 ((fun v17 : E.eq v4 v9 => F.In_s_m v17 (x0:=v2) (y0:=v2) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v2)) v7 v8) in let v18 : In v9 v2 := v13 v16 in let v19 : In v9 v2 := v15 v16 in v17) v11) ((fun v12 : E.eq v4 v9 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (forall v13 : In v4 v2, In v4 (v0 v3)) (forall v13 : In v9 v2, In v9 (v0 v3)) (Morphisms_Prop.iff_iff_iff_impl_morphism (In v4 v2) (In v9 v2) (F.In_m v12 (x0:=v2) (y0:=v2) (reflexive_proper_proxy Equivalence_Reflexive v2)) (In v4 (v0 v3)) (In v9 (v0 v3)) (F.In_m v12 (x0:=v0 v3) (y0:=v0 v3) (reflexive_proper_proxy Equivalence_Reflexive (v0 v3)))) (forall v13 : In v4 (v0 v3), In v4 v2) (forall v13 : In v9 (v0 v3), In v9 v2) (Morphisms_Prop.iff_iff_iff_impl_morphism (In v4 (v0 v3)) (In v9 (v0 v3)) (F.In_m v12 (x0:=v0 v3) (y0:=v0 v3) (reflexive_proper_proxy Equivalence_Reflexive (v0 v3))) (In v4 v2) (In v9 v2) (F.In_m v12 (x0:=v2) (y0:=v2) (reflexive_proper_proxy Equivalence_Reflexive v2)))) v7 v10) : In v9 (v0 v3)) : In v9 (v0 v3)) : In v9 (v0 v3)) : In v9 (v0 v3)) : In v9 (v0 v3)) : forall (v0 : forall v0 : @t, @t) (v1 : forall v1 : @elt, @elt) (v2 v3 : @t) (v4 v5 : @elt) (v6 : v2 [=] v0 v3) (v7 : E.eq v4 (v1 (v1 v5))) (v8 : In v4 v2), In (v1 (v1 v5)) (v0 v3))).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.function_test_2	100	0.131932	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @t, @t) (v1 : forall v1 : @elt, @elt) (v2 v3 : @t) (v4 v5 : @elt) (v6 : v2 [=] v0 v3) (v7 : E.eq v4 (v1 v5)) (v8 : In v4 v2) (v9 : v1 v5 = v1 (v1 v5)) => eq_ind (v1 v5) (fun v10 : @elt => In v10 (v0 v3)) ((let v10 : @elt := v1 v5 in ((((let v11 : In v4 v2 <-> In v4 (v0 v3) := v6 v4 in let v12 : In v10 v2 <-> In v10 (v0 v3) := v6 v10 in and_ind (fun (v13 : forall v13 : In v10 v2, In v10 (v0 v3)) (v14 : forall v14 : In v10 (v0 v3), In v10 v2) => and_ind (fun (v15 : forall v15 : In v10 v2, In v10 (v0 v3)) (v16 : forall v16 : In v10 (v0 v3), In v10 v2) => let v17 : In v10 (v0 v3) := v13 ((fun v17 : E.eq v4 v10 => F.In_s_m v17 (x0:=v2) (y0:=v2) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v2)) v7 v8) in let v18 : In v10 (v0 v3) := v15 ((fun v18 : E.eq v4 v10 => F.In_s_m v18 (x0:=v2) (y0:=v2) (reflexive_proper_proxy (@F.SubsetSetoid_Reflexive) v2)) v7 v8) in let v19 : In v10 v2 := v14 v17 in let v20 : In v10 v2 := v16 v17 in v18) v12) ((fun v13 : E.eq v4 v10 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (forall v14 : In v4 v2, In v4 (v0 v3)) (forall v14 : In v10 v2, In v10 (v0 v3)) (Morphisms_Prop.iff_iff_iff_impl_morphism (In v4 v2) (In v10 v2) (F.In_m v13 (x0:=v2) (y0:=v2) (reflexive_proper_proxy Equivalence_Reflexive v2)) (In v4 (v0 v3)) (In v10 (v0 v3)) (F.In_m v13 (x0:=v0 v3) (y0:=v0 v3) (reflexive_proper_proxy Equivalence_Reflexive (v0 v3)))) (forall v14 : In v4 (v0 v3), In v4 v2) (forall v14 : In v10 (v0 v3), In v10 v2) (Morphisms_Prop.iff_iff_iff_impl_morphism (In v4 (v0 v3)) (In v10 (v0 v3)) (F.In_m v13 (x0:=v0 v3) (y0:=v0 v3) (reflexive_proper_proxy Equivalence_Reflexive (v0 v3))) (In v4 v2) (In v10 v2) (F.In_m v13 (x0:=v2) (y0:=v2) (reflexive_proper_proxy Equivalence_Reflexive v2)))) v7 v11) : In v10 (v0 v3)) : In v10 (v0 v3)) : In v10 (v0 v3)) : In v10 (v0 v3)) : In v10 (v0 v3)) : In (v1 v5) (v0 v3)) (v1 (v1 v5)) v9)).
coq-tactician-stdlib.8.11.dev	Coq.FSets.FSetDecide.WDecide_fun.FSetDecideTestCases.test_baydemir	100	0.422362	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @t, @t) (v1 : @t) (v2 v3 : @elt) (v4 : In v2 (add v3 (v0 v1))) (v5 : ~ E.eq v2 v3) => (((((let v6 : E.eq v2 v3 \/ ~ E.eq v2 v3 := dec_eq v2 v3 in or_ind (fun v7 : E.eq v3 v2 => (let v8 : @False := let v8 : @True := @I in (fun v9 : E.eq v2 v2 <-> @True => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v2 v2) (@True) v9 (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) (eq_refl_iff v2) ((fun v9 : E.eq v3 v2 => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation))) (E.eq v2 v3) (E.eq v2 v2) (per_partial_app_morphism (Equivalence_PER (@F.E_ST)) v3 v2 v9) (@False) (@False) (reflexive_proper_proxy (@iff_Reflexive) (@False))) v7 v5) v8 in (fun v9 : @False => False_ind (In v2 (v0 v1)) v9) v8) : In v2 (v0 v1)) (fun v7 : In v2 (v0 v1) => v7) ((fun v7 : In v2 (add v3 (v0 v1)) <-> E.eq v3 v2 \/ In v2 (v0 v1) => iff_impl_subrelation (In v2 (add v3 (v0 v1))) (E.eq v3 v2 \/ In v2 (v0 v1)) v7) (F.add_iff (v0 v1) v3 v2) v4)) : In v2 (v0 v1)) : In v2 (v0 v1)) : In v2 (v0 v1)) : In v2 (v0 v1)) : In v2 (v0 v1)) : forall (v0 : forall v0 : @t, @t) (v1 : @t) (v2 v3 : @elt) (v4 : In v2 (add v3 (v0 v1))) (v5 : ~ E.eq v2 v3), In v2 (v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Cring.cring.cring_eq_ext	100	0.490132	1	1	0	synth with cache (only 1: refine {| Radd_ext := ((fun (v0 v1 : @R) (v2 : v0 == v1) => (fun (v3 v4 : @R) (v5 : v3 == v4) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + v3) (v0 + v4) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive v0) v3 v4 v5) (v1 + v4) (v1 + v4) (eq_proper_proxy (v1 + v4)) (trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 + v4) (v1 + v4) (ring_plus_comp v0 v1 v2 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) (v1 + v4) (v1 + v4) (eq_proper_proxy (v1 + v4)) (reflexivity (v1 + v4)))) : (_==_ ==> _==_)%signature (_+_ v0) (_+_ v1)) : (_==_ ==> _==_ ==> _==_)%signature _+_ _+_) : Proper (_==_ ==> _==_ ==> _==_) _+_; Rmul_ext := ((fun (v0 v1 : @R) (v2 : v0 == v1) => (fun (v3 v4 : @R) (v5 : v3 == v4) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * v3) (v0 * v4) (Reflexive_partial_app_morphism ring_mult_comp (reflexive_proper_proxy Equivalence_Reflexive v0) v3 v4 v5) (v1 * v4) (v1 * v4) (eq_proper_proxy (v1 * v4)) (trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 * v4) (v1 * v4) (ring_mult_comp v0 v1 v2 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) (v1 * v4) (v1 * v4) (eq_proper_proxy (v1 * v4)) (reflexivity (v1 * v4)))) : (_==_ ==> _==_)%signature (_*_ v0) (_*_ v1)) : (_==_ ==> _==_ ==> _==_)%signature _*_ _*_) : Proper (_==_ ==> _==_ ==> _==_) _*_; Ropp_ext := ((fun (v0 v1 : @R) (v2 : v0 == v1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (- v0) (- v1) (ring_opp_comp v0 v1 v2) (- v1) (- v1) (eq_proper_proxy (- v1)) (reflexivity (- v1))) : (_==_ ==> _==_)%signature -_ -_) : Proper (_==_ ==> _==_) -_ |}).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Cring.cring.cring_almost_ring_theory	100	1.220772	1	1
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Cring.cring.cring_morph	100	0.825186	1	1	0	synth with cache (only 1: refine {| morph0 := reflexivity 0 : Ncring_initial.gen_phiZ 0 == 0; morph1 := reflexivity 1 : Ncring_initial.gen_phiZ 1 == 1; morph_add := fun v0 v1 : @Z => (fun v2 : Ncring_initial.gen_phiZ (v0 + v1) == Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (Ncring_initial.gen_phiZ (v0 + v1)) (Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ v1) v2 (Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ v1) (Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ v1) (eq_proper_proxy (Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ v1))) (Ncring_initial.gen_phiZ_add v0 v1) (reflexivity (Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ v1)) : Ncring_initial.gen_phiZ (v0 + v1) == Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ v1; morph_sub := fun v0 v1 : @Z => (fun v2 : Ncring_initial.gen_phiZ v0 - Ncring_initial.gen_phiZ v1 == Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER ring_setoid) (Ncring_initial.gen_phiZ v0 - Ncring_initial.gen_phiZ v1) (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1) v2) (ring_sub_def (Ncring_initial.gen_phiZ v0) (Ncring_initial.gen_phiZ v1)) ((fun v2 : Ncring_initial.gen_phiZ (v0 + - v1) == Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ (- v1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (Ncring_initial.gen_phiZ (v0 + - v1)) (Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ (- v1)) v2 (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1) (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1) (eq_proper_proxy (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1))) (Ncring_initial.gen_phiZ_add v0 (- v1)) ((fun v2 : Ncring_initial.gen_phiZ (- v1) == - Ncring_initial.gen_phiZ v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (Ncring_initial.gen_phiZ v0 + Ncring_initial.gen_phiZ (- v1)) (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive (Ncring_initial.gen_phiZ v0)) (Ncring_initial.gen_phiZ (- v1)) (- Ncring_initial.gen_phiZ v1) v2) (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1) (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1) (eq_proper_proxy (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1))) (gen_phiZ_opp v1) (reflexivity (Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1))) : Ncring_initial.gen_phiZ (v0 - v1) == Ncring_initial.gen_phiZ v0 + - Ncring_initial.gen_phiZ v1) : Ncring_initial.gen_phiZ (v0 - v1) == Ncring_initial.gen_phiZ v0 - Ncring_initial.gen_phiZ v1; morph_mul := fun v0 v1 : @Z => (fun v2 : Ncring_initial.gen_phiZ (v0 * v1) == Ncring_initial.gen_phiZ v0 * Ncring_initial.gen_phiZ v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (Ncring_initial.gen_phiZ (v0 * v1)) (Ncring_initial.gen_phiZ v0 * Ncring_initial.gen_phiZ v1) v2 (Ncring_initial.gen_phiZ v0 * Ncring_initial.gen_phiZ v1) (Ncring_initial.gen_phiZ v0 * Ncring_initial.gen_phiZ v1) (eq_proper_proxy (Ncring_initial.gen_phiZ v0 * Ncring_initial.gen_phiZ v1))) (Ncring_initial.gen_phiZ_mul v0 v1) (reflexivity (Ncring_initial.gen_phiZ v0 * Ncring_initial.gen_phiZ v1)) : Ncring_initial.gen_phiZ (v0 * v1) == Ncring_initial.gen_phiZ v0 * Ncring_initial.gen_phiZ v1; morph_opp := fun v0 : @Z => (fun v1 : Ncring_initial.gen_phiZ (- v0) == - Ncring_initial.gen_phiZ v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (Ncring_initial.gen_phiZ (- v0)) (- Ncring_initial.gen_phiZ v0) v1 (- Ncring_initial.gen_phiZ v0) (- Ncring_initial.gen_phiZ v0) (eq_proper_proxy (- Ncring_initial.gen_phiZ v0))) (gen_phiZ_opp v0) (reflexivity (- Ncring_initial.gen_phiZ v0)) : Ncring_initial.gen_phiZ (- v0) == - Ncring_initial.gen_phiZ v0; morph_eq := fun (v0 v1 : @Z) (v2 : Zeq_bool v0 v1 = @true) => (fun v3 : v0 == v1 => Reflexive_partial_app_morphism (reflexive_proper (@equality (@R))) (eq_proper_proxy (eq_notation (T:=@R))) (Ncring_initial.gen_phiZ v0) (Ncring_initial.gen_phiZ v1) (Reflexive_partial_app_morphism (reflexive_proper (@Ncring_initial.gen_phiZ (@R) (@ring0) (@ring1) (@add) (@mul) (@sub) (@opp) (@ring_eq))) (eq_proper_proxy (@Ro)) v0 v1 v3) (Ncring_initial.gen_phiZ v1) (Ncring_initial.gen_phiZ v1) (eq_proper_proxy (Ncring_initial.gen_phiZ v1))) (Zeqb_ok v0 v1 v2) (reflexivity (Ncring_initial.gen_phiZ v1)) : Ncring_initial.gen_phiZ v0 == Ncring_initial.gen_phiZ v1 |}).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Cring.cring.cring_power_theory	100	0.185980	1	1	0	synth with cache (only 1: refine {| Ring_theory.rpow_pow_N := fun (v0 : @R) (v1 : @N) => reflexivity (Ring_theory.pow_N 1 _*_ v0 v1) |}).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Cring.cring.cring_div_theory	100	0.090237	1	1	0	synth with cache (only 1: refine (Ztriv_div_th ((ring_setoid : Equivalence _==_) : Setoid_Theory (@R) _==_) Ncring_initial.gen_phiZ)).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Cring.Zcri	100	0.062925	1	1	0	synth with cache (only 1: refine (@Z.mul_comm : Cring)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.BoundFromZero	100	0.037082	2	2
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.QCauchySeq_bounded	100	0.987485	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : forall v0 : @nat, @Q) (v1 : forall v1 : @positive, @nat) (v2 : QCauchySeq v0 v1) => let v3 : @Z := (Qnum (Qabs (v0 (v1 1%positive))) + 1)%Z in let v4 : v3 = (Qnum (Qabs (v0 (v1 1%positive))) + 1)%Z := eq_refl in let v5 : (0 < v3)%Z := eq_ind_r (fun v5 : @Z => (0 < v5)%Z) (let v5 : (0 <= Qabs (v0 (v1 1%positive)))%Q := Qabs_nonneg (v0 (v1 1%positive)) in let v6 : @Q := Qabs (v0 (v1 1%positive)) in match v6 as v7 in Q return (forall v8 : (0 <= v7)%Q, (0 < Qnum v7 + 1)%Z) with | (v7 # v8)%Q => (fun (v7 : @Z) (v8 : @positive) (v9 : (0 <= v7 # v8)%Q) => (let v10 : (0 <= v7)%Z := eq_ind (v7 * 1)%Z (fun v10 : @Z => (0 <= v10)%Z) v9 v7 (Z.mul_1_r v7) in Z.lt_le_trans 0 1 (v7 + 1) (eq_refl : (0 < 1)%Z) (eq_ind (0 + 1)%Z (fun v11 : @Z => (v11 <= v7 + v11)%Z) (eq_ind_r (fun v11 : @Z => (0 + 1 <= v11)%Z) (Zplus_le_compat_r 0 (v7 + 0) 1 (eq_ind_r (fun v11 : @Z => (0 <= v11)%Z) v10 (Z.add_0_r v7))) (Z.add_assoc v7 0 1)) 1%Z (Z.add_0_l 1))) : (0 < Qnum (v7 # v8) + 1)%Z) v7 v8 end v5) v4 in let v6 : {v6 : @positive | forall (v7 : @nat) (v8 : (v1 1%positive <= v7)%nat), (Qabs (v0 v7) * (1 # v6) < 1)%Q} := let v6 : @Z := v3 in let v7 : v3 = v6 := eq_refl in match v6 as v8 in Z return (forall (v9 : v3 = v8) (v10 : v8 = (Qnum (Qabs (v0 (v1 1%positive))) + 1)%Z) (v11 : (0 < v8)%Z), {v12 : @positive | forall (v13 : @nat) (v14 : (v1 1%positive <= v13)%nat), (Qabs (v0 v13) * (1 # v12) < 1)%Q}) with | 0%Z => fun (v8 : v3 = 0%Z) (v9 : 0%Z = (Qnum (Qabs (v0 (v1 1%positive))) + 1)%Z) (v10 : (0 < 0)%Z) => False_rec {v11 : @positive | forall (v12 : @nat) (v13 : (v1 1%positive <= v12)%nat), (Qabs (v0 v12) * (1 # v11) < 1)%Q} (Z.lt_irrefl 0 v10) | Z.pos v8 => (fun (v8 : @positive) (v9 : v3 = Z.pos v8) (v10 : Z.pos v8 = (Qnum (Qabs (v0 (v1 1%positive))) + 1)%Z) (v11 : (0 < Z.pos v8)%Z) => exist (fun v12 : @positive => forall (v13 : @nat) (v14 : (v1 1%positive <= v13)%nat), (Qabs (v0 v13) * (1 # v12) < 1)%Q) v8 (fun (v12 : @nat) (v13 : (v1 1%positive <= v12)%nat) => let v14 : (Qabs (v0 (v1 1%positive) - v0 v12) < 1)%Q := v2 1%positive (v1 1%positive) v12 (Nat.le_refl (v1 1%positive)) v13 in let v15 : (Qabs (v0 v12) < Qabs (v0 (v1 1%positive)) + 1)%Q := let v15 : forall v15 : (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)) < Qabs (v0 (v1 1%positive)) + 1 + - Qabs (v0 (v1 1%positive)))%Q, (Qabs (v0 v12) < Qabs (v0 (v1 1%positive)) + 1)%Q := match Qplus_lt_l (Qabs (v0 v12)) (Qabs (v0 (v1 1%positive)) + 1) (- Qabs (v0 (v1 1%positive))) as v15 in (_ /\ _) return (forall v16 : (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)) < Qabs (v0 (v1 1%positive)) + 1 + - Qabs (v0 (v1 1%positive)))%Q, (Qabs (v0 v12) < Qabs (v0 (v1 1%positive)) + 1)%Q) with | conj v15 v16 => (fun (v15 : forall v15 : (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)) < Qabs (v0 (v1 1%positive)) + 1 + - Qabs (v0 (v1 1%positive)))%Q, (Qabs (v0 v12) < Qabs (v0 (v1 1%positive)) + 1)%Q) (v16 : forall v16 : (Qabs (v0 v12) < Qabs (v0 (v1 1%positive)) + 1)%Q, (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)) < Qabs (v0 (v1 1%positive)) + 1 + - Qabs (v0 (v1 1%positive)))%Q) => v15) v15 v16 end in v15 ((fun v16 : (1 + Qabs (v0 (v1 1%positive)) == Qabs (v0 (v1 1%positive)) + 1)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)))%Q) (Qabs (v0 (v1 1%positive)) + 1 + - Qabs (v0 (v1 1%positive)))%Q (1 + Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive)))%Q (Qplus_comp (Qabs (v0 (v1 1%positive)) + 1)%Q (1 + Qabs (v0 (v1 1%positive)))%Q (symmetry v16) (- Qabs (v0 (v1 1%positive)))%Q (- Qabs (v0 (v1 1%positive)))%Q (reflexive_proper_proxy Equivalence_Reflexive (- Qabs (v0 (v1 1%positive)))%Q))) (Qplus_comm 1 (Qabs (v0 (v1 1%positive)))) ((fun v16 : (1 + (Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive))) == 1 + Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive)))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)))%Q) (1 + Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive)))%Q (1 + (Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive))))%Q (symmetry v16)) (Qplus_assoc 1 (Qabs (v0 (v1 1%positive))) (- Qabs (v0 (v1 1%positive)))) ((fun v16 : (Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive)) == 0)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)))%Q) (1 + (Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive))))%Q (1 + 0)%Q (Reflexive_partial_app_morphism (@Qplus_comp) (reflexive_proper_proxy Equivalence_Reflexive 1) (Qabs (v0 (v1 1%positive)) + - Qabs (v0 (v1 1%positive)))%Q 0 v16)) (Qplus_opp_r (Qabs (v0 (v1 1%positive)))) ((fun v16 : (1 + 0 == 1)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive)))%Q) (1 + 0)%Q 1 v16) (Qplus_0_r 1) (Qle_lt_trans (Qabs (v0 v12) + - Qabs (v0 (v1 1%positive))) (Qabs (v0 v12 - v0 (v1 1%positive))) 1 (Qabs_triangle_reverse (v0 v12) (v0 (v1 1%positive))) (eq_ind_r (fun v16 : @Q => (v16 < 1)%Q) v14 (Qabs_Qminus (v0 v12) (v0 (v1 1%positive))))))))) in Qlt_le_trans (Qabs (v0 v12) * (1 # v8)) ((Qabs (v0 (v1 1%positive)) + 1) * (1 # v8)) 1 (let v16 : forall (v16 v17 v18 : @Q) (v19 : (0 < v18)%Q) (v20 : (v16 < v17)%Q), (v16 * v18 < v17 * v18)%Q := fun (v16 v17 v18 : @Q) (v19 : (0 < v18)%Q) => match Qmult_lt_r v16 v17 v18 v19 as v20 in (_ /\ _) return (forall v21 : (v16 < v17)%Q, (v16 * v18 < v17 * v18)%Q) with | conj v20 v21 => (fun (v20 : forall v20 : (v16 * v18 < v17 * v18)%Q, (v16 < v17)%Q) (v21 : forall v21 : (v16 < v17)%Q, (v16 * v18 < v17 * v18)%Q) => v21) v20 v21 end in v16 (Qabs (v0 v12)) (Qabs (v0 (v1 1%positive)) + 1)%Q (1 # v8)%Q (((v11 : (0 < 1)%Z) : (Qnum 0 * QDen (1 # v8) < Qnum (1 # v8) * QDen 0)%Z) : (0 < 1 # v8)%Q) v15) ((eq_ind_r (fun v16 : @Z => (v16 <= Z.pos (Qden (Qabs (v0 (v1 1%positive))) * 1 * v8))%Z) (eq_ind_r (fun v16 : @Z => (v16 <= Z.pos (Qden (Qabs (v0 (v1 1%positive))) * 1 * v8))%Z) (eq_ind_r (fun v16 : @Z => (v16 + QDen (Qabs (v0 (v1 1%positive))) <= Z.pos (Qden (Qabs (v0 (v1 1%positive))) * 1 * v8))%Z) (eq_ind_r (fun v16 : @positive => (Qnum (Qabs (v0 (v1 1%positive))) + QDen (Qabs (v0 (v1 1%positive))) <= Z.pos (v16 * v8))%Z) (eq_ind_r (fun v16 : @Z => (Qnum (Qabs (v0 (v1 1%positive))) + QDen (Qabs (v0 (v1 1%positive))) <= v16)%Z) (eq_ind_r (fun v16 : @Z => (Qnum (Qabs (v0 (v1 1%positive))) + QDen (Qabs (v0 (v1 1%positive))) <= QDen (Qabs (v0 (v1 1%positive))) * v16)%Z) (let v16 : @Q := Qabs (v0 (v1 1%positive)) in let v17 : Qabs (v0 (v1 1%positive)) = v16 := eq_refl in match v16 as v18 in Q return (forall (v19 : Qabs (v0 (v1 1%positive)) = v18) (v20 : Z.pos v8 = (Qnum v18 + 1)%Z) (v21 : (Qabs (v0 v12) < v18 + 1)%Q), (Qnum v18 + QDen v18 <= QDen v18 * (Qnum v18 + 1))%Z) with | (v18 # v19)%Q => (fun (v18 : @Z) (v19 : @positive) (v20 : Qabs (v0 (v1 1%positive)) = (v18 # v19)%Q) (v21 : Z.pos v8 = (Qnum (v18 # v19) + 1)%Z) (v22 : (Qabs (v0 v12) < (v18 # v19) + 1)%Q) => eq_ind_r (fun v23 : @Z => (Qnum (v18 # v19) + QDen (v18 # v19) <= v23)%Z) (eq_ind_r (fun v23 : @Z => (Qnum (v18 # v19) + QDen (v18 # v19) <= QDen (v18 # v19) * Qnum (v18 # v19) + v23)%Z) (Zplus_le_compat_r (Qnum (v18 # v19)) (QDen (v18 # v19) * Qnum (v18 # v19)) (QDen (v18 # v19)) (eq_ind (1 * Qnum (v18 # v19))%Z (fun v23 : @Z => (v23 <= QDen (v18 # v19) * v23)%Z) (eq_ind_r (fun v23 : @Z => (1 * Qnum (v18 # v19) <= v23)%Z) (Zmult_le_compat_r 1 (QDen (v18 # v19) * 1) (Qnum (v18 # v19)) (eq_ind_r (fun v23 : @Z => (1 <= v23)%Z) ((eq_ind (1 ?= v19)%positive (fun v23 : @comparison => v23 <> @Gt) (match v19 as v23 in positive return (forall (v24 : Qabs (v0 (v1 1%positive)) = (v18 # v23)%Q) (v25 : Z.pos v8 = (Qnum (v18 # v23) + 1)%Z) (v26 : (Qabs (v0 v12) < (v18 # v23) + 1)%Q), BinPosDef.Pos.compare_cont (@Eq) 1 v23 <> @Gt) with | (v23~1)%positive => (fun (v23 : @positive) (v24 : Qabs (v0 (v1 1%positive)) = (v18 # v23~1)%Q) (v25 : Z.pos v8 = (Qnum (v18 # v23~1) + 1)%Z) (v26 : (Qabs (v0 v12) < (v18 # v23~1) + 1)%Q) => (fun v27 : BinPosDef.Pos.compare_cont (@Eq) 1 v23~1 = @Gt => let v28 : @False := eq_ind (BinPosDef.Pos.compare_cont (@Eq) 1 v23~1) (fun v28 : @comparison => match v28 as v29 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v27 in False_ind (@False) v28) : BinPosDef.Pos.compare_cont (@Eq) 1 v23~1 <> @Gt) v23 | (v23~0)%positive => (fun (v23 : @positive) (v24 : Qabs (v0 (v1 1%positive)) = (v18 # v23~0)%Q) (v25 : Z.pos v8 = (Qnum (v18 # v23~0) + 1)%Z) (v26 : (Qabs (v0 v12) < (v18 # v23~0) + 1)%Q) => (fun v27 : BinPosDef.Pos.compare_cont (@Eq) 1 v23~0 = @Gt => let v28 : @False := eq_ind (BinPosDef.Pos.compare_cont (@Eq) 1 v23~0) (fun v28 : @comparison => match v28 as v29 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v27 in False_ind (@False) v28) : BinPosDef.Pos.compare_cont (@Eq) 1 v23~0 <> @Gt) v23 | 1%positive => fun (v23 : Qabs (v0 (v1 1%positive)) = (v18 # 1)%Q) (v24 : Z.pos v8 = (Qnum (v18 # 1) + 1)%Z) (v25 : (Qabs (v0 v12) < (v18 # 1) + 1)%Q) => (fun v26 : BinPosDef.Pos.compare_cont (@Eq) 1 1 = @Gt => let v27 : @False := eq_ind (BinPosDef.Pos.compare_cont (@Eq) 1 1) (fun v27 : @comparison => match v27 as v28 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v26 in False_ind (@False) v27) : BinPosDef.Pos.compare_cont (@Eq) 1 1 <> @Gt end v20 v21 v22 : (1 ?= v19)%positive <> @Gt) (1 ?= Z.pos v19)%Z (Pos2Z.inj_compare 1 v19) : (1 <= Z.pos v19)%Z) : (1 <= QDen (v18 # v19))%Z) (Z.mul_1_r (QDen (v18 # v19)))) ((let v23 : (0 <= v18 # v19)%Q := eq_ind (Qabs (v0 (v1 1%positive))) (fun v23 : @Q => (0 <= v23)%Q) (Qabs_nonneg (v0 (v1 1%positive))) (v18 # v19)%Q v20 in let v24 : (0 <= v18)%Z := eq_ind (v18 * 1)%Z (fun v24 : @Z => (0 <= v24)%Z) v23 v18 (Z.mul_1_r v18) in v24) : (0 <= Qnum (v18 # v19))%Z)) (Z.mul_assoc (QDen (v18 # v19)) 1 (Qnum (v18 # v19)))) (Qnum (v18 # v19)) (Z.mul_1_l (Qnum (v18 # v19))))) (Z.mul_1_r (QDen (v18 # v19)))) (Z.mul_add_distr_l (QDen (v18 # v19)) (Qnum (v18 # v19)) 1)) v18 v19 end v17 v10 v15) v10) (Pos2Z.inj_mul (Qden (Qabs (v0 (v1 1%positive)))) v8)) (Pos.mul_1_r (Qden (Qabs (v0 (v1 1%positive)))))) (Z.mul_1_r (Qnum (Qabs (v0 (v1 1%positive)))))) (Z.mul_1_r (Qnum (Qabs (v0 (v1 1%positive))) * 1 + QDen (Qabs (v0 (v1 1%positive)))))) (Z.mul_1_r ((Qnum (Qabs (v0 (v1 1%positive))) * 1 + QDen (Qabs (v0 (v1 1%positive)))) * 1)) : (Qnum ((Qabs (v0 (v1 1%positive)) + 1) * (1 # v8)) * QDen 1 <= Qnum 1 * QDen ((Qabs (v0 (v1 1%positive)) + 1) * (1 # v8)))%Z) : ((Qabs (v0 (v1 1%positive)) + 1) * (1 # v8) <= 1)%Q))) v8 | Z.neg v8 => (fun (v8 : @positive) (v9 : v3 = Z.neg v8) (v10 : Z.neg v8 = (Qnum (Qabs (v0 (v1 1%positive))) + 1)%Z) (v11 : (0 < Z.neg v8)%Z) => False_rec {v12 : @positive | forall (v13 : @nat) (v14 : (v1 1%positive <= v13)%nat), (Qabs (v0 v13) * (1 # v12) < 1)%Q} (let v12 : forall v12 : @Lt = @Lt, @False := match v11 as v13 in (_ = v12) return (forall v14 : v12 = @Lt, @False) with | eq_refl => fun v12 : (0 ?= Z.neg v8)%Z = @Lt => (fun v13 : (0 ?= Z.neg v8)%Z = @Lt => let v14 : @False := eq_ind (0 ?= Z.neg v8)%Z (fun v14 : @comparison => match v14 as v15 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v13 in False_ind (@False) v14) v12 end in v12 eq_refl)) v8 end v7 v4 v5 in match v6 as v7 in (sig _) return {v8 : @positive | forall v9 : @nat, (Qabs (v0 v9) < Z.pos v8 # 1)%Q} with | exist _ v7 v8 => (fun (v7 : @positive) (v8 : forall (v8 : @nat) (v9 : (v1 1%positive <= v8)%nat), (Qabs (v0 v8) * (1 # v7) < 1)%Q) => BoundFromZero v0 (v1 1%positive) v7 (fun (v9 : @nat) (v10 : (v1 1%positive <= v9)%nat) => let v11 : (Qabs (v0 v9) * (1 # v7) < 1)%Q := v8 v9 v10 in let v12 : default_relation (Z.pos v7 # 1)%Q (/ (1 # v7)) := reflexivity (/ (1 # v7)) : default_relation (Z.pos v7 # 1)%Q (/ (1 # v7)) in ((fun v13 : (Z.pos v7 # 1 == / (1 # v7))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (Qabs (v0 v9))) (Z.pos v7 # 1)%Q (/ (1 # v7)) v13 ((fun v14 : (1 * / (1 # v7) == / (1 # v7))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (Qabs (v0 v9))) (/ (1 # v7)) (1 * / (1 # v7)) (symmetry v14)) (Qmult_1_l (/ (1 # v7))) (Qlt_shift_div_l (Qabs (v0 v9)) 1 (1 # v7) eq_refl v11))) : forall v13 : default_relation (Z.pos v7 # 1)%Q (/ (1 # v7)), (Qabs (v0 v9) < Z.pos v7 # 1)%Q) v12)) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_cauchy	100	2.564707	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.linear_max	100	0.111861	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @positive) (v3 : @nat) (v4 : (BinPosDef.Pos.to_nat v0 <= v3)%nat) => eq_ind_r (fun v5 : @nat => (v5 <= BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2) * v3)%nat) (eq_ind_r (fun v5 : @nat => (v5 <= BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2) * v3)%nat) (Nat.mul_le_mono_nonneg (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2)) (BinPosDef.Pos.to_nat v0) v3 (Nat.le_0_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2))) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2))) (Nat.le_0_l (BinPosDef.Pos.to_nat v0)) v4) (Pos2Nat.inj_mul (2 * BinPosDef.Pos.max v1 v2) v0)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2 * v0)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2 * v0)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v1 v2 * v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult	100	0.107311	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @CReal => match v0 as v2 in (sig _) return (@CReal) with | exist _ v2 v3 => (fun (v2 : forall v2 : @nat, @Q) (v3 : QCauchySeq v2 (@BinPosDef.Pos.to_nat)) => match v1 as v4 in (sig _) return (@CReal) with | exist _ v4 v5 => (fun (v4 : forall v4 : @nat, @Q) (v5 : QCauchySeq v4 (@BinPosDef.Pos.to_nat)) => let v6 : QSeqEquiv (fun v6 : @nat => (v2 v6 + v4 v6)%Q) (fun v6 : @nat => (v2 v6 + v4 v6)%Q) (fun v6 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * v6)) (BinPosDef.Pos.to_nat (2 * v6))) := CReal_plus_cauchy v2 v2 v4 (@BinPosDef.Pos.to_nat) v3 v5 in exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) (fun v7 : @nat => (v2 (2 * v7)%nat + v4 (2 * v7)%nat)%Q) ((fun (v7 : @positive) (v8 v9 : @nat) (v10 : (BinPosDef.Pos.to_nat v7 <= v8)%nat) (v11 : (BinPosDef.Pos.to_nat v7 <= v9)%nat) => v6 v7 (2 * v8)%nat (2 * v9)%nat (eq_ind_r (fun v12 : @nat => (v12 <= 2 * v8)%nat) (eq_ind_r (fun v12 : @nat => (v12 <= 2 * v8)%nat) (Nat.mul_le_mono_nonneg (BinPosDef.Pos.to_nat 2) 2 (BinPosDef.Pos.to_nat v7) v8 (Nat.le_0_l (BinPosDef.Pos.to_nat 2)) (Nat.le_refl 2) (Nat.le_0_l (BinPosDef.Pos.to_nat v7)) v10) (Pos2Nat.inj_mul 2 v7)) (max_l (BinPosDef.Pos.to_nat (2 * v7)) (BinPosDef.Pos.to_nat (2 * v7)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * v7))))) (eq_ind_r (fun v12 : @nat => (Init.Nat.max v12 v12 <= 2 * v9)%nat) (eq_ind_r (fun v12 : @nat => (v12 <= 2 * v9)%nat) (Nat.mul_le_mono_nonneg (BinPosDef.Pos.to_nat 2) 2 (BinPosDef.Pos.to_nat v7) v9 (Nat.le_0_l (BinPosDef.Pos.to_nat 2)) (Nat.le_refl 2) (Nat.le_0_l (BinPosDef.Pos.to_nat v7)) v11) (max_l (BinPosDef.Pos.to_nat 2 * BinPosDef.Pos.to_nat v7) (BinPosDef.Pos.to_nat 2 * BinPosDef.Pos.to_nat v7) (Nat.le_refl (BinPosDef.Pos.to_nat 2 * BinPosDef.Pos.to_nat v7)))) (Pos2Nat.inj_mul 2 v7))) : QCauchySeq (fun v7 : @nat => (v2 (2 * v7)%nat + v4 (2 * v7)%nat)%Q) (@BinPosDef.Pos.to_nat))) v4 v5 end) v2 v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_unfold	100	0.466520	1	1	0	synth with cache (only 1: refine (fun v0 : @CReal => match v0 as v1 in (sig _) return (forall v2 : @CReal, QSeqEquivEx (proj1_sig (v1 * v2)) (fun v3 : @nat => (proj1_sig v1 v3 * proj1_sig v2 v3)%Q)) with | exist _ v1 v2 => (fun (v1 : forall v1 : @nat, @Q) (v2 : QCauchySeq v1 (@BinPosDef.Pos.to_nat)) (v3 : @CReal) => match v3 as v4 in (sig _) return (QSeqEquivEx (proj1_sig (exist (fun v5 : forall v5 : @nat, @Q => QCauchySeq v5 (@BinPosDef.Pos.to_nat)) v1 v2 * v4)) (fun v5 : @nat => (proj1_sig (exist (fun v6 : forall v6 : @nat, @Q => QCauchySeq v6 (@BinPosDef.Pos.to_nat)) v1 v2) v5 * proj1_sig v4 v5)%Q)) with | exist _ v4 v5 => (fun (v4 : forall v4 : @nat, @Q) (v5 : QCauchySeq v4 (@BinPosDef.Pos.to_nat)) => ((let v6 : {v6 : @positive | forall v7 : @nat, (Qabs (v1 v7) < Z.pos v6 # 1)%Q} := QCauchySeq_bounded v1 (@BinPosDef.Pos.to_nat) v2 in match v6 as v7 in (sig _) return (QSeqEquivEx (proj1_sig match v7 as v8 in (sig _) return (@CReal) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, (Qabs (v1 v9) < Z.pos v8 # 1)%Q) => match QCauchySeq_bounded v4 (@BinPosDef.Pos.to_nat) v5 as v10 in (sig _) return (@CReal) with | exist _ v10 v11 => (fun (v10 : @positive) (v11 : forall v11 : @nat, (Qabs (v4 v11) < Z.pos v10 # 1)%Q) => exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => (v1 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v10)~0 * v12)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v10)~0 * v12)%nat)%Q) (fun (v12 : @positive) (v13 v14 : @nat) (v15 : (BinPosDef.Pos.to_nat v12 <= v13)%nat) (v16 : (BinPosDef.Pos.to_nat v12 <= v14)%nat) => CReal_mult_cauchy v1 v1 v4 v8 v10 (@BinPosDef.Pos.to_nat) v2 v5 v9 v11 v12 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v10)~0 * v13)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v10)~0 * v14)%nat (linear_max v12 v8 v10 v13 v15) (linear_max v12 v8 v10 v14 v16))) v10 v11 end) v8 v9 end) (fun v8 : @nat => (v1 v8 * v4 v8)%Q)) with | exist _ v7 v8 => (fun (v7 : @positive) (v8 : forall v8 : @nat, (Qabs (v1 v8) < Z.pos v7 # 1)%Q) => let v9 : {v9 : @positive | forall v10 : @nat, (Qabs (v4 v10) < Z.pos v9 # 1)%Q} := QCauchySeq_bounded v4 (@BinPosDef.Pos.to_nat) v5 in match v9 as v10 in (sig _) return (QSeqEquivEx (proj1_sig match v10 as v11 in (sig _) return (@CReal) with | exist _ v11 v12 => (fun (v11 : @positive) (v12 : forall v12 : @nat, (Qabs (v4 v12) < Z.pos v11 # 1)%Q) => exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) (fun v13 : @nat => (v1 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v11)~0 * v13)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v11)~0 * v13)%nat)%Q) (fun (v13 : @positive) (v14 v15 : @nat) (v16 : (BinPosDef.Pos.to_nat v13 <= v14)%nat) (v17 : (BinPosDef.Pos.to_nat v13 <= v15)%nat) => CReal_mult_cauchy v1 v1 v4 v7 v11 (@BinPosDef.Pos.to_nat) v2 v5 v8 v12 v13 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v11)~0 * v14)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v11)~0 * v15)%nat (linear_max v13 v7 v11 v14 v16) (linear_max v13 v7 v11 v15 v17))) v11 v12 end) (fun v11 : @nat => (v1 v11 * v4 v11)%Q)) with | exist _ v10 v11 => (fun (v10 : @positive) (v11 : forall v11 : @nat, (Qabs (v4 v11) < Z.pos v10 # 1)%Q) => (let v12 : QSeqEquiv (fun v12 : @nat => (v1 v12 * v4 v12)%Q) (fun v12 : @nat => (v1 v12 * v4 v12)%Q) (fun v12 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v12)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v12))) := CReal_mult_cauchy v1 v1 v4 v7 v10 (@BinPosDef.Pos.to_nat) v2 v5 v8 v11 in ex_intro (fun v13 : forall v13 : @positive, @nat => QSeqEquiv (fun v14 : @nat => (v1 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v14)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v14)%nat)%Q) (fun v14 : @nat => (v1 v14 * v4 v14)%Q) v13) (fun v13 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13))) ((fun (v13 : @positive) (v14 v15 : @nat) (v16 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) <= v14)%nat) (v17 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) <= v15)%nat) => let v18 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13) <= v14)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13))) (fun v18 : @nat => (v18 <= v14)%nat) v16 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)))) in let v19 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13) <= v15)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13))) (fun v19 : @nat => (v19 <= v15)%nat) v17 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)))) in v12 v13 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v14)%nat v15 (linear_max v13 v7 v10 v14 (Nat.le_trans (BinPosDef.Pos.to_nat v13) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) v14 (eq_ind (1 * BinPosDef.Pos.to_nat v13)%nat (fun v20 : @nat => (v20 <= BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13))%nat) (eq_ind_r (fun v20 : @nat => (1 * BinPosDef.Pos.to_nat v13 <= v20)%nat) (Nat.mul_le_mono_nonneg 1 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10)) (BinPosDef.Pos.to_nat v13) (BinPosDef.Pos.to_nat v13) (le_S 0 0 (le_n 0)) (Pos2Nat.is_pos (2 * BinPosDef.Pos.max v7 v10)) (Nat.le_0_l (BinPosDef.Pos.to_nat v13)) (Nat.le_refl (BinPosDef.Pos.to_nat v13))) (Pos2Nat.inj_mul (2 * BinPosDef.Pos.max v7 v10) v13)) (BinPosDef.Pos.to_nat v13) (Nat.mul_1_l (BinPosDef.Pos.to_nat v13))) v18)) (eq_ind_r (fun v20 : @nat => (v20 <= v15)%nat) v19 (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)))))) : QSeqEquiv (fun v13 : @nat => (v1 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v13)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v13)%nat)%Q) (fun v13 : @nat => (v1 v13 * v4 v13)%Q) (fun v13 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v7 v10 * v13))))) : QSeqEquivEx (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => (v1 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v12)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v12)%nat)%Q) (fun (v12 : @positive) (v13 v14 : @nat) (v15 : (BinPosDef.Pos.to_nat v12 <= v13)%nat) (v16 : (BinPosDef.Pos.to_nat v12 <= v14)%nat) => CReal_mult_cauchy v1 v1 v4 v7 v10 (@BinPosDef.Pos.to_nat) v2 v5 v8 v11 v12 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v13)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v10)~0 * v14)%nat (linear_max v12 v7 v10 v13 v15) (linear_max v12 v7 v10 v14 v16)))) (fun v12 : @nat => (v1 v12 * v4 v12)%Q)) v10 v11 end) v7 v8 end) : QSeqEquivEx (proj1_sig match QCauchySeq_bounded v1 (@BinPosDef.Pos.to_nat) v2 as v6 in (sig _) return (@CReal) with | exist _ v6 v7 => (fun (v6 : @positive) (v7 : forall v7 : @nat, (Qabs (v1 v7) < Z.pos v6 # 1)%Q) => match QCauchySeq_bounded v4 (@BinPosDef.Pos.to_nat) v5 as v8 in (sig _) return (@CReal) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, (Qabs (v4 v9) < Z.pos v8 # 1)%Q) => exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => (v1 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v6 v8) * v10)%nat * v4 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v6 v8) * v10)%nat)%Q) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy v1 v1 v4 v6 v8 (@BinPosDef.Pos.to_nat) v2 v5 v7 v9 v10 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v6 v8) * v11)%nat (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v6 v8) * v12)%nat (linear_max v10 v6 v8 v11 v13) (linear_max v10 v6 v8 v12 v14))) v8 v9 end) v6 v7 end) (fun v6 : @nat => (proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v1 v2) v6 * proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v4 v5) v6)%Q)) : QSeqEquivEx (proj1_sig (exist (fun v6 : forall v6 : @nat, @Q => QCauchySeq v6 (@BinPosDef.Pos.to_nat)) v1 v2 * exist (fun v6 : forall v6 : @nat, @Q => QCauchySeq v6 (@BinPosDef.Pos.to_nat)) v4 v5)) (fun v6 : @nat => (proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v1 v2) v6 * proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v4 v5) v6)%Q)) v4 v5 end) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_assoc_bounded_r	100	0.107972	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @nat, @Q) (v1 : forall v1 : @nat, @Q) (v2 : forall v2 : @nat, @Q) (v3 : QSeqEquivEx v0 v1) (v4 : QSeqEquiv v2 v2 (@BinPosDef.Pos.to_nat)) => match v3 as v5 in (ex _) return (QSeqEquivEx (fun v6 : @nat => (v0 v6 * v2 v6)%Q) (fun v6 : @nat => (v1 v6 * v2 v6)%Q)) with | ex_intro _ v5 v6 => (fun (v5 : forall v5 : @positive, @nat) (v6 : QSeqEquiv v0 v1 v5) => let v7 : {v7 : @positive | forall v8 : @nat, (Qabs (v1 v8) < Z.pos v7 # 1)%Q} := QCauchySeq_bounded v1 (fun v7 : @positive => v5 (2 * v7)%positive) (QSeqEquiv_cau_r v0 v1 v5 v6) in match v7 as v8 in (sig _) return (QSeqEquivEx (fun v9 : @nat => (v0 v9 * v2 v9)%Q) (fun v9 : @nat => (v1 v9 * v2 v9)%Q)) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, (Qabs (v1 v9) < Z.pos v8 # 1)%Q) => let v10 : {v10 : @positive | forall v11 : @nat, (Qabs (v2 v11) < Z.pos v10 # 1)%Q} := QCauchySeq_bounded v2 (@BinPosDef.Pos.to_nat) v4 in match v10 as v11 in (sig _) return (QSeqEquivEx (fun v12 : @nat => (v0 v12 * v2 v12)%Q) (fun v12 : @nat => (v1 v12 * v2 v12)%Q)) with | exist _ v11 v12 => (fun (v11 : @positive) (v12 : forall v12 : @nat, (Qabs (v2 v12) < Z.pos v11 # 1)%Q) => ex_intro (fun v13 : forall v13 : @positive, @nat => QSeqEquiv (fun v14 : @nat => (v0 v14 * v2 v14)%Q) (fun v14 : @nat => (v1 v14 * v2 v14)%Q) v13) (fun v13 : @positive => Init.Nat.max (v5 (2 * BinPosDef.Pos.max v8 v11 * v13)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v8 v11 * v13))) (CReal_mult_cauchy v0 v1 v2 v8 v11 v5 v6 v4 v9 v12)) v11 v12 end) v8 v9 end) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_assoc	100	1.813831	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @CReal => let v3 : forall (v3 v4 : @CReal) (v5 : forall v5 : @positive, (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v5) - proj1_sig v4 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q), v3 == v4 := fun v3 v4 : @CReal => match CRealEq_diff v3 v4 as v5 in (_ /\ _) return (forall v6 : forall v6 : @positive, (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q, v3 == v4) with | conj v5 v6 => (fun (v5 : forall (v5 : v3 == v4) (v6 : @positive), (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q) (v6 : forall v6 : forall v6 : @positive, (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q, v3 == v4) => v6) v5 v6 end in v3 (v0 * v1 * v2) (v0 * (v1 * v2)) (let v4 : forall (v4 v5 : @CReal) (v6 : QSeqEquivEx (proj1_sig v4) (proj1_sig v5)) (v7 : @positive), (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q := fun v4 v5 : @CReal => match CRealEq_modindep v4 v5 as v6 in (_ /\ _) return (forall (v7 : QSeqEquivEx (proj1_sig v4) (proj1_sig v5)) (v8 : @positive), (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v8) - proj1_sig v5 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q) with | conj v6 v7 => (fun (v6 : forall (v6 : QSeqEquivEx (proj1_sig v4) (proj1_sig v5)) (v7 : @positive), (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q) (v7 : forall v7 : forall v7 : @positive, (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q, QSeqEquivEx (proj1_sig v4) (proj1_sig v5)) => v6) v6 v7 end in v4 (v0 * v1 * v2) (v0 * (v1 * v2)) (QSeqEquivEx_trans (proj1_sig (v0 * v1 * v2)) (fun v5 : @nat => (proj1_sig v0 v5 * proj1_sig v1 v5 * proj1_sig v2 v5)%Q) (proj1_sig (v0 * (v1 * v2))) (QSeqEquivEx_trans (proj1_sig (v0 * v1 * v2)) (fun v5 : @nat => (proj1_sig (v0 * v1)%CReal v5 * proj1_sig v2 v5)%Q) (fun v5 : @nat => (proj1_sig v0 v5 * proj1_sig v1 v5 * proj1_sig v2 v5)%Q) (CReal_mult_unfold (v0 * v1) v2) match v0 as v5 in (sig _) return (QSeqEquivEx (fun v6 : @nat => (proj1_sig (v5 * v1)%CReal v6 * proj1_sig v2 v6)%Q) (fun v6 : @nat => (proj1_sig v5 v6 * proj1_sig v1 v6 * proj1_sig v2 v6)%Q)) with | exist _ v5 v6 => (fun (v5 : forall v5 : @nat, @Q) (v6 : QCauchySeq v5 (@BinPosDef.Pos.to_nat)) => match v1 as v7 in (sig _) return (QSeqEquivEx (fun v8 : @nat => (proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v5 v6 * v7)%CReal v8 * proj1_sig v2 v8)%Q) (fun v8 : @nat => (proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v5 v6) v8 * proj1_sig v7 v8 * proj1_sig v2 v8)%Q)) with | exist _ v7 v8 => (fun (v7 : forall v7 : @nat, @Q) (v8 : QCauchySeq v7 (@BinPosDef.Pos.to_nat)) => match v2 as v9 in (sig _) return (QSeqEquivEx (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v5 v6 * exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v7 v8)%CReal v10 * proj1_sig v9 v10)%Q) (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v5 v6) v10 * proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v7 v8) v10 * proj1_sig v9 v10)%Q)) with | exist _ v9 v10 => (fun (v9 : forall v9 : @nat, @Q) (v10 : QCauchySeq v9 (@BinPosDef.Pos.to_nat)) => ((let v11 : {v11 : @positive | forall v12 : @nat, (Qabs (v5 v12) < Z.pos v11 # 1)%Q} := QCauchySeq_bounded v5 (@BinPosDef.Pos.to_nat) v6 in match v11 as v12 in (sig _) return (QSeqEquivEx (fun v13 : @nat => (proj1_sig match v12 as v14 in (sig _) return (@CReal) with | exist _ v14 v15 => (fun (v14 : @positive) (v15 : forall v15 : @nat, Qabs (v5 v15) < Z.pos v14 # 1) => match QCauchySeq_bounded v7 (@BinPosDef.Pos.to_nat) v8 as v16 in (sig _) return (@CReal) with | exist _ v16 v17 => (fun (v16 : @positive) (v17 : forall v17 : @nat, Qabs (v7 v17) < Z.pos v16 # 1) => exist (fun v18 : forall v18 : @nat, @Q => QCauchySeq v18 (@BinPosDef.Pos.to_nat)) (fun v18 : @nat => v5 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v18)%nat * v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v18)%nat) (fun (v18 : @positive) (v19 v20 : @nat) (v21 : (BinPosDef.Pos.to_nat v18 <= v19)%nat) (v22 : (BinPosDef.Pos.to_nat v18 <= v20)%nat) => CReal_mult_cauchy v5 v5 v7 v14 v16 (@BinPosDef.Pos.to_nat) v6 v8 v15 v17 v18 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v19)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v20)%nat (linear_max v18 v14 v16 v19 v21) (linear_max v18 v14 v16 v20 v22))) v16 v17 end) v14 v15 end v13 * v9 v13)%Q) (fun v13 : @nat => (v5 v13 * v7 v13 * v9 v13)%Q)) with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : forall v13 : @nat, (Qabs (v5 v13) < Z.pos v12 # 1)%Q) => let v14 : {v14 : @positive | forall v15 : @nat, (Qabs (v7 v15) < Z.pos v14 # 1)%Q} := QCauchySeq_bounded v7 (@BinPosDef.Pos.to_nat) v8 in match v14 as v15 in (sig _) return (QSeqEquivEx (fun v16 : @nat => (proj1_sig match v15 as v17 in (sig _) return (@CReal) with | exist _ v17 v18 => (fun (v17 : @positive) (v18 : forall v18 : @nat, Qabs (v7 v18) < Z.pos v17 # 1) => exist (fun v19 : forall v19 : @nat, @Q => QCauchySeq v19 (@BinPosDef.Pos.to_nat)) (fun v19 : @nat => v5 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v17)~0 * v19)%nat * v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v17)~0 * v19)%nat) (fun (v19 : @positive) (v20 v21 : @nat) (v22 : (BinPosDef.Pos.to_nat v19 <= v20)%nat) (v23 : (BinPosDef.Pos.to_nat v19 <= v21)%nat) => CReal_mult_cauchy v5 v5 v7 v12 v17 (@BinPosDef.Pos.to_nat) v6 v8 v13 v18 v19 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v17)~0 * v20)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v17)~0 * v21)%nat (linear_max v19 v12 v17 v20 v22) (linear_max v19 v12 v17 v21 v23))) v17 v18 end v16 * v9 v16)%Q) (fun v16 : @nat => (v5 v16 * v7 v16 * v9 v16)%Q)) with | exist _ v15 v16 => (fun (v15 : @positive) (v16 : forall v16 : @nat, (Qabs (v7 v16) < Z.pos v15 # 1)%Q) => let v17 : {v17 : @positive | forall v18 : @nat, (Qabs (v9 v18) < Z.pos v17 # 1)%Q} := QCauchySeq_bounded v9 (@BinPosDef.Pos.to_nat) v10 in match v17 as v18 in (sig _) return (QSeqEquivEx (fun v19 : @nat => (proj1_sig (exist (fun v20 : forall v20 : @nat, @Q => QCauchySeq v20 (@BinPosDef.Pos.to_nat)) (fun v20 : @nat => v5 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v20)%nat * v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v20)%nat) (fun (v20 : @positive) (v21 v22 : @nat) (v23 : (BinPosDef.Pos.to_nat v20 <= v21)%nat) (v24 : (BinPosDef.Pos.to_nat v20 <= v22)%nat) => CReal_mult_cauchy v5 v5 v7 v12 v15 (@BinPosDef.Pos.to_nat) v6 v8 v13 v16 v20 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v21)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v22)%nat (linear_max v20 v12 v15 v21 v23) (linear_max v20 v12 v15 v22 v24))) v19 * v9 v19)%Q) (fun v19 : @nat => (v5 v19 * v7 v19 * v9 v19)%Q)) with | exist _ v18 v19 => (fun (v18 : @positive) (v19 : forall v19 : @nat, (Qabs (v9 v19) < Z.pos v18 # 1)%Q) => CReal_mult_assoc_bounded_r (proj1_sig (exist (fun v20 : forall v20 : @nat, @Q => QCauchySeq v20 (@BinPosDef.Pos.to_nat)) (fun v20 : @nat => (v5 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v20)%nat * v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v20)%nat)%Q) (fun (v20 : @positive) (v21 v22 : @nat) (v23 : (BinPosDef.Pos.to_nat v20 <= v21)%nat) (v24 : (BinPosDef.Pos.to_nat v20 <= v22)%nat) => CReal_mult_cauchy v5 v5 v7 v12 v15 (@BinPosDef.Pos.to_nat) v6 v8 v13 v16 v20 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v21)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v22)%nat (linear_max v20 v12 v15 v21 v23) (linear_max v20 v12 v15 v22 v24)))) (fun v20 : @nat => (v5 v20 * v7 v20)%Q) v9 ((let v20 : QSeqEquiv (fun v20 : @nat => (v5 v20 * v7 v20)%Q) (fun v20 : @nat => (v5 v20 * v7 v20)%Q) (fun v20 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v20)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v20))) := CReal_mult_cauchy v5 v5 v7 v12 v15 (@BinPosDef.Pos.to_nat) v6 v8 v13 v16 in ex_intro (fun v21 : forall v21 : @positive, @nat => QSeqEquiv (fun v22 : @nat => (v5 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v22)%nat * v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v22)%nat)%Q) (fun v22 : @nat => (v5 v22 * v7 v22)%Q) v21) (fun v21 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21))) ((fun (v21 : @positive) (v22 v23 : @nat) (v24 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) <= v22)%nat) (v25 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) <= v23)%nat) => let v26 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21) <= v22)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21))) (fun v26 : @nat => (v26 <= v22)%nat) v24 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)))) in let v27 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21) <= v23)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21))) (fun v27 : @nat => (v27 <= v23)%nat) v25 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)))) in v20 v21 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v22)%nat v23 (linear_max v21 v12 v15 v22 (Nat.le_trans (BinPosDef.Pos.to_nat v21) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) v22 (eq_ind (1 * BinPosDef.Pos.to_nat v21)%nat (fun v28 : @nat => (v28 <= BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21))%nat) (eq_ind_r (fun v28 : @nat => (1 * BinPosDef.Pos.to_nat v21 <= v28)%nat) (Nat.mul_le_mono_nonneg 1 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15)) (BinPosDef.Pos.to_nat v21) (BinPosDef.Pos.to_nat v21) (le_S 0 0 (le_n 0)) (Pos2Nat.is_pos (2 * BinPosDef.Pos.max v12 v15)) (Nat.le_0_l (BinPosDef.Pos.to_nat v21)) (Nat.le_refl (BinPosDef.Pos.to_nat v21))) (Pos2Nat.inj_mul (2 * BinPosDef.Pos.max v12 v15) v21)) (BinPosDef.Pos.to_nat v21) (Nat.mul_1_l (BinPosDef.Pos.to_nat v21))) v26)) (eq_ind_r (fun v28 : @nat => (v28 <= v23)%nat) v27 (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)))))) : QSeqEquiv (fun v21 : @nat => (v5 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v21)%nat * v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v21)%nat)%Q) (fun v21 : @nat => (v5 v21 * v7 v21)%Q) (fun v21 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v15 * v21))))) : QSeqEquivEx (proj1_sig (exist (fun v20 : forall v20 : @nat, @Q => QCauchySeq v20 (@BinPosDef.Pos.to_nat)) (fun v20 : @nat => (v5 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v20)%nat * v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v20)%nat)%Q) (fun (v20 : @positive) (v21 v22 : @nat) (v23 : (BinPosDef.Pos.to_nat v20 <= v21)%nat) (v24 : (BinPosDef.Pos.to_nat v20 <= v22)%nat) => CReal_mult_cauchy v5 v5 v7 v12 v15 (@BinPosDef.Pos.to_nat) v6 v8 v13 v16 v20 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v21)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v12 v15)~0 * v22)%nat (linear_max v20 v12 v15 v21 v23) (linear_max v20 v12 v15 v22 v24)))) (fun v20 : @nat => (v5 v20 * v7 v20)%Q)) v10) v18 v19 end) v15 v16 end) v12 v13 end) : QSeqEquivEx (fun v11 : @nat => (proj1_sig match QCauchySeq_bounded v5 (@BinPosDef.Pos.to_nat) v6 as v12 in (sig _) return (@CReal) with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : forall v13 : @nat, Qabs (v5 v13) < Z.pos v12 # 1) => match QCauchySeq_bounded v7 (@BinPosDef.Pos.to_nat) v8 as v14 in (sig _) return (@CReal) with | exist _ v14 v15 => (fun (v14 : @positive) (v15 : forall v15 : @nat, Qabs (v7 v15) < Z.pos v14 # 1) => exist (fun v16 : forall v16 : @nat, @Q => QCauchySeq v16 (@BinPosDef.Pos.to_nat)) (fun v16 : @nat => v5 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v16)%nat * v7 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v16)%nat) (fun (v16 : @positive) (v17 v18 : @nat) (v19 : (BinPosDef.Pos.to_nat v16 <= v17)%nat) (v20 : (BinPosDef.Pos.to_nat v16 <= v18)%nat) => CReal_mult_cauchy v5 v5 v7 v12 v14 (@BinPosDef.Pos.to_nat) v6 v8 v13 v15 v16 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v17)%nat (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v18)%nat (linear_max v16 v12 v14 v17 v19) (linear_max v16 v12 v14 v18 v20))) v14 v15 end) v12 v13 end v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v9 v10) v11)%Q) (fun v11 : @nat => (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v5 v6) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v9 v10) v11)%Q)) : QSeqEquivEx (fun v11 : @nat => (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v5 v6 * exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8)%CReal v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v9 v10) v11)%Q) (fun v11 : @nat => (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v5 v6) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v9 v10) v11)%Q)) v9 v10 end) v7 v8 end) v5 v6 end) (QSeqEquivEx_trans (fun v5 : @nat => (proj1_sig v0 v5 * proj1_sig v1 v5 * proj1_sig v2 v5)%Q) (fun v5 : @nat => (proj1_sig v0 v5 * proj1_sig (v1 * v2)%CReal v5)%Q) (proj1_sig (v0 * (v1 * v2))) match v0 as v5 in (sig _) return (QSeqEquivEx (fun v6 : @nat => (proj1_sig v5 v6 * proj1_sig v1 v6 * proj1_sig v2 v6)%Q) (fun v6 : @nat => (proj1_sig v5 v6 * proj1_sig (v1 * v2)%CReal v6)%Q)) with | exist _ v5 v6 => (fun (v5 : forall v5 : @nat, @Q) (v6 : QCauchySeq v5 (@BinPosDef.Pos.to_nat)) => match v1 as v7 in (sig _) return (QSeqEquivEx (fun v8 : @nat => (proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v5 v6) v8 * proj1_sig v7 v8 * proj1_sig v2 v8)%Q) (fun v8 : @nat => (proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v5 v6) v8 * proj1_sig (v7 * v2)%CReal v8)%Q)) with | exist _ v7 v8 => (fun (v7 : forall v7 : @nat, @Q) (v8 : QCauchySeq v7 (@BinPosDef.Pos.to_nat)) => match v2 as v9 in (sig _) return (QSeqEquivEx (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v5 v6) v10 * proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v7 v8) v10 * proj1_sig v9 v10)%Q) (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v5 v6) v10 * proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v7 v8 * v9)%CReal v10)%Q)) with | exist _ v9 v10 => (fun (v9 : forall v9 : @nat, @Q) (v10 : QCauchySeq v9 (@BinPosDef.Pos.to_nat)) => ((let v11 : {v11 : @positive | forall v12 : @nat, (Qabs (v5 v12) < Z.pos v11 # 1)%Q} := QCauchySeq_bounded v5 (@BinPosDef.Pos.to_nat) v6 in match v11 as v12 in (sig _) return (QSeqEquivEx (fun v13 : @nat => (v5 v13 * v7 v13 * v9 v13)%Q) (fun v13 : @nat => (v5 v13 * proj1_sig match QCauchySeq_bounded v7 (@BinPosDef.Pos.to_nat) v8 as v14 in (sig _) return (@CReal) with | exist _ v14 v15 => (fun (v14 : @positive) (v15 : forall v15 : @nat, Qabs (v7 v15) < Z.pos v14 # 1) => match QCauchySeq_bounded v9 (@BinPosDef.Pos.to_nat) v10 as v16 in (sig _) return (@CReal) with | exist _ v16 v17 => (fun (v16 : @positive) (v17 : forall v17 : @nat, Qabs (v9 v17) < Z.pos v16 # 1) => exist (fun v18 : forall v18 : @nat, @Q => QCauchySeq v18 (@BinPosDef.Pos.to_nat)) (fun v18 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v18)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v18)%nat) (fun (v18 : @positive) (v19 v20 : @nat) (v21 : (BinPosDef.Pos.to_nat v18 <= v19)%nat) (v22 : (BinPosDef.Pos.to_nat v18 <= v20)%nat) => CReal_mult_cauchy v7 v7 v9 v14 v16 (@BinPosDef.Pos.to_nat) v8 v10 v15 v17 v18 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v19)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v14 v16)~0 * v20)%nat (linear_max v18 v14 v16 v19 v21) (linear_max v18 v14 v16 v20 v22))) v16 v17 end) v14 v15 end v13)%Q)) with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : forall v13 : @nat, (Qabs (v5 v13) < Z.pos v12 # 1)%Q) => let v14 : {v14 : @positive | forall v15 : @nat, (Qabs (v7 v15) < Z.pos v14 # 1)%Q} := QCauchySeq_bounded v7 (@BinPosDef.Pos.to_nat) v8 in match v14 as v15 in (sig _) return (QSeqEquivEx (fun v16 : @nat => (v5 v16 * v7 v16 * v9 v16)%Q) (fun v16 : @nat => (v5 v16 * proj1_sig match v15 as v17 in (sig _) return (@CReal) with | exist _ v17 v18 => (fun (v17 : @positive) (v18 : forall v18 : @nat, Qabs (v7 v18) < Z.pos v17 # 1) => match QCauchySeq_bounded v9 (@BinPosDef.Pos.to_nat) v10 as v19 in (sig _) return (@CReal) with | exist _ v19 v20 => (fun (v19 : @positive) (v20 : forall v20 : @nat, Qabs (v9 v20) < Z.pos v19 # 1) => exist (fun v21 : forall v21 : @nat, @Q => QCauchySeq v21 (@BinPosDef.Pos.to_nat)) (fun v21 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v17 v19)~0 * v21)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v17 v19)~0 * v21)%nat) (fun (v21 : @positive) (v22 v23 : @nat) (v24 : (BinPosDef.Pos.to_nat v21 <= v22)%nat) (v25 : (BinPosDef.Pos.to_nat v21 <= v23)%nat) => CReal_mult_cauchy v7 v7 v9 v17 v19 (@BinPosDef.Pos.to_nat) v8 v10 v18 v20 v21 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v17 v19)~0 * v22)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v17 v19)~0 * v23)%nat (linear_max v21 v17 v19 v22 v24) (linear_max v21 v17 v19 v23 v25))) v19 v20 end) v17 v18 end v16)%Q)) with | exist _ v15 v16 => (fun (v15 : @positive) (v16 : forall v16 : @nat, (Qabs (v7 v16) < Z.pos v15 # 1)%Q) => let v17 : {v17 : @positive | forall v18 : @nat, (Qabs (v9 v18) < Z.pos v17 # 1)%Q} := QCauchySeq_bounded v9 (@BinPosDef.Pos.to_nat) v10 in match v17 as v18 in (sig _) return (QSeqEquivEx (fun v19 : @nat => (v5 v19 * v7 v19 * v9 v19)%Q) (fun v19 : @nat => (v5 v19 * proj1_sig match v18 as v20 in (sig _) return (@CReal) with | exist _ v20 v21 => (fun (v20 : @positive) (v21 : forall v21 : @nat, Qabs (v9 v21) < Z.pos v20 # 1) => exist (fun v22 : forall v22 : @nat, @Q => QCauchySeq v22 (@BinPosDef.Pos.to_nat)) (fun v22 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v20)~0 * v22)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v20)~0 * v22)%nat) (fun (v22 : @positive) (v23 v24 : @nat) (v25 : (BinPosDef.Pos.to_nat v22 <= v23)%nat) (v26 : (BinPosDef.Pos.to_nat v22 <= v24)%nat) => CReal_mult_cauchy v7 v7 v9 v15 v20 (@BinPosDef.Pos.to_nat) v8 v10 v16 v21 v22 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v20)~0 * v23)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v20)~0 * v24)%nat (linear_max v22 v15 v20 v23 v25) (linear_max v22 v15 v20 v24 v26))) v20 v21 end v19)%Q)) with | exist _ v18 v19 => (fun (v18 : @positive) (v19 : forall v19 : @nat, (Qabs (v9 v19) < Z.pos v18 # 1)%Q) => (let v20 : forall (v20 : QSeqEquivEx (fun v20 : @nat => (v7 v20 * v9 v20)%Q) (fun v20 : @nat => (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v20)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v20)%nat)%Q)) (v21 : QSeqEquiv v5 v5 (@BinPosDef.Pos.to_nat)), QSeqEquivEx (fun v22 : @nat => ((fun v23 : @nat => v7 v23 * v9 v23) v22 * v5 v22)%Q) (fun v22 : @nat => ((fun v23 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat) v22 * v5 v22)%Q) := CReal_mult_assoc_bounded_r (fun v20 : @nat => (v7 v20 * v9 v20)%Q) (fun v20 : @nat => (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v20)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v20)%nat)%Q) v5 in let v21 : exists v21 : forall v21 : @positive, @nat, QSeqEquiv (fun v22 : @nat => ((fun v23 : @nat => v7 v23 * v9 v23) v22 * v5 v22)%Q) (fun v22 : @nat => ((fun v23 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat) v22 * v5 v22)%Q) v21 := v20 (let v21 : QSeqEquiv (fun v21 : @nat => (v7 v21 * v9 v21)%Q) (fun v21 : @nat => (v7 v21 * v9 v21)%Q) (fun v21 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v21)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v21))) := CReal_mult_cauchy v7 v7 v9 v15 v18 (@BinPosDef.Pos.to_nat) v8 v10 v16 v19 in ex_intro (fun v22 : forall v22 : @positive, @nat => QSeqEquiv (fun v23 : @nat => (v7 v23 * v9 v23)%Q) (fun v23 : @nat => (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat)%Q) v22) (fun v22 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22))) ((fun (v22 : @positive) (v23 v24 : @nat) (v25 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) <= v23)%nat) (v26 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) <= v24)%nat) => let v27 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22) <= v23)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22))) (fun v27 : @nat => (v27 <= v23)%nat) v25 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)))) in let v28 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22) <= v24)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22))) (fun v28 : @nat => (v28 <= v24)%nat) v26 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)))) in v21 v22 v23 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v24)%nat (eq_ind_r (fun v29 : @nat => (v29 <= v23)%nat) v27 (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22))))) (linear_max v22 v15 v18 v24 (Nat.le_trans (BinPosDef.Pos.to_nat v22) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) v24 (eq_ind (1 * BinPosDef.Pos.to_nat v22)%nat (fun v29 : @nat => (v29 <= BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22))%nat) (eq_ind_r (fun v29 : @nat => (1 * BinPosDef.Pos.to_nat v22 <= v29)%nat) (Nat.mul_le_mono_nonneg 1 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18)) (BinPosDef.Pos.to_nat v22) (BinPosDef.Pos.to_nat v22) (le_S 0 0 (le_n 0)) (Pos2Nat.is_pos (2 * BinPosDef.Pos.max v15 v18)) (Nat.le_0_l (BinPosDef.Pos.to_nat v22)) (Nat.le_refl (BinPosDef.Pos.to_nat v22))) (Pos2Nat.inj_mul (2 * BinPosDef.Pos.max v15 v18) v22)) (BinPosDef.Pos.to_nat v22) (Nat.mul_1_l (BinPosDef.Pos.to_nat v22))) v28))) : QSeqEquiv (fun v22 : @nat => (v7 v22 * v9 v22)%Q) (fun v22 : @nat => (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v22)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v22)%nat)%Q) (fun v22 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v15 v18 * v22))))) v6 in match v21 as v22 in (ex _) return (QSeqEquivEx (fun v23 : @nat => (v5 v23 * v7 v23 * v9 v23)%Q) (fun v23 : @nat => (v5 v23 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat))%Q)) with | ex_intro _ v22 v23 => (fun (v22 : forall v22 : @positive, @nat) (v23 : QSeqEquiv (fun v23 : @nat => (v7 v23 * v9 v23 * v5 v23)%Q) (fun v23 : @nat => (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat * v5 v23)%Q) v22) => ex_intro (fun v24 : forall v24 : @positive, @nat => QSeqEquiv (fun v25 : @nat => (v5 v25 * v7 v25 * v9 v25)%Q) (fun v25 : @nat => (v5 v25 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v25)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v25)%nat))%Q) v24) v22 ((fun (v24 : @positive) (v25 v26 : @nat) (v27 : (v22 v24 <= v25)%nat) (v28 : (v22 v24 <= v26)%nat) => let v29 : (Qabs ((fun v29 : @nat => v7 v29 * v9 v29 * v5 v29) v25 - (fun v29 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v29)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v29)%nat * v5 v29) v26) < 1 # v24)%Q := v23 v24 v25 v26 v27 v28 in let v30 : default_relation (v5 v25 * v7 v25 * v9 v25 - v5 v26 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat))%Q ((fun v30 : @nat => v7 v30 * v9 v30 * v5 v30) v25 - (fun v30 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v30)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v30)%nat * v5 v30) v26)%Q := (let v30 : list (Ring_polynom.PExpr (@Q) * Ring_polynom.PExpr (@Q)) := nil in let v31 : list (@Q) := (v5 v25 :: v7 v25 :: v9 v25 :: v5 v26 :: v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat :: v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat :: nil)%list in Qfield_ring_lemma1 (@ring_subst_niter) v31 v30 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 1) (Ring_polynom.PEX (@Q) 2)) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 5) (Ring_polynom.PEX (@Q) 6)))) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEX (@Q) 1)) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 5) (Ring_polynom.PEX (@Q) 6)) (Ring_polynom.PEX (@Q) 4))) (@I) (eq_refl : (let v32 : list (@Q * @Ring_polynom.Mon * Ring_polynom.Pol (@Q)) := Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v30 in Ring_polynom.Peq (@Qeq_bool) (Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v32 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 1) (Ring_polynom.PEX (@Q) 2)) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 4) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 5) (Ring_polynom.PEX (@Q) 6))))) (Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v32 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEX (@Q) 1)) (Ring_polynom.PEmul (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 5) (Ring_polynom.PEX (@Q) 6)) (Ring_polynom.PEX (@Q) 4))))) = @true)) : default_relation (v5 v25 * v7 v25 * v9 v25 - v5 v26 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat))%Q ((fun v30 : @nat => v7 v30 * v9 v30 * v5 v30) v25 - (fun v30 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v30)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v30)%nat * v5 v30) v26)%Q in ((fun v31 : (v5 v25 * v7 v25 * v9 v25 - v5 v26 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat) == v7 v25 * v9 v25 * v5 v25 - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v5 v26)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation))) (Qabs (v5 v25 * v7 v25 * v9 v25 - v5 v26 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat))) (Qabs (v7 v25 * v9 v25 * v5 v25 - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v5 v26)) (Qabs_wd_Proper (v5 v25 * v7 v25 * v9 v25 - v5 v26 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat))%Q (v7 v25 * v9 v25 * v5 v25 - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v5 v26)%Q v31) (1 # v24)%Q (1 # v24)%Q (reflexive_proper_proxy Equivalence_Reflexive (1 # v24)%Q) v29) : forall v31 : default_relation (v5 v25 * v7 v25 * v9 v25 - v5 v26 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat))%Q ((fun v31 : @nat => v7 v31 * v9 v31 * v5 v31) v25 - (fun v31 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v31)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v31)%nat * v5 v31) v26)%Q, (Qabs (v5 v25 * v7 v25 * v9 v25 - v5 v26 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v26)%nat)) < 1 # v24)%Q) v30) : QSeqEquiv (fun v24 : @nat => (v5 v24 * v7 v24 * v9 v24)%Q) (fun v24 : @nat => (v5 v24 * (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v24)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v24)%nat))%Q) v22)) v22 v23 end) : QSeqEquivEx (fun v20 : @nat => (v5 v20 * v7 v20 * v9 v20)%Q) (fun v20 : @nat => (v5 v20 * proj1_sig (exist (fun v21 : forall v21 : @nat, @Q => QCauchySeq v21 (@BinPosDef.Pos.to_nat)) (fun v21 : @nat => v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v21)%nat * v9 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v21)%nat) (fun (v21 : @positive) (v22 v23 : @nat) (v24 : (BinPosDef.Pos.to_nat v21 <= v22)%nat) (v25 : (BinPosDef.Pos.to_nat v21 <= v23)%nat) => CReal_mult_cauchy v7 v7 v9 v15 v18 (@BinPosDef.Pos.to_nat) v8 v10 v16 v19 v21 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v22)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v15 v18)~0 * v23)%nat (linear_max v21 v15 v18 v22 v24) (linear_max v21 v15 v18 v23 v25))) v20)%Q)) v18 v19 end) v15 v16 end) v12 v13 end) : QSeqEquivEx (fun v11 : @nat => (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v5 v6) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v9 v10) v11)%Q) (fun v11 : @nat => (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v5 v6) v11 * proj1_sig match QCauchySeq_bounded v7 (@BinPosDef.Pos.to_nat) v8 as v12 in (sig _) return (@CReal) with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : forall v13 : @nat, Qabs (v7 v13) < Z.pos v12 # 1) => match QCauchySeq_bounded v9 (@BinPosDef.Pos.to_nat) v10 as v14 in (sig _) return (@CReal) with | exist _ v14 v15 => (fun (v14 : @positive) (v15 : forall v15 : @nat, Qabs (v9 v15) < Z.pos v14 # 1) => exist (fun v16 : forall v16 : @nat, @Q => QCauchySeq v16 (@BinPosDef.Pos.to_nat)) (fun v16 : @nat => v7 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v16)%nat * v9 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v16)%nat) (fun (v16 : @positive) (v17 v18 : @nat) (v19 : (BinPosDef.Pos.to_nat v16 <= v17)%nat) (v20 : (BinPosDef.Pos.to_nat v16 <= v18)%nat) => CReal_mult_cauchy v7 v7 v9 v12 v14 (@BinPosDef.Pos.to_nat) v8 v10 v13 v15 v16 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v17)%nat (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v14) * v18)%nat (linear_max v16 v12 v14 v17 v19) (linear_max v16 v12 v14 v18 v20))) v14 v15 end) v12 v13 end v11)%Q)) : QSeqEquivEx (fun v11 : @nat => (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v5 v6) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v9 v10) v11)%Q) (fun v11 : @nat => (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v5 v6) v11 * proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8 * exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v9 v10)%CReal v11)%Q)) v9 v10 end) v7 v8 end) v5 v6 end (QSeqEquivEx_sym (proj1_sig (v0 * (v1 * v2))) (fun v5 : @nat => (proj1_sig v0 v5 * proj1_sig (v1 * v2)%CReal v5)%Q) (CReal_mult_unfold v0 (v1 * v2)))))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_comm	100	0.596860	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @CReal => let v2 : forall (v2 v3 : @CReal) (v4 : forall v4 : @positive, (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v4) - proj1_sig v3 (BinPosDef.Pos.to_nat v4)) <= 2 # v4)%Q), v2 == v3 := fun v2 v3 : @CReal => match CRealEq_diff v2 v3 as v4 in (_ /\ _) return (forall v5 : forall v5 : @positive, (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v5) - proj1_sig v3 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q, v2 == v3) with | conj v4 v5 => (fun (v4 : forall (v4 : v2 == v3) (v5 : @positive), (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v5) - proj1_sig v3 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q) (v5 : forall v5 : forall v5 : @positive, (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v5) - proj1_sig v3 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q, v2 == v3) => v5) v4 v5 end in v2 (v0 * v1) (v1 * v0) (let v3 : forall (v3 v4 : @CReal) (v5 : QSeqEquivEx (proj1_sig v3) (proj1_sig v4)) (v6 : @positive), (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q := fun v3 v4 : @CReal => match CRealEq_modindep v3 v4 as v5 in (_ /\ _) return (forall (v6 : QSeqEquivEx (proj1_sig v3) (proj1_sig v4)) (v7 : @positive), (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v7) - proj1_sig v4 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q) with | conj v5 v6 => (fun (v5 : forall (v5 : QSeqEquivEx (proj1_sig v3) (proj1_sig v4)) (v6 : @positive), (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q) (v6 : forall v6 : forall v6 : @positive, (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q, QSeqEquivEx (proj1_sig v3) (proj1_sig v4)) => v5) v5 v6 end in v3 (v0 * v1) (v1 * v0) (QSeqEquivEx_trans (proj1_sig (v0 * v1)) (fun v4 : @nat => (proj1_sig v1 v4 * proj1_sig v0 v4)%Q) (proj1_sig (v1 * v0)) match v0 as v4 in (sig _) return (QSeqEquivEx (proj1_sig (v4 * v1)) (fun v5 : @nat => (proj1_sig v1 v5 * proj1_sig v4 v5)%Q)) with | exist _ v4 v5 => (fun (v4 : forall v4 : @nat, @Q) (v5 : QCauchySeq v4 (@BinPosDef.Pos.to_nat)) => match v1 as v6 in (sig _) return (QSeqEquivEx (proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v4 v5 * v6)) (fun v7 : @nat => (proj1_sig v6 v7 * proj1_sig (exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v4 v5) v7)%Q)) with | exist _ v6 v7 => (fun (v6 : forall v6 : @nat, @Q) (v7 : QCauchySeq v6 (@BinPosDef.Pos.to_nat)) => (let v8 : {v8 : @positive | forall v9 : @nat, (Qabs (v4 v9) < Z.pos v8 # 1)%Q} := QCauchySeq_bounded v4 (@BinPosDef.Pos.to_nat) v5 in match v8 as v9 in (sig _) return (QSeqEquivEx (proj1_sig match v9 as v10 in (sig _) return (@CReal) with | exist _ v10 v11 => (fun (v10 : @positive) (v11 : forall v11 : @nat, (Qabs (v4 v11) < Z.pos v10 # 1)%Q) => match QCauchySeq_bounded v6 (@BinPosDef.Pos.to_nat) v7 as v12 in (sig _) return (@CReal) with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : forall v13 : @nat, (Qabs (v6 v13) < Z.pos v12 # 1)%Q) => exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) (fun v14 : @nat => (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v12)~0 * v14)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v12)~0 * v14)%nat)%Q) (fun (v14 : @positive) (v15 v16 : @nat) (v17 : (BinPosDef.Pos.to_nat v14 <= v15)%nat) (v18 : (BinPosDef.Pos.to_nat v14 <= v16)%nat) => CReal_mult_cauchy v4 v4 v6 v10 v12 (@BinPosDef.Pos.to_nat) v5 v7 v11 v13 v14 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v12)~0 * v15)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v12)~0 * v16)%nat (linear_max v14 v10 v12 v15 v17) (linear_max v14 v10 v12 v16 v18))) v12 v13 end) v10 v11 end) (fun v10 : @nat => (v6 v10 * v4 v10)%Q)) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, (Qabs (v4 v10) < Z.pos v9 # 1)%Q) => let v11 : {v11 : @positive | forall v12 : @nat, (Qabs (v6 v12) < Z.pos v11 # 1)%Q} := QCauchySeq_bounded v6 (@BinPosDef.Pos.to_nat) v7 in match v11 as v12 in (sig _) return (QSeqEquivEx (proj1_sig match v12 as v13 in (sig _) return (@CReal) with | exist _ v13 v14 => (fun (v13 : @positive) (v14 : forall v14 : @nat, (Qabs (v6 v14) < Z.pos v13 # 1)%Q) => exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) (fun v15 : @nat => (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v13)~0 * v15)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v13)~0 * v15)%nat)%Q) (fun (v15 : @positive) (v16 v17 : @nat) (v18 : (BinPosDef.Pos.to_nat v15 <= v16)%nat) (v19 : (BinPosDef.Pos.to_nat v15 <= v17)%nat) => CReal_mult_cauchy v4 v4 v6 v9 v13 (@BinPosDef.Pos.to_nat) v5 v7 v10 v14 v15 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v13)~0 * v16)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v13)~0 * v17)%nat (linear_max v15 v9 v13 v16 v18) (linear_max v15 v9 v13 v17 v19))) v13 v14 end) (fun v13 : @nat => (v6 v13 * v4 v13)%Q)) with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : forall v13 : @nat, (Qabs (v6 v13) < Z.pos v12 # 1)%Q) => QSeqEquivEx_sym (fun v14 : @nat => (v6 v14 * v4 v14)%Q) (fun v14 : @nat => (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v14)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v14)%nat)%Q) (let v14 : QSeqEquiv (fun v14 : @nat => (v6 v14 * v4 v14)%Q) (fun v14 : @nat => (v6 v14 * v4 v14)%Q) (fun v14 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v14)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v14))) := CReal_mult_cauchy v6 v6 v4 v12 v9 (@BinPosDef.Pos.to_nat) v7 v5 v13 v10 in ex_intro (fun v15 : forall v15 : @positive, @nat => QSeqEquiv (fun v16 : @nat => (v6 v16 * v4 v16)%Q) (fun v16 : @nat => (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v16)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v16)%nat)%Q) v15) (fun v15 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15))) ((fun (v15 : @positive) (v16 v17 : @nat) (v18 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) <= v16)%nat) (v19 : (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) <= v17)%nat) => let v20 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15) <= v16)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15))) (fun v20 : @nat => (v20 <= v16)%nat) v18 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)))) in let v21 : (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15) <= v17)%nat := eq_ind (Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15))) (fun v21 : @nat => (v21 <= v17)%nat) v19 (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)))) in (fun v22 : (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat == v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation))) (Qabs (v6 v16 * v4 v16 - v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)) (Qabs (v6 v16 * v4 v16 - v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)) (Qabs_wd_Proper (v6 v16 * v4 v16 - v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)%Q (v6 v16 * v4 v16 - v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)%Q (Reflexive_partial_app_morphism (@Qminus_comp) (reflexive_proper_proxy Equivalence_Reflexive (v6 v16 * v4 v16)%Q) (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)%Q (v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat * v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)%Q v22)) (1 # v15)%Q (1 # v15)%Q (reflexive_proper_proxy Equivalence_Reflexive (1 # v15)%Q)) (Qmult_comm (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat) (v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat)) (v14 v15 v16 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat (eq_ind_r (fun v22 : @nat => (v22 <= v16)%nat) v20 (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15))))) (eq_ind_r (fun v22 : @nat => (v22 <= BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17)%nat) (Nat.le_trans (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) v17 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v17) v21 (eq_ind (1 * v17)%nat (fun v22 : @nat => (v22 <= BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v22)%nat) (eq_ind_r (fun v22 : @nat => (1 * v17 <= v22)%nat) (Nat.mul_le_mono_nonneg 1 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * 1) v17 v17 (le_S 0 0 (le_n 0)) (eq_ind_r (fun v22 : @nat => (1 <= v22)%nat) (Pos2Nat.is_pos (BinPosDef.Pos.max v9 v12)~0) (Nat.mul_1_r (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0))) (Nat.le_0_l v17) (Nat.le_refl v17)) (Nat.mul_assoc (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0) 1 v17)) v17 (Nat.mul_1_l v17))) (max_l (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (Nat.le_refl (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15))))))) : QSeqEquiv (fun v15 : @nat => (v6 v15 * v4 v15)%Q) (fun v15 : @nat => (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v15)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v15)%nat)%Q) (fun v15 : @positive => Init.Nat.max (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15)) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v12 v9 * v15))))) : QSeqEquivEx (proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) (fun v14 : @nat => (v4 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v14)%nat * v6 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v14)%nat)%Q) (fun (v14 : @positive) (v15 v16 : @nat) (v17 : (BinPosDef.Pos.to_nat v14 <= v15)%nat) (v18 : (BinPosDef.Pos.to_nat v14 <= v16)%nat) => CReal_mult_cauchy v4 v4 v6 v9 v12 (@BinPosDef.Pos.to_nat) v5 v7 v10 v13 v14 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v15)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v12)~0 * v16)%nat (linear_max v14 v9 v12 v15 v17) (linear_max v14 v9 v12 v16 v18)))) (fun v14 : @nat => (v6 v14 * v4 v14)%Q)) v12 v13 end) v9 v10 end) : QSeqEquivEx (proj1_sig (exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v4 v5 * exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v6 v7)) (fun v8 : @nat => (proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v6 v7) v8 * proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v4 v5) v8)%Q)) v6 v7 end) v4 v5 end (QSeqEquivEx_sym (proj1_sig (v1 * v0)) (fun v4 : @nat => (proj1_sig v1 v4 * proj1_sig v0 v4)%Q) (CReal_mult_unfold v1 v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_proper_l	100	0.897776	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @CReal) (v3 : v1 == v2) => let v4 : forall (v4 v5 : @CReal) (v6 : forall v6 : @positive, (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v6) - proj1_sig v5 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q), v4 == v5 := fun v4 v5 : @CReal => match CRealEq_diff v4 v5 as v6 in (_ /\ _) return (forall v7 : forall v7 : @positive, (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q, v4 == v5) with | conj v6 v7 => (fun (v6 : forall (v6 : v4 == v5) (v7 : @positive), (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q) (v7 : forall v7 : forall v7 : @positive, (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q, v4 == v5) => v7) v6 v7 end in v4 (v0 * v1) (v0 * v2) (let v5 : forall (v5 v6 : @CReal) (v7 : QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) (v8 : @positive), (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v8) - proj1_sig v6 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q := fun v5 v6 : @CReal => match CRealEq_modindep v5 v6 as v7 in (_ /\ _) return (forall (v8 : QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) (v9 : @positive), (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v9) - proj1_sig v6 (BinPosDef.Pos.to_nat v9)) <= 2 # v9)%Q) with | conj v7 v8 => (fun (v7 : forall (v7 : QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) (v8 : @positive), (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v8) - proj1_sig v6 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q) (v8 : forall v8 : forall v8 : @positive, (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v8) - proj1_sig v6 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q, QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) => v7) v7 v8 end in v5 (v0 * v1) (v0 * v2) (QSeqEquivEx_trans (proj1_sig (v0 * v1)) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v1 v6)%Q) (proj1_sig (v0 * v2)) (CReal_mult_unfold v0 v1) (QSeqEquivEx_sym (proj1_sig (v0 * v2)) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v1 v6)%Q) (QSeqEquivEx_trans (proj1_sig (v0 * v2)) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v2 v6)%Q) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v1 v6)%Q) (CReal_mult_unfold v0 v2) match v0 as v6 in (sig _) return (QSeqEquivEx (fun v7 : @nat => (proj1_sig v6 v7 * proj1_sig v2 v7)%Q) (fun v7 : @nat => (proj1_sig v6 v7 * proj1_sig v1 v7)%Q)) with | exist _ v6 v7 => (fun (v6 : forall v6 : @nat, @Q) (v7 : QCauchySeq v6 (@BinPosDef.Pos.to_nat)) => match v1 as v8 in (sig _) return (forall v9 : QSeqEquivEx (proj1_sig v8) (proj1_sig v2), QSeqEquivEx (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v6 v7) v10 * proj1_sig v2 v10)%Q) (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v6 v7) v10 * proj1_sig v8 v10)%Q)) with | exist _ v8 v9 => (fun (v8 : forall v8 : @nat, @Q) (v9 : QCauchySeq v8 (@BinPosDef.Pos.to_nat)) (v10 : QSeqEquivEx (proj1_sig (exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig v2)) => match v2 as v11 in (sig _) return (forall v12 : QSeqEquivEx (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig v11), QSeqEquivEx (fun v13 : @nat => (proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v6 v7) v13 * proj1_sig v11 v13)%Q) (fun v13 : @nat => (proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v6 v7) v13 * proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v8 v9) v13)%Q)) with | exist _ v11 v12 => (fun (v11 : forall v11 : @nat, @Q) (v12 : QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (v13 : QSeqEquivEx (proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v11 v12))) => match v13 as v14 in (ex _) return (QSeqEquivEx (fun v15 : @nat => (v6 v15 * v11 v15)%Q) (fun v15 : @nat => (v6 v15 * v8 v15)%Q)) with | ex_intro _ v14 v15 => (fun (v14 : forall v14 : @positive, @nat) (v15 : QSeqEquiv (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v11 v12)) v14) => let v16 : {v16 : @positive | forall v17 : @nat, (Qabs (v6 v17) < Z.pos v16 # 1)%Q} := QCauchySeq_bounded v6 (@BinPosDef.Pos.to_nat) v7 in match v16 as v17 in (sig _) return (QSeqEquivEx (fun v18 : @nat => (v6 v18 * v11 v18)%Q) (fun v18 : @nat => (v6 v18 * v8 v18)%Q)) with | exist _ v17 v18 => (fun (v17 : @positive) (v18 : forall v18 : @nat, (Qabs (v6 v18) < Z.pos v17 # 1)%Q) => let v19 : {v19 : @positive | forall v20 : @nat, (Qabs (v11 v20) < Z.pos v19 # 1)%Q} := QCauchySeq_bounded v11 (@BinPosDef.Pos.to_nat) v12 in match v19 as v20 in (sig _) return (QSeqEquivEx (fun v21 : @nat => (v6 v21 * v11 v21)%Q) (fun v21 : @nat => (v6 v21 * v8 v21)%Q)) with | exist _ v20 v21 => (fun (v20 : @positive) (v21 : forall v21 : @nat, (Qabs (v11 v21) < Z.pos v20 # 1)%Q) => let v22 : QSeqEquiv (fun v22 : @nat => (v8 v22 * v6 v22)%Q) (fun v22 : @nat => (v11 v22 * v6 v22)%Q) (fun v22 : @positive => Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v22)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v22))) := CReal_mult_cauchy v8 v11 v6 v20 v17 v14 v15 v7 v21 v18 in QSeqEquivEx_sym (fun v23 : @nat => (v6 v23 * v8 v23)%Q) (fun v23 : @nat => (v6 v23 * v11 v23)%Q) (ex_intro (fun v23 : forall v23 : @positive, @nat => QSeqEquiv (fun v24 : @nat => (v6 v24 * v8 v24)%Q) (fun v24 : @nat => (v6 v24 * v11 v24)%Q) v23) (fun v23 : @positive => Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23))) ((fun (v23 : @positive) (v24 v25 : @nat) (v26 : (Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23)) <= v24)%nat) (v27 : (Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23)) <= v25)%nat) => let v28 : (Qabs ((fun v28 : @nat => v8 v28 * v6 v28) v24 - (fun v28 : @nat => v11 v28 * v6 v28) v25) < 1 # v23)%Q := v22 v23 v24 v25 v26 v27 in let v29 : default_relation (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q := (let v29 : list (Ring_polynom.PExpr (@Q) * Ring_polynom.PExpr (@Q)) := nil in let v30 : list (@Q) := (v6 v24 :: v8 v24 :: v6 v25 :: v11 v25 :: nil)%list in Qfield_ring_lemma1 (@ring_subst_niter) v30 v29 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 1) (Ring_polynom.PEX (@Q) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 3) (Ring_polynom.PEX (@Q) 4))) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 4) (Ring_polynom.PEX (@Q) 3))) (@I) (eq_refl : (let v31 : list (@Q * @Ring_polynom.Mon * Ring_polynom.Pol (@Q)) := Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v29 in Ring_polynom.Peq (@Qeq_bool) (Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v31 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 1) (Ring_polynom.PEX (@Q) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 3) (Ring_polynom.PEX (@Q) 4)))) (Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v31 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 4) (Ring_polynom.PEX (@Q) 3))))) = @true)) : default_relation (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q in ((fun v30 : (v6 v24 * v8 v24 - v6 v25 * v11 v25 == v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation))) (Qabs (v6 v24 * v8 v24 - v6 v25 * v11 v25)) (Qabs (v8 v24 * v6 v24 - v11 v25 * v6 v25)) (Qabs_wd_Proper (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q v30) (1 # v23)%Q (1 # v23)%Q (reflexive_proper_proxy Equivalence_Reflexive (1 # v23)%Q) v28) : forall v30 : default_relation (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q, (Qabs (v6 v24 * v8 v24 - v6 v25 * v11 v25) < 1 # v23)%Q) v29) : QSeqEquiv (fun v23 : @nat => (v6 v23 * v8 v23)%Q) (fun v23 : @nat => (v6 v23 * v11 v23)%Q) (fun v23 : @positive => Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23)))))) v20 v21 end) v17 v18 end) v14 v15 end : QSeqEquivEx (fun v14 : @nat => (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v6 v7) v14 * proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v11 v12) v14)%Q) (fun v14 : @nat => (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v6 v7) v14 * proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v8 v9) v14)%Q)) v11 v12 end v10) v8 v9 end ((fun v8 : QSeqEquivEx (proj1_sig v1) (proj1_sig v2) <-> (forall v8 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v8) - proj1_sig v2 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q) => iff_impl_subrelation (forall v9 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v9) - proj1_sig v2 (BinPosDef.Pos.to_nat v9)) <= 2 # v9)%Q) (QSeqEquivEx (proj1_sig v1) (proj1_sig v2)) (symmetry v8)) (CRealEq_modindep v1 v2) ((fun v8 : v1 == v2 <-> (forall v8 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v8) - proj1_sig v2 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q) => iff_impl_subrelation (v1 == v2) (forall v9 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v9) - proj1_sig v2 (BinPosDef.Pos.to_nat v9)) <= 2 # v9)%Q) v8) (CRealEq_diff v1 v2) v3))) v6 v7 end)))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_lt_0_compat	100	1.685762	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_plus_distr_l	100	3.632242	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_plus_distr_r	100	0.146257	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @CReal => (fun v3 : (v1 + v2) * v0 == v0 * (v1 + v2) => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) ((v1 + v2) * v0) (v0 * (v1 + v2)) v3 (v1 * v0 + v2 * v0) (v1 * v0 + v2 * v0) (eq_proper_proxy (v1 * v0 + v2 * v0))) (CReal_mult_comm (v1 + v2) v0) ((fun v3 : v0 * (v1 + v2) == v0 * v1 + v0 * v2 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v0 * (v1 + v2)) (v0 * v1 + v0 * v2) v3 (v1 * v0 + v2 * v0) (v1 * v0 + v2 * v0) (eq_proper_proxy (v1 * v0 + v2 * v0))) (CReal_mult_plus_distr_l v0 v1 v2) ((fun v3 : v0 * v1 == v1 * v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v1 * v0 + v2 * v0) (v0 * v1 + v2 * v0) (CReal_plus_morph_Proper (v1 * v0) (v0 * v1) (symmetry v3) (v2 * v0) (v2 * v0) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) (v2 * v0)))) (CReal_mult_comm v0 v1) ((fun v3 : v0 * v2 == v2 * v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v0 * v1 + v2 * v0) (v0 * v1 + v0 * v2) (Reflexive_partial_app_morphism (@CReal_plus_morph_Proper) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) (v0 * v1)) (v2 * v0) (v0 * v2) (symmetry v3))) (CReal_mult_comm v0 v2) (reflexivity (v0 * v1 + v0 * v2))))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_1_l	100	0.866113	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_isRingExt	100	0.078619	1	1	0	synth with cache (only 1: refine {| Radd_ext := (fun (v0 v1 : @CReal) (v2 : v0 == v1) => (fun (v3 v4 : @CReal) (v5 : v3 == v4) => CReal_plus_morph v0 v1 v2 v3 v4 v5) : (@CRealEq ==> @CRealEq)%signature (CReal_plus v0) (CReal_plus v1)) : Proper (@CRealEq ==> @CRealEq ==> @CRealEq) (@CReal_plus); Rmul_ext := (fun (v0 v1 : @CReal) (v2 : v0 == v1) => (fun (v3 v4 : @CReal) (v5 : v3 == v4) => CRealEq_trans (v0 * v3) (v0 * v4) (v1 * v4) (CReal_mult_proper_l v0 v3 v4 v5) (CRealEq_trans (v0 * v4) (v4 * v0) (v1 * v4) (CReal_mult_comm v0 v4) (CRealEq_trans (v4 * v0) (v4 * v1) (v1 * v4) (CReal_mult_proper_l v4 v0 v1 v2) (CReal_mult_comm v4 v1)))) : (@CRealEq ==> @CRealEq)%signature (CReal_mult v0) (CReal_mult v1)) : Proper (@CRealEq ==> @CRealEq ==> @CRealEq) (@CReal_mult); Ropp_ext := (fun (v0 v1 : @CReal) (v2 : v0 == v1) => CReal_plus_eq_reg_l v0 (- v0) (- v1) (CRealEq_trans (v0 + - v0) (inject_Q 0) (v0 + - v1) (CReal_plus_opp_r v0) (CRealEq_trans (inject_Q 0) (v1 + - v1) (v0 + - v1) (CRealEq_sym (v1 + - v1) (inject_Q 0) (CReal_plus_opp_r v1)) (CReal_plus_proper_r v1 v0 (- v1) (CRealEq_sym v0 v1 v2))))) : Proper (@CRealEq ==> @CRealEq) (@CReal_opp) |}).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_isRing	100	0.114119	1	1	0	synth with cache (only 1: refine {| Radd_0_l := @CReal_plus_0_l; Radd_comm := @CReal_plus_comm; Radd_assoc := fun v0 v1 v2 : @CReal => symmetry (CReal_plus_assoc v0 v1 v2); Rmul_1_l := @CReal_mult_1_l; Rmul_comm := @CReal_mult_comm; Rmul_assoc := fun v0 v1 v2 : @CReal => symmetry (CReal_mult_assoc v0 v1 v2); Rdistr_l := fun v0 v1 v2 : @CReal => (fun v3 : v2 * (v0 + v1) == (v0 + v1) * v2 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) ((v0 + v1) * v2) (v2 * (v0 + v1)) (symmetry v3) (v0 * v2 + v1 * v2) (v0 * v2 + v1 * v2) (eq_proper_proxy (v0 * v2 + v1 * v2))) (CReal_mult_comm v2 (v0 + v1)) ((fun v3 : v2 * (v0 + v1) == v2 * v0 + v2 * v1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v2 * (v0 + v1)) (v2 * v0 + v2 * v1) v3 (v0 * v2 + v1 * v2) (v0 * v2 + v1 * v2) (eq_proper_proxy (v0 * v2 + v1 * v2))) (CReal_mult_plus_distr_l v2 v0 v1) (CRealEq_trans (v2 * v0 + v2 * v1) (v0 * v2 + v2 * v1) (v0 * v2 + v1 * v2) (CReal_plus_proper_r (v2 * v0) (v0 * v2) (v2 * v1) (CReal_mult_comm v2 v0)) (CReal_plus_proper_l (v2 * v1) (v1 * v2) (v0 * v2) (CReal_mult_comm v2 v1)))); Rsub_def := fun v0 v1 : @CReal => CRealEq_refl (v0 + - v1); Ropp_def := @CReal_plus_opp_r |}).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_morph_Proper	100	0.017563	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_morph_T	100	0.062617	1	1	0	synth with cache (only 1: refine (let v0 : Proper (@CRealEq ==> @CRealEq ==> @CRealEq) (@CReal_mult) := Rmul_ext (@CReal_isRingExt) in v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_opp_morph_Proper	100	0.016309	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_opp_morph_T	100	0.043401	1	1	0	synth with cache (only 1: refine (let v0 : Proper (@CRealEq ==> @CRealEq) (@CReal_opp) := Ropp_ext (@CReal_isRingExt) in v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_minus_morph_Proper	100	0.018307	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_minus_morph_T	100	0.110345	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @CReal) (v2 : v0 == v1) => (fun (v3 v4 : @CReal) (v5 : v3 == v4) => (fun v6 : v0 == v1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v0 + - v3) (v1 + - v3) (CReal_plus_morph_Proper v0 v1 v6 (- v3) (- v3) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) (- v3))) (v1 + - v4) (v1 + - v4) (eq_proper_proxy (v1 + - v4))) v2 ((fun v6 : v3 == v4 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v1 + - v3) (v1 + - v4) (Reflexive_partial_app_morphism (@CReal_plus_morph_Proper) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) v1) (- v3) (- v4) (CReal_opp_morph_Proper v3 v4 v6)) (v1 + - v4) (v1 + - v4) (eq_proper_proxy (v1 + - v4))) v5 (reflexivity (v1 + - v4))) : v0 - v3 == v1 - v4) : CMorphisms.respectful (@CRealEq) (@CRealEq) (CReal_minus v0) (CReal_minus v1)) : CMorphisms.Proper (CMorphisms.respectful (@CRealEq) (CMorphisms.respectful (@CRealEq) (@CRealEq))) (@CReal_minus))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_0_l	100	0.066861	1	1	0	synth with cache (only 1: refine (fun v0 : @CReal => let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : list (@CReal) := (v0 :: nil)%list in CRealRing_ring_lemma1 (@ring_subst_niter) v2 v1 (Ring_polynom.PEmul Ring_polynom.PEO (Ring_polynom.PEX (@Z) 1)) Ring_polynom.PEO (@I) (eq_refl : (let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul Ring_polynom.PEO (Ring_polynom.PEX (@Z) 1))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 Ring_polynom.PEO)) = @true))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_0_r	100	0.063074	1	1	0	synth with cache (only 1: refine (fun v0 : @CReal => let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : list (@CReal) := (v0 :: nil)%list in CRealRing_ring_lemma1 (@ring_subst_niter) v2 v1 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) Ring_polynom.PEO) Ring_polynom.PEO (@I) (eq_refl : (let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) Ring_polynom.PEO)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 Ring_polynom.PEO)) = @true))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_1_r	100	0.060655	1	1	0	synth with cache (only 1: refine (fun v0 : @CReal => let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : list (@CReal) := (v0 :: nil)%list in CRealRing_ring_lemma1 (@ring_subst_niter) v2 v1 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) Ring_polynom.PEI) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) Ring_polynom.PEI)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEX (@Z) 1))) = @true))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_opp_mult_distr_l	100	0.067644	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @CReal => let v2 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v3 : list (@CReal) := (v0 :: v1 :: nil)%list in CRealRing_ring_lemma1 (@ring_subst_niter) v3 v2 (Ring_polynom.PEopp (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEmul (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (@I) (eq_refl : (let v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEopp (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)))) = @true))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_opp_mult_distr_r	100	0.070851	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @CReal => let v2 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v3 : list (@CReal) := (v0 :: v1 :: nil)%list in CRealRing_ring_lemma1 (@ring_subst_niter) v3 v2 (Ring_polynom.PEopp (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 2))) (@I) (eq_refl : (let v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEopp (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 2))))) = @true))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_lt_compat_l	100	0.529085	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_lt_compat_r	100	0.217686	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @CReal) (v3 : inject_Q 0 < v0) (v4 : v1 < v2) => (fun v5 : v0 * v1 == v1 * v0 => CMorphisms.subrelation_proper (@CRealLt_morph) (@tt) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.flip2 (@CMorphisms.iffT_flip_arrow_subrelation)))) (v1 * v0) (v0 * v1) (CRelationClasses.symmetry v5) (v2 * v0) (v2 * v0) (CMorphisms.reflexive_proper_proxy CRelationClasses.Equivalence_Reflexive (v2 * v0))) (CReal_mult_comm v0 v1) ((fun v5 : v0 * v2 == v2 * v0 => CMorphisms.Reflexive_partial_app_morphism (CMorphisms.subrelation_proper (@CRealLt_morph) (@tt) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.flip2 (@CMorphisms.iffT_flip_arrow_subrelation))))) (CMorphisms.reflexive_proper_proxy CRelationClasses.Equivalence_Reflexive (v0 * v1)) (v2 * v0) (v0 * v2) (CRelationClasses.symmetry v5)) (CReal_mult_comm v0 v2) (CReal_mult_lt_compat_l v0 v1 v2 v3 v4)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_eq_reg_l	100	0.645704	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_abs_appart_zero	100	0.698362	1	1	0	synth with cache (only 1: refine (fun (v0 : @CReal) (v1 : @positive) (v2 : (2 # v1 < Qabs (proj1_sig v0 (BinPosDef.Pos.to_nat v1)))%Q) => match v0 as v3 in (sig _) return (forall v4 : (2 # v1 < Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v1)))%Q, inject_Q 0 # v3) with | exist _ v3 v4 => (fun (v3 : forall v3 : @nat, @Q) (v4 : QCauchySeq v3 (@BinPosDef.Pos.to_nat)) (v5 : (2 # v1 < Qabs (proj1_sig (exist (fun v5 : forall v5 : @nat, @Q => QCauchySeq v5 (@BinPosDef.Pos.to_nat)) v3 v4) (BinPosDef.Pos.to_nat v1)))%Q) => let v6 : {(0 < v3 (BinPosDef.Pos.to_nat v1))%Q} + {(v3 (BinPosDef.Pos.to_nat v1) <= 0)%Q} := Qlt_le_dec 0 (v3 (BinPosDef.Pos.to_nat v1)) in match v6 as v7 in ({_} + {_}) return (inject_Q 0 # exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v3 v4) with | left v7 => (fun v7 : (0 < v3 (BinPosDef.Pos.to_nat v1))%Q => inl (exist (fun v8 : @positive => (2 # v8 < proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v3 v4) (BinPosDef.Pos.to_nat v8) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v8))%Q) v1 ((let v8 : list (@Q) := ((2 # v1)%Q :: (v3 (BinPosDef.Pos.to_nat v1) - 0)%Q :: nil)%list in ((fun v9 : v8 = ((2 # v1)%Q :: (v3 (BinPosDef.Pos.to_nat v1) - 0)%Q :: nil)%list => let v10 : list (Ring_polynom.PExpr (@Q) * Ring_polynom.PExpr (@Q)) := nil in let v11 : list (@Q * @Ring_polynom.Mon * Ring_polynom.Pol (@Q)) := nil in let v12 : Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v10 = v11 := eq_refl : Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v10 = v11 in let v13 : forall (v13 : Ring_polynom.PExpr (@Q)) (v14 : Ring_polynom.Pol (@Q)) (v15 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v11 v13 = v14), (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v1 :: v3 (BinPosDef.Pos.to_nat v1) :: nil) v13 == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v1 :: v3 (BinPosDef.Pos.to_nat v1) :: nil) v14)%Q := Qfield_ring_lemma2 (@ring_subst_niter) v10 ((2 # v1)%Q :: v3 (BinPosDef.Pos.to_nat v1) :: nil) (@I) v11 v12 in let v14 : Ring_polynom.Pol (@Q) := Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0) in let v15 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v11 (Ring_polynom.PEX (@Q) 1) = v14 := eq_refl : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v11 (Ring_polynom.PEX (@Q) 1) = v14 in let v16 : (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v1 :: v3 (BinPosDef.Pos.to_nat v1) :: nil) (Ring_polynom.PEX (@Q) 1) == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v1 :: v3 (BinPosDef.Pos.to_nat v1) :: nil) v14)%Q := v13 (Ring_polynom.PEX (@Q) 1) v14 v15 in let v17 : Ring_polynom.Pol (@Q) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0)) in let v18 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v11 (Ring_polynom.PEsub (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEc 0)) = v17 := eq_refl : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v11 (Ring_polynom.PEsub (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEc 0)) = v17 in let v19 : (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v1 :: v3 (BinPosDef.Pos.to_nat v1) :: nil) (Ring_polynom.PEsub (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEc 0)) == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v1 :: v3 (BinPosDef.Pos.to_nat v1) :: nil) v17)%Q := v13 (Ring_polynom.PEsub (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEc 0)) v17 v18 in (fun v20 : (v3 (BinPosDef.Pos.to_nat v1) - 0 == v3 (BinPosDef.Pos.to_nat v1))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 # v1)%Q) (v3 (BinPosDef.Pos.to_nat v1) - 0)%Q (v3 (BinPosDef.Pos.to_nat v1)) v20) v19 ((fun v20 : (Qabs (v3 (BinPosDef.Pos.to_nat v1)) == v3 (BinPosDef.Pos.to_nat v1))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 # v1)%Q) (Qabs (v3 (BinPosDef.Pos.to_nat v1))) (v3 (BinPosDef.Pos.to_nat v1)) v20) (Qabs_pos (v3 (BinPosDef.Pos.to_nat v1)) (Qlt_le_weak 0 (v3 (BinPosDef.Pos.to_nat v1)) v7)) v5)) : forall v9 : v8 = v8, (2 # v1 < v3 (BinPosDef.Pos.to_nat v1) - 0)%Q) eq_refl) : (2 # v1 < proj1_sig (exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v3 v4) (BinPosDef.Pos.to_nat v1) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v1))%Q))) v7 | right v7 => (fun v7 : (v3 (BinPosDef.Pos.to_nat v1) <= 0)%Q => inr (exist (fun v8 : @positive => (2 # v8 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v8) - proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v3 v4) (BinPosDef.Pos.to_nat v8))%Q) v1 (((fun v8 : (0 + - v3 (BinPosDef.Pos.to_nat v1) == - v3 (BinPosDef.Pos.to_nat v1))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 # v1)%Q) (0 + - v3 (BinPosDef.Pos.to_nat v1))%Q (- v3 (BinPosDef.Pos.to_nat v1))%Q v8) (Qplus_0_l (- v3 (BinPosDef.Pos.to_nat v1))) ((fun v8 : (Qabs (v3 (BinPosDef.Pos.to_nat v1)) == - v3 (BinPosDef.Pos.to_nat v1))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (2 # v1)%Q) (Qabs (v3 (BinPosDef.Pos.to_nat v1))) (- v3 (BinPosDef.Pos.to_nat v1))%Q v8) (Qabs_neg (v3 (BinPosDef.Pos.to_nat v1)) v7) v5) : (2 # v1 < 0 - v3 (BinPosDef.Pos.to_nat v1))%Q) : (2 # v1 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v1) - proj1_sig (exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v3 v4) (BinPosDef.Pos.to_nat v1))%Q))) v7 end) v3 v4 end v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CRealArchimedean	100	3.130685	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.Rup_pos	100	0.104408	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @CReal => let v1 : {v1 : @Z & v0 < inject_Q (v1 # 1) < v0 + inject_Q 2} := CRealArchimedean v0 in match v1 as v2 in (sigT _) return {v3 : @positive & v0 < inject_Q (Z.pos v3 # 1)} with | existT _ v2 v3 => (fun (v2 : @Z) (v3 : v0 < inject_Q (v2 # 1) < v0 + inject_Q 2) => match v3 as v4 in (_ * _)%type return {v5 : @positive & v0 < inject_Q (Z.pos v5 # 1)} with | (v4, v5) => (fun (v4 : v0 < inject_Q (v2 # 1)) (v5 : inject_Q (v2 # 1) < v0 + inject_Q 2) => match v2 as v6 in Z return (forall v7 : v0 < inject_Q (v6 # 1), {v8 : @positive & v0 < inject_Q (Z.pos v8 # 1)}) with | 0%Z => fun v6 : v0 < inject_Q 0 => existT (fun v7 : @positive => v0 < inject_Q (Z.pos v7 # 1)) 1%positive (CReal_lt_trans v0 (inject_Q 0) (inject_Q 1) v6 (@CRealLt_0_1)) | Z.pos v6 => (fun (v6 : @positive) (v7 : v0 < inject_Q (Z.pos v6 # 1)) => existT (fun v8 : @positive => v0 < inject_Q (Z.pos v8 # 1)) v6 v7) v6 | Z.neg v6 => (fun (v6 : @positive) (v7 : v0 < inject_Q (Z.neg v6 # 1)) => existT (fun v8 : @positive => v0 < inject_Q (Z.pos v8 # 1)) 1%positive (CReal_lt_trans v0 (inject_Q (Z.neg v6 # 1)) (inject_Q 1) v7 (CReal_lt_trans (inject_Q (Z.neg v6 # 1)) (inject_Q 0) (inject_Q 1) (inject_Q_lt (Z.neg v6 # 1) 0 eq_refl) (@CRealLt_0_1)))) v6 end v4) v4 v5 end) v2 v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CRealLtDisjunctEpsilon	100	1.163747	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @CReal) (v4 : CRealLtProp v0 v1 \/ CRealLtProp v2 v3) => let v5 : exists v5 : @nat, v5 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v5 < proj1_sig v1 v5 - proj1_sig v0 v5)%Q \/ (2 # BinPosDef.Pos.of_nat v5 < proj1_sig v3 v5 - proj1_sig v2 v5)%Q) := match v4 as v5 in (_ \/ _) return (exists v6 : @nat, v6 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v6 < proj1_sig v1 v6 - proj1_sig v0 v6)%Q \/ (2 # BinPosDef.Pos.of_nat v6 < proj1_sig v3 v6 - proj1_sig v2 v6)%Q)) with | or_introl v5 => (fun v5 : CRealLtProp v0 v1 => match v5 as v6 in (ex _) return (exists v7 : @nat, v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q \/ (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q)) with | ex_intro _ v6 v7 => (fun (v6 : @positive) (v7 : (2 # v6 < proj1_sig v1 (BinPosDef.Pos.to_nat v6) - proj1_sig v0 (BinPosDef.Pos.to_nat v6))%Q) => ex_intro (fun v8 : @nat => v8 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v8 < proj1_sig v1 v8 - proj1_sig v0 v8)%Q \/ (2 # BinPosDef.Pos.of_nat v8 < proj1_sig v3 v8 - proj1_sig v2 v8)%Q)) (BinPosDef.Pos.to_nat v6) (conj ((fun v8 : BinPosDef.Pos.to_nat v6 = 0%nat => let v9 : exists v9 : @nat, BinPosDef.Pos.to_nat v6 = S v9 := Pos2Nat.is_succ v6 in match v9 as v10 in (ex _) return (@False) with | ex_intro _ v10 v11 => (fun (v10 : @nat) (v11 : BinPosDef.Pos.to_nat v6 = S v10) => let v12 : S v10 = 0%nat := eq_ind (BinPosDef.Pos.to_nat v6) (fun v12 : @nat => v12 = 0%nat) v8 (S v10) v11 in let v13 : forall v13 : 0%nat = 0%nat, @False := match v12 as v14 in (_ = v13) return (forall v15 : v13 = 0%nat, @False) with | eq_refl => fun v13 : S v10 = 0%nat => (fun v14 : S v10 = 0%nat => let v15 : @False := eq_ind (S v10) (fun v15 : @nat => match v15 as v16 in nat return Prop with | 0%nat => @False | S v16 => (fun v16 : @nat => @True) v16 end) (@I) 0%nat v14 in False_ind (@False) v15) v13 end in v13 eq_refl) v10 v11 end) : BinPosDef.Pos.to_nat v6 <> 0%nat) (or_introl (eq_ind_r (fun v8 : @positive => (2 # v8 < proj1_sig v1 (BinPosDef.Pos.to_nat v6) - proj1_sig v0 (BinPosDef.Pos.to_nat v6))%Q) v7 (Pos2Nat.id v6))))) v6 v7 end) v5 | or_intror v5 => (fun v5 : CRealLtProp v2 v3 => match v5 as v6 in (ex _) return (exists v7 : @nat, v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q \/ (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q)) with | ex_intro _ v6 v7 => (fun (v6 : @positive) (v7 : (2 # v6 < proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v2 (BinPosDef.Pos.to_nat v6))%Q) => ex_intro (fun v8 : @nat => v8 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v8 < proj1_sig v1 v8 - proj1_sig v0 v8)%Q \/ (2 # BinPosDef.Pos.of_nat v8 < proj1_sig v3 v8 - proj1_sig v2 v8)%Q)) (BinPosDef.Pos.to_nat v6) (conj ((fun v8 : BinPosDef.Pos.to_nat v6 = 0%nat => let v9 : exists v9 : @nat, BinPosDef.Pos.to_nat v6 = S v9 := Pos2Nat.is_succ v6 in match v9 as v10 in (ex _) return (@False) with | ex_intro _ v10 v11 => (fun (v10 : @nat) (v11 : BinPosDef.Pos.to_nat v6 = S v10) => let v12 : S v10 = 0%nat := eq_ind (BinPosDef.Pos.to_nat v6) (fun v12 : @nat => v12 = 0%nat) v8 (S v10) v11 in let v13 : forall v13 : 0%nat = 0%nat, @False := match v12 as v14 in (_ = v13) return (forall v15 : v13 = 0%nat, @False) with | eq_refl => fun v13 : S v10 = 0%nat => (fun v14 : S v10 = 0%nat => let v15 : @False := eq_ind (S v10) (fun v15 : @nat => match v15 as v16 in nat return Prop with | 0%nat => @False | S v16 => (fun v16 : @nat => @True) v16 end) (@I) 0%nat v14 in False_ind (@False) v15) v13 end in v13 eq_refl) v10 v11 end) : BinPosDef.Pos.to_nat v6 <> 0%nat) (or_intror (eq_ind_r (fun v8 : @positive => (2 # v8 < proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v2 (BinPosDef.Pos.to_nat v6))%Q) v7 (Pos2Nat.id v6))))) v6 v7 end) v5 end in let v6 : {v6 : @nat | v6 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v6 < proj1_sig v1 v6 - proj1_sig v0 v6)%Q \/ (2 # BinPosDef.Pos.of_nat v6 < proj1_sig v3 v6 - proj1_sig v2 v6)%Q)} := constructive_indefinite_ground_description_nat (fun v6 : @nat => v6 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v6 < proj1_sig v1 v6 - proj1_sig v0 v6)%Q \/ (2 # BinPosDef.Pos.of_nat v6 < proj1_sig v3 v6 - proj1_sig v2 v6)%Q)) (fun v6 : @nat => match v6 as v7 in nat return ({v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q \/ (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q)} + {~ (v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q \/ (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q))}) with | 0%nat => right ((fun v7 : 0%nat <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat 0 < proj1_sig v1 0%nat - proj1_sig v0 0%nat)%Q \/ (2 # BinPosDef.Pos.of_nat 0 < proj1_sig v3 0%nat - proj1_sig v2 0%nat)%Q) => match v7 as v8 in (_ /\ _) return (@False) with | conj v8 v9 => (fun (v8 : 0%nat <> 0%nat) (v9 : (2 # BinPosDef.Pos.of_nat 0 < proj1_sig v1 0%nat - proj1_sig v0 0%nat)%Q \/ (2 # BinPosDef.Pos.of_nat 0 < proj1_sig v3 0%nat - proj1_sig v2 0%nat)%Q) => v8 eq_refl) v8 v9 end) : ~ (0%nat <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat 0 < proj1_sig v1 0%nat - proj1_sig v0 0%nat)%Q \/ (2 # BinPosDef.Pos.of_nat 0 < proj1_sig v3 0%nat - proj1_sig v2 0%nat)%Q))) | S v7 => (fun v7 : @nat => let v8 : {(2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q} + {(proj1_sig v1 (S v7) - proj1_sig v0 (S v7) <= 2 # BinPosDef.Pos.of_nat (S v7))%Q} := Qlt_le_dec (2 # BinPosDef.Pos.of_nat (S v7)) (proj1_sig v1 (S v7) - proj1_sig v0 (S v7)) in match v8 as v9 in ({_} + {_}) return ({S v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q \/ (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q)} + {~ (S v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q \/ (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q))}) with | left v9 => (fun v9 : (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q => left (conj ((fun v10 : S v7 = 0%nat => let v11 : @False := eq_ind (S v7) (fun v11 : @nat => match v11 as v12 in nat return Prop with | 0%nat => @False | S v12 => (fun v12 : @nat => @True) v12 end) (@I) 0%nat v10 in False_ind (@False) v11) : S v7 <> 0%nat) (or_introl v9))) v9 | right v9 => (fun v9 : (proj1_sig v1 (S v7) - proj1_sig v0 (S v7) <= 2 # BinPosDef.Pos.of_nat (S v7))%Q => let v10 : {(2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q} + {(proj1_sig v3 (S v7) - proj1_sig v2 (S v7) <= 2 # BinPosDef.Pos.of_nat (S v7))%Q} := Qlt_le_dec (2 # BinPosDef.Pos.of_nat (S v7)) (proj1_sig v3 (S v7) - proj1_sig v2 (S v7)) in match v10 as v11 in ({_} + {_}) return ({S v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q \/ (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q)} + {~ (S v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q \/ (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q))}) with | left v11 => (fun v11 : (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q => left (conj ((fun v12 : S v7 = 0%nat => let v13 : @False := eq_ind (S v7) (fun v13 : @nat => match v13 as v14 in nat return Prop with | 0%nat => @False | S v14 => (fun v14 : @nat => @True) v14 end) (@I) 0%nat v12 in False_ind (@False) v13) : S v7 <> 0%nat) (or_intror v11))) v11 | right v11 => (fun v11 : (proj1_sig v3 (S v7) - proj1_sig v2 (S v7) <= 2 # BinPosDef.Pos.of_nat (S v7))%Q => right ((fun v12 : S v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q \/ (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q) => match v12 as v13 in (_ /\ _) return (@False) with | conj v13 v14 => (fun (v13 : S v7 <> 0%nat) (v14 : (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q \/ (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q) => match v14 as v15 in (_ \/ _) return (@False) with | or_introl v15 => (fun v15 : (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q => Qlt_not_le (2 # BinPosDef.Pos.of_nat (S v7)) (proj1_sig v1 (S v7) - proj1_sig v0 (S v7)) v15 v9) v15 | or_intror v15 => (fun v15 : (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q => Qlt_not_le (2 # BinPosDef.Pos.of_nat (S v7)) (proj1_sig v3 (S v7) - proj1_sig v2 (S v7)) v15 v11) v15 end) v13 v14 end) : ~ (S v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v1 (S v7) - proj1_sig v0 (S v7))%Q \/ (2 # BinPosDef.Pos.of_nat (S v7) < proj1_sig v3 (S v7) - proj1_sig v2 (S v7))%Q)))) v11 end) v9 end) v7 end) v5 in match v6 as v7 in (sig _) return ((v0 < v1) + (v2 < v3)) with | exist _ v7 v8 => (fun (v7 : @nat) (v8 : v7 <> 0%nat /\ ((2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q \/ (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q)) => match v8 as v9 in (_ /\ _) return ((v0 < v1) + (v2 < v3)) with | conj v9 v10 => (fun (v9 : v7 <> 0%nat) (v10 : (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q \/ (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q) => let v11 : {(2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q} + {(proj1_sig v1 v7 - proj1_sig v0 v7 <= 2 # BinPosDef.Pos.of_nat v7)%Q} := Qlt_le_dec (2 # BinPosDef.Pos.of_nat v7) (proj1_sig v1 v7 - proj1_sig v0 v7) in match v11 as v12 in ({_} + {_}) return ((v0 < v1) + (v2 < v3)) with | left v12 => (fun v12 : (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q => inl (exist (fun v13 : @positive => (2 # v13 < proj1_sig v1 (BinPosDef.Pos.to_nat v13) - proj1_sig v0 (BinPosDef.Pos.to_nat v13))%Q) (BinPosDef.Pos.of_nat v7) (eq_ind_r (fun v13 : @nat => (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v13 - proj1_sig v0 v13)%Q) v12 (Nat2Pos.id v7 v9)))) v12 | right v12 => (fun v12 : (proj1_sig v1 v7 - proj1_sig v0 v7 <= 2 # BinPosDef.Pos.of_nat v7)%Q => let v13 : (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q := match v10 as v13 in (_ \/ _) return (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q with | or_introl v13 => (fun v13 : (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v1 v7 - proj1_sig v0 v7)%Q => False_ind (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q (Qlt_not_le (2 # BinPosDef.Pos.of_nat v7) (proj1_sig v1 v7 - proj1_sig v0 v7) v13 v12)) v13 | or_intror v13 => (fun v13 : (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v7 - proj1_sig v2 v7)%Q => v13) v13 end in inr (exist (fun v14 : @positive => (2 # v14 < proj1_sig v3 (BinPosDef.Pos.to_nat v14) - proj1_sig v2 (BinPosDef.Pos.to_nat v14))%Q) (BinPosDef.Pos.of_nat v7) (eq_ind_r (fun v14 : @nat => (2 # BinPosDef.Pos.of_nat v7 < proj1_sig v3 v14 - proj1_sig v2 v14)%Q) v13 (Nat2Pos.id v7 v9)))) v12 end) v9 v10 end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CRealShiftReal	100	0.346809	1	1	0	synth with cache (only 1: refine (fun (v0 : @CReal) (v1 : @nat) => (fun (v2 : @positive) (v3 v4 : @nat) (v5 : (BinPosDef.Pos.to_nat v2 <= v3)%nat) (v6 : (BinPosDef.Pos.to_nat v2 <= v4)%nat) => match v0 as v7 in (sig _) return (Qabs (proj1_sig v7 (v3 + v1)%nat - proj1_sig v7 (v4 + v1)%nat) < 1 # v2)%Q with | exist _ v7 v8 => (fun (v7 : forall v7 : @nat, @Q) (v8 : QCauchySeq v7 (@BinPosDef.Pos.to_nat)) => match v1 as v9 in nat return (Qabs (v7 (v3 + v9)%nat - v7 (v4 + v9)%nat) < 1 # v2)%Q with | 0%nat => eq_ind_r (fun v9 : @nat => (Qabs (v7 v9 - v7 (v4 + 0)%nat) < 1 # v2)%Q) (eq_ind_r (fun v9 : @nat => (Qabs (v7 v3 - v7 v9) < 1 # v2)%Q) (v8 v2 v3 v4 v5 v6) (Nat.add_0_r v4)) (Nat.add_0_r v3) | S v9 => (fun v9 : @nat => let v10 : forall (v10 : (BinPosDef.Pos.to_nat (v2 + BinPosDef.Pos.of_nat (S v9)) <= v3 + S v9)%nat) (v11 : (BinPosDef.Pos.to_nat (v2 + BinPosDef.Pos.of_nat (S v9)) <= v4 + S v9)%nat), (Qabs (v7 (v3 + S v9)%nat - v7 (v4 + S v9)%nat) < 1 # v2 + BinPosDef.Pos.of_nat (S v9))%Q := v8 (v2 + BinPosDef.Pos.of_nat (S v9))%positive (v3 + S v9)%nat (v4 + S v9)%nat in Qlt_trans (Qabs (v7 (v3 + S v9)%nat - v7 (v4 + S v9)%nat)) (1 # v2 + BinPosDef.Pos.of_nat (S v9)) (1 # v2) (v10 (eq_ind_r (fun v11 : @nat => (v11 <= v3 + S v9)%nat) (eq_ind_r (fun v11 : @nat => (BinPosDef.Pos.to_nat v2 + v11 <= v3 + S v9)%nat) (let v11 : forall (v11 v12 v13 : @nat) (v14 : (v11 <= v12)%nat), (v11 + v13 <= v12 + v13)%nat := fun v11 v12 v13 : @nat => match Nat.add_le_mono_r v11 v12 v13 as v14 in (_ /\ _) return (forall v15 : (v11 <= v12)%nat, (v11 + v13 <= v12 + v13)%nat) with | conj v14 v15 => (fun (v14 : forall v14 : (v11 <= v12)%nat, (v11 + v13 <= v12 + v13)%nat) (v15 : forall v15 : (v11 + v13 <= v12 + v13)%nat, (v11 <= v12)%nat) => v14) v14 v15 end in v11 (BinPosDef.Pos.to_nat v2) v3 (S v9) v5) (Nat2Pos.id (S v9) ((fun v11 : S v9 = 0%nat => let v12 : @False := eq_ind (S v9) (fun v12 : @nat => match v12 as v13 in nat return Prop with | 0%nat => @False | S v13 => (fun v13 : @nat => @True) v13 end) (@I) 0%nat v11 in False_ind (@False) v12) : S v9 <> 0%nat))) (Pos2Nat.inj_add v2 (BinPosDef.Pos.of_nat (S v9)))) (eq_ind_r (fun v11 : @nat => (v11 <= v4 + S v9)%nat) (eq_ind_r (fun v11 : @nat => (BinPosDef.Pos.to_nat v2 + v11 <= v4 + S v9)%nat) (let v11 : forall (v11 v12 v13 : @nat) (v14 : (v11 <= v12)%nat), (v11 + v13 <= v12 + v13)%nat := fun v11 v12 v13 : @nat => match Nat.add_le_mono_r v11 v12 v13 as v14 in (_ /\ _) return (forall v15 : (v11 <= v12)%nat, (v11 + v13 <= v12 + v13)%nat) with | conj v14 v15 => (fun (v14 : forall v14 : (v11 <= v12)%nat, (v11 + v13 <= v12 + v13)%nat) (v15 : forall v15 : (v11 + v13 <= v12 + v13)%nat, (v11 <= v12)%nat) => v14) v14 v15 end in v11 (BinPosDef.Pos.to_nat v2) v4 (S v9) v6) (Nat2Pos.id (S v9) ((fun v11 : S v9 = 0%nat => let v12 : @False := eq_ind (S v9) (fun v12 : @nat => match v12 as v13 in nat return Prop with | 0%nat => @False | S v13 => (fun v13 : @nat => @True) v13 end) (@I) 0%nat v11 in False_ind (@False) v12) : S v9 <> 0%nat))) (Pos2Nat.inj_add v2 (BinPosDef.Pos.of_nat (S v9))))) (let v11 : forall (v11 v12 : @positive) (v13 : (BinPosDef.Pos.to_nat v11 < BinPosDef.Pos.to_nat v12)%nat), (v11 < v12)%positive := fun v11 v12 : @positive => match Pos2Nat.inj_lt v11 v12 as v13 in (_ /\ _) return (forall v14 : (BinPosDef.Pos.to_nat v11 < BinPosDef.Pos.to_nat v12)%nat, (v11 < v12)%positive) with | conj v13 v14 => (fun (v13 : forall v13 : (v11 < v12)%positive, (BinPosDef.Pos.to_nat v11 < BinPosDef.Pos.to_nat v12)%nat) (v14 : forall v14 : (BinPosDef.Pos.to_nat v11 < BinPosDef.Pos.to_nat v12)%nat, (v11 < v12)%positive) => v14) v13 v14 end in v11 (1 * Qden (1 # v2))%positive (1 * Qden (1 # v2 + BinPosDef.Pos.of_nat (S v9)))%positive (eq_ind_r (fun v12 : @nat => (BinPosDef.Pos.to_nat v2 < v12)%nat) (eq_ind (BinPosDef.Pos.to_nat v2 + 0)%nat (fun v12 : @nat => (v12 < v12 + BinPosDef.Pos.to_nat match v9 as v13 in nat return (@positive) with | 0%nat => 1 | S v13 => (fun v13 : @nat => BinPosDef.Pos.succ (BinPosDef.Pos.of_nat v9)) v13 end)%nat) (eq_ind (BinPosDef.Pos.to_nat v2 + (0 + BinPosDef.Pos.to_nat match v9 as v12 in nat return (@positive) with | 0%nat => 1 | S v12 => (fun v12 : @nat => BinPosDef.Pos.succ (BinPosDef.Pos.of_nat v9)) v12 end))%nat (fun v12 : @nat => (BinPosDef.Pos.to_nat v2 + 0 < v12)%nat) (let v12 : forall (v12 v13 v14 : @nat) (v15 : (v12 < v13)%nat), (v14 + v12 < v14 + v13)%nat := fun v12 v13 v14 : @nat => match Nat.add_lt_mono_l v12 v13 v14 as v15 in (_ /\ _) return (forall v16 : (v12 < v13)%nat, (v14 + v12 < v14 + v13)%nat) with | conj v15 v16 => (fun (v15 : forall v15 : (v12 < v13)%nat, (v14 + v12 < v14 + v13)%nat) (v16 : forall v16 : (v14 + v12 < v14 + v13)%nat, (v12 < v13)%nat) => v15) v15 v16 end in v12 0%nat (0 + BinPosDef.Pos.to_nat match v9 as v13 in nat return (@positive) with | 0%nat => 1 | S v13 => (fun v13 : @nat => BinPosDef.Pos.succ (BinPosDef.Pos.of_nat v9)) v13 end)%nat (BinPosDef.Pos.to_nat v2) (Pos2Nat.is_pos match v9 as v13 in nat return (@positive) with | 0%nat => 1 | S v13 => (fun v13 : @nat => BinPosDef.Pos.succ (BinPosDef.Pos.of_nat v9)) v13 end)) (BinPosDef.Pos.to_nat v2 + 0 + BinPosDef.Pos.to_nat match v9 as v12 in nat return (@positive) with | 0%nat => 1 | S v12 => (fun v12 : @nat => BinPosDef.Pos.succ (BinPosDef.Pos.of_nat v9)) v12 end)%nat (Nat.add_assoc (BinPosDef.Pos.to_nat v2) 0 (BinPosDef.Pos.to_nat match v9 as v12 in nat return (@positive) with | 0%nat => 1 | S v12 => (fun v12 : @nat => BinPosDef.Pos.succ (BinPosDef.Pos.of_nat v9)) v12 end))) (BinPosDef.Pos.to_nat v2) (Nat.add_0_r (BinPosDef.Pos.to_nat v2))) (Pos2Nat.inj_add v2 match v9 as v12 in nat return (@positive) with | 0%nat => 1 | S v12 => (fun v12 : @nat => BinPosDef.Pos.succ (BinPosDef.Pos.of_nat v9)) v12 end) : (BinPosDef.Pos.to_nat (1 * Qden (1 # v2)) < BinPosDef.Pos.to_nat (1 * Qden (1 # v2 + BinPosDef.Pos.of_nat (S v9))))%nat))) v9 end : (Qabs (proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v7 v8) (v3 + v1)%nat - proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v7 v8) (v4 + v1)%nat) < 1 # v2)%Q) v7 v8 end) : QCauchySeq (fun v2 : @nat => proj1_sig v0 (v2 + v1)%nat) (@BinPosDef.Pos.to_nat))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CRealShiftEqual	100	0.467338	1	1	0	synth with cache (only 1: refine (fun (v0 : @CReal) (v1 : @nat) => conj (fun v2 : v0 < exist (fun v2 : forall v2 : @nat, @Q => QCauchySeq v2 (@BinPosDef.Pos.to_nat)) (fun v2 : @nat => proj1_sig v0 (v2 + v1)%nat) (CRealShiftReal v0 v1) => match v2 as v3 in (sig _) return (@False) with | exist _ v3 v4 => (fun (v3 : @positive) (v4 : (2 # v3 < proj1_sig (exist (fun v4 : forall v4 : @nat, @Q => QCauchySeq v4 (@BinPosDef.Pos.to_nat)) (fun v4 : @nat => proj1_sig v0 (v4 + v1)%nat) (CRealShiftReal v0 v1)) (BinPosDef.Pos.to_nat v3) - proj1_sig v0 (BinPosDef.Pos.to_nat v3))%Q) => match v0 as v5 in (sig _) return (forall v6 : (2 # v3 < proj1_sig (exist (fun v6 : forall v6 : @nat, @Q => QCauchySeq v6 (@BinPosDef.Pos.to_nat)) (fun v6 : @nat => proj1_sig v5 (v6 + v1)%nat) (CRealShiftReal v5 v1)) (BinPosDef.Pos.to_nat v3) - proj1_sig v5 (BinPosDef.Pos.to_nat v3))%Q, @False) with | exist _ v5 v6 => (fun (v5 : forall v5 : @nat, @Q) (v6 : QCauchySeq v5 (@BinPosDef.Pos.to_nat)) (v7 : (2 # v3 < proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) (fun v7 : @nat => proj1_sig (exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v5 v6) (v7 + v1)%nat) (CRealShiftReal (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v5 v6) v1)) (BinPosDef.Pos.to_nat v3) - proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v5 v6) (BinPosDef.Pos.to_nat v3))%Q) => let v8 : forall (v8 : (BinPosDef.Pos.to_nat v3 <= BinPosDef.Pos.to_nat v3 + v1)%nat) (v9 : (BinPosDef.Pos.to_nat v3 <= BinPosDef.Pos.to_nat v3)%nat), (Qabs (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3)) < 1 # v3)%Q := v6 v3 (BinPosDef.Pos.to_nat v3 + v1)%nat (BinPosDef.Pos.to_nat v3) in let v9 : ~ (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3) <= 2 # v3)%Q := Qlt_not_le (2 # v3) (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3)) v7 in v9 (Qle_trans (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3)) (Qabs (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3))) (2 # v3) (Qle_Qabs (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3))) (Qle_trans (Qabs (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3))) (1 # v3) (2 # v3) (Z.lt_le_incl (Qnum (Qabs (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3))) * QDen (1 # v3)) (Qnum (1 # v3) * QDen (Qabs (v5 (BinPosDef.Pos.to_nat v3 + v1)%nat - v5 (BinPosDef.Pos.to_nat v3)))) (v8 (eq_ind (BinPosDef.Pos.to_nat v3 + 0)%nat (fun v10 : @nat => (v10 <= v10 + v1)%nat) (eq_ind (BinPosDef.Pos.to_nat v3 + (0 + v1))%nat (fun v10 : @nat => (BinPosDef.Pos.to_nat v3 + 0 <= v10)%nat) (let v10 : forall (v10 v11 v12 : @nat) (v13 : (v10 <= v11)%nat), (v12 + v10 <= v12 + v11)%nat := fun v10 v11 v12 : @nat => match Nat.add_le_mono_l v10 v11 v12 as v13 in (_ /\ _) return (forall v14 : (v10 <= v11)%nat, (v12 + v10 <= v12 + v11)%nat) with | conj v13 v14 => (fun (v13 : forall v13 : (v10 <= v11)%nat, (v12 + v10 <= v12 + v11)%nat) (v14 : forall v14 : (v12 + v10 <= v12 + v11)%nat, (v10 <= v11)%nat) => v13) v13 v14 end in v10 0%nat (0 + v1)%nat (BinPosDef.Pos.to_nat v3) (Nat.le_0_l (0 + v1))) (BinPosDef.Pos.to_nat v3 + 0 + v1)%nat (Nat.add_assoc (BinPosDef.Pos.to_nat v3) 0 v1)) (BinPosDef.Pos.to_nat v3) (Nat.add_0_r (BinPosDef.Pos.to_nat v3))) (Nat.le_refl (BinPosDef.Pos.to_nat v3)))) (let v10 : forall (v10 v11 v12 : @Z) (v13 : (0 < v12)%Z) (v14 : (v10 <= v11)%Z), (v10 * v12 <= v11 * v12)%Z := fun (v10 v11 v12 : @Z) (v13 : (0 < v12)%Z) => match Z.mul_le_mono_pos_r v10 v11 v12 v13 as v14 in (_ /\ _) return (forall v15 : (v10 <= v11)%Z, (v10 * v12 <= v11 * v12)%Z) with | conj v14 v15 => (fun (v14 : forall v14 : (v10 <= v11)%Z, (v10 * v12 <= v11 * v12)%Z) (v15 : forall v15 : (v10 * v12 <= v11 * v12)%Z, (v10 <= v11)%Z) => v14) v14 v15 end in v10 (Qnum (1 # v3)) (Qnum (2 # v3)) (QDen (1 # v3)) (Pos2Z.is_pos (Qden (1 # v3))) ((fun v11 : (Qnum (1 # v3) ?= Qnum (2 # v3))%Z = @Gt => let v12 : @False := eq_ind (Qnum (1 # v3) ?= Qnum (2 # v3))%Z (fun v12 : @comparison => match v12 as v13 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v11 in False_ind (@False) v12) : (Qnum (1 # v3) <= Qnum (2 # v3))%Z))))) v5 v6 end v4) v3 v4 end) (fun v2 : exist (fun v2 : forall v2 : @nat, @Q => QCauchySeq v2 (@BinPosDef.Pos.to_nat)) (fun v2 : @nat => proj1_sig v0 (v2 + v1)%nat) (CRealShiftReal v0 v1) < v0 => match v2 as v3 in (sig _) return (@False) with | exist _ v3 v4 => (fun (v3 : @positive) (v4 : (2 # v3 < proj1_sig v0 (BinPosDef.Pos.to_nat v3) - proj1_sig (exist (fun v4 : forall v4 : @nat, @Q => QCauchySeq v4 (@BinPosDef.Pos.to_nat)) (fun v4 : @nat => proj1_sig v0 (v4 + v1)%nat) (CRealShiftReal v0 v1)) (BinPosDef.Pos.to_nat v3))%Q) => match v0 as v5 in (sig _) return (forall v6 : (2 # v3 < proj1_sig v5 (BinPosDef.Pos.to_nat v3) - proj1_sig (exist (fun v6 : forall v6 : @nat, @Q => QCauchySeq v6 (@BinPosDef.Pos.to_nat)) (fun v6 : @nat => proj1_sig v5 (v6 + v1)%nat) (CRealShiftReal v5 v1)) (BinPosDef.Pos.to_nat v3))%Q, @False) with | exist _ v5 v6 => (fun (v5 : forall v5 : @nat, @Q) (v6 : QCauchySeq v5 (@BinPosDef.Pos.to_nat)) (v7 : (2 # v3 < proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v5 v6) (BinPosDef.Pos.to_nat v3) - proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) (fun v7 : @nat => proj1_sig (exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v5 v6) (v7 + v1)%nat) (CRealShiftReal (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v5 v6) v1)) (BinPosDef.Pos.to_nat v3))%Q) => let v8 : forall (v8 : (BinPosDef.Pos.to_nat v3 <= BinPosDef.Pos.to_nat v3)%nat) (v9 : (BinPosDef.Pos.to_nat v3 <= BinPosDef.Pos.to_nat v3 + v1)%nat), (Qabs (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat) < 1 # v3)%Q := v6 v3 (BinPosDef.Pos.to_nat v3) (BinPosDef.Pos.to_nat v3 + v1)%nat in let v9 : ~ (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat <= 2 # v3)%Q := Qlt_not_le (2 # v3) (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat) v7 in v9 (Qle_trans (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat) (Qabs (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat)) (2 # v3) (Qle_Qabs (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat)) (Qle_trans (Qabs (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat)) (1 # v3) (2 # v3) (Z.lt_le_incl (Qnum (Qabs (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat)) * QDen (1 # v3)) (Qnum (1 # v3) * QDen (Qabs (v5 (BinPosDef.Pos.to_nat v3) - v5 (BinPosDef.Pos.to_nat v3 + v1)%nat))) (v8 (Nat.le_refl (BinPosDef.Pos.to_nat v3)) (eq_ind (BinPosDef.Pos.to_nat v3 + 0)%nat (fun v10 : @nat => (v10 <= v10 + v1)%nat) (eq_ind (BinPosDef.Pos.to_nat v3 + (0 + v1))%nat (fun v10 : @nat => (BinPosDef.Pos.to_nat v3 + 0 <= v10)%nat) (let v10 : forall (v10 v11 v12 : @nat) (v13 : (v10 <= v11)%nat), (v12 + v10 <= v12 + v11)%nat := fun v10 v11 v12 : @nat => match Nat.add_le_mono_l v10 v11 v12 as v13 in (_ /\ _) return (forall v14 : (v10 <= v11)%nat, (v12 + v10 <= v12 + v11)%nat) with | conj v13 v14 => (fun (v13 : forall v13 : (v10 <= v11)%nat, (v12 + v10 <= v12 + v11)%nat) (v14 : forall v14 : (v12 + v10 <= v12 + v11)%nat, (v10 <= v11)%nat) => v13) v13 v14 end in v10 0%nat (0 + v1)%nat (BinPosDef.Pos.to_nat v3) (Nat.le_0_l (0 + v1))) (BinPosDef.Pos.to_nat v3 + 0 + v1)%nat (Nat.add_assoc (BinPosDef.Pos.to_nat v3) 0 v1)) (BinPosDef.Pos.to_nat v3) (Nat.add_0_r (BinPosDef.Pos.to_nat v3))))) (let v10 : forall (v10 v11 v12 : @Z) (v13 : (0 < v12)%Z) (v14 : (v10 <= v11)%Z), (v10 * v12 <= v11 * v12)%Z := fun (v10 v11 v12 : @Z) (v13 : (0 < v12)%Z) => match Z.mul_le_mono_pos_r v10 v11 v12 v13 as v14 in (_ /\ _) return (forall v15 : (v10 <= v11)%Z, (v10 * v12 <= v11 * v12)%Z) with | conj v14 v15 => (fun (v14 : forall v14 : (v10 <= v11)%Z, (v10 * v12 <= v11 * v12)%Z) (v15 : forall v15 : (v10 * v12 <= v11 * v12)%Z, (v10 <= v11)%Z) => v14) v14 v15 end in v10 (Qnum (1 # v3)) (Qnum (2 # v3)) (QDen (1 # v3)) (Pos2Z.is_pos (Qden (1 # v3))) ((fun v11 : (Qnum (1 # v3) ?= Qnum (2 # v3))%Z = @Gt => let v12 : @False := eq_ind (Qnum (1 # v3) ?= Qnum (2 # v3))%Z (fun v12 : @comparison => match v12 as v13 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v11 in False_ind (@False) v12) : (Qnum (1 # v3) <= Qnum (2 # v3))%Z))))) v5 v6 end v4) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CRealNegShift	100	1.189451	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @CReal) (v1 : v0 < inject_Q 0) => let v2 : forall (v2 : @positive) (v3 : (2 # v2 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v2) - proj1_sig v0 (BinPosDef.Pos.to_nat v2))%Q), match Qarchimedean (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v2) - proj1_sig v0 (BinPosDef.Pos.to_nat v2) - (2 # v2))) as v4 in (sig _) return Prop with | exist _ v4 v5 => (fun (v4 : @positive) (v5 : (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v2) - proj1_sig v0 (BinPosDef.Pos.to_nat v2) - (2 # v2)) < Z.pos v4 # 1)%Q) => forall (v6 : @positive) (v7 : (BinPosDef.Pos.max v2 (2 * v4) <= v6)%positive), (2 # BinPosDef.Pos.max v2 (2 * v4) < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v6) - proj1_sig v0 (BinPosDef.Pos.to_nat v6))%Q) v4 v5 end := CRealLt_aboveSig v0 (inject_Q 0) in let v3 : forall v3 : @nat, QCauchySeq (fun v4 : @nat => proj1_sig v0 (v4 + v3)%nat) (@BinPosDef.Pos.to_nat) := CRealShiftReal v0 in let v4 : forall v4 : @nat, v0 == exist (fun v5 : forall v5 : @nat, @Q => QCauchySeq v5 (@BinPosDef.Pos.to_nat)) (fun v5 : @nat => proj1_sig v0 (v5 + v4)%nat) (CRealShiftReal v0 v4) := CRealShiftEqual v0 in match v1 as v5 in (sig _) return {v6 : @positive * @CReal | v0 == snd v6 /\ (forall v7 : @nat, (proj1_sig (snd v6) v7 < -1 # fst v6)%Q)} with | exist _ v5 v6 => (fun (v5 : @positive) (v6 : (2 # v5 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5) - proj1_sig v0 (BinPosDef.Pos.to_nat v5))%Q) => match v0 as v7 in (sig _) return (forall (v8 : (2 # v5 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5) - proj1_sig v7 (BinPosDef.Pos.to_nat v5))%Q) (v9 : forall (v9 : @positive) (v10 : (2 # v9 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v9) - proj1_sig v7 (BinPosDef.Pos.to_nat v9))%Q), match Qarchimedean (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v9) - proj1_sig v7 (BinPosDef.Pos.to_nat v9) - (2 # v9))) as v11 in (sig _) return Prop with | exist _ v11 v12 => (fun (v11 : @positive) (v12 : (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v9) - proj1_sig v7 (BinPosDef.Pos.to_nat v9) - (2 # v9)) < Z.pos v11 # 1)%Q) => forall (v13 : @positive) (v14 : (BinPosDef.Pos.max v9 (2 * v11) <= v13)%positive), (2 # BinPosDef.Pos.max v9 (2 * v11) < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v13) - proj1_sig v7 (BinPosDef.Pos.to_nat v13))%Q) v11 v12 end) (v10 : forall v10 : @nat, QCauchySeq (fun v11 : @nat => proj1_sig v7 (v11 + v10)%nat) (@BinPosDef.Pos.to_nat)) (v11 : forall v11 : @nat, v7 == exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => proj1_sig v7 (v12 + v11)%nat) (CRealShiftReal v7 v11)), {v12 : @positive * @CReal | v7 == snd v12 /\ (forall v13 : @nat, (proj1_sig (snd v12) v13 < -1 # fst v12)%Q)}) with | exist _ v7 v8 => (fun (v7 : forall v7 : @nat, @Q) (v8 : QCauchySeq v7 (@BinPosDef.Pos.to_nat)) (v9 : (2 # v5 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5) - proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v5))%Q) (v10 : forall (v10 : @positive) (v11 : (2 # v10 < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v10) - proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v10))%Q), match Qarchimedean (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v10) - proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v10) - (2 # v10))) as v12 in (sig _) return Prop with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v10) - proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v10) - (2 # v10)) < Z.pos v12 # 1)%Q) => forall (v14 : @positive) (v15 : (BinPosDef.Pos.max v10 (2 * v12) <= v14)%positive), (2 # BinPosDef.Pos.max v10 (2 * v12) < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v14) - proj1_sig (exist (fun v16 : forall v16 : @nat, @Q => QCauchySeq v16 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v14))%Q) v12 v13 end) (v11 : forall v11 : @nat, QCauchySeq (fun v12 : @nat => proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8) (v12 + v11)%nat) (@BinPosDef.Pos.to_nat)) (v12 : forall v12 : @nat, exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8 == exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) (fun v13 : @nat => proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v7 v8) (v13 + v12)%nat) (CRealShiftReal (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8) v12)) => let v13 : match Qarchimedean (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5) - proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v5) - (2 # v5))) as v13 in (sig _) return Prop with | exist _ v13 v14 => (fun (v13 : @positive) (v14 : (/ (proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5) - proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v5) - (2 # v5)) < Z.pos v13 # 1)%Q) => forall (v15 : @positive) (v16 : (BinPosDef.Pos.max v5 (2 * v13) <= v15)%positive), (2 # BinPosDef.Pos.max v5 (2 * v13) < proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v15) - proj1_sig (exist (fun v17 : forall v17 : @nat, @Q => QCauchySeq v17 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v15))%Q) v13 v14 end := v10 v5 v9 in let v14 : {v14 : @positive | (/ (0 - v7 (BinPosDef.Pos.to_nat v5) - (2 # v5)) < Z.pos v14 # 1)%Q} := Qarchimedean (/ (0 - v7 (BinPosDef.Pos.to_nat v5) - (2 # v5))) in match v14 as v15 in (sig _) return (forall v16 : match v15 as v16 in (sig _) return Prop with | exist _ v16 v17 => (fun (v16 : @positive) (v17 : (/ (0 - v7 (BinPosDef.Pos.to_nat v5) - (2 # v5)) < Z.pos v16 # 1)%Q) => forall (v18 : @positive) (v19 : (BinPosDef.Pos.max v5 v16~0 <= v18)%positive), (2 # BinPosDef.Pos.max v5 v16~0 < 0 - v7 (BinPosDef.Pos.to_nat v18))%Q) v16 v17 end, {v17 : @positive * @CReal | exist (fun v18 : forall v18 : @nat, @Q => QCauchySeq v18 (@BinPosDef.Pos.to_nat)) v7 v8 == snd v17 /\ (forall v18 : @nat, (proj1_sig (snd v17) v18 < -1 # fst v17)%Q)}) with | exist _ v15 v16 => (fun (v15 : @positive) (v16 : (/ (0 - v7 (BinPosDef.Pos.to_nat v5) - (2 # v5)) < Z.pos v15 # 1)%Q) (v17 : forall (v17 : @positive) (v18 : (BinPosDef.Pos.max v5 v15~0 <= v17)%positive), (2 # BinPosDef.Pos.max v5 v15~0 < 0 - v7 (BinPosDef.Pos.to_nat v17))%Q) => let v18 : @positive := BinPosDef.Pos.max v5 v15~0 in let v19 : v18 = BinPosDef.Pos.max v5 v15~0 := eq_refl in exist (fun v20 : @positive * @CReal => exist (fun v21 : forall v21 : @nat, @Q => QCauchySeq v21 (@BinPosDef.Pos.to_nat)) v7 v8 == snd v20 /\ (forall v21 : @nat, (proj1_sig (snd v20) v21 < -1 # fst v20)%Q)) (v18, exist (fun v20 : forall v20 : @nat, @Q => QCauchySeq v20 (@BinPosDef.Pos.to_nat)) (fun v20 : @nat => v7 (v20 + BinPosDef.Pos.to_nat v18)%nat) (v11 (BinPosDef.Pos.to_nat v18))) (conj (v12 (BinPosDef.Pos.to_nat v18)) (fun v20 : @nat => (let v21 : forall (v21 v22 : @Q) (v23 : (0 < v22 + - v21)%Q), (v21 < v22)%Q := fun v21 v22 : @Q => match Qlt_minus_iff v21 v22 as v23 in (_ /\ _) return (forall v24 : (0 < v22 + - v21)%Q, (v21 < v22)%Q) with | conj v23 v24 => (fun (v23 : forall v23 : (v21 < v22)%Q, (0 < v22 + - v21)%Q) (v24 : forall v24 : (0 < v22 + - v21)%Q, (v21 < v22)%Q) => v24) v23 v24 end in v21 (v7 (v20 + BinPosDef.Pos.to_nat v18)%nat) (-1 # v18)%Q match v20 as v22 in nat return (0 < (-1 # v18) + - v7 (v22 + BinPosDef.Pos.to_nat v18)%nat)%Q with | 0%nat => let v22 : forall v22 : (v18 <= v18)%positive, (2 # v18 < 0 - v7 (BinPosDef.Pos.to_nat v18))%Q := v17 v18 in let v23 : forall (v23 v24 : @Q) (v25 : (v23 < v24)%Q), (0 < v24 + - v23)%Q := fun v23 v24 : @Q => match Qlt_minus_iff v23 v24 as v25 in (_ /\ _) return (forall v26 : (v23 < v24)%Q, (0 < v24 + - v23)%Q) with | conj v25 v26 => (fun (v25 : forall v25 : (v23 < v24)%Q, (0 < v24 + - v23)%Q) (v26 : forall v26 : (0 < v24 + - v23)%Q, (v23 < v24)%Q) => v25) v25 v26 end in let v24 : (0 < - v7 (BinPosDef.Pos.to_nat v18) + - (2 # v18))%Q := v23 (2 # v18)%Q (- v7 (BinPosDef.Pos.to_nat v18))%Q ((fun v24 : (0 + - v7 (BinPosDef.Pos.to_nat v18) == - v7 (BinPosDef.Pos.to_nat v18))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v18 <= v18)%positive) (2 # v18 < 0 + - v7 (BinPosDef.Pos.to_nat v18))%Q (2 # v18 < - v7 (BinPosDef.Pos.to_nat v18))%Q (Reflexive_partial_app_morphism (@Qlt_compat) (reflexive_proper_proxy Equivalence_Reflexive (2 # v18)%Q) (0 + - v7 (BinPosDef.Pos.to_nat v18))%Q (- v7 (BinPosDef.Pos.to_nat v18))%Q v24)) (Qplus_0_l (- v7 (BinPosDef.Pos.to_nat v18))) v22 (Pos.le_refl v18)) in (fun v25 : ((-1 # v18) + - v7 (0 + BinPosDef.Pos.to_nat v18)%nat == - v7 (0 + BinPosDef.Pos.to_nat v18)%nat + (-1 # v18))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) ((-1 # v18) + - v7 (0 + BinPosDef.Pos.to_nat v18)%nat)%Q (- v7 (0 + BinPosDef.Pos.to_nat v18)%nat + (-1 # v18))%Q v25) (Qplus_comm (-1 # v18) (- v7 (0 + BinPosDef.Pos.to_nat v18)%nat)) (Qlt_trans 0 (- v7 (BinPosDef.Pos.to_nat v18) - (2 # v18)) (- v7 (0 + BinPosDef.Pos.to_nat v18)%nat + (-1 # v18)) v24 (((let v25 : forall (v25 v26 v27 : @Q) (v28 : (v25 < v26)%Q), (v27 + v25 < v27 + v26)%Q := fun v25 v26 v27 : @Q => match Qplus_lt_r v25 v26 v27 as v28 in (_ /\ _) return (forall v29 : (v25 < v26)%Q, (v27 + v25 < v27 + v26)%Q) with | conj v28 v29 => (fun (v28 : forall v28 : (v27 + v25 < v27 + v26)%Q, (v25 < v26)%Q) (v29 : forall v29 : (v25 < v26)%Q, (v27 + v25 < v27 + v26)%Q) => v29) v28 v29 end in v25 (- (2 # v18))%Q (-1 # v18)%Q (- v7 (BinPosDef.Pos.to_nat v18))%Q (let v26 : forall (v26 v27 v28 : @Z) (v29 : (0 < v26)%Z) (v30 : (v27 < v28)%Z), (v27 * v26 < v28 * v26)%Z := fun (v26 v27 v28 : @Z) (v29 : (0 < v26)%Z) => match Z.mul_lt_mono_pos_r v26 v27 v28 v29 as v30 in (_ /\ _) return (forall v31 : (v27 < v28)%Z, (v27 * v26 < v28 * v26)%Z) with | conj v30 v31 => (fun (v30 : forall v30 : (v27 < v28)%Z, (v27 * v26 < v28 * v26)%Z) (v31 : forall v31 : (v27 * v26 < v28 * v26)%Z, (v27 < v28)%Z) => v30) v30 v31 end in v26 (QDen (- (2 # v18))) (Qnum (- (2 # v18))) (Qnum (-1 # v18)) (Pos2Z.is_pos v18 : (0 < QDen (- (2 # v18)))%Z) eq_refl)) : (- v7 (BinPosDef.Pos.to_nat v18) + - (2 # v18) < - v7 (0 + BinPosDef.Pos.to_nat v18)%nat + (-1 # v18))%Q) : (- v7 (BinPosDef.Pos.to_nat v18) - (2 # v18) < - v7 (0 + BinPosDef.Pos.to_nat v18)%nat + (-1 # v18))%Q)) : (0 < (-1 # v18) + - v7 (0 + BinPosDef.Pos.to_nat v18)%nat)%Q | S v22 => (fun v22 : @nat => Qlt_trans 0 (- (2 # v18) - v7 (S v22 + BinPosDef.Pos.to_nat v18)%nat) ((-1 # v18) + - v7 (S v22 + BinPosDef.Pos.to_nat v18)%nat) (eq_ind (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22))) (fun v23 : @nat => (0 < - (2 # v18) - v7 (v23 + BinPosDef.Pos.to_nat v18)%nat)%Q) (eq_ind (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)) (fun v23 : @nat => (0 < - (2 # v18) - v7 v23)%Q) (let v23 : forall v23 : (v18 <= BinPosDef.Pos.of_nat (S v22) + v18)%positive, (2 # v18 < 0 - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q := v17 (BinPosDef.Pos.of_nat (S v22) + v18)%positive in let v24 : forall (v24 v25 : @Q) (v26 : (v24 < v25)%Q), (0 < v25 + - v24)%Q := fun v24 v25 : @Q => match Qlt_minus_iff v24 v25 as v26 in (_ /\ _) return (forall v27 : (v24 < v25)%Q, (0 < v25 + - v24)%Q) with | conj v26 v27 => (fun (v26 : forall v26 : (v24 < v25)%Q, (0 < v25 + - v24)%Q) (v27 : forall v27 : (0 < v25 + - v24)%Q, (v24 < v25)%Q) => v26) v26 v27 end in let v25 : (0 < - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)) + - (2 # v18))%Q := v24 (2 # v18)%Q (- v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q ((fun v25 : (0 + - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)) == - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v18 <= BinPosDef.Pos.of_nat (S v22) + v18)%positive) (2 # v18 < 0 + - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q (2 # v18 < - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q (Reflexive_partial_app_morphism (@Qlt_compat) (reflexive_proper_proxy Equivalence_Reflexive (2 # v18)%Q) (0 + - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q (- v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q v25)) (Qplus_0_l (- v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))) v23 (let v25 : forall (v25 v26 : @positive) (v27 : (BinPosDef.Pos.to_nat v25 <= BinPosDef.Pos.to_nat v26)%nat), (v25 <= v26)%positive := fun v25 v26 : @positive => match Pos2Nat.inj_le v25 v26 as v27 in (_ /\ _) return (forall v28 : (BinPosDef.Pos.to_nat v25 <= BinPosDef.Pos.to_nat v26)%nat, (v25 <= v26)%positive) with | conj v27 v28 => (fun (v27 : forall v27 : (v25 <= v26)%positive, (BinPosDef.Pos.to_nat v25 <= BinPosDef.Pos.to_nat v26)%nat) (v28 : forall v28 : (BinPosDef.Pos.to_nat v25 <= BinPosDef.Pos.to_nat v26)%nat, (v25 <= v26)%positive) => v28) v27 v28 end in v25 v18 (BinPosDef.Pos.of_nat (S v22) + v18)%positive (eq_ind (0 + BinPosDef.Pos.to_nat v18)%nat (fun v26 : @nat => (v26 <= BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18))%nat) (eq_ind_r (fun v26 : @nat => (0 + BinPosDef.Pos.to_nat v18 <= v26)%nat) (let v26 : forall (v26 v27 v28 : @nat) (v29 : (v26 <= v27)%nat), (v26 + v28 <= v27 + v28)%nat := fun v26 v27 v28 : @nat => match Nat.add_le_mono_r v26 v27 v28 as v29 in (_ /\ _) return (forall v30 : (v26 <= v27)%nat, (v26 + v28 <= v27 + v28)%nat) with | conj v29 v30 => (fun (v29 : forall v29 : (v26 <= v27)%nat, (v26 + v28 <= v27 + v28)%nat) (v30 : forall v30 : (v26 + v28 <= v27 + v28)%nat, (v26 <= v27)%nat) => v29) v29 v30 end in v26 0%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22))) (BinPosDef.Pos.to_nat v18) (Nat.le_0_l (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22))))) (Pos2Nat.inj_add (BinPosDef.Pos.of_nat (S v22)) v18)) (BinPosDef.Pos.to_nat v18) (Nat.add_0_l (BinPosDef.Pos.to_nat v18))))) in (fun v26 : (- (2 # v18) + - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)) == - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)) + - (2 # v18))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (- (2 # v18) + - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q (- v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)) + - (2 # v18))%Q v26) (Qplus_comm (- (2 # v18)) (- v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))) v25 : (0 < - (2 # v18) - v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22) + v18)))%Q) (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v22)) + BinPosDef.Pos.to_nat v18)%nat (Pos2Nat.inj_add (BinPosDef.Pos.of_nat (S v22)) v18)) (S v22) (Nat2Pos.id (S v22) ((fun v23 : S v22 = 0%nat => let v24 : @False := eq_ind (S v22) (fun v24 : @nat => match v24 as v25 in nat return Prop with | 0%nat => @False | S v25 => (fun v25 : @nat => @True) v25 end) (@I) 0%nat v23 in False_ind (@False) v24) : S v22 <> 0%nat))) (let v23 : forall (v23 v24 v25 : @Q) (v26 : (v23 < v24)%Q), (v23 + v25 < v24 + v25)%Q := fun v23 v24 v25 : @Q => match Qplus_lt_l v23 v24 v25 as v26 in (_ /\ _) return (forall v27 : (v23 < v24)%Q, (v23 + v25 < v24 + v25)%Q) with | conj v26 v27 => (fun (v26 : forall v26 : (v23 + v25 < v24 + v25)%Q, (v23 < v24)%Q) (v27 : forall v27 : (v23 < v24)%Q, (v23 + v25 < v24 + v25)%Q) => v27) v26 v27 end in v23 (- (2 # v18))%Q (-1 # v18)%Q (- v7 (S v22 + BinPosDef.Pos.to_nat v18)%nat)%Q (let v24 : forall (v24 v25 v26 : @Z) (v27 : (0 < v24)%Z) (v28 : (v25 < v26)%Z), (v25 * v24 < v26 * v24)%Z := fun (v24 v25 v26 : @Z) (v27 : (0 < v24)%Z) => match Z.mul_lt_mono_pos_r v24 v25 v26 v27 as v28 in (_ /\ _) return (forall v29 : (v25 < v26)%Z, (v25 * v24 < v26 * v24)%Z) with | conj v28 v29 => (fun (v28 : forall v28 : (v25 < v26)%Z, (v25 * v24 < v26 * v24)%Z) (v29 : forall v29 : (v25 * v24 < v26 * v24)%Z, (v25 < v26)%Z) => v28) v28 v29 end in v24 (QDen (- (2 # v18))) (Qnum (- (2 # v18))) (Qnum (-1 # v18)) (Pos2Z.is_pos v18 : (0 < QDen (- (2 # v18)))%Z) eq_refl))) v22 end) : (proj1_sig (snd (v18, exist (fun v21 : forall v21 : @nat, @Q => QCauchySeq v21 (@BinPosDef.Pos.to_nat)) (fun v21 : @nat => v7 (v21 + BinPosDef.Pos.to_nat v18)%nat) (v11 (BinPosDef.Pos.to_nat v18)))) v20 < -1 # fst (v18, exist (fun v21 : forall v21 : @nat, @Q => QCauchySeq v21 (@BinPosDef.Pos.to_nat)) (fun v21 : @nat => v7 (v21 + BinPosDef.Pos.to_nat v18)%nat) (v11 (BinPosDef.Pos.to_nat v18))))%Q))) v15 v16 end v13) v7 v8 end v6 v2 v3 v4) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CRealPosShift	100	0.838855	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @CReal) (v1 : inject_Q 0 < v0) => let v2 : forall (v2 : @positive) (v3 : (2 # v2 < proj1_sig v0 (BinPosDef.Pos.to_nat v2) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v2))%Q), match Qarchimedean (/ (proj1_sig v0 (BinPosDef.Pos.to_nat v2) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v2) - (2 # v2))) as v4 in (sig _) return Prop with | exist _ v4 v5 => (fun (v4 : @positive) (v5 : (/ (proj1_sig v0 (BinPosDef.Pos.to_nat v2) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v2) - (2 # v2)) < Z.pos v4 # 1)%Q) => forall (v6 : @positive) (v7 : (BinPosDef.Pos.max v2 (2 * v4) <= v6)%positive), (2 # BinPosDef.Pos.max v2 (2 * v4) < proj1_sig v0 (BinPosDef.Pos.to_nat v6) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v6))%Q) v4 v5 end := CRealLt_aboveSig (inject_Q 0) v0 in let v3 : forall v3 : @nat, QCauchySeq (fun v4 : @nat => proj1_sig v0 (v4 + v3)%nat) (@BinPosDef.Pos.to_nat) := CRealShiftReal v0 in let v4 : forall v4 : @nat, v0 == exist (fun v5 : forall v5 : @nat, @Q => QCauchySeq v5 (@BinPosDef.Pos.to_nat)) (fun v5 : @nat => proj1_sig v0 (v5 + v4)%nat) (CRealShiftReal v0 v4) := CRealShiftEqual v0 in match v1 as v5 in (sig _) return {v6 : @positive * @CReal | v0 == snd v6 /\ (forall v7 : @nat, (1 # fst v6 < proj1_sig (snd v6) v7)%Q)} with | exist _ v5 v6 => (fun (v5 : @positive) (v6 : (2 # v5 < proj1_sig v0 (BinPosDef.Pos.to_nat v5) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5))%Q) => match v0 as v7 in (sig _) return (forall (v8 : (2 # v5 < proj1_sig v7 (BinPosDef.Pos.to_nat v5) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5))%Q) (v9 : forall (v9 : @positive) (v10 : (2 # v9 < proj1_sig v7 (BinPosDef.Pos.to_nat v9) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v9))%Q), match Qarchimedean (/ (proj1_sig v7 (BinPosDef.Pos.to_nat v9) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v9) - (2 # v9))) as v11 in (sig _) return Prop with | exist _ v11 v12 => (fun (v11 : @positive) (v12 : (/ (proj1_sig v7 (BinPosDef.Pos.to_nat v9) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v9) - (2 # v9)) < Z.pos v11 # 1)%Q) => forall (v13 : @positive) (v14 : (BinPosDef.Pos.max v9 (2 * v11) <= v13)%positive), (2 # BinPosDef.Pos.max v9 (2 * v11) < proj1_sig v7 (BinPosDef.Pos.to_nat v13) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v13))%Q) v11 v12 end) (v10 : forall v10 : @nat, QCauchySeq (fun v11 : @nat => proj1_sig v7 (v11 + v10)%nat) (@BinPosDef.Pos.to_nat)) (v11 : forall v11 : @nat, v7 == exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => proj1_sig v7 (v12 + v11)%nat) (CRealShiftReal v7 v11)), {v12 : @positive * @CReal | v7 == snd v12 /\ (forall v13 : @nat, (1 # fst v12 < proj1_sig (snd v12) v13)%Q)}) with | exist _ v7 v8 => (fun (v7 : forall v7 : @nat, @Q) (v8 : QCauchySeq v7 (@BinPosDef.Pos.to_nat)) (v9 : (2 # v5 < proj1_sig (exist (fun v9 : forall v9 : @nat, @Q => QCauchySeq v9 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v5) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v5))%Q) (v10 : forall (v10 : @positive) (v11 : (2 # v10 < proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v10) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v10))%Q), match Qarchimedean (/ (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v10) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v10) - (2 # v10))) as v12 in (sig _) return Prop with | exist _ v12 v13 => (fun (v12 : @positive) (v13 : (/ (proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v10) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v10) - (2 # v10)) < Z.pos v12 # 1)%Q) => forall (v14 : @positive) (v15 : (BinPosDef.Pos.max v10 (2 * v12) <= v14)%positive), (2 # BinPosDef.Pos.max v10 (2 * v12) < proj1_sig (exist (fun v16 : forall v16 : @nat, @Q => QCauchySeq v16 (@BinPosDef.Pos.to_nat)) v7 v8) (BinPosDef.Pos.to_nat v14) - proj1_sig (inject_Q 0) (BinPosDef.Pos.to_nat v14))%Q) v12 v13 end) (v11 : forall v11 : @nat, QCauchySeq (fun v12 : @nat => proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8) (v12 + v11)%nat) (@BinPosDef.Pos.to_nat)) (v12 : forall v12 : @nat, exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8 == exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) (fun v13 : @nat => proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v7 v8) (v13 + v12)%nat) (CRealShiftReal (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v7 v8) v12)) => let v13 : forall v13 : (2 # v5 < v7 (BinPosDef.Pos.to_nat v5) - 0)%Q, match Qarchimedean (/ (v7 (BinPosDef.Pos.to_nat v5) - 0 - (2 # v5))) as v14 in (sig _) return Prop with | exist _ v14 v15 => (fun (v14 : @positive) (v15 : (/ (v7 (BinPosDef.Pos.to_nat v5) - 0 - (2 # v5)) < Z.pos v14 # 1)%Q) => forall (v16 : @positive) (v17 : (BinPosDef.Pos.max v5 v14~0 <= v16)%positive), (2 # BinPosDef.Pos.max v5 v14~0 < v7 (BinPosDef.Pos.to_nat v16) - 0)%Q) v14 v15 end := v10 v5 in let v14 : {v14 : @positive | (/ (v7 (BinPosDef.Pos.to_nat v5) - 0 - (2 # v5)) < Z.pos v14 # 1)%Q} := Qarchimedean (/ (v7 (BinPosDef.Pos.to_nat v5) - 0 - (2 # v5))) in match v14 as v15 in (sig _) return (forall v16 : forall v16 : (2 # v5 < v7 (BinPosDef.Pos.to_nat v5) - 0)%Q, match v15 as v17 in (sig _) return Prop with | exist _ v17 v18 => (fun (v17 : @positive) (v18 : (/ (v7 (BinPosDef.Pos.to_nat v5) - 0 - (2 # v5)) < Z.pos v17 # 1)%Q) => forall (v19 : @positive) (v20 : (BinPosDef.Pos.max v5 v17~0 <= v19)%positive), (2 # BinPosDef.Pos.max v5 v17~0 < v7 (BinPosDef.Pos.to_nat v19) - 0)%Q) v17 v18 end, {v17 : @positive * @CReal | exist (fun v18 : forall v18 : @nat, @Q => QCauchySeq v18 (@BinPosDef.Pos.to_nat)) v7 v8 == snd v17 /\ (forall v18 : @nat, (1 # fst v17 < proj1_sig (snd v17) v18)%Q)}) with | exist _ v15 v16 => (fun (v15 : @positive) (v16 : (/ (v7 (BinPosDef.Pos.to_nat v5) - 0 - (2 # v5)) < Z.pos v15 # 1)%Q) (v17 : forall (v17 : (2 # v5 < v7 (BinPosDef.Pos.to_nat v5) - 0)%Q) (v18 : @positive) (v19 : (BinPosDef.Pos.max v5 v15~0 <= v18)%positive), (2 # BinPosDef.Pos.max v5 v15~0 < v7 (BinPosDef.Pos.to_nat v18) - 0)%Q) => let v18 : forall (v18 : @positive) (v19 : (BinPosDef.Pos.max v5 v15~0 <= v18)%positive), (2 # BinPosDef.Pos.max v5 v15~0 < v7 (BinPosDef.Pos.to_nat v18) - 0)%Q := v17 v9 in let v19 : @positive := BinPosDef.Pos.max v5 v15~0 in let v20 : v19 = BinPosDef.Pos.max v5 v15~0 := eq_refl in exist (fun v21 : @positive * @CReal => exist (fun v22 : forall v22 : @nat, @Q => QCauchySeq v22 (@BinPosDef.Pos.to_nat)) v7 v8 == snd v21 /\ (forall v22 : @nat, (1 # fst v21 < proj1_sig (snd v21) v22)%Q)) (v19, exist (fun v21 : forall v21 : @nat, @Q => QCauchySeq v21 (@BinPosDef.Pos.to_nat)) (fun v21 : @nat => v7 (v21 + BinPosDef.Pos.to_nat v19)%nat) (v11 (BinPosDef.Pos.to_nat v19))) (conj (v12 (BinPosDef.Pos.to_nat v19)) (fun v21 : @nat => (let v22 : forall (v22 v23 : @Q) (v24 : (0 < v23 + - v22)%Q), (v22 < v23)%Q := fun v22 v23 : @Q => match Qlt_minus_iff v22 v23 as v24 in (_ /\ _) return (forall v25 : (0 < v23 + - v22)%Q, (v22 < v23)%Q) with | conj v24 v25 => (fun (v24 : forall v24 : (v22 < v23)%Q, (0 < v23 + - v22)%Q) (v25 : forall v25 : (0 < v23 + - v22)%Q, (v22 < v23)%Q) => v25) v24 v25 end in v22 (1 # v19)%Q (v7 (v21 + BinPosDef.Pos.to_nat v19)%nat) match v21 as v23 in nat return (0 < v7 (v23 + BinPosDef.Pos.to_nat v19)%nat + - (1 # v19))%Q with | 0%nat => let v23 : forall v23 : (v19 <= v19)%positive, (2 # v19 < v7 (BinPosDef.Pos.to_nat v19) - 0)%Q := v18 v19 in (fun v24 : (1 # v19 < v7 (BinPosDef.Pos.to_nat v19))%Q <-> (0 < v7 (BinPosDef.Pos.to_nat v19) + - (1 # v19))%Q => iff_flip_impl_subrelation (0 < v7 (BinPosDef.Pos.to_nat v19) + - (1 # v19))%Q (1 # v19 < v7 (BinPosDef.Pos.to_nat v19))%Q (symmetry v24)) (Qlt_minus_iff (1 # v19) (v7 (BinPosDef.Pos.to_nat v19))) (Qlt_trans (1 # v19) (2 # v19) (v7 (BinPosDef.Pos.to_nat v19)) (let v24 : forall (v24 v25 v26 : @Z) (v27 : (0 < v24)%Z) (v28 : (v25 < v26)%Z), (v25 * v24 < v26 * v24)%Z := fun (v24 v25 v26 : @Z) (v27 : (0 < v24)%Z) => match Z.mul_lt_mono_pos_r v24 v25 v26 v27 as v28 in (_ /\ _) return (forall v29 : (v25 < v26)%Z, (v25 * v24 < v26 * v24)%Z) with | conj v28 v29 => (fun (v28 : forall v28 : (v25 < v26)%Z, (v25 * v24 < v26 * v24)%Z) (v29 : forall v29 : (v25 * v24 < v26 * v24)%Z, (v25 < v26)%Z) => v28) v28 v29 end in v24 (QDen (1 # v19)) (Qnum (1 # v19)) (Qnum (2 # v19)) (Pos2Z.is_pos v19 : (0 < QDen (1 # v19))%Z) eq_refl) ((fun v24 : (v7 (BinPosDef.Pos.to_nat v19) + 0 == v7 (BinPosDef.Pos.to_nat v19))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v19 <= v19)%positive) (2 # v19 < v7 (BinPosDef.Pos.to_nat v19) + - 0)%Q (2 # v19 < v7 (BinPosDef.Pos.to_nat v19))%Q (Reflexive_partial_app_morphism (@Qlt_compat) (reflexive_proper_proxy Equivalence_Reflexive (2 # v19)%Q) (v7 (BinPosDef.Pos.to_nat v19) + - 0)%Q (v7 (BinPosDef.Pos.to_nat v19)) v24)) (Qplus_0_r (v7 (BinPosDef.Pos.to_nat v19))) v23 (Pos.le_refl v19))) : (0 < v7 (0 + BinPosDef.Pos.to_nat v19)%nat + - (1 # v19))%Q | S v23 => (fun v23 : @nat => (fun v24 : (1 # v19 < v7 (S v23 + BinPosDef.Pos.to_nat v19)%nat)%Q <-> (0 < v7 (S v23 + BinPosDef.Pos.to_nat v19)%nat + - (1 # v19))%Q => iff_flip_impl_subrelation (0 < v7 (S v23 + BinPosDef.Pos.to_nat v19)%nat + - (1 # v19))%Q (1 # v19 < v7 (S v23 + BinPosDef.Pos.to_nat v19)%nat)%Q (symmetry v24)) (Qlt_minus_iff (1 # v19) (v7 (S v23 + BinPosDef.Pos.to_nat v19)%nat)) (Qlt_trans (1 # v19) (2 # v19) (v7 (S v23 + BinPosDef.Pos.to_nat v19)%nat) (let v24 : forall (v24 v25 v26 : @Z) (v27 : (0 < v24)%Z) (v28 : (v25 < v26)%Z), (v25 * v24 < v26 * v24)%Z := fun (v24 v25 v26 : @Z) (v27 : (0 < v24)%Z) => match Z.mul_lt_mono_pos_r v24 v25 v26 v27 as v28 in (_ /\ _) return (forall v29 : (v25 < v26)%Z, (v25 * v24 < v26 * v24)%Z) with | conj v28 v29 => (fun (v28 : forall v28 : (v25 < v26)%Z, (v25 * v24 < v26 * v24)%Z) (v29 : forall v29 : (v25 * v24 < v26 * v24)%Z, (v25 < v26)%Z) => v28) v28 v29 end in v24 (QDen (1 # v19)) (Qnum (1 # v19)) (Qnum (2 # v19)) (Pos2Z.is_pos v19 : (0 < QDen (1 # v19))%Z) eq_refl) (let v24 : forall v24 : (v19 <= BinPosDef.Pos.of_nat (S v23) + v19)%positive, (2 # v19 < v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)) - 0)%Q := v18 (BinPosDef.Pos.of_nat (S v23) + v19)%positive in let v25 : forall v25 : (v19 <= BinPosDef.Pos.of_nat (S v23) + v19)%positive, (2 # v19 < v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23)) + BinPosDef.Pos.to_nat v19)%nat)%Q := eq_ind (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)) (fun v25 : @nat => forall v26 : (v19 <= BinPosDef.Pos.of_nat (S v23) + v19)%positive, (2 # v19 < v7 v25)%Q) ((fun v25 : (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)) + 0 == v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)))%Q => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v19 <= BinPosDef.Pos.of_nat (S v23) + v19)%positive) (2 # v19 < v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)) + - 0)%Q (2 # v19 < v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)))%Q (Reflexive_partial_app_morphism (@Qlt_compat) (reflexive_proper_proxy Equivalence_Reflexive (2 # v19)%Q) (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)) + - 0)%Q (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19))) v25)) (Qplus_0_r (v7 (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19)))) v24) (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23)) + BinPosDef.Pos.to_nat v19)%nat (Pos2Nat.inj_add (BinPosDef.Pos.of_nat (S v23)) v19) in let v26 : forall v26 : (v19 <= BinPosDef.Pos.of_nat (S v23) + v19)%positive, (2 # v19 < v7 (S v23 + BinPosDef.Pos.to_nat v19)%nat)%Q := eq_ind (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23))) (fun v26 : @nat => forall v27 : (v19 <= BinPosDef.Pos.of_nat (S v23) + v19)%positive, (2 # v19 < v7 (v26 + BinPosDef.Pos.to_nat v19)%nat)%Q) v25 (S v23) (Nat2Pos.id (S v23) ((fun v26 : S v23 = 0%nat => let v27 : @False := eq_ind (S v23) (fun v27 : @nat => match v27 as v28 in nat return Prop with | 0%nat => @False | S v28 => (fun v28 : @nat => @True) v28 end) (@I) 0%nat v26 in False_ind (@False) v27) : S v23 <> 0%nat)) in v26 (let v27 : forall (v27 v28 : @positive) (v29 : (BinPosDef.Pos.to_nat v27 <= BinPosDef.Pos.to_nat v28)%nat), (v27 <= v28)%positive := fun v27 v28 : @positive => match Pos2Nat.inj_le v27 v28 as v29 in (_ /\ _) return (forall v30 : (BinPosDef.Pos.to_nat v27 <= BinPosDef.Pos.to_nat v28)%nat, (v27 <= v28)%positive) with | conj v29 v30 => (fun (v29 : forall v29 : (v27 <= v28)%positive, (BinPosDef.Pos.to_nat v27 <= BinPosDef.Pos.to_nat v28)%nat) (v30 : forall v30 : (BinPosDef.Pos.to_nat v27 <= BinPosDef.Pos.to_nat v28)%nat, (v27 <= v28)%positive) => v30) v29 v30 end in v27 v19 (BinPosDef.Pos.of_nat (S v23) + v19)%positive (eq_ind (0 + BinPosDef.Pos.to_nat v19)%nat (fun v28 : @nat => (v28 <= BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23) + v19))%nat) (eq_ind_r (fun v28 : @nat => (0 + BinPosDef.Pos.to_nat v19 <= v28)%nat) (let v28 : forall (v28 v29 v30 : @nat) (v31 : (v28 <= v29)%nat), (v28 + v30 <= v29 + v30)%nat := fun v28 v29 v30 : @nat => match Nat.add_le_mono_r v28 v29 v30 as v31 in (_ /\ _) return (forall v32 : (v28 <= v29)%nat, (v28 + v30 <= v29 + v30)%nat) with | conj v31 v32 => (fun (v31 : forall v31 : (v28 <= v29)%nat, (v28 + v30 <= v29 + v30)%nat) (v32 : forall v32 : (v28 + v30 <= v29 + v30)%nat, (v28 <= v29)%nat) => v31) v31 v32 end in v28 0%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23))) (BinPosDef.Pos.to_nat v19) (Nat.le_0_l (BinPosDef.Pos.to_nat (BinPosDef.Pos.of_nat (S v23))))) (Pos2Nat.inj_add (BinPosDef.Pos.of_nat (S v23)) v19)) (BinPosDef.Pos.to_nat v19) (Nat.add_0_l (BinPosDef.Pos.to_nat v19))))))) v23 end) : (1 # fst (v19, exist (fun v22 : forall v22 : @nat, @Q => QCauchySeq v22 (@BinPosDef.Pos.to_nat)) (fun v22 : @nat => v7 (v22 + BinPosDef.Pos.to_nat v19)%nat) (v11 (BinPosDef.Pos.to_nat v19))) < proj1_sig (snd (v19, exist (fun v22 : forall v22 : @nat, @Q => QCauchySeq v22 (@BinPosDef.Pos.to_nat)) (fun v22 : @nat => v7 (v22 + BinPosDef.Pos.to_nat v19)%nat) (v11 (BinPosDef.Pos.to_nat v19)))) v21)%Q))) v15 v16 end v13) v7 v8 end v6 v2 v3 v4) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv_neg	100	3.291506	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv_pos	100	2.258275	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv	100	0.325808	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @CReal) (v1 : v0 # inject_Q 0) => match v1 as v2 in (_ + _)%type return (@CReal) with | inl v2 => (fun v2 : v0 < inject_Q 0 => let v3 : {v3 : @positive * @CReal | v0 == snd v3 /\ (forall v4 : @nat, (proj1_sig (snd v3) v4 < -1 # fst v3)%Q)} := CRealNegShift v0 v2 in match v3 as v4 in (sig _) return (@CReal) with | exist _ v4 v5 => (fun (v4 : @positive * @CReal) (v5 : v0 == snd v4 /\ (forall v5 : @nat, (proj1_sig (snd v4) v5 < -1 # fst v4)%Q)) => match v4 as v6 in (_ * _)%type return (forall v7 : v0 == snd v6 /\ (forall v7 : @nat, (proj1_sig (snd v6) v7 < -1 # fst v6)%Q), @CReal) with | (v6, v7) => (fun (v6 : @positive) (v7 : @CReal) (v8 : v0 == snd (v6, v7) /\ (forall v8 : @nat, (proj1_sig (snd (v6, v7)) v8 < -1 # fst (v6, v7))%Q)) => match v8 as v9 in (_ /\ _) return (@CReal) with | conj v9 v10 => (fun (v9 : v0 == snd (v6, v7)) (v10 : forall v10 : @nat, (proj1_sig (snd (v6, v7)) v10 < -1 # fst (v6, v7))%Q) => match v7 as v11 in (sig _) return (forall v12 : forall v12 : @nat, (proj1_sig (snd (v6, v11)) v12 < -1 # fst (v6, v11))%Q, @CReal) with | exist _ v11 v12 => (fun (v11 : forall v11 : @nat, @Q) (v12 : QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (v13 : forall v13 : @nat, (proj1_sig (snd (v6, exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v11 v12)) v13 < -1 # fst (v6, exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v11 v12))%Q) => exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) (fun v14 : @nat => / v11 (BinPosDef.Pos.to_nat v6 ^ 2 * v14)%nat) (CReal_inv_neg v11 v6 v12 v13)) v11 v12 end v10) v9 v10 end) v6 v7 end v5) v4 v5 end) v2 | inr v2 => (fun v2 : inject_Q 0 < v0 => let v3 : {v3 : @positive * @CReal | v0 == snd v3 /\ (forall v4 : @nat, (1 # fst v3 < proj1_sig (snd v3) v4)%Q)} := CRealPosShift v0 v2 in match v3 as v4 in (sig _) return (@CReal) with | exist _ v4 v5 => (fun (v4 : @positive * @CReal) (v5 : v0 == snd v4 /\ (forall v5 : @nat, (1 # fst v4 < proj1_sig (snd v4) v5)%Q)) => match v4 as v6 in (_ * _)%type return (forall v7 : v0 == snd v6 /\ (forall v7 : @nat, (1 # fst v6 < proj1_sig (snd v6) v7)%Q), @CReal) with | (v6, v7) => (fun (v6 : @positive) (v7 : @CReal) (v8 : v0 == snd (v6, v7) /\ (forall v8 : @nat, (1 # fst (v6, v7) < proj1_sig (snd (v6, v7)) v8)%Q)) => match v8 as v9 in (_ /\ _) return (@CReal) with | conj v9 v10 => (fun (v9 : v0 == snd (v6, v7)) (v10 : forall v10 : @nat, (1 # fst (v6, v7) < proj1_sig (snd (v6, v7)) v10)%Q) => match v7 as v11 in (sig _) return (forall v12 : forall v12 : @nat, (1 # fst (v6, v11) < proj1_sig (snd (v6, v11)) v12)%Q, @CReal) with | exist _ v11 v12 => (fun (v11 : forall v11 : @nat, @Q) (v12 : QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (v13 : forall v13 : @nat, (1 # fst (v6, exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v11 v12) < proj1_sig (snd (v6, exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v11 v12)) v13)%Q) => exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) (fun v14 : @nat => / v11 (BinPosDef.Pos.to_nat v6 ^ 2 * v14)%nat) (CReal_inv_pos v11 v6 v12 v13)) v11 v12 end v10) v9 v10 end) v6 v7 end v5) v4 v5 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv_0_lt_compat	100	2.231672	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_linear_shift	100	0.112177	1	1	0	synth with cache (only 1: refine (fun v0 : @CReal => match v0 as v1 in (sig _) return (forall (v2 : @nat) (v3 : (1 <= v2)%nat), QCauchySeq (fun v4 : @nat => proj1_sig v1 (v2 * v4)%nat) (@BinPosDef.Pos.to_nat)) with | exist _ v1 v2 => (fun (v1 : forall v1 : @nat, @Q) (v2 : QCauchySeq v1 (@BinPosDef.Pos.to_nat)) (v3 : @nat) (v4 : (1 <= v3)%nat) => (fun (v5 : @positive) (v6 v7 : @nat) (v8 : (BinPosDef.Pos.to_nat v5 <= v6)%nat) (v9 : (BinPosDef.Pos.to_nat v5 <= v7)%nat) => v2 v5 (v3 * v6)%nat (v3 * v7)%nat (Nat.le_trans (BinPosDef.Pos.to_nat v5) v6 (v3 * v6) v8 (eq_ind (1 * v6)%nat (fun v10 : @nat => (v10 <= v3 * v10)%nat) (eq_ind_r (fun v10 : @nat => (1 * v6 <= v10)%nat) (Nat.mul_le_mono_nonneg_r 1 (v3 * 1) v6 (Nat.le_0_l v6) (eq_ind_r (fun v10 : @nat => (1 <= v10)%nat) v4 (Nat.mul_1_r v3))) (Nat.mul_assoc v3 1 v6)) v6 (Nat.mul_1_l v6))) (Nat.le_trans (BinPosDef.Pos.to_nat v5) v7 (v3 * v7) v9 (eq_ind (1 * v7)%nat (fun v10 : @nat => (v10 <= v3 * v10)%nat) (eq_ind_r (fun v10 : @nat => (1 * v7 <= v10)%nat) (Nat.mul_le_mono_nonneg_r 1 (v3 * 1) v7 (Nat.le_0_l v7) (eq_ind_r (fun v10 : @nat => (1 <= v10)%nat) v4 (Nat.mul_1_r v3))) (Nat.mul_assoc v3 1 v7)) v7 (Nat.mul_1_l v7))) : (Qabs (proj1_sig (exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) v1 v2) (v3 * v6)%nat - proj1_sig (exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) v1 v2) (v3 * v7)%nat) < 1 # v5)%Q) : QCauchySeq (fun v5 : @nat => proj1_sig (exist (fun v6 : forall v6 : @nat, @Q => QCauchySeq v6 (@BinPosDef.Pos.to_nat)) v1 v2) (v3 * v5)%nat) (@BinPosDef.Pos.to_nat)) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_linear_shift_eq	100	0.297283	1	1	0	synth with cache (only 1: refine (fun (v0 : @CReal) (v1 : @nat) (v2 : (1 <= v1)%nat) => let v3 : forall (v3 v4 : @CReal) (v5 : forall v5 : @positive, (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v5) - proj1_sig v4 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q), v3 == v4 := fun v3 v4 : @CReal => match CRealEq_diff v3 v4 as v5 in (_ /\ _) return (forall v6 : forall v6 : @positive, (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q, v3 == v4) with | conj v5 v6 => (fun (v5 : forall (v5 : v3 == v4) (v6 : @positive), (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q) (v6 : forall v6 : forall v6 : @positive, (Qabs (proj1_sig v3 (BinPosDef.Pos.to_nat v6) - proj1_sig v4 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q, v3 == v4) => v6) v5 v6 end in v3 v0 (exist (fun v4 : forall v4 : @nat, @Q => QCauchySeq v4 (@BinPosDef.Pos.to_nat)) (fun v4 : @nat => proj1_sig v0 (v1 * v4)%nat) (CReal_linear_shift v0 v1 v2)) (fun v4 : @positive => match v0 as v5 in (sig _) return (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v4) - proj1_sig (exist (fun v6 : forall v6 : @nat, @Q => QCauchySeq v6 (@BinPosDef.Pos.to_nat)) (fun v6 : @nat => proj1_sig v5 (v1 * v6)%nat) (CReal_linear_shift v5 v1 v2)) (BinPosDef.Pos.to_nat v4)) <= 2 # v4)%Q with | exist _ v5 v6 => (fun (v5 : forall v5 : @nat, @Q) (v6 : QCauchySeq v5 (@BinPosDef.Pos.to_nat)) => (let v7 : forall (v7 : (BinPosDef.Pos.to_nat v4 <= BinPosDef.Pos.to_nat v4)%nat) (v8 : (BinPosDef.Pos.to_nat v4 <= v1 * BinPosDef.Pos.to_nat v4)%nat), (Qabs (v5 (BinPosDef.Pos.to_nat v4) - v5 (v1 * BinPosDef.Pos.to_nat v4)%nat) < 1 # v4)%Q := v6 v4 (BinPosDef.Pos.to_nat v4) (v1 * BinPosDef.Pos.to_nat v4)%nat in Qle_trans (Qabs (v5 (BinPosDef.Pos.to_nat v4) - v5 (v1 * BinPosDef.Pos.to_nat v4)%nat)) (1 # v4) (2 # v4) (Qlt_le_weak (Qabs (v5 (BinPosDef.Pos.to_nat v4) - v5 (v1 * BinPosDef.Pos.to_nat v4)%nat)) (1 # v4) (v7 (Nat.le_refl (BinPosDef.Pos.to_nat v4)) (eq_ind (1 * BinPosDef.Pos.to_nat v4)%nat (fun v8 : @nat => (v8 <= v1 * v8)%nat) (eq_ind_r (fun v8 : @nat => (1 * BinPosDef.Pos.to_nat v4 <= v8)%nat) (Nat.mul_le_mono_nonneg_r 1 (v1 * 1) (BinPosDef.Pos.to_nat v4) (Nat.le_0_l (BinPosDef.Pos.to_nat v4)) (eq_ind_r (fun v8 : @nat => (1 <= v8)%nat) v2 (Nat.mul_1_r v1))) (Nat.mul_assoc v1 1 (BinPosDef.Pos.to_nat v4))) (BinPosDef.Pos.to_nat v4) (Nat.mul_1_l (BinPosDef.Pos.to_nat v4))))) (Z.mul_le_mono_nonneg_r (Qnum (1 # v4)) (Qnum (2 # v4)) (QDen (1 # v4)) ((fun v8 : (0 ?= QDen (1 # v4))%Z = @Gt => let v9 : @False := eq_ind (0 ?= QDen (1 # v4))%Z (fun v9 : @comparison => match v9 as v10 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v8 in False_ind (@False) v9) : (0 <= QDen (1 # v4))%Z) ((fun v8 : (Qnum (1 # v4) ?= Qnum (2 # v4))%Z = @Gt => let v9 : @False := eq_ind (Qnum (1 # v4) ?= Qnum (2 # v4))%Z (fun v9 : @comparison => match v9 as v10 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v8 in False_ind (@False) v9) : (Qnum (1 # v4) <= Qnum (2 # v4))%Z))) : (Qabs (proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v5 v6) (BinPosDef.Pos.to_nat v4) - proj1_sig (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) (fun v7 : @nat => proj1_sig (exist (fun v8 : forall v8 : @nat, @Q => QCauchySeq v8 (@BinPosDef.Pos.to_nat)) v5 v6) (v1 * v7)%nat) (CReal_linear_shift (exist (fun v7 : forall v7 : @nat, @Q => QCauchySeq v7 (@BinPosDef.Pos.to_nat)) v5 v6) v1 v2)) (BinPosDef.Pos.to_nat v4)) <= 2 # v4)%Q) v5 v6 end))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv_l	100	4.550722	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv_r	100	0.074618	1	1	0	synth with cache (only 1: refine (fun (v0 : @CReal) (v1 : v0 # inject_Q 0) => (fun v2 : v0 * (/ v0) v1 == (/ v0) v1 * v0 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v0 * (/ v0) v1) ((/ v0) v1 * v0) v2 (inject_Q 1) (inject_Q 1) (eq_proper_proxy (inject_Q 1))) (CReal_mult_comm v0 ((/ v0) v1)) ((fun v2 : (/ v0) v1 * v0 == inject_Q 1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) ((/ v0) v1 * v0) (inject_Q 1) v2 (inject_Q 1) (inject_Q 1) (eq_proper_proxy (inject_Q 1))) (CReal_inv_l v0 v1) (reflexivity (inject_Q 1))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv_1	100	0.101124	1	1	0	synth with cache (only 1: refine (fun v0 : inject_Q 1 # inject_Q 0 => (fun v1 : inject_Q 1 * (/ inject_Q 1) v0 == (/ inject_Q 1) v0 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) ((/ inject_Q 1) v0) (inject_Q 1 * (/ inject_Q 1) v0) (symmetry v1) (inject_Q 1) (inject_Q 1) (eq_proper_proxy (inject_Q 1))) (CReal_mult_1_l ((/ inject_Q 1) v0)) ((fun v1 : inject_Q 1 * (/ inject_Q 1) v0 == inject_Q 1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (inject_Q 1 * (/ inject_Q 1) v0) (inject_Q 1) v1 (inject_Q 1) (inject_Q 1) (eq_proper_proxy (inject_Q 1))) (CReal_inv_r (inject_Q 1) v0) (reflexivity (inject_Q 1))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_inv_mult_distr	100	0.257127	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @CReal) (v2 : v0 # inject_Q 0) (v3 : v1 # inject_Q 0) (v4 : v0 * v1 # inject_Q 0) => CReal_mult_eq_reg_l v0 ((/ (v0 * v1)) v4) ((/ v0) v2 * (/ v1) v3) v2 ((fun v5 : v0 * (/ v0) v2 * (/ v1) v3 == v0 * ((/ v0) v2 * (/ v1) v3) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v0 * ((/ v0) v2 * (/ v1) v3)) (v0 * (/ v0) v2 * (/ v1) v3) (symmetry v5)) (CReal_mult_assoc v0 ((/ v0) v2) ((/ v1) v3)) ((fun v5 : v0 * (/ v0) v2 == inject_Q 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v0 * (/ v0) v2 * (/ v1) v3) (inject_Q 1 * (/ v1) v3) (CReal_mult_morph_Proper (v0 * (/ v0) v2) (inject_Q 1) v5 ((/ v1) v3) ((/ v1) v3) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) ((/ v1) v3)))) (CReal_inv_r v0 v2) ((fun v5 : inject_Q 1 * (/ v1) v3 == (/ v1) v3 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (inject_Q 1 * (/ v1) v3) ((/ v1) v3) v5) (CReal_mult_1_l ((/ v1) v3)) (CReal_mult_eq_reg_l v1 (v0 * (/ (v0 * v1)) v4) ((/ v1) v3) v3 ((fun v5 : v1 * (/ v1) v3 == inject_Q 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v1 * (/ v1) v3) (inject_Q 1) v5) (CReal_inv_r v1 v3) ((fun v5 : v1 * v0 * (/ (v0 * v1)) v4 == v1 * (v0 * (/ (v0 * v1)) v4) => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v1 * (v0 * (/ (v0 * v1)) v4)) (v1 * v0 * (/ (v0 * v1)) v4) (symmetry v5) (inject_Q 1) (inject_Q 1) (eq_proper_proxy (inject_Q 1))) (CReal_mult_assoc v1 v0 ((/ (v0 * v1)) v4)) ((fun v5 : v1 * v0 == v0 * v1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v1 * v0 * (/ (v0 * v1)) v4) (v0 * v1 * (/ (v0 * v1)) v4) (CReal_mult_morph_Proper (v1 * v0) (v0 * v1) v5 ((/ (v0 * v1)) v4) ((/ (v0 * v1)) v4) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) ((/ (v0 * v1)) v4))) (inject_Q 1) (inject_Q 1) (eq_proper_proxy (inject_Q 1))) (CReal_mult_comm v1 v0) ((fun v5 : v0 * v1 * (/ (v0 * v1)) v4 == inject_Q 1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v0 * v1 * (/ (v0 * v1)) v4) (inject_Q 1) v5 (inject_Q 1) (inject_Q 1) (eq_proper_proxy (inject_Q 1))) (CReal_inv_r (v0 * v1) v4) (reflexivity (inject_Q 1)))))))))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.Rinv_eq_compat	100	0.103784	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @CReal) (v2 : v0 # inject_Q 0) (v3 : v1 # inject_Q 0) (v4 : v0 == v1) => CReal_mult_eq_reg_l v0 ((/ v0) v2) ((/ v1) v3) v2 ((fun v5 : v0 * (/ v0) v2 == inject_Q 1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v0 * (/ v0) v2) (inject_Q 1) v5 (v0 * (/ v1) v3) (v0 * (/ v1) v3) (eq_proper_proxy (v0 * (/ v1) v3))) (CReal_inv_r v0 v2) ((fun v5 : v0 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v0 * (/ v1) v3) (v1 * (/ v1) v3) (CReal_mult_morph_Proper v0 v1 v5 ((/ v1) v3) ((/ v1) v3) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) ((/ v1) v3)))) v4 ((fun v5 : v1 * (/ v1) v3 == inject_Q 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v1 * (/ v1) v3) (inject_Q 1) v5) (CReal_inv_r v1 v3) (reflexivity (inject_Q 1))))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_lt_reg_l	100	0.405446	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_lt_reg_r	100	0.212376	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @CReal) (v3 : inject_Q 0 < v0) (v4 : v1 * v0 < v2 * v0) => CReal_mult_lt_reg_l v0 v1 v2 v3 ((fun v5 : v0 * v1 == v1 * v0 => CMorphisms.subrelation_proper (@CRealLt_morph) (@tt) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.flip2 (@CMorphisms.iffT_flip_arrow_subrelation)))) (v0 * v1) (v1 * v0) v5 (v0 * v2) (v0 * v2) (CMorphisms.reflexive_proper_proxy CRelationClasses.Equivalence_Reflexive (v0 * v2))) (CReal_mult_comm v0 v1) ((fun v5 : v0 * v2 == v2 * v0 => CMorphisms.Reflexive_partial_app_morphism (CMorphisms.subrelation_proper (@CRealLt_morph) (@tt) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.flip2 (@CMorphisms.iffT_flip_arrow_subrelation))))) (CMorphisms.reflexive_proper_proxy CRelationClasses.Equivalence_Reflexive (v1 * v0)) (v0 * v2) (v2 * v0) v5) (CReal_mult_comm v0 v2) v4)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_eq_reg_r	100	0.075213	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @CReal) (v3 : v1 * v0 == v2 * v0) (v4 : v0 # inject_Q 0) => CReal_mult_eq_reg_l v0 v1 v2 v4 ((fun v5 : v0 * v1 == v1 * v0 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v0 * v1) (v1 * v0) v5 (v0 * v2) (v0 * v2) (eq_proper_proxy (v0 * v2))) (CReal_mult_comm v0 v1) ((fun v5 : v0 * v2 == v2 * v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@CRealEq_rel)) (v0 * v2) (v2 * v0) v5) (CReal_mult_comm v0 v2) v3)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_eq_compat_l	100	0.872016	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @CReal) (v3 : v1 == v2) => let v4 : forall (v4 v5 : @CReal) (v6 : forall v6 : @positive, (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v6) - proj1_sig v5 (BinPosDef.Pos.to_nat v6)) <= 2 # v6)%Q), v4 == v5 := fun v4 v5 : @CReal => match CRealEq_diff v4 v5 as v6 in (_ /\ _) return (forall v7 : forall v7 : @positive, (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q, v4 == v5) with | conj v6 v7 => (fun (v6 : forall (v6 : v4 == v5) (v7 : @positive), (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q) (v7 : forall v7 : forall v7 : @positive, (Qabs (proj1_sig v4 (BinPosDef.Pos.to_nat v7) - proj1_sig v5 (BinPosDef.Pos.to_nat v7)) <= 2 # v7)%Q, v4 == v5) => v7) v6 v7 end in v4 (v0 * v1) (v0 * v2) (let v5 : forall (v5 v6 : @CReal) (v7 : QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) (v8 : @positive), (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v8) - proj1_sig v6 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q := fun v5 v6 : @CReal => match CRealEq_modindep v5 v6 as v7 in (_ /\ _) return (forall (v8 : QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) (v9 : @positive), (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v9) - proj1_sig v6 (BinPosDef.Pos.to_nat v9)) <= 2 # v9)%Q) with | conj v7 v8 => (fun (v7 : forall (v7 : QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) (v8 : @positive), (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v8) - proj1_sig v6 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q) (v8 : forall v8 : forall v8 : @positive, (Qabs (proj1_sig v5 (BinPosDef.Pos.to_nat v8) - proj1_sig v6 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q, QSeqEquivEx (proj1_sig v5) (proj1_sig v6)) => v7) v7 v8 end in v5 (v0 * v1) (v0 * v2) (QSeqEquivEx_trans (proj1_sig (v0 * v1)) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v1 v6)%Q) (proj1_sig (v0 * v2)) (CReal_mult_unfold v0 v1) (QSeqEquivEx_sym (proj1_sig (v0 * v2)) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v1 v6)%Q) (QSeqEquivEx_trans (proj1_sig (v0 * v2)) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v2 v6)%Q) (fun v6 : @nat => (proj1_sig v0 v6 * proj1_sig v1 v6)%Q) (CReal_mult_unfold v0 v2) match v0 as v6 in (sig _) return (QSeqEquivEx (fun v7 : @nat => (proj1_sig v6 v7 * proj1_sig v2 v7)%Q) (fun v7 : @nat => (proj1_sig v6 v7 * proj1_sig v1 v7)%Q)) with | exist _ v6 v7 => (fun (v6 : forall v6 : @nat, @Q) (v7 : QCauchySeq v6 (@BinPosDef.Pos.to_nat)) => match v1 as v8 in (sig _) return (forall v9 : QSeqEquivEx (proj1_sig v8) (proj1_sig v2), QSeqEquivEx (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v6 v7) v10 * proj1_sig v2 v10)%Q) (fun v10 : @nat => (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) v6 v7) v10 * proj1_sig v8 v10)%Q)) with | exist _ v8 v9 => (fun (v8 : forall v8 : @nat, @Q) (v9 : QCauchySeq v8 (@BinPosDef.Pos.to_nat)) (v10 : QSeqEquivEx (proj1_sig (exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig v2)) => match v2 as v11 in (sig _) return (forall v12 : QSeqEquivEx (proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig v11), QSeqEquivEx (fun v13 : @nat => (proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v6 v7) v13 * proj1_sig v11 v13)%Q) (fun v13 : @nat => (proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v6 v7) v13 * proj1_sig (exist (fun v14 : forall v14 : @nat, @Q => QCauchySeq v14 (@BinPosDef.Pos.to_nat)) v8 v9) v13)%Q)) with | exist _ v11 v12 => (fun (v11 : forall v11 : @nat, @Q) (v12 : QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (v13 : QSeqEquivEx (proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig (exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) v11 v12))) => match v13 as v14 in (ex _) return (QSeqEquivEx (fun v15 : @nat => (v6 v15 * v11 v15)%Q) (fun v15 : @nat => (v6 v15 * v8 v15)%Q)) with | ex_intro _ v14 v15 => (fun (v14 : forall v14 : @positive, @nat) (v15 : QSeqEquiv (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v8 v9)) (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v11 v12)) v14) => let v16 : {v16 : @positive | forall v17 : @nat, (Qabs (v6 v17) < Z.pos v16 # 1)%Q} := QCauchySeq_bounded v6 (@BinPosDef.Pos.to_nat) v7 in match v16 as v17 in (sig _) return (QSeqEquivEx (fun v18 : @nat => (v6 v18 * v11 v18)%Q) (fun v18 : @nat => (v6 v18 * v8 v18)%Q)) with | exist _ v17 v18 => (fun (v17 : @positive) (v18 : forall v18 : @nat, (Qabs (v6 v18) < Z.pos v17 # 1)%Q) => let v19 : {v19 : @positive | forall v20 : @nat, (Qabs (v11 v20) < Z.pos v19 # 1)%Q} := QCauchySeq_bounded v11 (@BinPosDef.Pos.to_nat) v12 in match v19 as v20 in (sig _) return (QSeqEquivEx (fun v21 : @nat => (v6 v21 * v11 v21)%Q) (fun v21 : @nat => (v6 v21 * v8 v21)%Q)) with | exist _ v20 v21 => (fun (v20 : @positive) (v21 : forall v21 : @nat, (Qabs (v11 v21) < Z.pos v20 # 1)%Q) => let v22 : QSeqEquiv (fun v22 : @nat => (v8 v22 * v6 v22)%Q) (fun v22 : @nat => (v11 v22 * v6 v22)%Q) (fun v22 : @positive => Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v22)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v22))) := CReal_mult_cauchy v8 v11 v6 v20 v17 v14 v15 v7 v21 v18 in QSeqEquivEx_sym (fun v23 : @nat => (v6 v23 * v8 v23)%Q) (fun v23 : @nat => (v6 v23 * v11 v23)%Q) (ex_intro (fun v23 : forall v23 : @positive, @nat => QSeqEquiv (fun v24 : @nat => (v6 v24 * v8 v24)%Q) (fun v24 : @nat => (v6 v24 * v11 v24)%Q) v23) (fun v23 : @positive => Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23))) ((fun (v23 : @positive) (v24 v25 : @nat) (v26 : (Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23)) <= v24)%nat) (v27 : (Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23)) <= v25)%nat) => let v28 : (Qabs ((fun v28 : @nat => v8 v28 * v6 v28) v24 - (fun v28 : @nat => v11 v28 * v6 v28) v25) < 1 # v23)%Q := v22 v23 v24 v25 v26 v27 in let v29 : default_relation (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q := (let v29 : list (Ring_polynom.PExpr (@Q) * Ring_polynom.PExpr (@Q)) := nil in let v30 : list (@Q) := (v6 v24 :: v8 v24 :: v6 v25 :: v11 v25 :: nil)%list in Qfield_ring_lemma1 (@ring_subst_niter) v30 v29 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 1) (Ring_polynom.PEX (@Q) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 3) (Ring_polynom.PEX (@Q) 4))) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 4) (Ring_polynom.PEX (@Q) 3))) (@I) (eq_refl : (let v31 : list (@Q * @Ring_polynom.Mon * Ring_polynom.Pol (@Q)) := Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v29 in Ring_polynom.Peq (@Qeq_bool) (Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v31 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 1) (Ring_polynom.PEX (@Q) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 3) (Ring_polynom.PEX (@Q) 4)))) (Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v31 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 4) (Ring_polynom.PEX (@Q) 3))))) = @true)) : default_relation (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q in ((fun v30 : (v6 v24 * v8 v24 - v6 v25 * v11 v25 == v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation))) (Qabs (v6 v24 * v8 v24 - v6 v25 * v11 v25)) (Qabs (v8 v24 * v6 v24 - v11 v25 * v6 v25)) (Qabs_wd_Proper (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q v30) (1 # v23)%Q (1 # v23)%Q (reflexive_proper_proxy Equivalence_Reflexive (1 # v23)%Q) v28) : forall v30 : default_relation (v6 v24 * v8 v24 - v6 v25 * v11 v25)%Q (v8 v24 * v6 v24 - v11 v25 * v6 v25)%Q, (Qabs (v6 v24 * v8 v24 - v6 v25 * v11 v25) < 1 # v23)%Q) v29) : QSeqEquiv (fun v23 : @nat => (v6 v23 * v8 v23)%Q) (fun v23 : @nat => (v6 v23 * v11 v23)%Q) (fun v23 : @positive => Init.Nat.max (v14 (2 * BinPosDef.Pos.max v20 v17 * v23)%positive) (BinPosDef.Pos.to_nat (2 * BinPosDef.Pos.max v20 v17 * v23)))))) v20 v21 end) v17 v18 end) v14 v15 end : QSeqEquivEx (fun v14 : @nat => (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v6 v7) v14 * proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v11 v12) v14)%Q) (fun v14 : @nat => (proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v6 v7) v14 * proj1_sig (exist (fun v15 : forall v15 : @nat, @Q => QCauchySeq v15 (@BinPosDef.Pos.to_nat)) v8 v9) v14)%Q)) v11 v12 end v10) v8 v9 end ((fun v8 : QSeqEquivEx (proj1_sig v1) (proj1_sig v2) <-> (forall v8 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v8) - proj1_sig v2 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q) => iff_impl_subrelation (forall v9 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v9) - proj1_sig v2 (BinPosDef.Pos.to_nat v9)) <= 2 # v9)%Q) (QSeqEquivEx (proj1_sig v1) (proj1_sig v2)) (symmetry v8)) (CRealEq_modindep v1 v2) ((fun v8 : v1 == v2 <-> (forall v8 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v8) - proj1_sig v2 (BinPosDef.Pos.to_nat v8)) <= 2 # v8)%Q) => iff_impl_subrelation (v1 == v2) (forall v9 : @positive, (Qabs (proj1_sig v1 (BinPosDef.Pos.to_nat v9) - proj1_sig v2 (BinPosDef.Pos.to_nat v9)) <= 2 # v9)%Q) v8) (CRealEq_diff v1 v2) v3))) v6 v7 end)))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_eq_compat_r	100	0.071963	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @CReal) (v3 : v1 == v2) => (fun v4 : v1 == v2 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (v1 * v0) (v2 * v0) (CReal_mult_morph_Proper v1 v2 v4 v0 v0 (reflexive_proper_proxy (@CRealEq_rel_Reflexive) v0)) (v2 * v0) (v2 * v0) (eq_proper_proxy (v2 * v0))) v3 (reflexivity (v2 * v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_pos_appart_zero	100	2.063171	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_mult_le_compat_l_half	100	0.068464	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @CReal) (v3 : inject_Q 0 < v0) (v4 : v1 <= v2) => (fun v5 : v0 * v2 < v0 * v1 => let v6 : v2 < v1 := CReal_mult_lt_reg_l v0 v2 v1 v3 v5 in False_ind (@False) (v4 v6)) : v0 * v1 <= v0 * v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CReal_invQ	100	1.127586	1	1	0	synth with cache (only 1: refine (fun (v0 : @positive) (v1 : (0 < Z.pos v0 # 1)%Q) => CReal_mult_eq_reg_l (inject_Q (Z.pos v0 # 1)) ((/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1))) (inject_Q (1 # v0)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1)) ((fun v2 : inject_Q (Z.pos v0 # 1) * (/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1)) == (/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1)) * inject_Q (Z.pos v0 # 1) => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) (inject_Q (Z.pos v0 # 1) * (/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1))) ((/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1)) * inject_Q (Z.pos v0 # 1)) v2 (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0)) (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0)) (eq_proper_proxy (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0)))) (CReal_mult_comm (inject_Q (Z.pos v0 # 1)) ((/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1)))) ((fun v2 : (/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1)) * inject_Q (Z.pos v0 # 1) == inject_Q 1 => trans_co_eq_inv_impl_morphism (@CRealEq_rel_Transitive) ((/ inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1)) * inject_Q (Z.pos v0 # 1)) (inject_Q 1) v2 (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0)) (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0)) (eq_proper_proxy (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0)))) (CReal_inv_l (inject_Q (Z.pos v0 # 1)) (inr (CReal_injectQPos (Z.pos v0 # 1) v1))) (let v2 : forall (v2 v3 : @CReal) (v4 : forall v4 : @positive, (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v4) - proj1_sig v3 (BinPosDef.Pos.to_nat v4)) <= 2 # v4)%Q), v2 == v3 := fun v2 v3 : @CReal => match CRealEq_diff v2 v3 as v4 in (_ /\ _) return (forall v5 : forall v5 : @positive, (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v5) - proj1_sig v3 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q, v2 == v3) with | conj v4 v5 => (fun (v4 : forall (v4 : v2 == v3) (v5 : @positive), (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v5) - proj1_sig v3 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q) (v5 : forall v5 : forall v5 : @positive, (Qabs (proj1_sig v2 (BinPosDef.Pos.to_nat v5) - proj1_sig v3 (BinPosDef.Pos.to_nat v5)) <= 2 # v5)%Q, v2 == v3) => v5) v4 v5 end in v2 (inject_Q 1) (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0)) (fun v3 : @positive => (let v4 : {v4 : @positive | forall v5 : @nat, (Qabs ((fun v6 : @nat => 1 # v0) v5) < Z.pos v4 # 1)%Q} := QCauchySeq_bounded (fun v4 : @nat => (1 # v0)%Q) (@BinPosDef.Pos.to_nat) (ConstCauchy (1 # v0)) in match v4 as v5 in (sig _) return (BinIntDef.Z.abs match (- Qnum (proj1_sig match QCauchySeq_bounded (fun v6 : @nat => Z.pos v0 # 1) (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) as v6 in (sig _) return (@CReal) with | exist _ v6 v7 => (fun (v6 : @positive) (v7 : forall v7 : @nat, (Z.pos v0 # 1 < Z.pos v6 # 1)%Q) => match v5 as v8 in (sig _) return (@CReal) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, (1 # v0 < Z.pos v8 # 1)%Q) => exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => ((Z.pos v0 # 1) * (1 # v0))%Q) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => 1 # v0) v6 v8 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v7 v9 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v12)%nat (linear_max v10 v6 v8 v11 v13) (linear_max v10 v6 v8 v12 v14))) v8 v9 end) v6 v7 end (BinPosDef.Pos.to_nat v3)) * 1)%Z as v6 in Z return (@Z) with | 0 => QDen (proj1_sig match QCauchySeq_bounded (fun v6 : @nat => Z.pos v0 # 1) (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) as v6 in (sig _) return (@CReal) with | exist _ v6 v7 => (fun (v6 : @positive) (v7 : forall v7 : @nat, Z.pos v0 # 1 < Z.pos v6 # 1) => match v5 as v8 in (sig _) return (@CReal) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, 1 # v0 < Z.pos v8 # 1) => exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => 1 # v0) v6 v8 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v7 v9 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v12)%nat (linear_max v10 v6 v8 v11 v13) (linear_max v10 v6 v8 v12 v14))) v8 v9 end) v6 v7 end (BinPosDef.Pos.to_nat v3)) | Z.pos v6 => (fun v6 : @positive => Z.pos (Qden (proj1_sig match QCauchySeq_bounded (fun v7 : @nat => Z.pos v0 # 1) (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) as v7 in (sig _) return (@CReal) with | exist _ v7 v8 => (fun (v7 : @positive) (v8 : forall v8 : @nat, Z.pos v0 # 1 < Z.pos v7 # 1) => match v5 as v9 in (sig _) return (@CReal) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, 1 # v0 < Z.pos v9 # 1) => exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => 1 # v0) v7 v9 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v8 v10 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v13)%nat (linear_max v11 v7 v9 v12 v14) (linear_max v11 v7 v9 v13 v15))) v9 v10 end) v7 v8 end (BinPosDef.Pos.to_nat v3)) + v6)) v6 | Z.neg v6 => (fun v6 : @positive => BinIntDef.Z.pos_sub (Qden (proj1_sig match QCauchySeq_bounded (fun v7 : @nat => Z.pos v0 # 1) (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) as v7 in (sig _) return (@CReal) with | exist _ v7 v8 => (fun (v7 : @positive) (v8 : forall v8 : @nat, Z.pos v0 # 1 < Z.pos v7 # 1) => match v5 as v9 in (sig _) return (@CReal) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, 1 # v0 < Z.pos v9 # 1) => exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => 1 # v0) v7 v9 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v8 v10 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v13)%nat (linear_max v11 v7 v9 v12 v14) (linear_max v11 v7 v9 v13 v15))) v9 v10 end) v7 v8 end (BinPosDef.Pos.to_nat v3))) v6) v6 end # Qden (proj1_sig match QCauchySeq_bounded (fun v6 : @nat => Z.pos v0 # 1) (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) as v6 in (sig _) return (@CReal) with | exist _ v6 v7 => (fun (v6 : @positive) (v7 : forall v7 : @nat, Z.pos v0 # 1 < Z.pos v6 # 1) => match v5 as v8 in (sig _) return (@CReal) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, 1 # v0 < Z.pos v8 # 1) => exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => 1 # v0) v6 v8 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v7 v9 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v12)%nat (linear_max v10 v6 v8 v11 v13) (linear_max v10 v6 v8 v12 v14))) v8 v9 end) v6 v7 end (BinPosDef.Pos.to_nat v3)) <= 2 # v3)%Q with | exist _ v5 v6 => (fun (v5 : @positive) (v6 : forall v6 : @nat, (Qabs (1 # v0) < Z.pos v5 # 1)%Q) => let v7 : {v7 : @positive | forall v8 : @nat, (Qabs ((fun v9 : @nat => Z.pos v0 # 1) v8) < Z.pos v7 # 1)%Q} := QCauchySeq_bounded (fun v7 : @nat => (Z.pos v0 # 1)%Q) (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) in match v7 as v8 in (sig _) return (BinIntDef.Z.abs match (- Qnum (proj1_sig match v8 as v9 in (sig _) return (@CReal) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, (Z.pos v0 # 1 < Z.pos v9 # 1)%Q) => exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => ((Z.pos v0 # 1) * (1 # v0))%Q) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => 1 # v0) v9 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v10 v6 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v5)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v5)~0 * v13)%nat (linear_max v11 v9 v5 v12 v14) (linear_max v11 v9 v5 v13 v15))) v9 v10 end (BinPosDef.Pos.to_nat v3)) * 1)%Z as v9 in Z return (@Z) with | 0 => QDen (proj1_sig match v8 as v9 in (sig _) return (@CReal) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, Z.pos v0 # 1 < Z.pos v9 # 1) => exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => 1 # v0) v9 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v10 v6 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v5)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v5)~0 * v13)%nat (linear_max v11 v9 v5 v12 v14) (linear_max v11 v9 v5 v13 v15))) v9 v10 end (BinPosDef.Pos.to_nat v3)) | Z.pos v9 => (fun v9 : @positive => Z.pos (Qden (proj1_sig match v8 as v10 in (sig _) return (@CReal) with | exist _ v10 v11 => (fun (v10 : @positive) (v11 : forall v11 : @nat, Z.pos v0 # 1 < Z.pos v10 # 1) => exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v12 : @positive) (v13 v14 : @nat) (v15 : (BinPosDef.Pos.to_nat v12 <= v13)%nat) (v16 : (BinPosDef.Pos.to_nat v12 <= v14)%nat) => CReal_mult_cauchy (fun v17 : @nat => Z.pos v0 # 1) (fun v17 : @nat => Z.pos v0 # 1) (fun v17 : @nat => 1 # v0) v10 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v11 v6 v12 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v5)~0 * v13)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v5)~0 * v14)%nat (linear_max v12 v10 v5 v13 v15) (linear_max v12 v10 v5 v14 v16))) v10 v11 end (BinPosDef.Pos.to_nat v3)) + v9)) v9 | Z.neg v9 => (fun v9 : @positive => BinIntDef.Z.pos_sub (Qden (proj1_sig match v8 as v10 in (sig _) return (@CReal) with | exist _ v10 v11 => (fun (v10 : @positive) (v11 : forall v11 : @nat, Z.pos v0 # 1 < Z.pos v10 # 1) => exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v12 : @positive) (v13 v14 : @nat) (v15 : (BinPosDef.Pos.to_nat v12 <= v13)%nat) (v16 : (BinPosDef.Pos.to_nat v12 <= v14)%nat) => CReal_mult_cauchy (fun v17 : @nat => Z.pos v0 # 1) (fun v17 : @nat => Z.pos v0 # 1) (fun v17 : @nat => 1 # v0) v10 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v11 v6 v12 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v5)~0 * v13)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v10 v5)~0 * v14)%nat (linear_max v12 v10 v5 v13 v15) (linear_max v12 v10 v5 v14 v16))) v10 v11 end (BinPosDef.Pos.to_nat v3))) v9) v9 end # Qden (proj1_sig match v8 as v9 in (sig _) return (@CReal) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, Z.pos v0 # 1 < Z.pos v9 # 1) => exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => 1 # v0) v9 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v10 v6 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v5)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v9 v5)~0 * v13)%nat (linear_max v11 v9 v5 v12 v14) (linear_max v11 v9 v5 v13 v15))) v9 v10 end (BinPosDef.Pos.to_nat v3)) <= 2 # v3)%Q with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, (Qabs (Z.pos v0 # 1) < Z.pos v8 # 1)%Q) => eq_ind_r (fun v10 : @positive => (BinIntDef.Z.abs (BinIntDef.Z.pos_sub v0 v10) # v0 <= 2 # v3)%Q) (eq_ind_r (fun v10 : @positive => (BinIntDef.Z.abs (BinIntDef.Z.pos_sub v0 v10) # v0 <= 2 # v3)%Q) (eq_ind_r (fun v10 : @Z => (BinIntDef.Z.abs v10 # v0 <= 2 # v3)%Q) ((fun v10 : (Qnum (BinIntDef.Z.abs 0 # v0) * QDen (2 # v3) ?= Qnum (2 # v3) * QDen (BinIntDef.Z.abs 0 # v0))%Z = @Gt => let v11 : @False := eq_ind (Qnum (BinIntDef.Z.abs 0 # v0) * QDen (2 # v3) ?= Qnum (2 # v3) * QDen (BinIntDef.Z.abs 0 # v0))%Z (fun v11 : @comparison => match v11 as v12 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v10 in False_ind (@False) v11) : (BinIntDef.Z.abs 0 # v0 <= 2 # v3)%Q) (Z.pos_sub_diag v0)) (Pos.mul_1_r v0)) (Pos.mul_1_r (v0 * 1)) : (BinIntDef.Z.abs match (- Qnum (proj1_sig (exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => ((Z.pos v0 # 1) * (1 # v0))%Q) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => 1 # v0) v8 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v9 v6 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v12)%nat (linear_max v10 v8 v5 v11 v13) (linear_max v10 v8 v5 v12 v14))) (BinPosDef.Pos.to_nat v3)) * 1)%Z as v10 in Z return (@Z) with | 0 => QDen (proj1_sig (exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => 1 # v0) v8 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v9 v6 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v12)%nat (linear_max v10 v8 v5 v11 v13) (linear_max v10 v8 v5 v12 v14))) (BinPosDef.Pos.to_nat v3)) | Z.pos v10 => (fun v10 : @positive => Z.pos (Qden (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => 1 # v0) v8 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v9 v6 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v13)%nat (linear_max v11 v8 v5 v12 v14) (linear_max v11 v8 v5 v13 v15))) (BinPosDef.Pos.to_nat v3)) + v10)) v10 | Z.neg v10 => (fun v10 : @positive => BinIntDef.Z.pos_sub (Qden (proj1_sig (exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => Z.pos v0 # 1) (fun v16 : @nat => 1 # v0) v8 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v9 v6 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v13)%nat (linear_max v11 v8 v5 v12 v14) (linear_max v11 v8 v5 v13 v15))) (BinPosDef.Pos.to_nat v3))) v10) v10 end # Qden (proj1_sig (exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => (Z.pos v0 # 1) * (1 # v0)) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => Z.pos v0 # 1) (fun v15 : @nat => 1 # v0) v8 v5 (@BinPosDef.Pos.to_nat) (ConstCauchy (Z.pos v0 # 1)) (ConstCauchy (1 # v0)) v9 v6 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v8 v5)~0 * v12)%nat (linear_max v10 v8 v5 v11 v13) (linear_max v10 v8 v5 v12 v14))) (BinPosDef.Pos.to_nat v3)) <= 2 # v3)%Q) v8 v9 end) v5 v6 end) : (Qabs (proj1_sig (inject_Q 1) (BinPosDef.Pos.to_nat v3) - proj1_sig (inject_Q (Z.pos v0 # 1) * inject_Q (1 # v0))%CReal (BinPosDef.Pos.to_nat v3)) <= 2 # v3)%Q)))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.CRealQ_dense	100	5.654968	2	2
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveCauchyRealsMult.inject_Q_mult	100	0.845655	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Q => conj (fun v2 : inject_Q (v0 * v1) < inject_Q v0 * inject_Q v1 => match v2 as v3 in (sig _) return (@False) with | exist _ v3 v4 => (fun (v3 : @positive) (v4 : (2 # v3 < proj1_sig (inject_Q v0 * inject_Q v1)%CReal (BinPosDef.Pos.to_nat v3) - proj1_sig (inject_Q (v0 * v1)) (BinPosDef.Pos.to_nat v3))%Q) => let v5 : {v5 : @positive | forall v6 : @nat, (Qabs ((fun v7 : @nat => v0) v6) < Z.pos v5 # 1)%Q} := QCauchySeq_bounded (fun v5 : @nat => v0) (@BinPosDef.Pos.to_nat) (ConstCauchy v0) in match v5 as v6 in (sig _) return (forall v7 : (2 # v3 < proj1_sig match v6 as v7 in (sig _) return (@CReal) with | exist _ v7 v8 => (fun (v7 : @positive) (v8 : forall v8 : @nat, Qabs v0 < Z.pos v7 # 1) => match QCauchySeq_bounded (fun v9 : @nat => v1) (@BinPosDef.Pos.to_nat) (ConstCauchy v1) as v9 in (sig _) return (@CReal) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, Qabs v1 < Z.pos v9 # 1) => exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => v0 * v1) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => v0) (fun v16 : @nat => v0) (fun v16 : @nat => v1) v7 v9 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v8 v10 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v13)%nat (linear_max v11 v7 v9 v12 v14) (linear_max v11 v7 v9 v13 v15))) v9 v10 end) v7 v8 end (BinPosDef.Pos.to_nat v3) - v0 * v1)%Q, @False) with | exist _ v6 v7 => (fun (v6 : @positive) (v7 : forall v7 : @nat, (Qabs v0 < Z.pos v6 # 1)%Q) (v8 : (2 # v3 < proj1_sig match QCauchySeq_bounded (fun v8 : @nat => v1) (@BinPosDef.Pos.to_nat) (ConstCauchy v1) as v8 in (sig _) return (@CReal) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, Qabs v1 < Z.pos v8 # 1) => exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => v0 * v1) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => v0) (fun v15 : @nat => v0) (fun v15 : @nat => v1) v6 v8 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v7 v9 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v12)%nat (linear_max v10 v6 v8 v11 v13) (linear_max v10 v6 v8 v12 v14))) v8 v9 end (BinPosDef.Pos.to_nat v3) - v0 * v1)%Q) => let v9 : {v9 : @positive | forall v10 : @nat, (Qabs ((fun v11 : @nat => v1) v10) < Z.pos v9 # 1)%Q} := QCauchySeq_bounded (fun v9 : @nat => v1) (@BinPosDef.Pos.to_nat) (ConstCauchy v1) in match v9 as v10 in (sig _) return (forall v11 : (2 # v3 < proj1_sig match v10 as v11 in (sig _) return (@CReal) with | exist _ v11 v12 => (fun (v11 : @positive) (v12 : forall v12 : @nat, Qabs v1 < Z.pos v11 # 1) => exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) (fun v13 : @nat => v0 * v1) (fun (v13 : @positive) (v14 v15 : @nat) (v16 : (BinPosDef.Pos.to_nat v13 <= v14)%nat) (v17 : (BinPosDef.Pos.to_nat v13 <= v15)%nat) => CReal_mult_cauchy (fun v18 : @nat => v0) (fun v18 : @nat => v0) (fun v18 : @nat => v1) v6 v11 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v7 v12 v13 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v11)~0 * v14)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v11)~0 * v15)%nat (linear_max v13 v6 v11 v14 v16) (linear_max v13 v6 v11 v15 v17))) v11 v12 end (BinPosDef.Pos.to_nat v3) - v0 * v1)%Q, @False) with | exist _ v10 v11 => (fun (v10 : @positive) (v11 : forall v11 : @nat, (Qabs v1 < Z.pos v10 # 1)%Q) (v12 : (2 # v3 < proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => v0 * v1) (fun (v12 : @positive) (v13 v14 : @nat) (v15 : (BinPosDef.Pos.to_nat v12 <= v13)%nat) (v16 : (BinPosDef.Pos.to_nat v12 <= v14)%nat) => CReal_mult_cauchy (fun v17 : @nat => v0) (fun v17 : @nat => v0) (fun v17 : @nat => v1) v6 v10 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v7 v11 v12 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v10)~0 * v13)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v10)~0 * v14)%nat (linear_max v12 v6 v10 v13 v15) (linear_max v12 v6 v10 v14 v16))) (BinPosDef.Pos.to_nat v3) - v0 * v1)%Q) => let v13 : Prop := @False in (let v14 : list (@Q) := ((2 # v3)%Q :: (v0 * v1 - v0 * v1)%Q :: nil)%list in ((fun v15 : v14 = ((2 # v3)%Q :: (v0 * v1 - v0 * v1)%Q :: nil)%list => let v16 : list (Ring_polynom.PExpr (@Q) * Ring_polynom.PExpr (@Q)) := nil in let v17 : list (@Q * @Ring_polynom.Mon * Ring_polynom.Pol (@Q)) := nil in let v18 : Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v16 = v17 := eq_refl : Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v16 = v17 in let v19 : forall (v19 : Ring_polynom.PExpr (@Q)) (v20 : Ring_polynom.Pol (@Q)) (v21 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 v19 = v20), (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v3 :: v0 :: v1 :: nil) v19 == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v3 :: v0 :: v1 :: nil) v20)%Q := Qfield_ring_lemma2 (@ring_subst_niter) v16 ((2 # v3)%Q :: v0 :: v1 :: nil) (@I) v17 v18 in let v20 : Ring_polynom.Pol (@Q) := Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0) in let v21 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEX (@Q) 1) = v20 := eq_refl : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEX (@Q) 1) = v20 in let v22 : (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v3 :: v0 :: v1 :: nil) (Ring_polynom.PEX (@Q) 1) == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v3 :: v0 :: v1 :: nil) v20)%Q := v19 (Ring_polynom.PEX (@Q) 1) v20 v21 in let v23 : Ring_polynom.Pol (@Q) := Ring_polynom.Pc 0 in let v24 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) = v23 := eq_refl : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) = v23 in let v25 : (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v3 :: v0 :: v1 :: nil) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v3 :: v0 :: v1 :: nil) v23)%Q := v19 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) v23 v24 in (fun v26 : (v0 * v1 - v0 * v1 == 0)%Q => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 # v3 < v0 * v1 - v0 * v1)%Q (2 # v3 < 0)%Q (Reflexive_partial_app_morphism (@Qlt_compat) (reflexive_proper_proxy Equivalence_Reflexive (2 # v3)%Q) (v0 * v1 - v0 * v1)%Q 0 v26) v13 v13 (reflexive_proper_proxy (@iff_Reflexive) v13)) v25 (fun v26 : (2 # v3 < 0)%Q => (let v27 : @False := eq_ind (Qnum (2 # v3) * QDen 0 ?= Qnum 0 * QDen (2 # v3))%Z (fun v27 : @comparison => match v27 as v28 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v26 in False_ind (@False) v27) : v13)) : forall (v15 : v14 = v14) (v16 : (2 # v3 < v0 * v1 - v0 * v1)%Q), v13) eq_refl) v12) v10 v11 end v8) v6 v7 end v4) v3 v4 end) (fun v2 : inject_Q v0 * inject_Q v1 < inject_Q (v0 * v1) => match v2 as v3 in (sig _) return (@False) with | exist _ v3 v4 => (fun (v3 : @positive) (v4 : (2 # v3 < proj1_sig (inject_Q (v0 * v1)) (BinPosDef.Pos.to_nat v3) - proj1_sig (inject_Q v0 * inject_Q v1)%CReal (BinPosDef.Pos.to_nat v3))%Q) => let v5 : {v5 : @positive | forall v6 : @nat, (Qabs ((fun v7 : @nat => v0) v6) < Z.pos v5 # 1)%Q} := QCauchySeq_bounded (fun v5 : @nat => v0) (@BinPosDef.Pos.to_nat) (ConstCauchy v0) in match v5 as v6 in (sig _) return (forall v7 : (2 # v3 < v0 * v1 - proj1_sig match v6 as v7 in (sig _) return (@CReal) with | exist _ v7 v8 => (fun (v7 : @positive) (v8 : forall v8 : @nat, Qabs v0 < Z.pos v7 # 1) => match QCauchySeq_bounded (fun v9 : @nat => v1) (@BinPosDef.Pos.to_nat) (ConstCauchy v1) as v9 in (sig _) return (@CReal) with | exist _ v9 v10 => (fun (v9 : @positive) (v10 : forall v10 : @nat, Qabs v1 < Z.pos v9 # 1) => exist (fun v11 : forall v11 : @nat, @Q => QCauchySeq v11 (@BinPosDef.Pos.to_nat)) (fun v11 : @nat => v0 * v1) (fun (v11 : @positive) (v12 v13 : @nat) (v14 : (BinPosDef.Pos.to_nat v11 <= v12)%nat) (v15 : (BinPosDef.Pos.to_nat v11 <= v13)%nat) => CReal_mult_cauchy (fun v16 : @nat => v0) (fun v16 : @nat => v0) (fun v16 : @nat => v1) v7 v9 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v8 v10 v11 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v12)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v7 v9)~0 * v13)%nat (linear_max v11 v7 v9 v12 v14) (linear_max v11 v7 v9 v13 v15))) v9 v10 end) v7 v8 end (BinPosDef.Pos.to_nat v3))%Q, @False) with | exist _ v6 v7 => (fun (v6 : @positive) (v7 : forall v7 : @nat, (Qabs v0 < Z.pos v6 # 1)%Q) (v8 : (2 # v3 < v0 * v1 - proj1_sig match QCauchySeq_bounded (fun v8 : @nat => v1) (@BinPosDef.Pos.to_nat) (ConstCauchy v1) as v8 in (sig _) return (@CReal) with | exist _ v8 v9 => (fun (v8 : @positive) (v9 : forall v9 : @nat, Qabs v1 < Z.pos v8 # 1) => exist (fun v10 : forall v10 : @nat, @Q => QCauchySeq v10 (@BinPosDef.Pos.to_nat)) (fun v10 : @nat => v0 * v1) (fun (v10 : @positive) (v11 v12 : @nat) (v13 : (BinPosDef.Pos.to_nat v10 <= v11)%nat) (v14 : (BinPosDef.Pos.to_nat v10 <= v12)%nat) => CReal_mult_cauchy (fun v15 : @nat => v0) (fun v15 : @nat => v0) (fun v15 : @nat => v1) v6 v8 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v7 v9 v10 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v11)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v8)~0 * v12)%nat (linear_max v10 v6 v8 v11 v13) (linear_max v10 v6 v8 v12 v14))) v8 v9 end (BinPosDef.Pos.to_nat v3))%Q) => let v9 : {v9 : @positive | forall v10 : @nat, (Qabs ((fun v11 : @nat => v1) v10) < Z.pos v9 # 1)%Q} := QCauchySeq_bounded (fun v9 : @nat => v1) (@BinPosDef.Pos.to_nat) (ConstCauchy v1) in match v9 as v10 in (sig _) return (forall v11 : (2 # v3 < v0 * v1 - proj1_sig match v10 as v11 in (sig _) return (@CReal) with | exist _ v11 v12 => (fun (v11 : @positive) (v12 : forall v12 : @nat, Qabs v1 < Z.pos v11 # 1) => exist (fun v13 : forall v13 : @nat, @Q => QCauchySeq v13 (@BinPosDef.Pos.to_nat)) (fun v13 : @nat => v0 * v1) (fun (v13 : @positive) (v14 v15 : @nat) (v16 : (BinPosDef.Pos.to_nat v13 <= v14)%nat) (v17 : (BinPosDef.Pos.to_nat v13 <= v15)%nat) => CReal_mult_cauchy (fun v18 : @nat => v0) (fun v18 : @nat => v0) (fun v18 : @nat => v1) v6 v11 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v7 v12 v13 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v11)~0 * v14)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v11)~0 * v15)%nat (linear_max v13 v6 v11 v14 v16) (linear_max v13 v6 v11 v15 v17))) v11 v12 end (BinPosDef.Pos.to_nat v3))%Q, @False) with | exist _ v10 v11 => (fun (v10 : @positive) (v11 : forall v11 : @nat, (Qabs v1 < Z.pos v10 # 1)%Q) (v12 : (2 # v3 < v0 * v1 - proj1_sig (exist (fun v12 : forall v12 : @nat, @Q => QCauchySeq v12 (@BinPosDef.Pos.to_nat)) (fun v12 : @nat => v0 * v1) (fun (v12 : @positive) (v13 v14 : @nat) (v15 : (BinPosDef.Pos.to_nat v12 <= v13)%nat) (v16 : (BinPosDef.Pos.to_nat v12 <= v14)%nat) => CReal_mult_cauchy (fun v17 : @nat => v0) (fun v17 : @nat => v0) (fun v17 : @nat => v1) v6 v10 (@BinPosDef.Pos.to_nat) (ConstCauchy v0) (ConstCauchy v1) v7 v11 v12 (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v10)~0 * v13)%nat (BinPosDef.Pos.to_nat (BinPosDef.Pos.max v6 v10)~0 * v14)%nat (linear_max v12 v6 v10 v13 v15) (linear_max v12 v6 v10 v14 v16))) (BinPosDef.Pos.to_nat v3))%Q) => let v13 : Prop := @False in (let v14 : list (@Q) := ((2 # v3)%Q :: (v0 * v1 - v0 * v1)%Q :: nil)%list in ((fun v15 : v14 = ((2 # v3)%Q :: (v0 * v1 - v0 * v1)%Q :: nil)%list => let v16 : list (Ring_polynom.PExpr (@Q) * Ring_polynom.PExpr (@Q)) := nil in let v17 : list (@Q * @Ring_polynom.Mon * Ring_polynom.Pol (@Q)) := nil in let v18 : Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v16 = v17 := eq_refl : Ring_polynom.mk_monpol_list 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) v16 = v17 in let v19 : forall (v19 : Ring_polynom.PExpr (@Q)) (v20 : Ring_polynom.Pol (@Q)) (v21 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 v19 = v20), (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v3 :: v0 :: v1 :: nil) v19 == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v3 :: v0 :: v1 :: nil) v20)%Q := Qfield_ring_lemma2 (@ring_subst_niter) v16 ((2 # v3)%Q :: v0 :: v1 :: nil) (@I) v17 v18 in let v20 : Ring_polynom.Pol (@Q) := Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0) in let v21 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEX (@Q) 1) = v20 := eq_refl : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEX (@Q) 1) = v20 in let v22 : (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v3 :: v0 :: v1 :: nil) (Ring_polynom.PEX (@Q) 1) == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v3 :: v0 :: v1 :: nil) v20)%Q := v19 (Ring_polynom.PEX (@Q) 1) v20 v21 in let v23 : Ring_polynom.Pol (@Q) := Ring_polynom.Pc 0 in let v24 : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) = v23 := eq_refl : Ring_polynom.norm_subst 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (triv_div 0 1 (@Qeq_bool)) (@ring_subst_niter) v17 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) = v23 in let v25 : (Ring_polynom.PEeval 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (2 # v3 :: v0 :: v1 :: nil) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) == Ring_polynom.Pphi_pow 0 1 (@Qplus) (@Qmult) (@Qminus) (@Qopp) 0 1 (@Qeq_bool) (IDphi (R:=@Q)) (@BinIntDef.Z.of_N) (@Qpower) (get_sign_None (C:=@Q)) (2 # v3 :: v0 :: v1 :: nil) v23)%Q := v19 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Q) 2) (Ring_polynom.PEX (@Q) 3))) v23 v24 in (fun v26 : (v0 * v1 - v0 * v1 == 0)%Q => subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (2 # v3 < v0 * v1 - v0 * v1)%Q (2 # v3 < 0)%Q (Reflexive_partial_app_morphism (@Qlt_compat) (reflexive_proper_proxy Equivalence_Reflexive (2 # v3)%Q) (v0 * v1 - v0 * v1)%Q 0 v26) v13 v13 (reflexive_proper_proxy (@iff_Reflexive) v13)) v25 (fun v26 : (2 # v3 < 0)%Q => (let v27 : @False := eq_ind (Qnum (2 # v3) * QDen 0 ?= Qnum 0 * QDen (2 # v3))%Z (fun v27 : @comparison => match v27 as v28 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v26 in False_ind (@False) v27) : v13)) : forall (v15 : v14 = v14) (v16 : (2 # v3 < v0 * v1 - v0 * v1)%Q), v13) eq_refl) v12) v10 v11 end v8) v6 v7 end v4) v3 v4 end))).
