coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj1	100	2.841239	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@A) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v1) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Conjunction.proj2	100	0.052216	1	1	0	synth with cache (only 1: refine (fun v0 : @A /\ @B => match v0 as v1 in (_ /\ _) return (@B) with | conj v1 v2 => (fun (v1 : @A) (v2 : @B) => v2) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_refl	100	0.025464	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : v0 => v1) (fun v1 : v0 => v1))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_trans	100	0.068965	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v1 <-> v2, v0 <-> v2) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v1 <-> v2) => match v6 as v7 in (_ /\ _) return (v0 <-> v2) with | conj v7 v8 => (fun (v7 : forall v7 : v1, v2) (v8 : forall v8 : v2, v1) => conj (fun v9 : v0 => v7 (v4 v9)) (fun v9 : v2 => v5 (v4 (v5 (v8 v9))))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Equivalence.iff_sym	100	0.055536	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return (v1 <-> v0) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v4 v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_l	100	0.082776	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 /\ v1 <-> v0 /\ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 /\ v1 => match v6 as v7 in (_ /\ _) return (v0 /\ v2) with | conj v7 v8 => (fun (v7 : v0) (v8 : v1) => conj v7 (v4 v8)) v7 v8 end) (fun v6 : v0 /\ v2 => match v6 as v7 in (_ /\ _) return (v0 /\ v1) with | conj v7 v8 => (fun (v7 : v0) (v8 : v2) => conj v7 (v5 v8)) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_iff_compat_r	100	0.134073	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 /\ v0 <-> v2 /\ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 /\ v0 => match v6 as v7 in (_ /\ _) return (v2 /\ v0) with | conj v7 v8 => (fun (v7 : v1) (v8 : v0) => conj (v4 v7) v8) v7 v8 end) (fun v6 : v2 /\ v0 => match v6 as v7 in (_ /\ _) return (v1 /\ v0) with | conj v7 v8 => (fun (v7 : v2) (v8 : v0) => conj (v5 v7) v8) v7 v8 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_l	100	0.153879	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v0 \/ v1 <-> v0 \/ v2) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v0 \/ v1 => match v6 as v7 in (_ \/ _) return (v0 \/ v2) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v1 => or_intror (v4 v7)) v7 end) (fun v6 : v0 \/ v2 => match v6 as v7 in (_ \/ _) return (v0 \/ v1) with | or_introl v7 => (fun v7 : v0 => or_introl v7) v7 | or_intror v7 => (fun v7 : v2 => or_intror (v5 v7)) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_iff_compat_r	100	0.113493	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return (v1 \/ v0 <-> v2 \/ v0) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun v6 : v1 \/ v0 => match v6 as v7 in (_ \/ _) return (v2 \/ v0) with | or_introl v7 => (fun v7 : v1 => or_introl (v4 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end) (fun v6 : v2 \/ v0 => match v6 as v7 in (_ \/ _) return (v1 \/ v0) with | or_introl v7 => (fun v7 : v2 => or_introl (v5 v7)) v7 | or_intror v7 => (fun v7 : v0 => or_intror v7) v7 end)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_l	100	0.063003	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v0, v1) <-> (forall v5 : v0, v2)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v0, v1) (v7 : v0) => v4 (v6 v7)) (fun (v6 : forall v6 : v0, v2) (v7 : v0) => v5 (v6 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.imp_iff_compat_r	100	0.068126	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v1 <-> v2) => match v3 as v4 in (_ /\ _) return ((forall v5 : v1, v0) <-> (forall v5 : v2, v0)) with | conj v4 v5 => (fun (v4 : forall v4 : v1, v2) (v5 : forall v5 : v2, v1) => conj (fun (v6 : forall v6 : v1, v0) (v7 : v2) => v6 (v5 v7)) (fun (v6 : forall v6 : v2, v0) (v7 : v1) => v6 (v4 v7))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.not_iff_compat	100	0.037388	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => imp_iff_compat_r (@False) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.neg_false	100	0.068211	1	1	0	synth with cache (only 1: refine (fun v0 : Prop => conj (fun v1 : forall v1 : v0, @False => conj v1 (fun v2 : @False => False_ind v0 v2)) (fun v1 : v0 <-> @False => match v1 as v2 in (_ /\ _) return (forall v3 : v0, @False) with | conj v2 v3 => (fun (v2 : forall v2 : v0, @False) (v3 : forall v3 : @False, v0) => v2) v2 v3 end) : ~ v0 <-> (v0 <-> @False))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_l	100	0.134176	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v0 /\ v1 <-> v0 /\ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 /\ v1, v0 /\ v2) (v7 : forall v7 : v0 /\ v2, v0 /\ v1) => conj (fun v8 : v1 => let v9 : forall v9 : v0 /\ v1, v2 := fun v9 : v0 /\ v1 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v0) (v11 : v2) => v11) v10 v11 end in v9 (conj (v3 v8) v8)) (fun v8 : v2 => let v9 : forall v9 : v0 /\ v2, v1 := fun v9 : v0 /\ v2 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v0) (v11 : v1) => v11) v10 v11 end in v9 (conj (v4 v8) v8))) v6 v7 end) (and_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_cancel_r	100	0.164150	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, v0) (v4 : forall v4 : v2, v0) => conj (fun v5 : v1 /\ v0 <-> v2 /\ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 /\ v0, v2 /\ v0) (v7 : forall v7 : v2 /\ v0, v1 /\ v0) => conj (fun v8 : v1 => let v9 : forall v9 : v1 /\ v0, v2 := fun v9 : v1 /\ v0 => match v6 v9 as v10 in (_ /\ _) return v2 with | conj v10 v11 => (fun (v10 : v2) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v3 v8))) (fun v8 : v2 => let v9 : forall v9 : v2 /\ v0, v1 := fun v9 : v2 /\ v0 => match v7 v9 as v10 in (_ /\ _) return v1 with | conj v10 v11 => (fun (v10 : v1) (v11 : v0) => v10) v10 v11 end in v9 (conj v8 (v4 v8)))) v6 v7 end) (and_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_comm	100	0.058109	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 /\ v1 => match v2 as v3 in (_ /\ _) return (v1 /\ v0) with | conj v3 v4 => (fun (v3 : v0) (v4 : v1) => conj v4 v3) v3 v4 end) (fun v2 : v1 /\ v0 => match v2 as v3 in (_ /\ _) return (v0 /\ v1) with | conj v3 v4 => (fun (v3 : v1) (v4 : v0) => conj v4 v3) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.and_assoc	100	0.192865	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 /\ v1) /\ v2 => match v3 as v4 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v4 v5 => (fun (v4 : v0 /\ v1) (v5 : v2) => match v4 as v6 in (_ /\ _) return (v0 /\ v1 /\ v2) with | conj v6 v7 => (fun (v6 : v0) (v7 : v1) => conj v6 (conj v7 v5)) v6 v7 end) v4 v5 end) (fun v3 : v0 /\ v1 /\ v2 => match v3 as v4 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v4 v5 => (fun (v4 : v0) (v5 : v1 /\ v2) => match v5 as v6 in (_ /\ _) return ((v0 /\ v1) /\ v2) with | conj v6 v7 => (fun (v6 : v1) (v7 : v2) => conj (conj v4 v6) v7) v6 v7 end) v4 v5 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_l	100	0.197407	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v0 \/ v1 <-> v0 \/ v2 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v0 \/ v1, v0 \/ v2) (v7 : forall v7 : v0 \/ v2, v0 \/ v1) => conj (fun v8 : v1 => let v9 : v0 \/ v2 := v6 (or_intror v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 | or_intror v10 => (fun v10 : v2 => v10) v10 end) (fun v8 : v2 => let v9 : v0 \/ v1 := v7 (or_intror v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 | or_intror v10 => (fun v10 : v1 => v10) v10 end)) v6 v7 end) (or_iff_compat_l v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_cancel_r	100	0.190934	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : forall v3 : v1, ~ v0) (v4 : forall v4 : v2, ~ v0) => conj (fun v5 : v1 \/ v0 <-> v2 \/ v0 => match v5 as v6 in (_ /\ _) return (v1 <-> v2) with | conj v6 v7 => (fun (v6 : forall v6 : v1 \/ v0, v2 \/ v0) (v7 : forall v7 : v2 \/ v0, v1 \/ v0) => conj (fun v8 : v1 => let v9 : v2 \/ v0 := v6 (or_introl v8) in match v9 as v10 in (_ \/ _) return v2 with | or_introl v10 => (fun v10 : v2 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v3 v8 v10 in match v11 as v12 in False return v2 with end) v10 end) (fun v8 : v2 => let v9 : v1 \/ v0 := v7 (or_introl v8) in match v9 as v10 in (_ \/ _) return v1 with | or_introl v10 => (fun v10 : v1 => v10) v10 | or_intror v10 => (fun v10 : v0 => let v11 : @False := v4 v8 v10 in match v11 as v12 in False return v1 with end) v10 end)) v6 v7 end) (or_iff_compat_r v0 (C:=v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_comm	100	0.124752	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 \/ v1 => match v2 as v3 in (_ \/ _) return (v1 \/ v0) with | or_introl v3 => (fun v3 : v0 => or_intror v3) v3 | or_intror v3 => (fun v3 : v1 => or_introl v3) v3 end) (fun v2 : v1 \/ v0 => match v2 as v3 in (_ \/ _) return (v0 \/ v1) with | or_introl v3 => (fun v3 : v1 => or_intror v3) v3 | or_intror v3 => (fun v3 : v0 => or_introl v3) v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.or_assoc	100	0.156346	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : Prop => conj (fun v3 : (v0 \/ v1) \/ v2 => match v3 as v4 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v4 => (fun v4 : v0 \/ v1 => match v4 as v5 in (_ \/ _) return (v0 \/ v1 \/ v2) with | or_introl v5 => (fun v5 : v0 => or_introl v5) v5 | or_intror v5 => (fun v5 : v1 => or_intror (or_introl v5)) v5 end) v4 | or_intror v4 => (fun v4 : v2 => or_intror (or_intror v4)) v4 end) (fun v3 : v0 \/ v1 \/ v2 => match v3 as v4 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v4 => (fun v4 : v0 => or_introl (or_introl v4)) v4 | or_intror v4 => (fun v4 : v1 \/ v2 => match v4 as v5 in (_ \/ _) return ((v0 \/ v1) \/ v2) with | or_introl v5 => (fun v5 : v1 => or_introl (or_intror v5)) v5 | or_intror v5 => (fun v5 : v2 => or_intror v5) v5 end) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_and	100	0.076386	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Prop) (v2 : v0 <-> v1) => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj v3 v4) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_to_and	100	0.165052	1	1	0	synth with cache (only 1: refine (fun v0 v1 : Prop => conj (fun v2 : v0 <-> v1 => match v2 as v3 in (_ /\ _) return ((forall v4 : v0, v1) /\ (forall v4 : v1, v0)) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end) (fun v2 : (forall v2 : v0, v1) /\ (forall v2 : v1, v0) => match v2 as v3 in (_ /\ _) return (v0 <-> v1) with | conj v3 v4 => (fun (v3 : forall v3 : v0, v1) (v4 : forall v4 : v1, v0) => conj (fun v5 : v0 => v3 v5) (fun v5 : v1 => v4 v5)) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.inst	100	0.080681	1	1	0	synth with cache (only 1: refine ((fun (v0 : @A) (v1 : forall v1 : @A, P v1) => v1 v0) : forall (v0 : @A) (v1 : all (fun v1 : @A => P v1)), P v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.universal_quantification.gen	100	0.062743	1	1	0	synth with cache (only 1: refine ((fun (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0) (v3 : @A) => v1 v3 v2) : forall (v0 : Prop) (v1 : forall (v1 : @A) (v2 : v0), P v1) (v2 : v0), all (@P))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.absurd	100	0.043905	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : Prop) (v2 : v0) (v3 : forall v3 : v0, @False) => let v4 : @False := v3 v2 in match v4 as v5 in False return v1 with end) : forall (v0 v1 : Prop) (v2 : v0) (v3 : ~ v0), v1)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_sym	100	0.081756	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (v1 = @x) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans	100	0.100678	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @y = @z) => match v1 as v3 in (_ = v2) return (@x = v2) with | eq_refl => v0 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.eq_trans_r	100	0.082308	1	1	0	synth with cache (only 1: refine (fun (v0 : @x = @y) (v1 : @z = @y) => match v1 as v3 in (_ = v2) return (forall v4 : @x = v2, @x = @z) with | eq_refl => fun v2 : @x = @z => v2 end v0)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.f_equal	100	0.102012	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.equality.not_eq_sym	100	0.109550	1	1	0	synth with cache (only 1: refine ((fun (v0 : @x <> @y) (v1 : @y = @x) => v0 (match v1 as v3 in (_ = v2) return (forall v4 : v2 <> @y, v2 = @y) with | eq_refl => fun v2 : @y <> @y => eq_refl end v0)) : forall v0 : @x <> @y, @y <> @x)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_sind_r	100	0.037380	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, SProp) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_sind (fun v6 : v0 => v2 v6) v3 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_ind_r	100	0.053469	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Prop) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_ind v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rec_r	100	0.051274	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Set) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rec v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.Logic_lemmas.eq_rect_r	100	0.045878	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : v2 v1) (v4 : v0) (v5 : v4 = v1) => eq_rect v1 (fun v6 : v0 => v2 v6) v3 v4 (eq_sym v5))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep.f_equal_dep	100	0.111414	1	1	0	synth with cache (only 1: refine (fun v0 : @x = @y => match v0 as v2 in (_ = v1) return (rew [@B] v2 in f (@x) = f v1) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.equality_dep2.f_equal_dep2	100	0.194908	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v2 v6) (v9 : v2 v7) (v10 : v6 = v7) => match v10 as v12 in (_ = v11) return (forall (v13 : v2 v11) (v14 : rew [v2] v12 in v8 = v13), rew [v3] f_equal v4 v12 in v5 v6 v8 = v5 v11 v13) with | eq_refl => fun (v11 : v2 v6) (v12 : rew [v2] eq_refl in v8 = v11) => match v12 as v14 in (_ = v13) return (rew [v3] f_equal v4 eq_refl in v5 v6 v8 = v5 v6 v13) with | eq_refl => eq_refl end end v9)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_r	100	0.073611	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v3) => match v4 as v7 in (_ = v6) return (forall v8 : v1 v6, rew [v1] v7 in rew <- [v1] v7 in v8 = v8) with | eq_refl => fun v6 : v1 v2 => eq_refl end v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_opp_l	100	0.051458	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) (v5 : v1 v2) => match v4 as v7 in (_ = v6) return (rew <- [v1] v7 in rew [v1] v7 in v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal2	100	0.061584	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 : forall (v3 : v0) (v4 : v1), v2) (v4 v5 : v0) (v6 v7 : v1) (v8 : v4 = v5) => match v8 as v10 in (_ = v9) return (forall v11 : v6 = v7, v3 v4 v6 = v3 v9 v7) with | eq_refl => fun v9 : v6 = v7 => match v9 as v11 in (_ = v10) return (v3 v4 v6 = v3 v4 v10) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal3	100	0.081038	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : Type) (v4 : forall (v4 : v0) (v5 : v1) (v6 : v2), v3) (v5 v6 : v0) (v7 v8 : v1) (v9 v10 : v2) (v11 : v5 = v6) => match v11 as v13 in (_ = v12) return (forall (v14 : v7 = v8) (v15 : v9 = v10), v4 v5 v7 v9 = v4 v12 v8 v10) with | eq_refl => fun v12 : v7 = v8 => match v12 as v14 in (_ = v13) return (forall v15 : v9 = v10, v4 v5 v7 v9 = v4 v5 v13 v10) with | eq_refl => fun v13 : v9 = v10 => match v13 as v15 in (_ = v14) return (v4 v5 v7 v9 = v4 v5 v7 v14) with | eq_refl => eq_refl end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal4	100	0.107404	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 : Type) (v5 : forall (v5 : v0) (v6 : v1) (v7 : v2) (v8 : v3), v4) (v6 v7 : v0) (v8 v9 : v1) (v10 v11 : v2) (v12 v13 : v3) (v14 : v6 = v7) => match v14 as v16 in (_ = v15) return (forall (v17 : v8 = v9) (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v15 v9 v11 v13) with | eq_refl => fun v15 : v8 = v9 => match v15 as v17 in (_ = v16) return (forall (v18 : v10 = v11) (v19 : v12 = v13), v5 v6 v8 v10 v12 = v5 v6 v16 v11 v13) with | eq_refl => fun v16 : v10 = v11 => match v16 as v18 in (_ = v17) return (forall v19 : v12 = v13, v5 v6 v8 v10 v12 = v5 v6 v8 v17 v13) with | eq_refl => fun v17 : v12 = v13 => match v17 as v19 in (_ = v18) return (v5 v6 v8 v10 v12 = v5 v6 v8 v10 v18) with | eq_refl => eq_refl end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal5	100	0.088259	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 v5 : Type) (v6 : forall (v6 : v0) (v7 : v1) (v8 : v2) (v9 : v3) (v10 : v4), v5) (v7 v8 : v0) (v9 v10 : v1) (v11 v12 : v2) (v13 v14 : v3) (v15 v16 : v4) (v17 : v7 = v8) => match v17 as v19 in (_ = v18) return (forall (v20 : v9 = v10) (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v18 v10 v12 v14 v16) with | eq_refl => fun v18 : v9 = v10 => match v18 as v20 in (_ = v19) return (forall (v21 : v11 = v12) (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v19 v12 v14 v16) with | eq_refl => fun v19 : v11 = v12 => match v19 as v21 in (_ = v20) return (forall (v22 : v13 = v14) (v23 : v15 = v16), v6 v7 v9 v11 v13 v15 = v6 v7 v9 v20 v14 v16) with | eq_refl => fun v20 : v13 = v14 => match v20 as v22 in (_ = v21) return (forall v23 : v15 = v16, v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v21 v16) with | eq_refl => fun v21 : v15 = v16 => match v21 as v23 in (_ = v22) return (v6 v7 v9 v11 v13 v15 = v6 v7 v9 v11 v13 v22) with | eq_refl => eq_refl end end end end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.f_equal_compose	100	0.069145	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Type) (v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : forall v6 : v1, v2) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v6 (f_equal v5 v9) = f_equal (fun v10 : v0 => v6 (v5 v10)) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_l	100	0.042312	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans eq_refl v5 = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_refl_r	100	0.040120	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 eq_refl = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_involutive	100	0.039029	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_sym (eq_sym v5) = v5) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_l	100	0.048550	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans (eq_sym v5) v5 = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_inv_r	100	0.048845	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 : v0) (v3 : v1 = v2) => match v3 as v5 in (_ = v4) return (eq_trans v5 (eq_sym v5) = eq_refl) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_assoc	100	0.071971	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 v4 : v0) (v5 : v1 = v2) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (eq_trans v5 (eq_trans v6 v9) = eq_trans (eq_trans v5 v6) v9) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_map	100	0.066788	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v1, Type) (v3 : forall v3 : v0, v1) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v2 (v3 v4), rew [fun v10 : v0 => v2 (v3 v10)] v8 in v9 = rew [v2] f_equal v3 v8 in v9) with | eq_refl => fun v7 : v2 (v3 v4) => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map	100	0.093224	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v1 v2) (v6 : v1 v3) (v7 : v1 v4) (v8 : v2 = v3) (v9 : v3 = v4) (v10 : rew [v1] v8 in v5 = v6) (v11 : rew [v1] v9 in v6 = v7) => match v9 as v13 in (_ = v12) return (forall (v14 : v1 v12) (v15 : rew [v1] v13 in v6 = v14), rew [v1] eq_trans v8 v13 in v5 = v14) with | eq_refl => fun (v12 : v1 v3) (v13 : rew [v1] eq_refl in v6 = v12) => eq_trans v10 v13 end v7 v11)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst	100	0.055992	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v1 v3), v2 v3) (v4 v5 : v0) (v6 : v4 = v5) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v4, rew [v2] v8 in v3 v4 v9 = v3 v7 (rew [v1] v8 in v9)) with | eq_refl => fun v7 : v1 v4 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.map_subst_map	100	0.070860	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Type) (v3 : forall v3 : v1, Type) (v4 : forall v4 : v0, v1) (v5 : forall (v5 : v0) (v6 : v2 v5), v3 (v4 v5)) (v6 v7 : v0) (v8 : v6 = v7) => match v8 as v10 in (_ = v9) return (forall v11 : v2 v6, rew [v3] f_equal v4 v10 in v5 v6 v11 = v5 v9 (rew [v2] v10 in v11)) with | eq_refl => fun v9 : v2 v6 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_swap	100	0.057322	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall (v7 : v1 v2) (v8 : v1 v5) (v9 : rew [v1] v6 in v7 = v8), v7 = rew <- [v1] v6 in v8) with | eq_refl => fun (v5 v6 : v1 v2) (v7 : rew [v1] eq_refl in v5 = v6) => v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_compose	100	0.070108	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) (v6 : v3 = v4) => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] v8 in rew [v1] v5 in v9 = rew [v1] eq_trans v5 v8 in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_l	100	0.074045	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v2 = v1 v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 v3)) (v2 v3)) (fun v4 : v1 v3 = v1 v3 => match v2 v3 as v6 in (_ = v5) return (v1 v3 = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : v3 = v1 v3 := v2 v3 in let v5 : v0 := v1 v3 in match v4 as v7 in (_ = v6) return (match v7 as v9 in (_ = v8) return (v6 = v1 v8) with | eq_refl => eq_trans (eq_sym v7) (v2 v3) end = v2 v6) with | eq_refl => let v6 : v3 = v1 v3 := v2 v3 in let v7 : v0 := v1 v3 in match v6 as v9 in (_ = v8) return (eq_trans (eq_sym eq_refl) v9 = v9) with | eq_refl => eq_refl end end) eq_refl (eq_trans_sym_inv_l (v2 v3)) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_id_comm_r	100	0.189197	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, v0) (v2 : forall v2 : v0, v1 v2 = v2) (v3 : v0) => eq_ind (eq_trans (eq_sym (v2 (v1 (v1 v3)))) (v2 (v1 (v1 v3)))) (fun v4 : v1 (v1 v3) = v1 (v1 v3) => match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => v4 end = v2 (v1 v3)) (let v4 : forall v4 : v0, v4 = v1 v4 := fun v4 : v0 => eq_sym (v2 v4) in (let v5 : f_equal v1 (v4 (v1 v3)) = v4 (v1 (v1 v3)) := eq_id_comm_l v1 v4 (v1 v3) in let v6 : v1 (v1 v3) = v1 (v1 (v1 v3)) := v4 (v1 (v1 v3)) in match v5 as v8 in (_ = v7) return (match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans v7 (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => let v7 : f_equal v1 (v4 v3) = v4 (v1 v3) := eq_id_comm_l v1 v4 v3 in let v8 : v1 v3 = v1 (v1 v3) := v4 (v1 v3) in match v7 as v10 in (_ = v9) return (match v2 v3 as v12 in (_ = v11) return (v1 (v1 v3) = v1 v11) with | eq_refl => eq_trans (f_equal v1 v9) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) with | eq_refl => (let v9 : v1 v3 = v3 := v2 v3 in match v9 as v11 in (_ = v10) return (match v11 as v13 in (_ = v12) return (v1 (v1 v10) = v1 v12) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (eq_sym v11))) (v2 (v1 (v1 v3))) end = v2 (v1 v10)) with | eq_refl => eq_ind_r (fun v10 : v1 (v1 (v1 v3)) = v1 (v1 v3) => v10 = v2 (v1 (v1 v3))) eq_refl (eq_trans_refl_l (v2 (v1 (v1 v3)))) : eq_trans (f_equal v1 (f_equal v1 (eq_sym eq_refl))) (v2 (v1 (v1 v3))) = v2 (v1 (v1 v3)) end) : match v2 v3 as v10 in (_ = v9) return (v1 (v1 v3) = v1 v9) with | eq_refl => eq_trans (f_equal v1 (f_equal v1 (v4 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3) end end) : match v2 v3 as v6 in (_ = v5) return (v1 (v1 v3) = v1 v5) with | eq_refl => eq_trans (v4 (v1 (v1 v3))) (v2 (v1 (v1 v3))) end = v2 (v1 v3)) eq_refl (eq_trans_sym_inv_l (v2 (v1 (v1 v3)))) : f_equal v1 (v2 v3) = v2 (v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_refl_map_distr	100	0.028606	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : v0) (v3 : forall v3 : v0, v1) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_map_distr	100	0.091698	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 v4 : v0) (v5 : forall v5 : v0, v1) (v6 : v2 = v3) (v7 : v3 = v4) => match v7 as v9 in (_ = v8) return (f_equal v5 (eq_trans v6 v9) = eq_trans (f_equal v5 v6) (f_equal v5 v9)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_sym_map_distr	100	0.070605	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : forall v4 : v0, v1) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (eq_sym (f_equal v4 v7) = f_equal v4 (eq_sym v7)) with | eq_refl => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_sym_distr	100	0.107648	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) => match v4 as v6 in (_ = v5) return (forall v7 : v5 = v3, eq_sym (eq_trans v6 v7) = eq_trans (eq_sym v7) (eq_sym v6)) with | eq_refl => fun v5 : v1 = v3 => match v5 as v7 in (_ = v6) return (eq_sym (eq_trans eq_refl v7) = eq_trans (eq_sym v7) (eq_sym eq_refl)) with | eq_refl => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_trans_rew_distr	100	0.101946	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Type) (v2 v3 v4 : v0) (v5 : v2 = v3) => match v5 as v7 in (_ = v6) return (forall (v8 : v6 = v4) (v9 : v1 v2), rew [v1] eq_trans v7 v8 in v9 = rew [v1] v8 in rew [v1] v7 in v9) with | eq_refl => fun v6 : v2 = v4 => match v6 as v8 in (_ = v7) return (forall v9 : v1 v2, rew [v1] eq_trans eq_refl v8 in v9 = rew [v1] v8 in rew [v1] eq_refl in v9) with | eq_refl => fun v7 : v1 v2 => eq_refl end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.rew_const	100	0.040347	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 v3 : v0) (v4 : v2 = v3) => match v4 as v6 in (_ = v5) return (forall v7 : v1, rew [fun v8 : v0 => v1] v6 in v7 = v7) with | eq_refl => fun v5 : v1 => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.unique_existence	100	0.100778	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) => conj (fun v2 : (exists v2 : v0, v1 v2) /\ uniqueness v1 => match v2 as v3 in (_ /\ _) return (exists ! v4 : v0, v1 v4) with | conj v3 v4 => (fun (v3 : exists v3 : v0, v1 v3) (v4 : uniqueness v1) => match v3 as v5 in (ex _) return (exists ! v6 : v0, v1 v6) with | ex_intro _ v5 v6 => (fun (v5 : v0) (v6 : v1 v5) => ex_intro (unique (fun v7 : v0 => v1 v7)) v5 (conj v6 (fun (v7 : v0) (v8 : v1 v7) => v4 v5 v7 v6 v8) : unique (fun v7 : v0 => v1 v7) v5)) v5 v6 end) v3 v4 end) (fun v2 : exists ! v2 : v0, v1 v2 => match v2 as v3 in (ex _) return ((exists v4 : v0, v1 v4) /\ uniqueness v1) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return ((exists v6 : v0, v1 v6) /\ uniqueness v1) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) => conj (ex_intro (fun v7 : v0 => v1 v7) v3 v5) ((fun (v7 v8 : v0) (v9 : v1 v7) (v10 : v1 v8) => eq_trans (eq_sym (v6 v7 v9)) (v6 v8 v10)) : uniqueness v1)) v5 v6 end) v3 v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_unique_domain_coincide	100	0.086636	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists ! v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (forall v4 : forall v4 : v0, Prop, (forall (v5 : v0) (v6 : v1 v5), v4 v5) <-> (exists v5 : v0, v1 v5 /\ v4 v5)) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : unique (fun v4 : v0 => v1 v4) v3) => match v4 as v5 in (_ /\ _) return (forall v6 : forall v6 : v0, Prop, (forall (v7 : v0) (v8 : v1 v7), v6 v7) <-> (exists v7 : v0, v1 v7 /\ v6 v7)) with | conj v5 v6 => (fun (v5 : v1 v3) (v6 : forall (v6 : v0) (v7 : v1 v6), v3 = v6) (v7 : forall v7 : v0, Prop) => conj (fun v8 : forall (v8 : v0) (v9 : v1 v8), v7 v8 => ex_intro (fun v9 : v0 => v1 v9 /\ v7 v9) v3 (conj v5 (v8 v3 v5))) (fun v8 : exists v8 : v0, v1 v8 /\ v7 v8 => match v8 as v9 in (ex _) return (forall (v10 : v0) (v11 : v1 v10), v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v0) (v10 : v1 v9 /\ v7 v9) => match v10 as v11 in (_ /\ _) return (forall (v12 : v0) (v13 : v1 v12), v7 v12) with | conj v11 v12 => (fun (v11 : v1 v9) (v12 : v7 v9) (v13 : v0) (v14 : v1 v13) => let v15 : v9 = v13 := eq_trans (eq_sym (v6 v9 v11)) (v6 v13 v14) in match v15 as v17 in (_ = v16) return (forall v18 : v1 v16, v7 v16) with | eq_refl => fun v16 : v1 v9 => v12 end v14) v11 v12 end) v9 v10 end)) v5 v6 end) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.forall_exists_coincide_unique_domain	100	0.091558	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : forall v2 : v0, Prop, (forall (v3 : v0) (v4 : v1 v3), v2 v3) <-> (exists v3 : v0, v1 v3 /\ v2 v3)) => let v3 : (forall v3 : forall (v3 : v0) (v4 : v1 v3), v1 v3, exists v4 : v0, v1 v4 /\ v1 v4) /\ (forall (v3 : exists v3 : v0, v1 v3 /\ v1 v3) (v4 : v0) (v5 : v1 v4), v1 v4) := v2 v1 in match v3 as v4 in (_ /\ _) return (exists ! v5 : v0, v1 v5) with | conj v4 v5 => (fun (v4 : forall v4 : forall (v4 : v0) (v5 : v1 v4), v1 v4, exists v5 : v0, v1 v5 /\ v1 v5) (v5 : forall (v5 : exists v5 : v0, v1 v5 /\ v1 v5) (v6 : v0) (v7 : v1 v6), v1 v6) => let v6 : exists v6 : v0, v1 v6 /\ v1 v6 := v4 (fun (v6 : v0) (v7 : v1 v6) => v7) in match v6 as v7 in (ex _) return (exists ! v8 : v0, v1 v8) with | ex_intro _ v7 v8 => (fun (v7 : v0) (v8 : v1 v7 /\ v1 v7) => match v8 as v9 in (_ /\ _) return (exists ! v10 : v0, v1 v10) with | conj v9 v10 => (fun v9 v10 : v1 v7 => ex_intro (unique (fun v11 : v0 => v1 v11)) v7 (conj v9 (let v11 : (forall v11 : forall (v11 : v0) (v12 : v1 v11), v7 = v11, exists v12 : v0, v1 v12 /\ v7 = v12) /\ (forall (v11 : exists v11 : v0, v1 v11 /\ v7 = v11) (v12 : v0) (v13 : v1 v12), v7 = v12) := v2 (fun v11 : v0 => v7 = v11) in match v11 as v12 in (_ /\ _) return (forall (v13 : v0) (v14 : v1 v13), v7 = v13) with | conj v12 v13 => (fun (v12 : forall v12 : forall (v12 : v0) (v13 : v1 v12), v7 = v12, exists v13 : v0, v1 v13 /\ v7 = v13) (v13 : forall (v13 : exists v13 : v0, v1 v13 /\ v7 = v13) (v14 : v0) (v15 : v1 v14), v7 = v14) => v13 (ex_intro (fun v14 : v0 => v1 v14 /\ v7 = v14) v7 (conj v9 eq_refl))) v12 v13 end))) v9 v10 end) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.exists_inhabited	100	0.026920	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : exists v2 : v0, v1 v2) => match v2 as v3 in (ex _) return (inhabited v0) with | ex_intro _ v3 v4 => (fun (v3 : v0) (v4 : v1 v3) => inhabits v3) v3 v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.inhabited_covariant	100	0.026700	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, v1) (v3 : inhabited v0) => match v3 as v4 in (inhabited _) return (inhabited v1) with | inhabits v4 => (fun v4 : v0 => inhabits (v2 v4)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.eq_stepl	100	0.024383	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 v2 v3 : v0) (v4 : v1 = v2) (v5 : v1 = v3) => eq_ind v1 (fun v6 : v0 => v6 = v2) v4 v3 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.iff_stepl	100	0.044718	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : Prop) (v3 : v0 <-> v1) => match v3 as v4 in (_ /\ _) return (forall v5 : v0 <-> v2, v2 <-> v1) with | conj v4 v5 => (fun (v4 : forall v4 : v0, v1) (v5 : forall v5 : v1, v0) (v6 : v0 <-> v2) => match v6 as v7 in (_ /\ _) return (v2 <-> v1) with | conj v7 v8 => (fun (v7 : forall v7 : v0, v2) (v8 : forall v8 : v2, v0) => conj (fun v9 : v2 => v4 (v5 (v4 (v8 v9)))) (fun v9 : v1 => v7 (v5 v9))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.eq_ex_uncurried	100	0.103908	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 v3 : v0) (v4 : v1 v2) (v5 : v1 v3) (v6 : exists v6 : v2 = v3, rew [v1] v6 in v4 = v5) => match v6 as v7 in (ex _) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v5) with | ex_intro _ v7 v8 => (fun (v7 : v2 = v3) (v8 : rew [v1] v7 in v4 = v5) => match v8 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v3 v9) with | eq_refl => match v7 as v10 in (_ = v9) return (ex_intro v1 v2 v4 = ex_intro v1 v9 (rew [v1] v10 in v4)) with | eq_refl => eq_refl end : ex_intro v1 v2 v4 = ex_intro v1 v3 (rew [v1] v7 in v4) end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex.rew_ex	100	0.116847	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : exists v4 : v2 v1, v3 v1 v4) (v5 : v0) (v6 : v1 = v5) => match v6 as v8 in (_ = v7) return (rew [fun v9 : v0 => exists v10 : v2 v9, v3 v9 v10] v8 in v4 = match v4 as v9 in (ex _) return (exists v10 : v2 v7, v3 v7 v10) with | ex_intro _ v9 v10 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) => ex_intro (v3 v7) (rew [v2] v8 in v9) match v8 as v12 in (_ = v11) return (v3 v11 (rew [v2] v12 in v9)) with | eq_refl => v10 end) v9 v10 end) with | eq_refl => match v4 as v7 in (ex _) return (rew [fun v8 : v0 => exists v9 : v2 v8, v3 v8 v9] eq_refl in v7 = match v7 as v8 in (ex _) return (exists v9 : v2 v1, v3 v1 v9) with | ex_intro _ v8 v9 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) => ex_intro (v3 v1) (rew [v2] eq_refl in v8) v9) v8 v9 end) with | ex_intro _ v7 v8 => (fun (v7 : v2 v1) (v8 : v3 v1 v7) => eq_refl) v7 v8 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.eq_ex2_uncurried	100	0.125241	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : forall v2 : v0, Prop) (v3 v4 : v0) (v5 : v1 v3) (v6 : v1 v4) (v7 : v2 v3) (v8 : v2 v4) (v9 : exists2 v9 : v3 = v4, rew [v1] v9 in v5 = v6 & rew [v2] v9 in v7 = v8) => match v9 as v10 in (ex2 _ _) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v8) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v3 = v4) (v11 : rew [v1] v10 in v5 = v6) (v12 : rew [v2] v10 in v7 = v8) => match v12 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v6 v13) with | eq_refl => match v11 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v4 v13 (rew [v2] v10 in v7)) with | eq_refl => match v10 as v14 in (_ = v13) return (ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v13 (rew [v1] v14 in v5) (rew [v2] v14 in v7)) with | eq_refl => eq_refl : ex_intro2 v1 v2 v3 v5 v7 = ex_intro2 v1 v2 v3 (rew [v1] eq_refl in v5) (rew [v2] eq_refl in v7) end end end) v10 v11 v12 end)).
coq-tactician-stdlib.8.11.dev	Coq.Init.Logic.ex2.rew_ex2	100	0.165202	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall v2 : v0, Type) (v3 : forall (v3 : v0) (v4 : v2 v3), Prop) (v4 : forall (v4 : v0) (v5 : v2 v4), Prop) (v5 : exists2 v5 : v2 v1, v3 v1 v5 & v4 v1 v5) (v6 : v0) (v7 : v1 = v6) => match v7 as v9 in (_ = v8) return (rew [fun v10 : v0 => exists2 v11 : v2 v10, v3 v10 v11 & v4 v10 v11] v9 in v5 = match v5 as v10 in (ex2 _ _) return (exists2 v11 : v2 v8, v3 v8 v11 & v4 v8 v11) with | ex_intro2 _ _ v10 v11 v12 => (fun (v10 : v2 v1) (v11 : v3 v1 v10) (v12 : v4 v1 v10) => ex_intro2 (v3 v8) (v4 v8) (rew [v2] v9 in v10) match v9 as v14 in (_ = v13) return (v3 v13 (rew [v2] v14 in v10)) with | eq_refl => v11 end match v9 as v14 in (_ = v13) return (v4 v13 (rew [v2] v14 in v10)) with | eq_refl => v12 end) v10 v11 v12 end) with | eq_refl => match v5 as v8 in (ex2 _ _) return (rew [fun v9 : v0 => exists2 v10 : v2 v9, v3 v9 v10 & v4 v9 v10] eq_refl in v8 = match v8 as v9 in (ex2 _ _) return (exists2 v10 : v2 v1, v3 v1 v10 & v4 v1 v10) with | ex_intro2 _ _ v9 v10 v11 => (fun (v9 : v2 v1) (v10 : v3 v1 v9) (v11 : v4 v1 v9) => ex_intro2 (v3 v1) (v4 v1) (rew [v2] eq_refl in v9) v10 v11) v9 v10 v11 end) with | ex_intro2 _ _ v8 v9 v10 => (fun (v8 : v2 v1) (v9 : v3 v1 v8) (v10 : v4 v1 v8) => eq_refl) v8 v9 v10 end end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_eq_iff	100	0.151439	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Eq <-> v0 == v1) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Eq => v2) (fun v3 : v0 == v1 => eq_refl)) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Eq => let v4 : forall v4 : @Eq = @Eq, v0 == v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, v0 == v1) with | eq_refl => fun v4 : @Lt = @Eq => (fun v5 : @Lt = @Eq => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (v0 == v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 == v1 => False_ind (@Lt = @Eq) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v1) (v1 < v1) (lt_compat v4 (reflexive_proper_proxy Equivalence_Reflexive v1))) v3 (irreflexivity (x:=v1)) : forall v4 : v0 < v1, @False) v2))) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Eq => let v4 : forall v4 : @Eq = @Eq, v0 == v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, v0 == v1) with | eq_refl => fun v4 : @Gt = @Eq => (fun v5 : @Gt = @Eq => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (v0 == v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 == v1 => False_ind (@Gt = @Eq) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v1 < v0) (v1 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v0 v1 v4)) v3 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_eq	100	0.069723	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => let v2 : forall (v2 v3 : @t) (v4 : (v2 ?= v3) = @Eq), v2 == v3 := fun v2 v3 : @t => match compare_eq_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Eq, v2 == v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Eq, v2 == v3) (v5 : forall v5 : v2 == v3, (v2 ?= v3) = @Eq) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_lt_iff	100	0.170700	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Lt <-> v0 < v1) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Lt => let v4 : forall v4 : @Lt = @Lt, v0 < v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, v0 < v1) with | eq_refl => fun v4 : @Eq = @Lt => (fun v5 : @Eq = @Lt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (v0 < v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 < v1 => False_ind (@Eq = @Lt) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v1) (v1 < v1) (lt_compat v4 (reflexive_proper_proxy Equivalence_Reflexive v1))) v2 (irreflexivity (x:=v1)) : forall v4 : v0 < v1, @False) v3))) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Lt => v2) (fun v3 : v0 < v1 => eq_refl)) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Lt => let v4 : forall v4 : @Lt = @Lt, v0 < v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, v0 < v1) with | eq_refl => fun v4 : @Gt = @Lt => (fun v5 : @Gt = @Lt => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (v0 < v1) v6) v4 end in v4 eq_refl) (fun v3 : v0 < v1 => False_ind (@Gt = @Lt) (((fun v4 : v1 < v0 => proper_normalizes_proper (forall v5 : Prop, Prop) (flip_arrow (flip_atom Prop (@impl)) (flip_atom Prop (flip (@impl)))) (proper_flip_proper (subrelation_proper (@Morphisms_Prop.not_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (flip (@impl))) (flip2 (subrelation_refl (@impl)))))) (v0 < v1) (v0 < v0) (trans_co_impl_morphism StrictOrder_Transitive v1 v0 v4)) v2 (irreflexivity (x:=v0)) : forall v4 : v0 < v1, @False) v3))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_gt_iff	100	0.214379	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return (v2 = @Gt <-> v1 < v0) with | CompEq _ _ v2 => (fun v2 : v0 == v1 => conj (fun v3 : @Eq = @Gt => let v4 : forall v4 : @Gt = @Gt, v1 < v0 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, v1 < v0) with | eq_refl => fun v4 : @Eq = @Gt => (fun v5 : @Eq = @Gt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (v1 < v0) v6) v4 end in v4 eq_refl) (fun v3 : v1 < v0 => False_ind (@Eq = @Gt) (((fun v4 : v0 == v1 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v1 < v0) (v1 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v0 v1 v4)) v2 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v3))) v2 | CompLt _ _ v2 => (fun v2 : v0 < v1 => conj (fun v3 : @Lt = @Gt => let v4 : forall v4 : @Gt = @Gt, v1 < v0 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, v1 < v0) with | eq_refl => fun v4 : @Lt = @Gt => (fun v5 : @Lt = @Gt => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (v1 < v0) v6) v4 end in v4 eq_refl) (fun v3 : v1 < v0 => False_ind (@Lt = @Gt) (((fun v4 : v0 < v1 => proper_normalizes_proper (forall v5 : Prop, Prop) (flip_arrow (flip_atom Prop (@impl)) (flip_atom Prop (flip (@impl)))) (proper_flip_proper (subrelation_proper (@Morphisms_Prop.not_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (flip (@impl))) (flip2 (subrelation_refl (@impl)))))) (v1 < v0) (v1 < v1) (trans_co_impl_morphism StrictOrder_Transitive v0 v1 v4)) v2 (irreflexivity (x:=v1)) : forall v4 : v1 < v0, @False) v3))) v2 | CompGt _ _ v2 => (fun v2 : v1 < v0 => conj (fun v3 : @Gt = @Gt => v2) (fun v3 : v1 < v0 => eq_refl)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_nlt_iff	100	0.090726	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Lt) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Lt) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (compare_lt_iff v0 v1) (conj (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1) (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_ngt_iff	100	0.091004	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Gt <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Gt) (~ v1 < v0) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Gt) (v1 < v0) v2) (~ v1 < v0) (~ v1 < v0) (eq_proper_proxy (~ v1 < v0))) (compare_gt_iff v0 v1) (conj (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_compat	100	0.395696	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => (fun (v3 v4 : @t) (v5 : v3 == v4) => match compare_spec v1 v4 as v7 in (CompareSpec _ _ _ v6) return ((v0 ?= v3) = v6) with | CompEq _ _ v6 => (fun v6 : (v0 ?= v3) = @Eq <-> v0 == v3 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) ((v0 ?= v3) = @Eq) (v0 == v3) v6) (compare_eq_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) (v0 == v3) (v1 == v3) (PER_morphism (Equivalence_PER (@eq_equiv)) v0 v1 v6 v3 v3 (reflexive_proper_proxy Equivalence_Reflexive v3))) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 == v4)) (v1 == v3) (v1 == v4) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) v3 v4 v6)) v5 (fun v6 : v1 == v4 => v6))) v6 | CompLt _ _ v6 => (fun v6 : (v0 ?= v3) = @Lt <-> v0 < v3 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) ((v0 ?= v3) = @Lt) (v0 < v3) v6) (compare_lt_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) (v0 < v3) (v1 < v3) (lt_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v3))) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v4)) (v1 < v3) (v1 < v4) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v3 v4 v6)) v5 (fun v6 : v1 < v4 => v6))) v6 | CompGt _ _ v6 => (fun v6 : (v0 ?= v3) = @Gt <-> v3 < v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) ((v0 ?= v3) = @Gt) (v3 < v0) v6) (compare_gt_iff v0 v3) ((fun v6 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) (v3 < v0) (v3 < v1) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v3) v0 v1 v6)) v2 ((fun v6 : v3 == v4 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v4 < v1)) (v3 < v1) (v4 < v1) (lt_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v1))) v5 (fun v6 : v4 < v1 => v6))) v6 end) : (@eq ==> Logic.eq)%signature (compare v0) (compare v1)) : Proper (@eq ==> @eq ==> Logic.eq) (@compare))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_refl	100	0.077669	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => match compare_spec v0 v0 as v2 in (CompareSpec _ _ _ v1) return (v1 = @Eq) with | CompEq _ _ v1 => (fun v1 : v0 == v0 => eq_refl) v1 | CompLt _ _ v1 => (fun v1 : v0 < v0 => False_ind (@Lt = @Eq) (irreflexivity v1)) v1 | CompGt _ _ v1 => (fun v1 : v0 < v0 => False_ind (@Gt = @Eq) (irreflexivity v1)) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareFacts.compare_antisym	100	0.188436	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match compare_spec v0 v1 as v3 in (CompareSpec _ _ _ v2) return ((v1 ?= v0) = CompOpp v2) with | CompEq _ _ v2 => ((fun v2 : (v1 ?= v0) = @Eq <-> v1 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 == v1)) ((v1 ?= v0) = @Eq) (v1 == v0) v2) (compare_eq_iff v1 v0) (fun v2 : v0 == v1 => symmetry v2) : forall v2 : v0 == v1, (v1 ?= v0) = CompOpp (@Eq)) v2 | CompLt _ _ v2 => ((fun v2 : (v1 ?= v0) = @Gt <-> v0 < v1 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 < v1)) ((v1 ?= v0) = @Gt) (v0 < v1) v2) (compare_gt_iff v1 v0) (fun v2 : v0 < v1 => v2) : forall v2 : v0 < v1, (v1 ?= v0) = CompOpp (@Lt)) v2 | CompGt _ _ v2 => ((fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0)) ((v1 ?= v0) = @Lt) (v1 < v0) v2) (compare_lt_iff v1 v0) (fun v2 : v1 < v0 => v2) : forall v2 : v1 < v0, (v1 ?= v0) = CompOpp (@Gt)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_compat	100	0.066378	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_preorder	100	0.052013	1	1	0	synth with cache (only 1: refine {| PreOrder_Reflexive := (fun v0 : @t => OrderTac.le_refl v0) : Reflexive (@le); PreOrder_Transitive := (fun (v0 v1 v2 : @t) (v3 : v0 <= v1) (v4 : v1 <= v2) => OrderTac.not_gt_le ((fun v5 : v2 < v0 => (fun v6 : v1 < v0 => (fun v7 : v0 < v0 => OrderTac.lt_irrefl v7) (OrderTac.le_lt_trans v3 v6)) (OrderTac.le_lt_trans v4 v5)) : ~ v2 < v0)) : Transitive (@le) |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_order	100	0.056707	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj (OrderTac.not_gt_le ((fun v3 : v1 < v0 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2)) : ~ v1 < v0) : v0 <= v1) (OrderTac.not_gt_le ((fun v3 : v0 < v1 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3)) : ~ v0 < v1) : v1 <= v0)) (fun v2 : v0 <= v1 <= v0 => and_ind (fun (v3 : v0 <= v1) (v4 : v1 <= v0) => OrderTac.not_neq_eq ((fun v5 : v0 ~= v1 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v5)) (OrderTac.le_antisym v3 v4)) : ~ v0 ~= v1) : v0 == v1) v2)) : PartialOrder (@eq) (@le))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_antisym	100	0.028940	1	1	0	synth with cache (only 1: refine (partial_order_antisym (@le_order))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_not_gt_iff	100	0.071418	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 <= v1 => (fun v3 : v1 < v0 => False_ind (@False) ((fun v4 : v0 < v0 => OrderTac.lt_irrefl v4) (OrderTac.le_lt_trans v2 v3)) : @False) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (let v3 : v0 <= v1 := OrderTac.not_gt_le v2 in OrderTac.not_gt_le ((fun v4 : v1 < v0 => (fun v5 : v0 < v0 => OrderTac.lt_irrefl v5) (OrderTac.le_lt_trans v3 v4)) : ~ v1 < v0)) : v0 <= v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.lt_not_ge_iff	100	0.068677	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 < v1 => (fun v3 : v1 <= v0 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.le_lt_trans v3 v2)) : @False) : ~ v1 <= v0) (fun v2 : ~ v1 <= v0 => (let v3 : v0 < v1 := OrderTac.not_ge_lt v2 in OrderTac.not_ge_lt ((fun v4 : v1 <= v0 => (fun v5 : v1 < v1 => OrderTac.lt_irrefl v5) (OrderTac.le_lt_trans v4 v3)) : ~ v1 <= v0)) : v0 < v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.le_or_gt	100	0.072349	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <= v1 <-> v0 < v1 \/ v0 == v1 => subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 <= v1) (v0 < v1 \/ v0 == v1) v2 (v1 < v0) (v1 < v0) (reflexive_proper_proxy (@iff_Reflexive) (v1 < v0))) (le_lteq v0 v1) (let v2 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v3 : @comparison := v0 ?= v1 in match v2 as v5 in (CompareSpec _ _ _ v4) return ((v0 < v1 \/ v0 == v1) \/ v1 < v0) with | CompEq _ _ v4 => (fun v4 : v0 == v1 => or_introl (or_intror v4)) v4 | CompLt _ _ v4 => (fun v4 : v0 < v1 => or_introl (or_introl v4)) v4 | CompGt _ _ v4 => (fun v4 : v1 < v0 => or_intror v4) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.lt_or_ge	100	0.083484	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => (fun v2 : v1 <= v0 <-> v1 < v0 \/ v1 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 < v1)) (v1 <= v0) (v1 < v0 \/ v1 == v0) v2) (le_lteq v1 v0) (let v2 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v3 : @comparison := v0 ?= v1 in match v2 as v5 in (CompareSpec _ _ _ v4) return (v0 < v1 \/ v1 < v0 \/ v1 == v0) with | CompEq _ _ v4 => (fun v4 : v0 == v1 => or_intror (or_intror (OrderTac.not_neq_eq ((fun v5 : v1 ~= v0 => (fun v6 : v1 ~= v1 => v6 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v5 v4)) : ~ v1 ~= v0) : v1 == v0))) v4 | CompLt _ _ v4 => (fun v4 : v0 < v1 => or_introl v4) v4 | CompGt _ _ v4 => (fun v4 : v1 < v0 => or_intror (or_introl v4)) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.eq_is_le_ge	100	0.054275	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj (OrderTac.not_gt_le ((fun v3 : v1 < v0 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2)) : ~ v1 < v0) : v0 <= v1) (OrderTac.not_gt_le ((fun v3 : v0 < v1 => (fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3)) : ~ v0 < v1) : v1 <= v0)) (fun v2 : v0 <= v1 <= v0 => and_ind (fun (v3 : v0 <= v1) (v4 : v1 <= v0) => OrderTac.not_neq_eq ((fun v5 : v0 ~= v1 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v5)) (OrderTac.le_antisym v3 v4)) : ~ v0 ~= v1) : v0 == v1) v2))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.compare_le_iff	100	0.054401	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <= v1 <-> ~ v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <= v1) (~ v1 < v0) v2) (le_not_gt_iff v0 v1) (compare_ngt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFullFacts.compare_ge_iff	100	0.055108	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v1 <= v0 <-> ~ v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) (~ v0 < v1) v2) (le_not_gt_iff v1 v0) (compare_nlt_iff v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.lt_dec	100	0.058794	0	1
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.if_eq_dec	100	0.156084	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : Type) (v3 v4 : v2) => let v5 : {v0 == v1} + {v0 ~= v1} := eq_dec v0 v1 in match v5 as v6 in ({_} + {_}) return (match v6 as v7 in ({_} + {_}) return v2 with | left v7 => (fun v7 : v0 == v1 => v3) v7 | right v7 => (fun v7 : v0 ~= v1 => v4) v7 end = match v0 ?= v1 as v7 in comparison return v2 with | Eq => v3 | _ => v4 end) with | left v6 => (fun v6 : v0 == v1 => let v7 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v8 : @comparison := v0 ?= v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (v3 = match v9 as v11 in comparison return v2 with | Eq => v3 | _ => v4 end) with | CompEq _ _ v9 => (fun v9 : v0 == v1 => Logic.eq_refl) v9 | CompLt _ _ v9 => (fun v9 : v0 < v1 => False_ind (v3 = v4) ((fun v10 : v1 < v1 => OrderTac.lt_irrefl v10) (OrderTac.eq_lt (OrderTac.eq_sym v6) v9))) v9 | CompGt _ _ v9 => (fun v9 : v1 < v0 => False_ind (v3 = v4) ((fun v10 : v1 < v1 => OrderTac.lt_irrefl v10) (OrderTac.lt_eq v9 v6))) v9 end) v6 | right v6 => (fun v6 : v0 ~= v1 => let v7 : CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1) := compare_spec v0 v1 in let v8 : @comparison := v0 ?= v1 in match v7 as v10 in (CompareSpec _ _ _ v9) return (v4 = match v9 as v11 in comparison return v2 with | Eq => v3 | _ => v4 end) with | CompEq _ _ v9 => (fun v9 : v0 == v1 => False_ind (v4 = v3) ((fun v10 : v1 ~= v1 => v10 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v9) v6))) v9 | CompLt _ _ v9 => (fun v9 : v0 < v1 => Logic.eq_refl) v9 | CompGt _ _ v9 => (fun v9 : v1 < v0 => Logic.eq_refl) v9 end) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.eqb_alt	100	0.061887	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @t => if_eq_dec v0 v1 (@true) (@false)) : forall v0 v1 : @t, eqb v0 v1 = match v0 ?= v1 as v2 in comparison return (@bool) with | Eq => @true | _ => @false end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeFacts.eqb_compat	100	0.232635	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => (fun (v3 v4 : @t) (v5 : v3 == v4) => eq_ind_r (fun v6 : @bool => v6 = eqb v1 v4) (eq_ind_r (fun v6 : @bool => match v0 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end = v6) ((fun v6 : v0 == v1 => trans_co_eq_inv_impl_morphism eq_Transitive match v0 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (f_equal (fun v7 : @comparison => match v7 as v8 in comparison return (@bool) with | Eq => @true | _ => @false end) (compare_compat v6 (reflexive_proper_proxy Equivalence_Reflexive v3))) match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (eq_proper_proxy match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end)) v2 ((fun v6 : v3 == v4 => trans_co_eq_inv_impl_morphism eq_Transitive match v1 ?= v3 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (f_equal (fun v7 : @comparison => match v7 as v8 in comparison return (@bool) with | Eq => @true | _ => @false end) (Reflexive_partial_app_morphism (@compare_compat) (reflexive_proper_proxy Equivalence_Reflexive v1) v3 v4 v6)) match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end (eq_proper_proxy match v1 ?= v4 as v7 in comparison return (@bool) with | Eq => @true | _ => @false end)) v5 Logic.eq_refl)) (eqb_alt v1 v4)) (eqb_alt v0 v3)) : (@eq ==> Logic.eq)%signature (eqb v0) (eqb v1)) : Proper (@eq ==> @eq ==> Logic.eq) (@eqb))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_not_eq	100	0.038450	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : v0 < v1) => (fun v3 : v0 == v1 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v3) v2))) : v0 ~= v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_eq	100	0.068568	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_lt	100	0.067413	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_eq	100	0.057235	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 <= v1) (v4 : v1 == v2) => let v5 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v3 in (fun v6 : v2 < v0 => False_ind (@False) ((fun v7 : OrderTac.OTF.le v0 v2 => (fun v8 : v0 < v0 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v7 v6)) (OrderTac.le_eq v5 v4))) : v0 <= v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_le	100	0.055098	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 == v1) (v4 : v1 <= v2) => let v5 : OrderTac.OTF.le v1 v2 := OrderTac.not_gt_le v4 in (fun v6 : v2 < v0 => False_ind (@False) ((fun v7 : v2 < v1 => (fun v8 : v1 < v1 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v5 v7)) (OrderTac.lt_eq v6 v3))) : v0 <= v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.neq_eq	100	0.056615	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_neq	100	0.056065	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_lt_trans	100	0.060551	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_le_trans	100	0.060414	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_trans	100	0.065052	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_antisym	100	0.074284	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.le_neq	100	0.064955	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : v0 <= v1) (v3 : v0 ~= v1) => let v4 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v2 in OrderTac.not_ge_lt ((fun v5 : OrderTac.OTF.le v1 v0 => (fun v6 : v0 == v1 => (fun v7 : v1 ~= v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v6) v3)) (OrderTac.le_antisym v4 v5)) : ~ OrderTac.OTF.le v1 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.neq_sym	100	0.039039	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_le	100	0.035662	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.gt_not_eq	100	0.036033	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_not_lt	100	0.038494	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_not_gt	100	0.036571	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.lt_not_gt	100	0.036095	1	2
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeTest.eq_is_nlt_ngt	100	0.068086	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => conj (fun v2 : v0 == v1 => conj ((fun v3 : v0 < v1 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3))) : v1 <= v0) ((fun v3 : v1 < v0 => False_ind (@False) ((fun v4 : v1 < v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2))) : v0 <= v1)) (fun v2 : v1 <= v0 /\ v0 <= v1 => and_ind (fun (v3 : v1 <= v0) (v4 : v0 <= v1) => let v5 : OrderTac.OTF.le v0 v1 := OrderTac.not_gt_le v4 in let v6 : OrderTac.OTF.le v1 v0 := OrderTac.not_gt_le v3 in OrderTac.not_neq_eq ((fun v7 : v0 ~= v1 => (fun v8 : v1 == v0 => (fun v9 : v0 ~= v0 => v9 (OrderTac.eq_refl v0)) (OrderTac.neq_eq v7 v8)) (OrderTac.le_antisym v6 v5)) : ~ v0 ~= v1)) v2))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.lt_strorder	100	0.019657	1	1	0	synth with cache (only 1: refine (flip_StrictOrder (@O.lt_strorder) : StrictOrder (@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.lt_compat	100	0.050428	1	1	0	synth with cache (only 1: refine (flip_proper (@O.lt_compat) : Proper (@eq ==> @eq ==> @iff) (@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.le_lteq	100	0.077260	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @O.t => (((fun v2 : O.le v1 v0 <-> O.lt v1 v0 \/ O.eq v1 v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (O.le v1 v0) (O.lt v1 v0 \/ O.eq v1 v0) v2 (O.lt v1 v0 \/ eq v0 v1) (O.lt v1 v0 \/ eq v0 v1) (eq_proper_proxy (O.lt v1 v0 \/ eq v0 v1))) (O.le_lteq v1 v0) (conj (fun v2 : O.lt v1 v0 \/ O.eq v1 v0 => or_ind (fun v3 : O.lt v1 v0 => or_introl v3) (fun v3 : O.eq v1 v0 => or_intror (symmetry v3 : eq v0 v1)) v2) (fun v2 : O.lt v1 v0 \/ eq v0 v1 => or_ind (fun v3 : O.lt v1 v0 => or_introl v3) (fun v3 : eq v0 v1 => or_intror (symmetry v3 : O.eq v1 v0)) v2)) : flip (@O.le) v0 v1 <-> flip (@O.lt) v0 v1 \/ eq v0 v1) : flip (@O.le) v0 v1 <-> lt v0 v1 \/ eq v0 v1) : le v0 v1 <-> lt v0 v1 \/ eq v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.OrderedTypeRev.compare_spec	100	0.071082	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @O.t => ((((let v2 : CompareSpec (O.eq v1 v0) (O.lt v1 v0) (O.lt v0 v1) (O.compare v1 v0) := O.compare_spec v1 v0 in let v3 : @comparison := O.compare v1 v0 in match v2 as v5 in (CompareSpec _ _ _ v4) return (CompSpec (@O.eq) (fun v6 v7 : @O.t => O.lt v7 v6) v0 v1 v4) with | CompEq _ _ v4 => (fun v4 : O.eq v1 v0 => CompEq (O.lt v1 v0) (O.lt v0 v1) (symmetry v4) : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Eq)) v4 | CompLt _ _ v4 => (fun v4 : O.lt v1 v0 => CompLt (O.eq v0 v1) (O.lt v0 v1) v4 : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Lt)) v4 | CompGt _ _ v4 => (fun v4 : O.lt v0 v1 => CompGt (O.eq v0 v1) (O.lt v1 v0) v4 : CompSpec (@O.eq) (fun v5 v6 : @O.t => O.lt v6 v5) v0 v1 (@Gt)) v4 end) : CompSpec (@O.eq) (flip (@O.lt)) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@O.eq) (@lt) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@eq) (@lt) v0 v1 (flip (@O.compare) v0 v1)) : CompSpec (@eq) (@lt) v0 v1 (compare v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_spec	100	0.123520	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (match v0 ?= v1 as v2 in comparison return (forall v3 : (v0 ?= v1) = v2, CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) v2) with | Eq => fun v2 : (v0 ?= v1) = @Eq => CompEq (v0 < v1) (v1 < v0) (let v3 : forall (v3 v4 : @t) (v5 : (v3 ?= v4) = @Eq), v3 == v4 := fun v3 v4 : @t => match compare_eq_iff v3 v4 as v5 in (_ /\ _) return (forall v6 : (v3 ?= v4) = @Eq, v3 == v4) with | conj v5 v6 => (fun (v5 : forall v5 : (v3 ?= v4) = @Eq, v3 == v4) (v6 : forall v6 : v3 == v4, (v3 ?= v4) = @Eq) => v5) v5 v6 end in v3 v0 v1 v2) | Lt => fun v2 : (v0 ?= v1) = @Lt => CompLt (v0 == v1) (v1 < v0) (let v3 : forall (v3 v4 : @t) (v5 : (v3 ?= v4) = @Lt), v3 < v4 := fun v3 v4 : @t => match compare_lt_iff v3 v4 as v5 in (_ /\ _) return (forall v6 : (v3 ?= v4) = @Lt, v3 < v4) with | conj v5 v6 => (fun (v5 : forall v5 : (v3 ?= v4) = @Lt, v3 < v4) (v6 : forall v6 : v3 < v4, (v3 ?= v4) = @Lt) => v5) v5 v6 end in v3 v0 v1 v2) | Gt => fun v2 : (v0 ?= v1) = @Gt => CompGt (v0 == v1) (v0 < v1) (let v3 : CompOpp (v1 ?= v0) = @Gt := eq_ind (v0 ?= v1) (fun v3 : @comparison => v3 = @Gt) v2 (CompOpp (v1 ?= v0)) (compare_antisym v1 v0) in let v4 : forall (v4 v5 : @t) (v6 : (v4 ?= v5) = @Lt), v4 < v5 := fun v4 v5 : @t => match compare_lt_iff v4 v5 as v6 in (_ /\ _) return (forall v7 : (v4 ?= v5) = @Lt, v4 < v5) with | conj v6 v7 => (fun (v6 : forall v6 : (v4 ?= v5) = @Lt, v4 < v5) (v7 : forall v7 : v4 < v5, (v4 ?= v5) = @Lt) => v6) v6 v7 end in v4 v1 v0 ((fun v5 : CompOpp (v1 ?= v0) = @Gt <-> (v1 ?= v0) = CompOpp (@Gt) => iff_impl_subrelation (CompOpp (v1 ?= v0) = @Gt) ((v1 ?= v0) = CompOpp (@Gt)) v5) (CompOpp_iff (v1 ?= v0) (@Gt)) v3)) end : forall v2 : (v0 ?= v1) = (v0 ?= v1), CompareSpec (v0 == v1) (v0 < v1) (v1 < v0) (v0 ?= v1)) eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_eq	100	0.068633	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => let v2 : forall (v2 v3 : @t) (v4 : (v2 ?= v3) = @Eq), v2 == v3 := fun v2 v3 : @t => match compare_eq_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : (v2 ?= v3) = @Eq, v2 == v3) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Eq, v2 == v3) (v5 : forall v5 : v2 == v3, (v2 ?= v3) = @Eq) => v4) v4 v5 end in v2 v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_refl	100	0.070049	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v1 == v2), (v1 ?= v2) = @Eq := fun v1 v2 : @t => match compare_eq_iff v1 v2 as v3 in (_ /\ _) return (forall v4 : v1 == v2, (v1 ?= v2) = @Eq) with | conj v3 v4 => (fun (v3 : forall v3 : (v1 ?= v2) = @Eq, v1 == v2) (v4 : forall v4 : v1 == v2, (v1 ?= v2) = @Eq) => v4) v3 v4 end in v1 v0 v0 (reflexivity v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_gt_iff	100	0.063882	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v2)) (compare_lt_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 = @Gt <-> (v1 ?= v0) = @Lt) ((fun v2 : CompOpp (v1 ?= v0) = @Gt <-> (v1 ?= v0) = CompOpp (@Gt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) = @Gt) ((v1 ?= v0) = CompOpp (@Gt)) v2 ((v1 ?= v0) = @Lt) ((v1 ?= v0) = @Lt) (eq_proper_proxy ((v1 ?= v0) = @Lt))) (CompOpp_iff (v1 ?= v0) (@Gt)) (reflexivity ((v1 ?= v0) = @Lt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_ge_iff	100	0.069045	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v2)) (compare_le_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 <> @Lt <-> (v1 ?= v0) <> @Gt) ((fun v2 : CompOpp (v1 ?= v0) = @Lt <-> (v1 ?= v0) = CompOpp (@Lt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) <> @Lt) ((v1 ?= v0) <> CompOpp (@Lt)) (Morphisms_Prop.not_iff_morphism (CompOpp (v1 ?= v0) = @Lt) ((v1 ?= v0) = CompOpp (@Lt)) v2) ((v1 ?= v0) <> @Gt) ((v1 ?= v0) <> @Gt) (eq_proper_proxy ((v1 ?= v0) <> @Gt))) (CompOpp_iff (v1 ?= v0) (@Lt)) (reflexivity ((v1 ?= v0) <> @Gt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_ngt_iff	100	0.091380	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Gt <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Gt) (~ v1 < v0) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Gt) (v1 < v0) v2) (~ v1 < v0) (~ v1 < v0) (eq_proper_proxy (~ v1 < v0))) (compare_gt_iff v0 v1) (conj (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0) (fun v2 : ~ v1 < v0 => (fun v3 : v1 < v0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v1 < v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nlt_iff	100	0.089337	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 ?= v1) <> @Lt) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism ((v0 ?= v1) = @Lt) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (compare_lt_iff v0 v1) (conj (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1) (fun v2 : ~ v0 < v1 => (fun v3 : v0 < v1 => let v4 : @False := v2 v3 in False_ind (@False) v4) : ~ v0 < v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nle_iff	100	0.247972	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (~ v0 <= v1) (~ (v0 ?= v1) <> @Gt) (Morphisms_Prop.not_iff_morphism (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2))) (compare_le_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Gt <-> ~ v3 <> @Gt) with | Eq => conj (fun v3 : @Eq = @Gt => let v4 : forall v4 : @Gt = @Gt, ~ @Eq <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, ~ @Eq <> @Gt) with | eq_refl => fun v4 : @Eq = @Gt => (fun v5 : @Eq = @Gt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (~ @Eq <> @Gt) v6) v4 end in v4 eq_refl) (fun v3 : ~ @Eq <> @Gt => let v4 : @False := v3 ((fun v4 : @Eq = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Eq = @Gt => (fun v6 : @Eq = @Gt => let v7 : @False := eq_ind (@Eq) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Eq <> @Gt) in match v4 as v5 in False return (@Eq = @Gt) with end) | Lt => conj (fun v3 : @Lt = @Gt => let v4 : forall v4 : @Gt = @Gt, ~ @Lt <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Gt, ~ @Lt <> @Gt) with | eq_refl => fun v4 : @Lt = @Gt => (fun v5 : @Lt = @Gt => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v5 in False_ind (~ @Lt <> @Gt) v6) v4 end in v4 eq_refl) (fun v3 : ~ @Lt <> @Gt => let v4 : @False := v3 ((fun v4 : @Lt = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Lt = @Gt => (fun v6 : @Lt = @Gt => let v7 : @False := eq_ind (@Lt) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Lt <> @Gt) in match v4 as v5 in False return (@Lt = @Gt) with end) | Gt => conj (fun v3 : @Gt = @Gt => (fun v4 : @Gt <> @Gt => False_ind (@False) (v4 eq_refl)) : ~ @Gt <> @Gt) (fun v3 : ~ @Gt <> @Gt => eq_refl) end))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.compare_nge_iff	100	0.067280	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v1 ?= v0) = @Gt <-> ~ v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (~ v1 <= v0) ((v1 ?= v0) = @Gt) (symmetry v2)) (compare_nle_iff v1 v0) (eq_ind_r (fun v2 : @comparison => v2 = @Lt <-> (v1 ?= v0) = @Gt) ((fun v2 : CompOpp (v1 ?= v0) = @Lt <-> (v1 ?= v0) = CompOpp (@Lt) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (CompOpp (v1 ?= v0) = @Lt) ((v1 ?= v0) = CompOpp (@Lt)) v2 ((v1 ?= v0) = @Gt) ((v1 ?= v0) = @Gt) (eq_proper_proxy ((v1 ?= v0) = @Gt))) (CompOpp_iff (v1 ?= v0) (@Lt)) (reflexivity ((v1 ?= v0) = @Gt))) (compare_antisym v1 v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.lt_irrefl	100	0.066735	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => (fun v1 : (v0 ?= v0) = @Lt <-> v0 < v0 => subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)) (v0 < v0) ((v0 ?= v0) = @Lt) (symmetry v1)) (compare_lt_iff v0 v0) (eq_ind_r (fun v1 : @comparison => v1 <> @Lt) ((fun v1 : @Eq = @Lt => let v2 : forall v2 : @Lt = @Lt, @False := match v1 as v3 in (_ = v2) return (forall v4 : v2 = @Lt, @False) with | eq_refl => fun v2 : @Eq = @Lt => (fun v3 : @Eq = @Lt => let v4 : @False := eq_ind (@Eq) (fun v4 : @comparison => match v4 as v5 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v3 in False_ind (@False) v4) v2 end in v2 eq_refl) : @Eq <> @Lt) (compare_refl v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.CompareBasedOrderFacts.lt_eq_cases	100	0.424590	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 < v1 \/ v0 == v1) ((v0 ?= v1) = @Lt \/ v0 == v1) (Morphisms_Prop.or_iff_morphism (v0 < v1) ((v0 ?= v1) = @Lt) (symmetry v2) (v0 == v1) (v0 == v1) (reflexive_proper_proxy (@iff_Reflexive) (v0 == v1)))) (compare_lt_iff v0 v1) ((fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2) ((v0 ?= v1) = @Lt \/ v0 == v1) ((v0 ?= v1) = @Lt \/ v0 == v1) (eq_proper_proxy ((v0 ?= v1) = @Lt \/ v0 == v1))) (compare_le_iff v0 v1) ((fun v2 : (v0 ?= v1) = @Eq <-> v0 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v0 ?= v1) = @Lt \/ v0 == v1) ((v0 ?= v1) = @Lt \/ (v0 ?= v1) = @Eq) (Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) ((v0 ?= v1) = @Lt)) (v0 == v1) ((v0 ?= v1) = @Eq) (symmetry v2))) (compare_eq_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 <> @Gt <-> v3 = @Lt \/ v3 = @Eq) with | Eq => conj (fun v3 : @Eq <> @Gt => or_intror eq_refl) (fun v3 : @Eq = @Lt \/ @Eq = @Eq => (fun v4 : @Eq = @Gt => or_ind (fun v5 : @Eq = @Lt => let v6 : forall v6 : @Lt = @Lt, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Lt, @False) with | eq_refl => fun v6 : @Eq = @Lt => (fun v7 : @Eq = @Lt => let v8 : @False := eq_ind (@Eq) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Eq = @Eq => let v6 : forall v6 : @Gt = @Gt, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Gt, @False) with | eq_refl => fun v6 : @Eq = @Gt => (fun v7 : @Eq = @Gt => let v8 : @False := eq_ind (@Eq) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Eq <> @Gt) | Lt => conj (fun v3 : @Lt <> @Gt => or_introl eq_refl) (fun v3 : @Lt = @Lt \/ @Lt = @Eq => (fun v4 : @Lt = @Gt => or_ind (fun v5 : @Lt = @Lt => let v6 : forall v6 : @Gt = @Gt, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Gt, @False) with | eq_refl => fun v6 : @Lt = @Gt => (fun v7 : @Lt = @Gt => let v8 : @False := eq_ind (@Lt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Lt = @Eq => let v6 : forall v6 : @Eq = @Eq, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Eq, @False) with | eq_refl => fun v6 : @Lt = @Eq => (fun v7 : @Lt = @Eq => let v8 : @False := eq_ind (@Lt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Lt <> @Gt) | Gt => conj (fun v3 : @Gt <> @Gt => let v4 : @False := let v4 : @Gt = @Gt := eq_refl in v3 v4 in (fun v5 : @False => False_ind (@Gt = @Lt \/ @Gt = @Eq) v5) v4) (fun v3 : @Gt = @Lt \/ @Gt = @Eq => (fun v4 : @Gt = @Gt => or_ind (fun v5 : @Gt = @Lt => let v6 : forall v6 : @Lt = @Lt, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Lt, @False) with | eq_refl => fun v6 : @Gt = @Lt => (fun v7 : @Gt = @Lt => let v8 : @False := eq_ind (@Gt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) (fun v5 : @Gt = @Eq => let v6 : forall v6 : @Eq = @Eq, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = @Eq, @False) with | eq_refl => fun v6 : @Gt = @Eq => (fun v7 : @Gt = @Eq => let v8 : @False := eq_ind (@Gt) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v7 in False_ind (@False) v8) v6 end in v6 eq_refl) v3) : @Gt <> @Gt) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_spec0	100	0.034678	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => iff_reflect (v0 <= v1) (v0 <=? v1) (symmetry (leb_le v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_spec	100	0.125969	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match leb_spec0 v0 v1 as v3 in (reflect _ v2) return (BoolSpec (v0 <= v1) (v1 < v0) v2) with | ReflectT _ v2 => (fun v2 : v0 <= v1 => BoolSpecT (v1 < v0) v2) v2 | ReflectF _ v2 => (fun v2 : ~ v0 <= v1 => BoolSpecF (v0 <= v1) ((fun v3 : (v1 ?= v0) = @Lt <-> v1 < v0 => iff_flip_impl_subrelation (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v3)) (compare_lt_iff v1 v0) ((fun v3 : (v1 ?= v0) = @Lt <-> ~ v0 <= v1 => iff_flip_impl_subrelation ((v1 ?= v0) = @Lt) (~ v0 <= v1) v3) (compare_nge_iff v1 v0) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_spec0	100	0.035278	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => iff_reflect (v0 < v1) (v0 <? v1) (symmetry (ltb_lt v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_spec	100	0.056476	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => match ltb_spec0 v0 v1 as v3 in (reflect _ v2) return (BoolSpec (v0 < v1) (v1 <= v0) v2) with | ReflectT _ v2 => (fun v2 : v0 < v1 => BoolSpecT (v1 <= v0) v2) v2 | ReflectF _ v2 => (fun v2 : ~ v0 < v1 => BoolSpecF (v0 < v1) ((fun v3 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => iff_flip_impl_subrelation (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v3)) (compare_le_iff v1 v0) ((fun v3 : (v1 ?= v0) <> @Gt <-> ~ v0 < v1 => iff_flip_impl_subrelation ((v1 ?= v0) <> @Gt) (~ v0 < v1) v3) (compare_ngt_iff v1 v0) v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_nle	100	0.057986	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <=? v1 <> @true <-> v0 <=? v1 = @false => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @false) (v0 <=? v1 <> @true) (symmetry v2) (~ v0 <= v1) (~ v0 <= v1) (eq_proper_proxy (~ v0 <= v1))) (not_true_iff_false (v0 <=? v1)) ((fun v2 : v0 <=? v1 = @true <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 <> @true) (~ v0 <= v1) (Morphisms_Prop.not_iff_morphism (v0 <=? v1 = @true) (v0 <= v1) v2) (~ v0 <= v1) (~ v0 <= v1) (eq_proper_proxy (~ v0 <= v1))) (leb_le v0 v1) (reflexivity (~ v0 <= v1))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_gt	100	0.056622	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <=? v1 = @false <-> ~ v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @false) (~ v0 <= v1) v2 (v1 < v0) (v1 < v0) (eq_proper_proxy (v1 < v0))) (leb_nle v0 v1) ((fun v2 : (v1 ?= v0) = @Lt <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 < v0) ((v1 ?= v0) = @Lt) (symmetry v2)) (compare_lt_iff v1 v0) ((fun v2 : (v1 ?= v0) = @Lt <-> ~ v0 <= v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v1 ?= v0) = @Lt) (~ v0 <= v1) v2) (compare_nge_iff v1 v0) (reflexivity (~ v0 <= v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_nlt	100	0.059811	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <? v1 <> @true <-> v0 <? v1 = @false => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @false) (v0 <? v1 <> @true) (symmetry v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (not_true_iff_false (v0 <? v1)) ((fun v2 : v0 <? v1 = @true <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 <> @true) (~ v0 < v1) (Morphisms_Prop.not_iff_morphism (v0 <? v1 = @true) (v0 < v1) v2) (~ v0 < v1) (~ v0 < v1) (eq_proper_proxy (~ v0 < v1))) (ltb_lt v0 v1) (reflexivity (~ v0 < v1))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_ge	100	0.059192	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => (fun v2 : v0 <? v1 = @false <-> ~ v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @false) (~ v0 < v1) v2 (v1 <= v0) (v1 <= v0) (eq_proper_proxy (v1 <= v0))) (ltb_nlt v0 v1) ((fun v2 : (v1 ?= v0) <> @Gt <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v1 <= v0) ((v1 ?= v0) <> @Gt) (symmetry v2)) (compare_le_iff v1 v0) ((fun v2 : (v1 ?= v0) <> @Gt <-> ~ v0 < v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) ((v1 ?= v0) <> @Gt) (~ v0 < v1) v2) (compare_ngt_iff v1 v0) (reflexivity (~ v0 < v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_refl	100	0.064403	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v1 <= v2), v1 <=? v2 = @true := fun v1 v2 : @t => match leb_le v1 v2 as v3 in (_ /\ _) return (forall v4 : v1 <= v2, v1 <=? v2 = @true) with | conj v3 v4 => (fun (v3 : forall v3 : v1 <=? v2 = @true, v1 <= v2) (v4 : forall v4 : v1 <= v2, v1 <=? v2 = @true) => v4) v3 v4 end in v1 v0 v0 (let v2 : forall (v2 v3 : @t) (v4 : v2 < v3 \/ v2 == v3), v2 <= v3 := fun v2 v3 : @t => match lt_eq_cases v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 <= v3, v2 < v3 \/ v2 == v3) (v5 : forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) => v5) v4 v5 end in v2 v0 v0 (or_intror (reflexivity v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_antisym	100	0.058591	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v1 <=? v0) (negb (v0 <? v1)) ((fun v2 : negb (v0 <? v1) = @true <-> v0 <? v1 = @false => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (negb (v0 <? v1) = @true) (v0 <? v1 = @false) v2) (negb_true_iff (v0 <? v1)) ((fun v2 : v1 <=? v0 = @true <-> v1 <= v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v1 <=? v0 = @true) (v1 <= v0) v2 (v0 <? v1 = @false) (v0 <? v1 = @false) (eq_proper_proxy (v0 <? v1 = @false))) (leb_le v1 v0) ((fun v2 : v0 <? v1 = @false <-> v1 <= v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <? v1 = @false) (v1 <= v0) v2) (ltb_ge v0 v1) (reflexivity (v1 <= v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_irrefl	100	0.060718	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @t => let v1 : forall (v1 v2 : @t) (v3 : v2 <= v1), v1 <? v2 = @false := fun v1 v2 : @t => match ltb_ge v1 v2 as v3 in (_ /\ _) return (forall v4 : v2 <= v1, v1 <? v2 = @false) with | conj v3 v4 => (fun (v3 : forall v3 : v1 <? v2 = @false, v2 <= v1) (v4 : forall v4 : v2 <= v1, v1 <? v2 = @false) => v4) v3 v4 end in v1 v0 v0 (let v2 : forall (v2 v3 : @t) (v4 : v2 < v3 \/ v2 == v3), v2 <= v3 := fun v2 v3 : @t => match lt_eq_cases v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) with | conj v4 v5 => (fun (v4 : forall v4 : v2 <= v3, v2 < v3 \/ v2 == v3) (v5 : forall v5 : v2 < v3 \/ v2 == v3, v2 <= v3) => v5) v4 v5 end in v2 v0 v0 (or_intror (reflexivity v0))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_antisym	100	0.055928	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v1 <? v0) (negb (v0 <=? v1)) ((fun v2 : negb (v0 <=? v1) = @true <-> v0 <=? v1 = @false => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (negb (v0 <=? v1) = @true) (v0 <=? v1 = @false) v2) (negb_true_iff (v0 <=? v1)) ((fun v2 : v1 <? v0 = @true <-> v1 < v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v1 <? v0 = @true) (v1 < v0) v2 (v0 <=? v1 = @false) (v0 <=? v1 = @false) (eq_proper_proxy (v0 <=? v1 = @false))) (ltb_lt v1 v0) ((fun v2 : v0 <=? v1 = @false <-> v1 < v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <=? v1 = @false) (v1 < v0) v2) (leb_gt v0 v1) (reflexivity (v1 < v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.eqb_compare	100	0.355649	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 =? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Eq => @true | _ => @false end ((fun v2 : (v0 =? v1) = @true <-> v0 == v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v0 =? v1) = @true) (v0 == v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true))) (eqb_eq v0 v1) ((fun v2 : (v0 ?= v1) = @Eq <-> v0 == v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 == v1) ((v0 ?= v1) = @Eq) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true))) (compare_eq_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Eq <-> match v3 as v4 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) with | Eq => conj (fun v3 : @Eq = @Eq => eq_refl) (fun v3 : @true = @true => eq_refl) | Lt => conj (fun v3 : @Lt = @Eq => let v4 : forall v4 : @Eq = @Eq, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, @false = @true) with | eq_refl => fun v4 : @Lt = @Eq => (fun v5 : @Lt = @Eq => let v6 : @False := eq_ind (@Lt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Lt = @Eq := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Lt = @Eq) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Lt = @Eq) v6) v4 end in v4 eq_refl) | Gt => conj (fun v3 : @Gt = @Eq => let v4 : forall v4 : @Eq = @Eq, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Eq, @false = @true) with | eq_refl => fun v4 : @Gt = @Eq => (fun v5 : @Gt = @Eq => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt = @Eq := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt = @Eq) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt = @Eq) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.ltb_compare	100	0.343871	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 <? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Lt => @true | _ => @false end ((fun v2 : v0 <? v1 = @true <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <? v1 = @true) (v0 < v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true))) (ltb_lt v0 v1) ((fun v2 : (v0 ?= v1) = @Lt <-> v0 < v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 < v1) ((v0 ?= v1) = @Lt) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Lt => @true | _ => @false end = @true))) (compare_lt_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 = @Lt <-> match v3 as v4 in comparison return (@bool) with | Lt => @true | _ => @false end = @true) with | Eq => conj (fun v3 : @Eq = @Lt => let v4 : forall v4 : @Lt = @Lt, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, @false = @true) with | eq_refl => fun v4 : @Eq = @Lt => (fun v5 : @Eq = @Lt => let v6 : @False := eq_ind (@Eq) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Eq = @Lt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Eq = @Lt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Eq = @Lt) v6) v4 end in v4 eq_refl) | Lt => conj (fun v3 : @Lt = @Lt => eq_refl) (fun v3 : @true = @true => eq_refl) | Gt => conj (fun v3 : @Gt = @Lt => let v4 : forall v4 : @Lt = @Lt, @false = @true := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @Lt, @false = @true) with | eq_refl => fun v4 : @Gt = @Lt => (fun v5 : @Gt = @Lt => let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@false = @true) v6) v4 end in v4 eq_refl) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt = @Lt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt = @Lt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt = @Lt) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrdersFacts.BoolOrderFacts.leb_compare	100	0.319500	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => eq_true_iff_eq (v0 <=? v1) match v0 ?= v1 as v2 in comparison return (@bool) with | Gt => @false | _ => @true end ((fun v2 : v0 <=? v1 = @true <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <=? v1 = @true) (v0 <= v1) v2 (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true))) (leb_le v0 v1) ((fun v2 : (v0 ?= v1) <> @Gt <-> v0 <= v1 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <= v1) ((v0 ?= v1) <> @Gt) (symmetry v2) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) (eq_proper_proxy (match v0 ?= v1 as v3 in comparison return (@bool) with | Gt => @false | _ => @true end = @true))) (compare_le_iff v0 v1) (let v2 : @comparison := v0 ?= v1 in match v2 as v3 in comparison return (v3 <> @Gt <-> match v3 as v4 in comparison return (@bool) with | Gt => @false | _ => @true end = @true) with | Eq => conj (fun v3 : @Eq <> @Gt => eq_refl) (fun v3 : @true = @true => (fun v4 : @Eq = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Eq = @Gt => (fun v6 : @Eq = @Gt => let v7 : @False := eq_ind (@Eq) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Eq <> @Gt) | Lt => conj (fun v3 : @Lt <> @Gt => eq_refl) (fun v3 : @true = @true => (fun v4 : @Lt = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : @Lt = @Gt => (fun v6 : @Lt = @Gt => let v7 : @False := eq_ind (@Lt) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : @Lt <> @Gt) | Gt => conj (fun v3 : @Gt <> @Gt => False_ind (@false = @true) (v3 eq_refl)) (fun v3 : @false = @true => let v4 : forall v4 : @true = @true, @Gt <> @Gt := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, @Gt <> @Gt) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (@Gt <> @Gt) v6) v4 end in v4 eq_refl) end))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NAddOrder.NAddOrderProp.le_add_r	100	0.112024	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => induction (fun v2 : @t => v0 <= v0 + v2) (((fun (v2 v3 : @t) (v4 : v2 == v3) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (v0 <= v0 + v2) (v0 <= v0 + v3) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 + v2) (v0 + v3) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) v2 v3 v4)) (v0 <= v0 + v3) (v0 <= v0 + v3) (eq_proper_proxy (v0 <= v0 + v3)) (reflexivity (v0 <= v0 + v3))) : (@eq ==> @iff)%signature (fun v2 : @t => v0 <= v0 + v2) (fun v2 : @t => v0 <= v0 + v2)) : Proper (@eq ==> @iff) (fun v2 : @t => v0 <= v0 + v2)) ((fun v2 : v0 + 0 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 + 0) v0 v2) (add_0_r v0) (eq_le_incl v0 v0 (reflexivity v0))) (fun (v2 : @t) (v3 : v0 <= v0 + v2) => (fun v4 : v0 + S v2 == S (v0 + v2) => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive v0) (v0 + S v2) (S (v0 + v2)) v4) (add_succ_r v0 v2) (le_le_succ_r v0 (v0 + v2) v3)) v1 : v0 <= v0 + v1)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NAddOrder.NAddOrderProp.lt_lt_add_r	100	0.049057	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : v0 < v1) => (fun v4 : v0 + 0 == v0 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v0 (v0 + 0) (symmetry v4) (v1 + v2) (v1 + v2) (reflexive_proper_proxy Equivalence_Reflexive (v1 + v2))) (add_0_r v0) (add_lt_le_mono v0 v1 0 v2 v3 (le_0_l v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NAddOrder.NAddOrderProp.lt_lt_add_l	100	0.194970	1	1
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NAddOrder.NAddOrderProp.add_pos_l	100	0.026858	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v0) => add_pos_nonneg v0 v1 v2 (le_0_l v1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Natural.Abstract.NAddOrder.NAddOrderProp.add_pos_r	100	0.027460	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : 0 < v1) => add_nonneg_pos v0 v1 (le_0_l v0) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.GenericAbs.abs_eq	100	0.046070	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 <= v0) => max_l v0 (- v0) (le_trans (- v0) 0 v0 ((fun v2 : - v0 <= 0 <-> 0 <= v0 => iff_flip_impl_subrelation (- v0 <= 0) (0 <= v0) v2) (opp_nonpos_nonneg v0) v1) v1) : abs v0 == v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.GenericAbs.abs_neq	100	0.042436	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : v0 <= 0) => max_r v0 (- v0) (le_trans v0 0 (- v0) v1 ((fun v2 : 0 <= - v0 <-> v0 <= 0 => iff_flip_impl_subrelation (0 <= - v0) (v0 <= 0) v2) (opp_nonneg_nonpos v0) v1)) : abs v0 == - v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.GenericSgn.sgn_null	100	0.063317	1	1	0	synth with cache (only 1: refine ((fun (v0 : @t) (v1 : v0 == 0) => let v2 : CompareSpec (0 == v0) (0 < v0) (v0 < 0) (compare 0 v0) := compare_spec 0 v0 in let v3 : @comparison := compare 0 v0 in match v2 as v5 in (CompareSpec _ _ _ v4) return (match v4 as v6 in comparison return (@t) with | Eq => 0 | Lt => 1 | Gt => - (1) end == 0) with | CompEq _ _ v4 => (fun v4 : 0 == v0 => Private_OrderTac.Tac.eq_refl 0) v4 | CompLt _ _ v4 => (fun v4 : 0 < v0 => Private_OrderTac.Tac.not_neq_eq ((fun v5 : 1 ~= 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_eq v4 v1)) : ~ 1 ~= 0)) v4 | CompGt _ _ v4 => (fun v4 : v0 < 0 => Private_OrderTac.Tac.not_neq_eq ((fun v5 : - (1) ~= 0 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v1) v4)) : ~ - (1) ~= 0)) v4 end) : forall (v0 : @t) (v1 : v0 == 0), sgn v0 == 0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.GenericSgn.sgn_pos	100	0.064768	1	1	0	synth with cache (only 1: refine ((fun (v0 : @t) (v1 : 0 < v0) => let v2 : CompareSpec (0 == v0) (0 < v0) (v0 < 0) (compare 0 v0) := compare_spec 0 v0 in let v3 : @comparison := compare 0 v0 in match v2 as v5 in (CompareSpec _ _ _ v4) return (match v4 as v6 in comparison return (@t) with | Eq => 0 | Lt => 1 | Gt => - (1) end == 1) with | CompEq _ _ v4 => (fun v4 : 0 == v0 => Private_OrderTac.Tac.not_neq_eq ((fun v5 : 0 ~= 1 => (fun v6 : v0 ~= 1 => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.eq_lt (Private_OrderTac.Tac.eq_sym v4) v1)) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v4) v5)) : ~ 0 ~= 1)) v4 | CompLt _ _ v4 => (fun v4 : 0 < v0 => Private_OrderTac.Tac.eq_refl 1) v4 | CompGt _ _ v4 => (fun v4 : v0 < 0 => Private_OrderTac.Tac.not_neq_eq ((fun v5 : - (1) ~= 1 => (fun v6 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v1 v4)) : ~ - (1) ~= 1)) v4 end) : forall (v0 : @t) (v1 : 0 < v0), sgn v0 == 1)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.GenericSgn.sgn_neg	100	0.066565	1	1	0	synth with cache (only 1: refine ((fun (v0 : @t) (v1 : v0 < 0) => let v2 : CompareSpec (0 == v0) (0 < v0) (v0 < 0) (compare 0 v0) := compare_spec 0 v0 in let v3 : @comparison := compare 0 v0 in match v2 as v5 in (CompareSpec _ _ _ v4) return (match v4 as v6 in comparison return (@t) with | Eq => 0 | Lt => 1 | Gt => - (1) end == - (1)) with | CompEq _ _ v4 => (fun v4 : 0 == v0 => Private_OrderTac.Tac.not_neq_eq ((fun v5 : 0 ~= - (1) => (fun v6 : v0 ~= - (1) => (fun v7 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.lt_eq v1 v4)) (Private_OrderTac.Tac.eq_neq (Private_OrderTac.Tac.eq_sym v4) v5)) : ~ 0 ~= - (1))) v4 | CompLt _ _ v4 => (fun v4 : 0 < v0 => Private_OrderTac.Tac.not_neq_eq ((fun v5 : 1 ~= - (1) => (fun v6 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_trans v1 v4)) : ~ 1 ~= - (1))) v4 | CompGt _ _ v4 => (fun v4 : v0 < 0 => Private_OrderTac.Tac.eq_refl (- (1))) v4 end) : forall (v0 : @t) (v1 : v0 < 0), sgn v0 == - (1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_wd	100	0.106831	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => let v3 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v3 as v4 in (_ \/ _) return (abs v0 == abs v1) with | or_introl v4 => (fun v4 : 0 <= v0 => (fun v5 : abs v0 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0) v0 v5 (abs v1) (abs v1) (eq_proper_proxy (abs v1))) (abs_eq v0 v4) ((fun v5 : abs v1 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (abs v1) v1 v5) (abs_eq v1 ((fun v5 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) v1 v0 (symmetry v5)) v2 v4)) v2)) v4 | or_intror v4 => (fun v4 : v0 <= 0 => (fun v5 : abs v0 == - v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0) (- v0) v5 (abs v1) (abs v1) (eq_proper_proxy (abs v1))) (abs_neq v0 v4) ((fun v5 : abs v1 == - v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (abs v1) (- v1) v5) (abs_neq v1 (Private_OrderTac.Tac.not_gt_le ((fun v5 : 0 < v1 => (fun v6 : v1 <= 0 => (fun v7 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v7) (Private_OrderTac.Tac.le_lt_trans v6 v5)) (Private_OrderTac.Tac.eq_le (Private_OrderTac.Tac.eq_sym v2) v4)) : ~ 0 < v1))) ((fun v5 : - v0 == - v1 <-> v0 == v1 => iff_flip_impl_subrelation (- v0 == - v1) (v0 == v1) v5) (opp_inj_wd v0 v1) v2))) v4 end) : Proper (@eq ==> @eq) (@abs))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_max	100	0.071161	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v1 as v2 in (_ \/ _) return (abs v0 == max v0 (- v0)) with | or_introl v2 => (fun v2 : 0 <= v0 => (fun v3 : abs v0 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0) v0 v3 (max v0 (- v0)) (max v0 (- v0)) (eq_proper_proxy (max v0 (- v0)))) (abs_eq v0 v2) ((fun v3 : max v0 (- v0) == v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (max v0 (- v0)) v0 v3) (max_l v0 (- v0) (le_trans (- v0) 0 v0 ((fun v3 : - v0 <= 0 <-> 0 <= v0 => iff_flip_impl_subrelation (- v0 <= 0) (0 <= v0) v3) (opp_nonpos_nonneg v0) v2) v2)) (reflexivity v0))) v2 | or_intror v2 => (fun v2 : v0 <= 0 => (fun v3 : abs v0 == - v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0) (- v0) v3 (max v0 (- v0)) (max v0 (- v0)) (eq_proper_proxy (max v0 (- v0)))) (abs_neq v0 v2) ((fun v3 : max v0 (- v0) == - v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (max v0 (- v0)) (- v0) v3) (max_r v0 (- v0) (le_trans v0 0 (- v0) v2 ((fun v3 : 0 <= - v0 <-> v0 <= 0 => iff_flip_impl_subrelation (0 <= - v0) (v0 <= 0) v3) (opp_nonneg_nonpos v0) v2))) (reflexivity (- v0)))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_neq'	100	0.044017	1	1	0	synth with cache (only 1: refine (fun (v0 : @t) (v1 : 0 <= - v0) => abs_neq v0 ((fun v2 : 0 <= - v0 <-> v0 <= 0 => iff_flip_impl_subrelation (v0 <= 0) (0 <= - v0) (symmetry v2)) (opp_nonneg_nonpos v0) v1))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_nonneg	100	0.087615	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v1 as v2 in (_ \/ _) return (0 <= abs v0) with | or_introl v2 => (fun v2 : 0 <= v0 => (fun v3 : abs v0 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (abs v0) v0 v3) (abs_eq v0 v2) v2) v2 | or_intror v2 => (fun v2 : v0 <= 0 => (fun v3 : abs v0 == - v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (abs v0) (- v0) v3) (abs_neq v0 v2) ((fun v3 : 0 <= - v0 <-> v0 <= 0 => iff_flip_impl_subrelation (0 <= - v0) (v0 <= 0) v3) (opp_nonneg_nonpos v0) v2)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_eq_iff	100	0.053560	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (fun v1 : abs v0 == v0 => (fun v2 : abs v0 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) v0 (abs v0) (symmetry v2)) v1 (abs_nonneg v0)) (abs_eq v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_neq_iff	100	0.061699	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (fun v1 : abs v0 == - v0 => (fun v2 : 0 <= - v0 <-> v0 <= 0 => iff_flip_impl_subrelation (v0 <= 0) (0 <= - v0) (symmetry v2)) (opp_nonneg_nonpos v0) ((fun v2 : abs v0 == - v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (- v0) (abs v0) (symmetry v2)) v1 (abs_nonneg v0))) (abs_neq v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_opp	100	0.075473	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v1 as v2 in (_ \/ _) return (abs (- v0) == abs v0) with | or_introl v2 => (fun v2 : 0 <= v0 => (fun v3 : abs v0 == v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (abs v0) v0 v3) (abs_eq v0 v2) ((fun v3 : abs (- v0) == - - v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs (- v0)) (- - v0) v3 v0 v0 (eq_proper_proxy v0)) (abs_neq (- v0) ((fun v3 : - v0 <= 0 <-> 0 <= v0 => iff_flip_impl_subrelation (- v0 <= 0) (0 <= v0) v3) (opp_nonpos_nonneg v0) v2)) ((fun v3 : - - v0 == v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (- - v0) v0 v3 v0 v0 (eq_proper_proxy v0)) (opp_involutive v0) (reflexivity v0)))) v2 | or_intror v2 => (fun v2 : v0 <= 0 => (fun v3 : abs v0 == - v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (abs v0) (- v0) v3) (abs_neq v0 v2) ((fun v3 : abs (- v0) == - v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs (- v0)) (- v0) v3 (- v0) (- v0) (eq_proper_proxy (- v0))) (abs_eq (- v0) ((fun v3 : 0 <= - v0 <-> v0 <= 0 => iff_flip_impl_subrelation (0 <= - v0) (v0 <= 0) v3) (opp_nonneg_nonpos v0) v2)) (reflexivity (- v0)))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_0	100	0.017149	1	1	0	synth with cache (only 1: refine (abs_eq 0 (le_refl 0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_0_iff	100	0.212673	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (let v1 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v1 as v2 in (_ \/ _) return (forall v3 : abs v0 == 0, v0 == 0) with | or_introl v2 => (fun v2 : 0 <= v0 => (fun v3 : abs v0 == v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (abs v0 == 0) (v0 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) v0 v3 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (abs_eq v0 v2) (fun v3 : v0 == 0 => v3)) v2 | or_intror v2 => (fun v2 : v0 <= 0 => (fun v3 : abs v0 == - v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (abs v0 == 0) (- v0 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) (- v0) v3 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (abs_neq v0 v2) ((fun v3 : - v0 == 0 <-> v0 == - 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (- v0 == 0) (v0 == - 0) v3 (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (eq_opp_l v0 0) ((fun v3 : - 0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 == - 0) (v0 == 0) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (- 0) 0 v3) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (@opp_0) (fun v3 : v0 == 0 => v3)))) v2 end) (fun v1 : v0 == 0 => (fun v2 : v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0) (abs 0) (abs_wd v0 0 v2) 0 0 (eq_proper_proxy 0)) v1 ((fun v2 : abs 0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs 0) 0 v2 0 0 (eq_proper_proxy 0)) (abs_eq 0 (le_refl 0)) (eq_refl 0))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_pos	100	0.095173	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : abs v0 == 0 <-> v0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 ~= 0) (abs v0 ~= 0) (not_iff_morphism (v0 == 0) (abs v0 == 0) (symmetry v1))) (abs_0_iff v0) (conj (fun v1 : 0 < abs v0 => (fun v2 : abs v0 == 0 => False_ind (@False) (lt_irrefl 0 ((fun v3 : abs v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (abs v0) 0 v3) v2 v1))) : abs v0 ~= 0) (fun v1 : abs v0 ~= 0 => let v2 : 0 <= abs v0 := abs_nonneg v0 in match (fun v3 : 0 <= abs v0 <-> 0 < abs v0 \/ 0 == abs v0 => iff_impl_subrelation (0 <= abs v0) (0 < abs v0 \/ 0 == abs v0) v3) (lt_eq_cases 0 (abs v0)) v2 as v3 in (_ \/ _) return (0 < abs v0) with | or_introl v3 => (fun v3 : 0 < abs v0 => v3) v3 | or_intror v3 => (fun v3 : 0 == abs v0 => False_ind (0 < abs v0) (v1 (symmetry v3))) v3 end)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_eq_or_opp	100	0.107585	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v1 as v2 in (_ \/ _) return (abs v0 == v0 \/ abs v0 == - v0) with | or_introl v2 => (fun v2 : 0 <= v0 => (fun v3 : abs v0 == v0 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (abs v0 == v0) (v0 == v0) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) v0 v3 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (abs v0 == - v0) (v0 == - v0) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) v0 v3 (- v0) (- v0) (reflexive_proper_proxy Equivalence_Reflexive (- v0)))) (abs_eq v0 v2) (or_introl (reflexivity v0))) v2 | or_intror v2 => (fun v2 : v0 <= 0 => (fun v3 : abs v0 == - v0 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (abs v0 == v0) (- v0 == v0) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) (- v0) v3 v0 v0 (reflexive_proper_proxy Equivalence_Reflexive v0)) (abs v0 == - v0) (- v0 == - v0) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) (- v0) v3 (- v0) (- v0) (reflexive_proper_proxy Equivalence_Reflexive (- v0)))) (abs_neq v0 v2) (or_intror (reflexivity (- v0)))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_or_opp_abs	100	0.197166	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v1 as v2 in (_ \/ _) return (v0 == abs v0 \/ v0 == - abs v0) with | or_introl v2 => (fun v2 : 0 <= v0 => (fun v3 : abs v0 == v0 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 == abs v0) (v0 == v0) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (abs v0) v0 v3) (v0 == - abs v0) (v0 == - v0) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (- abs v0) (- v0) (opp_wd (abs v0) v0 v3))) (abs_eq v0 v2) (or_introl (reflexivity v0))) v2 | or_intror v2 => (fun v2 : v0 <= 0 => (fun v3 : abs v0 == - v0 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 == abs v0) (v0 == - v0) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (abs v0) (- v0) v3) (v0 == - abs v0) (v0 == - - v0) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (- abs v0) (- - v0) (opp_wd (abs v0) (- v0) v3))) (abs_neq v0 v2) ((fun v3 : - - v0 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (v0 == - v0)) (v0 == - - v0) (v0 == v0) (per_partial_app_morphism (Equivalence_PER (@eq_equiv)) (- - v0) v0 v3)) (opp_involutive v0) (or_intror (reflexivity v0)))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_involutive	100	0.020285	1	1	0	synth with cache (only 1: refine (fun v0 : @t => abs_eq (abs v0) (abs_nonneg v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_spec	100	0.104200	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 <= v0 \/ v0 < 0 := le_gt_cases 0 v0 in match v1 as v2 in (_ \/ _) return (0 <= v0 /\ abs v0 == v0 \/ v0 < 0 /\ abs v0 == - v0) with | or_introl v2 => (fun v2 : 0 <= v0 => or_introl (conj v2 (abs_eq v0 v2))) v2 | or_intror v2 => (fun v2 : v0 < 0 => or_intror (conj v2 (abs_neq v0 (lt_le_incl v0 0 v2)))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_case_strong	100	0.077515	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @t, Prop) (v1 : @t) (v2 : Proper (@eq ==> @iff) v0) (v3 : forall v3 : 0 <= v1, v0 v1) (v4 : forall v4 : v1 <= 0, v0 (- v1)) => let v5 : 0 <= v1 \/ v1 <= 0 := le_ge_cases 0 v1 in match v5 as v6 in (_ \/ _) return (v0 (abs v1)) with | or_introl v6 => (fun v6 : 0 <= v1 => (fun v7 : abs v1 == v1 => subrelation_proper v2 (@tt) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)) (abs v1) v1 v7) (abs_eq v1 v6) (v3 v6)) v6 | or_intror v6 => (fun v6 : v1 <= 0 => (fun v7 : abs v1 == - v1 => subrelation_proper v2 (@tt) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)) (abs v1) (- v1) v7) (abs_neq v1 v6) (v4 v6)) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_case	100	0.045466	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @t, Prop) (v1 : @t) (v2 : Proper (@eq ==> @iff) v0) (v3 : v0 v1) (v4 : v0 (- v1)) => abs_case_strong (fun v5 : @t => v0 v5) v1 v2 (fun v5 : 0 <= v1 => v3) (fun v5 : v1 <= 0 => v4))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_eq_cases	100	0.310821	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : abs v0 == abs v1) => let v3 : v0 == abs v0 \/ v0 == - abs v0 := abs_or_opp_abs v0 in match v3 as v4 in (_ \/ _) return (v0 == v1 \/ v0 == - v1) with | or_introl v4 => (fun v4 : v0 == abs v0 => (fun v5 : v0 == abs v0 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 == v1) (abs v0 == v1) (PER_morphism (Equivalence_PER (@eq_equiv)) v0 (abs v0) v5 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (v0 == - v1) (abs v0 == - v1) (PER_morphism (Equivalence_PER (@eq_equiv)) v0 (abs v0) v5 (- v1) (- v1) (reflexive_proper_proxy Equivalence_Reflexive (- v1)))) v4 ((fun v5 : abs v0 == abs v1 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (abs v0 == v1) (abs v1 == v1) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) (abs v1) v5 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (abs v0 == - v1) (abs v1 == - v1) (PER_morphism (Equivalence_PER (@eq_equiv)) (abs v0) (abs v1) v5 (- v1) (- v1) (reflexive_proper_proxy Equivalence_Reflexive (- v1)))) v2 (abs_eq_or_opp v1))) v4 | or_intror v4 => (fun v4 : v0 == - abs v0 => (fun v5 : v0 == - abs v0 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (v0 == v1) (- abs v0 == v1) (PER_morphism (Equivalence_PER (@eq_equiv)) v0 (- abs v0) v5 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (v0 == - v1) (- abs v0 == - v1) (PER_morphism (Equivalence_PER (@eq_equiv)) v0 (- abs v0) v5 (- v1) (- v1) (reflexive_proper_proxy Equivalence_Reflexive (- v1)))) v4 ((fun v5 : abs v0 == abs v1 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (- abs v0 == v1) (- abs v1 == v1) (PER_morphism (Equivalence_PER (@eq_equiv)) (- abs v0) (- abs v1) (opp_wd (abs v0) (abs v1) v5) v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (- abs v0 == - v1) (- abs v1 == - v1) (PER_morphism (Equivalence_PER (@eq_equiv)) (- abs v0) (- abs v1) (opp_wd (abs v0) (abs v1) v5) (- v1) (- v1) (reflexive_proper_proxy Equivalence_Reflexive (- v1)))) v2 ((fun v5 : - abs v1 == - v1 <-> abs v1 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) (- abs v1 == v1)) (- abs v1 == - v1) (abs v1 == v1) v5) (opp_inj_wd (abs v1) v1) ((fun v5 : - abs v1 == v1 <-> abs v1 == - v1 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (- abs v1 == v1) (abs v1 == - v1) v5 (abs v1 == v1) (abs v1 == v1) (reflexive_proper_proxy (@iff_Reflexive) (abs v1 == v1))) (eq_opp_l (abs v1) v1) ((fun v5 : abs v1 == - v1 \/ abs v1 == v1 <-> abs v1 == v1 \/ abs v1 == - v1 => iff_flip_impl_subrelation (abs v1 == - v1 \/ abs v1 == v1) (abs v1 == v1 \/ abs v1 == - v1) v5) (or_comm (abs v1 == - v1) (abs v1 == v1)) (abs_eq_or_opp v1)))))) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_lt	100	0.289057	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => let v2 : 0 <= v0 /\ abs v0 == v0 \/ v0 < 0 /\ abs v0 == - v0 := abs_spec v0 in match v2 as v3 in (_ \/ _) return (abs v0 < v1 <-> - v1 < v0 < v1) with | or_introl v3 => (fun v3 : 0 <= v0 /\ abs v0 == v0 => match v3 as v4 in (_ /\ _) return (abs v0 < v1 <-> - v1 < v0 < v1) with | conj v4 v5 => (fun (v4 : 0 <= v0) (v5 : abs v0 == v0) => (fun v6 : abs v0 == v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (abs v0 < v1) (v0 < v1) (lt_wd (abs v0) v0 v6 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (- v1 < v0 < v1) (- v1 < v0 < v1) (eq_proper_proxy (- v1 < v0 < v1))) v5 (conj (fun v6 : v0 < v1 => conj (lt_le_trans (- v1) 0 v0 (let v7 : forall (v7 : @t) (v8 : 0 < v7), - v7 < 0 := fun v7 : @t => match opp_neg_pos v7 as v8 in (_ /\ _) return (forall v9 : 0 < v7, - v7 < 0) with | conj v8 v9 => (fun (v8 : forall v8 : - v7 < 0, 0 < v7) (v9 : forall v9 : 0 < v7, - v7 < 0) => v9) v8 v9 end in v7 v1 (Private_OrderTac.Tac.not_ge_lt ((fun v8 : v1 <= 0 => (fun v9 : 0 < v1 => (fun v10 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v9)) (Private_OrderTac.Tac.le_lt_trans v4 v6)) : ~ v1 <= 0))) v4) (Private_OrderTac.Tac.not_ge_lt ((fun v7 : v1 <= v0 => (fun v8 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v7 v6)) : ~ v1 <= v0))) (fun v6 : - v1 < v0 < v1 => match v6 as v7 in (_ /\ _) return (v0 < v1) with | conj v7 v8 => (fun (v7 : - v1 < v0) (v8 : v0 < v1) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : v1 <= v0 => (fun v10 : - v1 < v1 => (fun v11 : v1 < v1 => Private_OrderTac.Tac.lt_irrefl v11) (Private_OrderTac.Tac.le_lt_trans v9 v8)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ v1 <= v0)) v7 v8 end))) v4 v5 end) v3 | or_intror v3 => (fun v3 : v0 < 0 /\ abs v0 == - v0 => match v3 as v4 in (_ /\ _) return (abs v0 < v1 <-> - v1 < v0 < v1) with | conj v4 v5 => (fun (v4 : v0 < 0) (v5 : abs v0 == - v0) => (fun v6 : abs v0 == - v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (abs v0 < v1) (- v0 < v1) (lt_wd (abs v0) (- v0) v6 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (- v1 < v0 < v1) (- v1 < v0 < v1) (eq_proper_proxy (- v1 < v0 < v1))) v5 ((fun v6 : - v0 < v1 <-> - v1 < - - v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (- v0 < v1) (- v1 < - - v0) v6 (- v1 < v0 < v1) (- v1 < v0 < v1) (eq_proper_proxy (- v1 < v0 < v1))) (opp_lt_mono (- v0) v1) ((fun v6 : - - v0 == v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (- v1 < - - v0) (- v1 < v0) (Reflexive_partial_app_morphism (@lt_wd) (reflexive_proper_proxy Equivalence_Reflexive (- v1)) (- - v0) v0 v6) (- v1 < v0 < v1) (- v1 < v0 < v1) (eq_proper_proxy (- v1 < v0 < v1))) (opp_involutive v0) (conj (fun v6 : - v1 < v0 => conj (Private_OrderTac.Tac.not_ge_lt ((fun v7 : v0 <= - v1 => (fun v8 : - v1 < 0 => (fun v9 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v9) (Private_OrderTac.Tac.le_lt_trans v7 v6)) (Private_OrderTac.Tac.lt_trans v6 v4)) : ~ v0 <= - v1)) (lt_le_trans v0 0 v1 v4 (let v7 : forall (v7 : @t) (v8 : - v7 <= 0), 0 <= v7 := fun v7 : @t => match opp_nonpos_nonneg v7 as v8 in (_ /\ _) return (forall v9 : - v7 <= 0, 0 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : - v7 <= 0, 0 <= v7) (v9 : forall v9 : 0 <= v7, - v7 <= 0) => v8) v8 v9 end in v7 v1 (Private_OrderTac.Tac.not_gt_le ((fun v8 : 0 < - v1 => (fun v9 : v0 < - v1 => (fun v10 : - v1 < - v1 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.lt_trans v6 v9)) (Private_OrderTac.Tac.lt_trans v4 v8)) : ~ 0 < - v1))))) (fun v6 : - v1 < v0 < v1 => match v6 as v7 in (_ /\ _) return (- v1 < v0) with | conj v7 v8 => (fun (v7 : - v1 < v0) (v8 : v0 < v1) => Private_OrderTac.Tac.not_ge_lt ((fun v9 : v0 <= - v1 => (fun v10 : - v1 < v1 => (fun v11 : - v1 < 0 => (fun v12 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v12) (Private_OrderTac.Tac.le_lt_trans v9 v7)) (Private_OrderTac.Tac.lt_trans v7 v4)) (Private_OrderTac.Tac.lt_trans v7 v8)) : ~ v0 <= - v1)) v7 v8 end))))) v4 v5 end) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_le	100	0.287710	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => let v2 : 0 <= v0 /\ abs v0 == v0 \/ v0 < 0 /\ abs v0 == - v0 := abs_spec v0 in match v2 as v3 in (_ \/ _) return (abs v0 <= v1 <-> - v1 <= v0 <= v1) with | or_introl v3 => (fun v3 : 0 <= v0 /\ abs v0 == v0 => match v3 as v4 in (_ /\ _) return (abs v0 <= v1 <-> - v1 <= v0 <= v1) with | conj v4 v5 => (fun (v4 : 0 <= v0) (v5 : abs v0 == v0) => (fun v6 : abs v0 == v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (abs v0 <= v1) (v0 <= v1) (le_wd (abs v0) v0 v6 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (- v1 <= v0 <= v1) (- v1 <= v0 <= v1) (eq_proper_proxy (- v1 <= v0 <= v1))) v5 (conj (fun v6 : v0 <= v1 => conj (le_trans (- v1) 0 v0 (let v7 : forall (v7 : @t) (v8 : 0 <= v7), - v7 <= 0 := fun v7 : @t => match opp_nonpos_nonneg v7 as v8 in (_ /\ _) return (forall v9 : 0 <= v7, - v7 <= 0) with | conj v8 v9 => (fun (v8 : forall v8 : - v7 <= 0, 0 <= v7) (v9 : forall v9 : 0 <= v7, - v7 <= 0) => v9) v8 v9 end in v7 v1 (Private_OrderTac.Tac.not_gt_le ((fun v8 : v1 < 0 => (fun v9 : v0 < 0 => (fun v10 : 0 < 0 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v4 v9)) (Private_OrderTac.Tac.le_lt_trans v6 v8)) : ~ v1 < 0))) v4) (Private_OrderTac.Tac.not_gt_le ((fun v7 : v1 < v0 => (fun v8 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v6 v7)) : ~ v1 < v0))) (fun v6 : - v1 <= v0 <= v1 => match v6 as v7 in (_ /\ _) return (v0 <= v1) with | conj v7 v8 => (fun (v7 : - v1 <= v0) (v8 : v0 <= v1) => Private_OrderTac.Tac.not_gt_le ((fun v9 : v1 < v0 => (fun v10 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v8 v9)) : ~ v1 < v0)) v7 v8 end))) v4 v5 end) v3 | or_intror v3 => (fun v3 : v0 < 0 /\ abs v0 == - v0 => match v3 as v4 in (_ /\ _) return (abs v0 <= v1 <-> - v1 <= v0 <= v1) with | conj v4 v5 => (fun (v4 : v0 < 0) (v5 : abs v0 == - v0) => (fun v6 : abs v0 == - v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (abs v0 <= v1) (- v0 <= v1) (le_wd (abs v0) (- v0) v6 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) (- v1 <= v0 <= v1) (- v1 <= v0 <= v1) (eq_proper_proxy (- v1 <= v0 <= v1))) v5 ((fun v6 : - v0 <= v1 <-> - v1 <= - - v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (- v0 <= v1) (- v1 <= - - v0) v6 (- v1 <= v0 <= v1) (- v1 <= v0 <= v1) (eq_proper_proxy (- v1 <= v0 <= v1))) (opp_le_mono (- v0) v1) ((fun v6 : - - v0 == v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (- v1 <= - - v0) (- v1 <= v0) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive (- v1)) (- - v0) v0 v6) (- v1 <= v0 <= v1) (- v1 <= v0 <= v1) (eq_proper_proxy (- v1 <= v0 <= v1))) (opp_involutive v0) (conj (fun v6 : - v1 <= v0 => conj (Private_OrderTac.Tac.not_gt_le ((fun v7 : v0 < - v1 => (fun v8 : - v1 < - v1 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.le_lt_trans v6 v7)) : ~ v0 < - v1)) (le_trans v0 0 v1 (Private_OrderTac.Tac.not_gt_le ((fun v7 : 0 < v0 => (fun v8 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v8) (Private_OrderTac.Tac.lt_trans v4 v7)) : ~ 0 < v0)) (let v7 : forall (v7 : @t) (v8 : - v7 <= 0), 0 <= v7 := fun v7 : @t => match opp_nonpos_nonneg v7 as v8 in (_ /\ _) return (forall v9 : - v7 <= 0, 0 <= v7) with | conj v8 v9 => (fun (v8 : forall v8 : - v7 <= 0, 0 <= v7) (v9 : forall v9 : 0 <= v7, - v7 <= 0) => v8) v8 v9 end in v7 v1 (Private_OrderTac.Tac.not_gt_le ((fun v8 : 0 < - v1 => (fun v9 : v0 < - v1 => (fun v10 : - v1 < - v1 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v6 v9)) (Private_OrderTac.Tac.lt_trans v4 v8)) : ~ 0 < - v1))))) (fun v6 : - v1 <= v0 <= v1 => match v6 as v7 in (_ /\ _) return (- v1 <= v0) with | conj v7 v8 => (fun (v7 : - v1 <= v0) (v8 : v0 <= v1) => Private_OrderTac.Tac.not_gt_le ((fun v9 : v0 < - v1 => (fun v10 : - v1 < - v1 => Private_OrderTac.Tac.lt_irrefl v10) (Private_OrderTac.Tac.le_lt_trans v7 v9)) : ~ v0 < - v1)) v7 v8 end))))) v4 v5 end) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_triangle	100	1.056402	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => let v2 : 0 <= v0 \/ v0 <= 0 := le_ge_cases 0 v0 in match v2 as v3 in (_ \/ _) return (abs (v0 + v1) <= abs v0 + abs v1) with | or_introl v3 => (fun v3 : 0 <= v0 => (fun v4 : abs v0 == v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (abs (v0 + v1))) (abs v0 + abs v1) (v0 + abs v1) (add_wd (abs v0) v0 v4 (abs v1) (abs v1) (reflexive_proper_proxy Equivalence_Reflexive (abs v1)))) (abs_eq v0 v3) (let v4 : 0 <= v1 \/ v1 <= 0 := le_ge_cases 0 v1 in match v4 as v5 in (_ \/ _) return (abs (v0 + v1) <= v0 + abs v1) with | or_introl v5 => (fun v5 : 0 <= v1 => (fun v6 : abs v1 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (abs (v0 + v1))) (v0 + abs v1) (v0 + v1) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (abs v1) v1 v6)) (abs_eq v1 v5) ((fun v6 : abs (v0 + v1) == v0 + v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (abs (v0 + v1)) (v0 + v1) v6 (v0 + v1) (v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + v1))) (abs_eq (v0 + v1) (add_nonneg_nonneg v0 v1 v3 v5)) (le_refl (v0 + v1)))) v5 | or_intror v5 => (fun v5 : v1 <= 0 => (fun v6 : abs v1 == - v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (abs (v0 + v1))) (v0 + abs v1) (v0 + - v1) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (abs v1) (- v1) v6)) (abs_neq v1 v5) (let v6 : 0 <= v0 + v1 \/ v0 + v1 <= 0 := le_ge_cases 0 (v0 + v1) in match v6 as v7 in (_ \/ _) return (abs (v0 + v1) <= v0 + - v1) with | or_introl v7 => (fun v7 : 0 <= v0 + v1 => (fun v8 : abs (v0 + v1) == v0 + v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (abs (v0 + v1)) (v0 + v1) v8 (v0 + - v1) (v0 + - v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + - v1))) (abs_eq (v0 + v1) v7) (let v8 : forall (v8 v9 v10 : @t) (v11 : v8 <= v9), v10 + v8 <= v10 + v9 := fun v8 v9 v10 : @t => match add_le_mono_l v8 v9 v10 as v11 in (_ /\ _) return (forall v12 : v8 <= v9, v10 + v8 <= v10 + v9) with | conj v11 v12 => (fun (v11 : forall v11 : v8 <= v9, v10 + v8 <= v10 + v9) (v12 : forall v12 : v10 + v8 <= v10 + v9, v8 <= v9) => v11) v11 v12 end in v8 v1 (- v1) v0 (le_trans v1 0 (- v1) v5 ((fun v9 : 0 <= - v1 <-> v1 <= 0 => iff_flip_impl_subrelation (0 <= - v1) (v1 <= 0) v9) (opp_nonneg_nonpos v1) v5)))) v7 | or_intror v7 => (fun v7 : v0 + v1 <= 0 => (fun v8 : abs (v0 + v1) == - (v0 + v1) => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (abs (v0 + v1)) (- (v0 + v1)) v8 (v0 + - v1) (v0 + - v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + - v1))) (abs_neq (v0 + v1) v7) ((fun v8 : - (v0 + v1) == - v0 + - v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (- (v0 + v1)) (- v0 + - v1) v8 (v0 + - v1) (v0 + - v1) (reflexive_proper_proxy Equivalence_Reflexive (v0 + - v1))) (opp_add_distr v0 v1) (let v8 : forall (v8 v9 v10 : @t) (v11 : v8 <= v9), v8 + v10 <= v9 + v10 := fun v8 v9 v10 : @t => match add_le_mono_r v8 v9 v10 as v11 in (_ /\ _) return (forall v12 : v8 <= v9, v8 + v10 <= v9 + v10) with | conj v11 v12 => (fun (v11 : forall v11 : v8 <= v9, v8 + v10 <= v9 + v10) (v12 : forall v12 : v8 + v10 <= v9 + v10, v8 <= v9) => v11) v11 v12 end in v8 (- v0) v0 (- v1) (le_trans (- v0) 0 v0 ((fun v9 : - v0 <= 0 <-> 0 <= v0 => iff_flip_impl_subrelation (- v0 <= 0) (0 <= v0) v9) (opp_nonpos_nonneg v0) v3) v3)))) v7 end)) v5 end)) v3 | or_intror v3 => (fun v3 : v0 <= 0 => (fun v4 : abs v0 == - v0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (abs (v0 + v1))) (abs v0 + abs v1) (- v0 + abs v1) (add_wd (abs v0) (- v0) v4 (abs v1) (abs v1) (reflexive_proper_proxy Equivalence_Reflexive (abs v1)))) (abs_neq v0 v3) (let v4 : 0 <= v1 \/ v1 <= 0 := le_ge_cases 0 v1 in match v4 as v5 in (_ \/ _) return (abs (v0 + v1) <= - v0 + abs v1) with | or_introl v5 => (fun v5 : 0 <= v1 => (fun v6 : abs v1 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (abs (v0 + v1))) (- v0 + abs v1) (- v0 + v1) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (- v0)) (abs v1) v1 v6)) (abs_eq v1 v5) (let v6 : 0 <= v0 + v1 \/ v0 + v1 <= 0 := le_ge_cases 0 (v0 + v1) in match v6 as v7 in (_ \/ _) return (abs (v0 + v1) <= - v0 + v1) with | or_introl v7 => (fun v7 : 0 <= v0 + v1 => (fun v8 : abs (v0 + v1) == v0 + v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (abs (v0 + v1)) (v0 + v1) v8 (- v0 + v1) (- v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (- v0 + v1))) (abs_eq (v0 + v1) v7) (let v8 : forall (v8 v9 v10 : @t) (v11 : v8 <= v9), v8 + v10 <= v9 + v10 := fun v8 v9 v10 : @t => match add_le_mono_r v8 v9 v10 as v11 in (_ /\ _) return (forall v12 : v8 <= v9, v8 + v10 <= v9 + v10) with | conj v11 v12 => (fun (v11 : forall v11 : v8 <= v9, v8 + v10 <= v9 + v10) (v12 : forall v12 : v8 + v10 <= v9 + v10, v8 <= v9) => v11) v11 v12 end in v8 v0 (- v0) v1 (le_trans v0 0 (- v0) v3 ((fun v9 : 0 <= - v0 <-> v0 <= 0 => iff_flip_impl_subrelation (0 <= - v0) (v0 <= 0) v9) (opp_nonneg_nonpos v0) v3)))) v7 | or_intror v7 => (fun v7 : v0 + v1 <= 0 => (fun v8 : abs (v0 + v1) == - (v0 + v1) => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (abs (v0 + v1)) (- (v0 + v1)) v8 (- v0 + v1) (- v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (- v0 + v1))) (abs_neq (v0 + v1) v7) ((fun v8 : - (v0 + v1) == - v0 + - v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (- (v0 + v1)) (- v0 + - v1) v8 (- v0 + v1) (- v0 + v1) (reflexive_proper_proxy Equivalence_Reflexive (- v0 + v1))) (opp_add_distr v0 v1) (let v8 : forall (v8 v9 v10 : @t) (v11 : v8 <= v9), v10 + v8 <= v10 + v9 := fun v8 v9 v10 : @t => match add_le_mono_l v8 v9 v10 as v11 in (_ /\ _) return (forall v12 : v8 <= v9, v10 + v8 <= v10 + v9) with | conj v11 v12 => (fun (v11 : forall v11 : v8 <= v9, v10 + v8 <= v10 + v9) (v12 : forall v12 : v10 + v8 <= v10 + v9, v8 <= v9) => v11) v11 v12 end in v8 (- v1) v1 (- v0) (le_trans (- v1) 0 v1 ((fun v9 : - v1 <= 0 <-> 0 <= v1 => iff_flip_impl_subrelation (- v1 <= 0) (0 <= v1) v9) (opp_nonpos_nonneg v1) v5) v5)))) v7 end)) v5 | or_intror v5 => (fun v5 : v1 <= 0 => (fun v6 : abs v1 == - v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (abs (v0 + v1))) (- v0 + abs v1) (- v0 + - v1) (Reflexive_partial_app_morphism (@add_wd) (reflexive_proper_proxy Equivalence_Reflexive (- v0)) (abs v1) (- v1) v6)) (abs_neq v1 v5) ((fun v6 : abs (v0 + v1) == - (v0 + v1) => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (abs (v0 + v1)) (- (v0 + v1)) v6 (- v0 + - v1) (- v0 + - v1) (reflexive_proper_proxy Equivalence_Reflexive (- v0 + - v1))) (abs_neq (v0 + v1) (add_nonpos_nonpos v0 v1 v3 v5)) ((fun v6 : - (v0 + v1) == - v0 + - v1 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (- (v0 + v1)) (- v0 + - v1) v6 (- v0 + - v1) (- v0 + - v1) (reflexive_proper_proxy Equivalence_Reflexive (- v0 + - v1))) (opp_add_distr v0 v1) (le_refl (- v0 + - v1))))) v5 end)) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_sub_triangle	100	0.119830	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => (fun v2 : abs v0 - abs v1 <= abs (v0 - v1) <-> abs v0 <= abs v1 + abs (v0 - v1) => iff_flip_impl_subrelation (abs v0 - abs v1 <= abs (v0 - v1)) (abs v0 <= abs v1 + abs (v0 - v1)) v2) (le_sub_le_add_l (abs v0) (abs v1) (abs (v0 - v1))) ((fun v2 : abs v1 + abs (v0 - v1) == abs (v0 - v1) + abs v1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (abs v0)) (abs v1 + abs (v0 - v1)) (abs (v0 - v1) + abs v1) v2) (add_comm (abs v1) (abs (v0 - v1))) ((fun v2 : v0 - v1 + v1 == v0 => subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (abs v0) (abs (v0 - v1 + v1)) (abs_wd v0 (v0 - v1 + v1) (symmetry v2)) (abs (v0 - v1) + abs v1) (abs (v0 - v1) + abs v1) (reflexive_proper_proxy Equivalence_Reflexive (abs (v0 - v1) + abs v1))) (sub_simpl_r v0 v1) (abs_triangle (v0 - v1) v1))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_mul	100	0.256104	1	1	0	synth with cache (only 1: refine (let v0 : forall (v0 v1 : @t) (v2 : 0 <= v0), abs (v0 * v1) == v0 * abs v1 := fun (v0 v1 : @t) (v2 : 0 <= v0) => let v3 : 0 <= v1 \/ v1 <= 0 := le_ge_cases 0 v1 in match v3 as v4 in (_ \/ _) return (abs (v0 * v1) == v0 * abs v1) with | or_introl v4 => (fun v4 : 0 <= v1 => (fun v5 : abs v1 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * abs v1) (v0 * v1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (abs v1) v1 v5)) (abs_eq v1 v4) ((fun v5 : abs (v0 * v1) == v0 * v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs (v0 * v1)) (v0 * v1) v5 (v0 * v1) (v0 * v1) (eq_proper_proxy (v0 * v1))) (abs_eq (v0 * v1) (mul_nonneg_nonneg v0 v1 v2 v4)) (eq_refl (v0 * v1)))) v4 | or_intror v4 => (fun v4 : v1 <= 0 => (fun v5 : abs v1 == - v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * abs v1) (v0 * - v1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (abs v1) (- v1) v5)) (abs_neq v1 v4) ((fun v5 : abs (v0 * v1) == - (v0 * v1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs (v0 * v1)) (- (v0 * v1)) v5 (v0 * - v1) (v0 * - v1) (eq_proper_proxy (v0 * - v1))) (abs_neq (v0 * v1) (mul_nonneg_nonpos v0 v1 v2 v4)) ((fun v5 : v0 * - v1 == - (v0 * v1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * - v1) (- (v0 * v1)) v5) (mul_opp_r v0 v1) (reflexivity (- (v0 * v1)))))) v4 end in fun v1 v2 : @t => let v3 : 0 <= v1 \/ v1 <= 0 := le_ge_cases 0 v1 in match v3 as v4 in (_ \/ _) return (abs (v1 * v2) == abs v1 * abs v2) with | or_introl v4 => (fun v4 : 0 <= v1 => (fun v5 : abs v1 == v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (abs v1 * abs v2) (v1 * abs v2) (mul_wd (abs v1) v1 v5 (abs v2) (abs v2) (reflexive_proper_proxy Equivalence_Reflexive (abs v2)))) (abs_eq v1 v4) (v0 v1 v2 v4)) v4 | or_intror v4 => (fun v4 : v1 <= 0 => (fun v5 : abs v1 == - v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (abs v1 * abs v2) (- v1 * abs v2) (mul_wd (abs v1) (- v1) v5 (abs v2) (abs v2) (reflexive_proper_proxy Equivalence_Reflexive (abs v2)))) (abs_neq v1 v4) ((fun v5 : - v1 * - v2 == v1 * v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs (v1 * v2)) (abs (- v1 * - v2)) (abs_wd (v1 * v2) (- v1 * - v2) (symmetry v5)) (- v1 * abs v2) (- v1 * abs v2) (eq_proper_proxy (- v1 * abs v2))) (mul_opp_opp v1 v2) ((fun v5 : abs (- v1 * - v2) == - v1 * abs (- v2) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs (- v1 * - v2)) (- v1 * abs (- v2)) v5 (- v1 * abs v2) (- v1 * abs v2) (eq_proper_proxy (- v1 * abs v2))) (v0 (- v1) (- v2) (let v5 : forall (v5 : @t) (v6 : v5 <= 0), 0 <= - v5 := fun v5 : @t => match opp_nonneg_nonpos v5 as v6 in (_ /\ _) return (forall v7 : v5 <= 0, 0 <= - v5) with | conj v6 v7 => (fun (v6 : forall v6 : 0 <= - v5, v5 <= 0) (v7 : forall v7 : v5 <= 0, 0 <= - v5) => v7) v6 v7 end in v5 v1 v4)) ((fun v5 : abs (- v2) == abs v2 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (- v1 * abs (- v2)) (- v1 * abs v2) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (- v1)) (abs (- v2)) (abs v2) v5) (- v1 * abs v2) (- v1 * abs v2) (eq_proper_proxy (- v1 * abs v2))) (abs_opp v2) (reflexivity (- v1 * abs v2)))))) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_square	100	0.065199	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : abs (v0 * v0) == abs v0 * abs v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0 * abs v0) (abs (v0 * v0)) (symmetry v1) (v0 * v0) (v0 * v0) (eq_proper_proxy (v0 * v0))) (abs_mul v0 v0) (abs_eq (v0 * v0) (square_nonneg v0)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_wd	100	0.211449	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @t) (v2 : v0 == v1) => let v3 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v3 as v4 in (_ \/ _) return (sgn v0 == sgn v1) with | or_introl v4 => (fun v4 : 0 < v0 => (fun v5 : sgn v0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (sgn v0) 1 v5 (sgn v1) (sgn v1) (eq_proper_proxy (sgn v1))) (sgn_pos v0 v4) ((fun v5 : sgn v1 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v1) 1 v5) (sgn_pos v1 ((fun v5 : v0 == v1 => Reflexive_partial_app_morphism (subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) v1 v0 (symmetry v5)) v2 v4)) (reflexivity 1))) v4 | or_intror v4 => (fun v4 : 0 == v0 \/ v0 < 0 => match v4 as v5 in (_ \/ _) return (sgn v0 == sgn v1) with | or_introl v5 => (fun v5 : 0 == v0 => (fun v6 : sgn v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (sgn v0) 0 v6 (sgn v1) (sgn v1) (eq_proper_proxy (sgn v1))) (sgn_null v0 (symmetry v5)) ((fun v6 : sgn v1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v1) 0 v6) (sgn_null v1 ((fun v6 : v0 == v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive v1 v0 (symmetry v6) 0 0 (eq_proper_proxy 0)) v2 (symmetry v5))) (reflexivity 0))) v5 | or_intror v5 => (fun v5 : v0 < 0 => (fun v6 : sgn v0 == - (1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (sgn v0) (- (1)) v6 (sgn v1) (sgn v1) (eq_proper_proxy (sgn v1))) (sgn_neg v0 v5) ((fun v6 : sgn v1 == - (1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v1) (- (1)) v6) (sgn_neg v1 ((fun v6 : v0 == v1 => subrelation_proper (@lt_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) v1 v0 (symmetry v6) 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) v2 v5)) (reflexivity (- (1))))) v5 end) v4 end) : Proper (@eq ==> @eq) (@sgn))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_spec	100	0.423260	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (0 < v0 /\ sgn v0 == 1 \/ 0 == v0 /\ sgn v0 == 0 \/ v0 < 0 /\ sgn v0 == - (1)) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 < v0 /\ sgn v0 == 1) (0 < v0 /\ 1 == 1) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 < v0)) (sgn v0 == 1) (1 == 1) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 1 v3 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1))) (0 == v0 /\ sgn v0 == 0 \/ v0 < 0 /\ sgn v0 == - (1)) (0 == v0 /\ 1 == 0 \/ v0 < 0 /\ 1 == - (1)) (or_iff_morphism (0 == v0 /\ sgn v0 == 0) (0 == v0 /\ 1 == 0) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 == v0)) (sgn v0 == 0) (1 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 1 v3 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0))) (v0 < 0 /\ sgn v0 == - (1)) (v0 < 0 /\ 1 == - (1)) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 0)) (sgn v0 == - (1)) (1 == - (1)) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 1 v3 (- (1)) (- (1)) (reflexive_proper_proxy Equivalence_Reflexive (- (1))))))) (sgn_pos v0 v2) (or_introl (conj v2 (reflexivity 1)))) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (0 < v0 /\ sgn v0 == 1 \/ 0 == v0 /\ sgn v0 == 0 \/ v0 < 0 /\ sgn v0 == - (1)) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 < v0 /\ sgn v0 == 1) (0 < v0 /\ 0 == 1) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 < v0)) (sgn v0 == 1) (0 == 1) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 0 v4 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1))) (0 == v0 /\ sgn v0 == 0 \/ v0 < 0 /\ sgn v0 == - (1)) (0 == v0 /\ 0 == 0 \/ v0 < 0 /\ 0 == - (1)) (or_iff_morphism (0 == v0 /\ sgn v0 == 0) (0 == v0 /\ 0 == 0) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 == v0)) (sgn v0 == 0) (0 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 0 v4 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0))) (v0 < 0 /\ sgn v0 == - (1)) (v0 < 0 /\ 0 == - (1)) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 0)) (sgn v0 == - (1)) (0 == - (1)) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 0 v4 (- (1)) (- (1)) (reflexive_proper_proxy Equivalence_Reflexive (- (1))))))) (sgn_null v0 (symmetry v3)) (or_intror (or_introl (conj v3 (reflexivity 0))))) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => subrelation_proper (@or_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 < v0 /\ sgn v0 == 1) (0 < v0 /\ - (1) == 1) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 < v0)) (sgn v0 == 1) (- (1) == 1) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) (- (1)) v4 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1))) (0 == v0 /\ sgn v0 == 0 \/ v0 < 0 /\ sgn v0 == - (1)) (0 == v0 /\ - (1) == 0 \/ v0 < 0 /\ - (1) == - (1)) (or_iff_morphism (0 == v0 /\ sgn v0 == 0) (0 == v0 /\ - (1) == 0) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (0 == v0)) (sgn v0 == 0) (- (1) == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) (- (1)) v4 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0))) (v0 < 0 /\ sgn v0 == - (1)) (v0 < 0 /\ - (1) == - (1)) (Reflexive_partial_app_morphism (@and_iff_morphism) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 0)) (sgn v0 == - (1)) (- (1) == - (1)) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) (- (1)) v4 (- (1)) (- (1)) (reflexive_proper_proxy Equivalence_Reflexive (- (1))))))) (sgn_neg v0 v3) (or_intror (or_intror (conj v3 (reflexivity (- (1))))))) v3 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_0	100	0.021327	1	1	0	synth with cache (only 1: refine (sgn_null 0 (reflexivity 0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_pos_iff	100	0.238983	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (forall v3 : sgn v0 == 1, 0 < v0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == 1) (1 == 1) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 1 v3 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1)) (0 < v0) (0 < v0) (reflexive_proper_proxy (@iff_Reflexive) (0 < v0))) (sgn_pos v0 v2) (fun v3 : 1 == 1 => v2)) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (forall v4 : sgn v0 == 1, 0 < v0) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == 1) (0 == 1) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 0 v4 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1)) (0 < v0) (0 < v0) (reflexive_proper_proxy (@iff_Reflexive) (0 < v0))) (sgn_null v0 (symmetry v3)) (fun v4 : 0 == 1 => False_ind (0 < v0) (lt_neq 0 1 (@lt_0_1) v4))) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == 1) (- (1) == 1) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) (- (1)) v4 1 1 (reflexive_proper_proxy Equivalence_Reflexive 1)) (0 < v0) (0 < v0) (reflexive_proper_proxy (@iff_Reflexive) (0 < v0))) (sgn_neg v0 v3) (fun v4 : - (1) == 1 => False_ind (0 < v0) (lt_neq (- (1)) 1 (lt_trans (- (1)) 0 1 ((fun v5 : - (1) < 0 <-> 0 < 1 => iff_flip_impl_subrelation (- (1) < 0) (0 < 1) v5) (opp_neg_pos 1) (@lt_0_1)) (@lt_0_1)) v4))) v3 end) v2 end) (sgn_pos v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_null_iff	100	0.279721	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (forall v3 : sgn v0 == 0, v0 == 0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == 0) (1 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 1 v3 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (sgn_pos v0 v2) (fun v3 : 1 == 0 => False_ind (v0 == 0) (lt_neq 0 1 (@lt_0_1) (symmetry v3)))) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (forall v4 : sgn v0 == 0, v0 == 0) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == 0) (0 == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 0 v4 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (sgn_null v0 (symmetry v3)) (fun v4 : 0 == 0 => symmetry v3)) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == 0) (- (1) == 0) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) (- (1)) v4 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (v0 == 0) (v0 == 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 == 0))) (sgn_neg v0 v3) (fun v4 : - (1) == 0 => False_ind (v0 == 0) (lt_neq (- (1)) 0 ((fun v5 : - (1) < 0 <-> 0 < 1 => iff_flip_impl_subrelation (- (1) < 0) (0 < 1) v5) (opp_neg_pos 1) (@lt_0_1)) v4))) v3 end) v2 end) (sgn_null v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_neg_iff	100	0.245437	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (forall v3 : sgn v0 == - (1), v0 < 0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == - (1)) (1 == - (1)) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 1 v3 (- (1)) (- (1)) (reflexive_proper_proxy Equivalence_Reflexive (- (1)))) (v0 < 0) (v0 < 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 0))) (sgn_pos v0 v2) (fun v3 : 1 == - (1) => False_ind (v0 < 0) (lt_neq (- (1)) 1 (lt_trans (- (1)) 0 1 ((fun v4 : - (1) < 0 <-> 0 < 1 => iff_flip_impl_subrelation (- (1) < 0) (0 < 1) v4) (opp_neg_pos 1) (@lt_0_1)) (@lt_0_1)) (symmetry v3)))) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (forall v4 : sgn v0 == - (1), v0 < 0) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == - (1)) (0 == - (1)) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) 0 v4 (- (1)) (- (1)) (reflexive_proper_proxy Equivalence_Reflexive (- (1)))) (v0 < 0) (v0 < 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 0))) (sgn_null v0 (symmetry v3)) (fun v4 : 0 == - (1) => False_ind (v0 < 0) (lt_neq (- (1)) 0 ((fun v5 : - (1) < 0 <-> 0 < 1 => iff_flip_impl_subrelation (- (1) < 0) (0 < 1) v5) (opp_neg_pos 1) (@lt_0_1)) (symmetry v4)))) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (sgn v0 == - (1)) (- (1) == - (1)) (PER_morphism (Equivalence_PER (@eq_equiv)) (sgn v0) (- (1)) v4 (- (1)) (- (1)) (reflexive_proper_proxy Equivalence_Reflexive (- (1)))) (v0 < 0) (v0 < 0) (reflexive_proper_proxy (@iff_Reflexive) (v0 < 0))) (sgn_neg v0 v3) (fun v4 : - (1) == - (1) => v3)) v3 end) v2 end) (sgn_neg v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_opp	100	0.151898	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (sgn (- v0) == - sgn v0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- sgn v0) (- (1)) (opp_wd (sgn v0) 1 v3)) (sgn_pos v0 v2) (sgn_neg (- v0) ((fun v3 : - v0 < 0 <-> 0 < v0 => iff_flip_impl_subrelation (- v0 < 0) (0 < v0) v3) (opp_neg_pos v0) v2))) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (sgn (- v0) == - sgn v0) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- sgn v0) (- 0) (opp_wd (sgn v0) 0 v4)) (sgn_null v0 (symmetry v3)) (let v4 : default_relation v0 0 := symmetry v3 : default_relation v0 0 in ((fun v5 : v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (sgn (- v0)) (sgn (- 0)) (sgn_wd (- v0) (- 0) (opp_wd v0 0 v5)) (- 0) (- 0) (eq_proper_proxy (- 0)) ((fun v6 : - 0 == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (sgn (- 0)) (sgn 0) (sgn_wd (- 0) 0 v6) (- 0) 0 v6) (@opp_0) (@sgn_0))) : forall v5 : default_relation v0 0, sgn (- v0) == - 0) v4)) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- sgn v0) (- - (1)) (opp_wd (sgn v0) (- (1)) v4)) (sgn_neg v0 v3) ((fun v4 : - - (1) == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- - (1)) 1 v4) (opp_involutive 1) (sgn_pos (- v0) ((fun v4 : 0 < - v0 <-> v0 < 0 => iff_flip_impl_subrelation (0 < - v0) (v0 < 0) v4) (opp_pos_neg v0) v3)))) v3 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_nonneg	100	0.352534	1	1	0	synth with cache (only 1: refine (fun v0 : @t => conj (let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (forall v3 : 0 <= sgn v0, 0 <= v0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 <= sgn v0) (0 <= 1) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (sgn v0) 1 v3) (0 <= v0) (0 <= v0) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v0))) (sgn_pos v0 v2) (fun v3 : 0 <= 1 => lt_le_incl 0 v0 v2)) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (forall v4 : 0 <= sgn v0, 0 <= v0) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 <= sgn v0) (0 <= 0) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (sgn v0) 0 v4) (0 <= v0) (0 <= v0) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v0))) (sgn_null v0 (symmetry v3)) (fun v4 : 0 <= 0 => Private_OrderTac.Tac.not_gt_le ((fun v5 : v0 < 0 => (fun v6 : v0 < v0 => Private_OrderTac.Tac.lt_irrefl v6) (Private_OrderTac.Tac.lt_eq v5 v3)) : ~ v0 < 0))) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 <= sgn v0) (0 <= - (1)) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (sgn v0) (- (1)) v4) (0 <= v0) (0 <= v0) (reflexive_proper_proxy (@iff_Reflexive) (0 <= v0))) (sgn_neg v0 v3) (fun v4 : 0 <= - (1) => False_ind (0 <= v0) (lt_irrefl 0 (lt_le_trans 0 1 0 (@lt_0_1) ((fun v5 : 0 <= - (1) <-> 1 <= 0 => iff_flip_impl_subrelation (1 <= 0) (0 <= - (1)) (symmetry v5)) (opp_nonneg_nonpos 1) v4))))) v3 end) v2 end) ((fun v1 : 0 <= v0 <-> 0 < v0 \/ 0 == v0 => subrelation_proper (@iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (0 <= v0) (0 < v0 \/ 0 == v0) v1 (0 <= sgn v0) (0 <= sgn v0) (reflexive_proper_proxy (@iff_Reflexive) (0 <= sgn v0))) (lt_eq_cases 0 v0) (fun v1 : 0 < v0 \/ 0 == v0 => match v1 as v2 in (_ \/ _) return (0 <= sgn v0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (sgn v0) 1 v3) (sgn_pos v0 v2) (lt_le_incl 0 1 (@lt_0_1))) v2 | or_intror v2 => (fun v2 : 0 == v0 => (fun v3 : sgn v0 == 0 => Reflexive_partial_app_morphism (subrelation_proper (@le_wd) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) (sgn v0) 0 v3) (sgn_null v0 (symmetry v2)) (le_refl 0)) v2 end)))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_nonpos	100	0.066410	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : 0 <= - sgn v0 <-> sgn v0 <= 0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (sgn v0 <= 0) (0 <= - sgn v0) (symmetry v1) (v0 <= 0) (v0 <= 0) (eq_proper_proxy (v0 <= 0))) (opp_nonneg_nonpos (sgn v0)) ((fun v1 : 0 <= - v0 <-> v0 <= 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 <= 0) (0 <= - v0) (symmetry v1)) (opp_nonneg_nonpos v0) ((fun v1 : sgn (- v0) == - sgn v0 => trans_co_eq_inv_impl_morphism (@iff_Transitive) (0 <= - sgn v0) (0 <= sgn (- v0)) (Reflexive_partial_app_morphism (@le_wd) (reflexive_proper_proxy Equivalence_Reflexive 0) (- sgn v0) (sgn (- v0)) (symmetry v1)) (0 <= - v0) (0 <= - v0) (eq_proper_proxy (0 <= - v0))) (sgn_opp v0) (sgn_nonneg (- v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_mul	100	0.346295	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => let v2 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v2 as v3 in (_ \/ _) return (sgn (v0 * v1) == sgn v0 * sgn v1) with | or_introl v3 => (fun v3 : 0 < v0 => (fun v4 : sgn v0 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v0 * sgn v1) (1 * sgn v1) (mul_wd (sgn v0) 1 v4 (sgn v1) (sgn v1) (reflexive_proper_proxy Equivalence_Reflexive (sgn v1)))) (sgn_pos v0 v3) ((fun v4 : 1 * sgn v1 == sgn v1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (1 * sgn v1) (sgn v1) v4) (mul_1_l (sgn v1)) (let v4 : 0 < v1 \/ 0 == v1 \/ v1 < 0 := lt_trichotomy 0 v1 in match v4 as v5 in (_ \/ _) return (sgn (v0 * v1) == sgn v1) with | or_introl v5 => (fun v5 : 0 < v1 => (fun v6 : sgn v1 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v1) 1 v6) (sgn_pos v1 v5) (sgn_pos (v0 * v1) (mul_pos_pos v0 v1 v3 v5))) v5 | or_intror v5 => (fun v5 : 0 == v1 \/ v1 < 0 => match v5 as v6 in (_ \/ _) return (sgn (v0 * v1) == sgn v1) with | or_introl v6 => (fun v6 : 0 == v1 => (fun v7 : sgn v1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v1) 0 v7) (sgn_null v1 (symmetry v6)) (sgn_null (v0 * v1) ((fun v7 : v0 * v1 == 0 <-> v0 == 0 \/ v1 == 0 => iff_flip_impl_subrelation (v0 * v1 == 0) (v0 == 0 \/ v1 == 0) v7) (eq_mul_0 v0 v1) (or_intror (symmetry v6))))) v6 | or_intror v6 => (fun v6 : v1 < 0 => (fun v7 : sgn v1 == - (1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v1) (- (1)) v7) (sgn_neg v1 v6) (sgn_neg (v0 * v1) (mul_pos_neg v0 v1 v3 v6))) v6 end) v5 end))) v3 | or_intror v3 => (fun v3 : 0 == v0 \/ v0 < 0 => match v3 as v4 in (_ \/ _) return (sgn (v0 * v1) == sgn v0 * sgn v1) with | or_introl v4 => (fun v4 : 0 == v0 => (fun v5 : sgn v0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v0 * sgn v1) (0 * sgn v1) (mul_wd (sgn v0) 0 v5 (sgn v1) (sgn v1) (reflexive_proper_proxy Equivalence_Reflexive (sgn v1)))) (sgn_null v0 (symmetry v4)) ((fun v5 : 0 * sgn v1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (0 * sgn v1) 0 v5) (mul_0_l (sgn v1)) (sgn_null (v0 * v1) ((fun v5 : v0 * v1 == 0 <-> v0 == 0 \/ v1 == 0 => iff_flip_impl_subrelation (v0 * v1 == 0) (v0 == 0 \/ v1 == 0) v5) (eq_mul_0 v0 v1) (or_introl (symmetry v4)))))) v4 | or_intror v4 => (fun v4 : v0 < 0 => (fun v5 : sgn v0 == - (1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (sgn v0 * sgn v1) (- (1) * sgn v1) (mul_wd (sgn v0) (- (1)) v5 (sgn v1) (sgn v1) (reflexive_proper_proxy Equivalence_Reflexive (sgn v1)))) (sgn_neg v0 v4) (let v5 : 0 < v1 \/ 0 == v1 \/ v1 < 0 := lt_trichotomy 0 v1 in match v5 as v6 in (_ \/ _) return (sgn (v0 * v1) == - (1) * sgn v1) with | or_introl v6 => (fun v6 : 0 < v1 => (fun v7 : sgn v1 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- (1) * sgn v1) (- (1) * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (- (1))) (sgn v1) 1 v7)) (sgn_pos v1 v6) ((fun v7 : - (1) * 1 == - (1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- (1) * 1) (- (1)) v7) (mul_1_r (- (1))) (sgn_neg (v0 * v1) (mul_neg_pos v0 v1 v4 v6)))) v6 | or_intror v6 => (fun v6 : 0 == v1 \/ v1 < 0 => match v6 as v7 in (_ \/ _) return (sgn (v0 * v1) == - (1) * sgn v1) with | or_introl v7 => (fun v7 : 0 == v1 => (fun v8 : sgn v1 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- (1) * sgn v1) (- (1) * 0) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (- (1))) (sgn v1) 0 v8)) (sgn_null v1 (symmetry v7)) ((fun v8 : - (1) * 0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- (1) * 0) 0 v8) (mul_0_r (- (1))) (sgn_null (v0 * v1) ((fun v8 : v0 * v1 == 0 <-> v0 == 0 \/ v1 == 0 => iff_flip_impl_subrelation (v0 * v1 == 0) (v0 == 0 \/ v1 == 0) v8) (eq_mul_0 v0 v1) (or_intror (symmetry v7)))))) v7 | or_intror v7 => (fun v7 : v1 < 0 => (fun v8 : sgn v1 == - (1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- (1) * sgn v1) (- (1) * - (1)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (- (1))) (sgn v1) (- (1)) v8)) (sgn_neg v1 v7) ((fun v8 : - (1) * - (1) == 1 * 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- (1) * - (1)) (1 * 1) v8) (mul_opp_opp 1 1) ((fun v8 : 1 * 1 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (1 * 1) 1 v8) (mul_1_r 1) (sgn_pos (v0 * v1) (mul_neg_neg v0 v1 v4 v7))))) v7 end) v6 end)) v4 end) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_abs	100	0.123694	1	1	0	synth with cache (only 1: refine (fun v0 : @t => symmetry (let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (abs v0 == v0 * sgn v0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * sgn v0) (v0 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (sgn v0) 1 v3)) (sgn_pos v0 v2) ((fun v3 : v0 * 1 == v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * 1) v0 v3) (mul_1_r v0) (abs_eq v0 (lt_le_incl 0 v0 v2)))) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (abs v0 == v0 * sgn v0) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * sgn v0) (v0 * 0) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (sgn v0) 0 v4)) (sgn_null v0 (symmetry v3)) ((fun v4 : v0 * 0 == 0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * 0) 0 v4) (mul_0_r v0) ((fun v4 : abs v0 == 0 <-> v0 == 0 => iff_flip_impl_subrelation (abs v0 == 0) (v0 == 0) v4) (abs_0_iff v0) (symmetry v3)))) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * sgn v0) (v0 * - (1)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive v0) (sgn v0) (- (1)) v4)) (sgn_neg v0 v3) ((fun v4 : v0 * - (1) == - (v0 * 1) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (v0 * - (1)) (- (v0 * 1)) v4) (mul_opp_r v0 1) ((fun v4 : v0 * 1 == v0 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@eq_equiv)) (- (v0 * 1)) (- v0) (opp_wd (v0 * 1) v0 v4)) (mul_1_r v0) (abs_neq v0 (lt_le_incl v0 0 v3))))) v3 end) v2 end))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.abs_sgn	100	0.130566	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 < v0 \/ 0 == v0 \/ v0 < 0 := lt_trichotomy 0 v0 in match v1 as v2 in (_ \/ _) return (abs v0 * sgn v0 == v0) with | or_introl v2 => (fun v2 : 0 < v0 => (fun v3 : sgn v0 == 1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0 * sgn v0) (abs v0 * 1) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (abs v0)) (sgn v0) 1 v3) v0 v0 (eq_proper_proxy v0)) (sgn_pos v0 v2) ((fun v3 : abs v0 * 1 == abs v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0 * 1) (abs v0) v3 v0 v0 (eq_proper_proxy v0)) (mul_1_r (abs v0)) (abs_eq v0 (lt_le_incl 0 v0 v2)))) v2 | or_intror v2 => (fun v2 : 0 == v0 \/ v0 < 0 => match v2 as v3 in (_ \/ _) return (abs v0 * sgn v0 == v0) with | or_introl v3 => (fun v3 : 0 == v0 => (fun v4 : sgn v0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0 * sgn v0) (abs v0 * 0) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (abs v0)) (sgn v0) 0 v4) v0 v0 (eq_proper_proxy v0)) (sgn_null v0 (symmetry v3)) ((fun v4 : abs v0 * 0 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0 * 0) 0 v4 v0 v0 (eq_proper_proxy v0)) (mul_0_r (abs v0)) v3)) v3 | or_intror v3 => (fun v3 : v0 < 0 => (fun v4 : sgn v0 == - (1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0 * sgn v0) (abs v0 * - (1)) (Reflexive_partial_app_morphism (@mul_wd) (reflexive_proper_proxy Equivalence_Reflexive (abs v0)) (sgn v0) (- (1)) v4) v0 v0 (eq_proper_proxy v0)) (sgn_neg v0 v3) ((fun v4 : abs v0 * - (1) == - (abs v0 * 1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (abs v0 * - (1)) (- (abs v0 * 1)) v4 v0 v0 (eq_proper_proxy v0)) (mul_opp_r (abs v0) 1) ((fun v4 : abs v0 * 1 == abs v0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (- (abs v0 * 1)) (- abs v0) (opp_wd (abs v0 * 1) (abs v0) v4) v0 v0 (eq_proper_proxy v0)) (mul_1_r (abs v0)) ((fun v4 : - abs v0 == v0 <-> abs v0 == - v0 => iff_flip_impl_subrelation (- abs v0 == v0) (abs v0 == - v0) v4) (eq_opp_l (abs v0) v0) (abs_neq v0 (lt_le_incl v0 0 v3)))))) v3 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Integer.Abstract.ZSgnAbs.ZSgnAbsProp.sgn_sgn	100	0.177819	1	1	0	synth with cache (only 1: refine (fun v0 : @t => let v1 : 0 < v0 /\ sgn v0 == 1 \/ 0 == v0 /\ sgn v0 == 0 \/ v0 < 0 /\ sgn v0 == - (1) := sgn_spec v0 in match v1 as v2 in (_ \/ _) return (sgn (sgn v0) == sgn v0) with | or_introl v2 => (fun v2 : 0 < v0 /\ sgn v0 == 1 => match v2 as v3 in (_ /\ _) return (sgn (sgn v0) == sgn v0) with | conj v3 v4 => (fun (v3 : 0 < v0) (v4 : sgn v0 == 1) => (fun v5 : sgn v0 == 1 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (sgn (sgn v0)) (sgn 1) (sgn_wd (sgn v0) 1 v5) (sgn v0) 1 v5) v4 (sgn_pos 1 (@lt_0_1))) v3 v4 end) v2 | or_intror v2 => (fun v2 : 0 == v0 /\ sgn v0 == 0 \/ v0 < 0 /\ sgn v0 == - (1) => match v2 as v3 in (_ \/ _) return (sgn (sgn v0) == sgn v0) with | or_introl v3 => (fun v3 : 0 == v0 /\ sgn v0 == 0 => match v3 as v4 in (_ /\ _) return (sgn (sgn v0) == sgn v0) with | conj v4 v5 => (fun (v4 : 0 == v0) (v5 : sgn v0 == 0) => (fun v6 : sgn v0 == 0 => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (sgn (sgn v0)) (sgn 0) (sgn_wd (sgn v0) 0 v6) (sgn v0) 0 v6) v5 (sgn_null 0 (reflexivity 0))) v4 v5 end) v3 | or_intror v3 => (fun v3 : v0 < 0 /\ sgn v0 == - (1) => match v3 as v4 in (_ /\ _) return (sgn (sgn v0) == sgn v0) with | conj v4 v5 => (fun (v4 : v0 < 0) (v5 : sgn v0 == - (1)) => (fun v6 : sgn v0 == - (1) => subrelation_proper (PER_morphism (Equivalence_PER (@eq_equiv))) (@tt) (subrelation_respectful (subrelation_refl (@eq)) (subrelation_respectful (subrelation_refl (@eq)) (@iff_flip_impl_subrelation))) (sgn (sgn v0)) (sgn (- (1))) (sgn_wd (sgn v0) (- (1)) v6) (sgn v0) (- (1)) v6) v5 (sgn_neg (- (1)) ((fun v6 : - (1) < 0 <-> 0 < 1 => iff_flip_impl_subrelation (- (1) < 0) (0 < 1) v6) (opp_neg_pos 1) (@lt_0_1)))) v4 v5 end) v3 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.meq_refl	100	0.052542	1	1	0	synth with cache (only 1: refine (fun v0 : @multiset => match v0 as v1 in multiset return (meq v1 v1) with | Bag v1 => (fun v1 : forall v1 : @A, @nat => (fun v2 : @A => eq_refl) : meq (Bag v1) (Bag v1)) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.meq_trans	100	0.100439	1	1	0	synth with cache (only 1: refine ((fun v0 : @multiset => match v0 as v1 in multiset return (forall (v2 v3 : @multiset) (v4 : forall v4 : @A, multiplicity v1 v4 = multiplicity v2 v4) (v5 : forall v5 : @A, multiplicity v2 v5 = multiplicity v3 v5) (v6 : @A), multiplicity v1 v6 = multiplicity v3 v6) with | Bag v1 => (fun (v1 : forall v1 : @A, @nat) (v2 : @multiset) => match v2 as v3 in multiset return (forall (v4 : @multiset) (v5 : forall v5 : @A, multiplicity (Bag v1) v5 = multiplicity v3 v5) (v6 : forall v6 : @A, multiplicity v3 v6 = multiplicity v4 v6) (v7 : @A), multiplicity (Bag v1) v7 = multiplicity v4 v7) with | Bag v3 => (fun (v3 : forall v3 : @A, @nat) (v4 : @multiset) => match v4 as v5 in multiset return (forall (v6 : forall v6 : @A, multiplicity (Bag v1) v6 = multiplicity (Bag v3) v6) (v7 : forall v7 : @A, multiplicity (Bag v3) v7 = multiplicity v5 v7) (v8 : @A), multiplicity (Bag v1) v8 = multiplicity v5 v8) with | Bag v5 => (fun (v5 : forall v5 : @A, @nat) (v6 : forall v6 : @A, multiplicity (Bag v1) v6 = multiplicity (Bag v3) v6) (v7 : forall v7 : @A, multiplicity (Bag v3) v7 = multiplicity (Bag v5) v7) (v8 : @A) => eq_ind_r (fun v9 : @nat => v9 = multiplicity (Bag v5) v8) (v7 v8) (v6 v8)) v5 end) v3 end) v1 end) : forall (v0 v1 v2 : @multiset) (v3 : meq v0 v1) (v4 : meq v1 v2), meq v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.meq_sym	100	0.059766	1	1	0	synth with cache (only 1: refine ((fun v0 : @multiset => match v0 as v1 in multiset return (forall (v2 : @multiset) (v3 : forall v3 : @A, multiplicity v1 v3 = multiplicity v2 v3) (v4 : @A), multiplicity v2 v4 = multiplicity v1 v4) with | Bag v1 => (fun (v1 : forall v1 : @A, @nat) (v2 : @multiset) => match v2 as v3 in multiset return (forall (v4 : forall v4 : @A, multiplicity (Bag v1) v4 = multiplicity v3 v4) (v5 : @A), multiplicity v3 v5 = multiplicity (Bag v1) v5) with | Bag v3 => (fun (v3 : forall v3 : @A, @nat) (v4 : forall v4 : @A, multiplicity (Bag v1) v4 = multiplicity (Bag v3) v4) (v5 : @A) => eq_sym (v4 v5)) v3 end) v1 end) : forall (v0 v1 : @multiset) (v2 : meq v0 v1), meq v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.munion_empty_left	100	0.070825	1	1	0	synth with cache (only 1: refine ((((fun (v0 : @multiset) (v1 : @A) => eq_refl) : forall (v0 : @multiset) (v1 : @A), multiplicity v0 v1 = multiplicity (Bag (fun v2 : @A => multiplicity (@EmptyBag) v2 + multiplicity v0 v2)) v1) : forall (v0 : @multiset) (v1 : @A), multiplicity v0 v1 = multiplicity (munion (@EmptyBag) v0) v1) : forall v0 : @multiset, meq v0 (munion (@EmptyBag) v0))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.munion_empty_right	100	0.084732	1	1	0	synth with cache (only 1: refine ((((fun (v0 : @multiset) (v1 : @A) => plus_n_O (multiplicity v0 v1)) : forall (v0 : @multiset) (v1 : @A), multiplicity v0 v1 = multiplicity (Bag (fun v2 : @A => multiplicity v0 v2 + multiplicity (@EmptyBag) v2)) v1) : forall (v0 : @multiset) (v1 : @A), multiplicity v0 v1 = multiplicity (munion v0 (@EmptyBag)) v1) : forall v0 : @multiset, meq v0 (munion v0 (@EmptyBag)))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.munion_comm	100	0.088294	1	1	0	synth with cache (only 1: refine ((((fun v0 : @multiset => match v0 as v1 in multiset return (forall (v2 : @multiset) (v3 : @A), multiplicity v1 v3 + multiplicity v2 v3 = multiplicity v2 v3 + multiplicity v1 v3) with | Bag v1 => (fun (v1 : forall v1 : @A, @nat) (v2 : @multiset) => match v2 as v3 in multiset return (forall v4 : @A, multiplicity (Bag v1) v4 + multiplicity v3 v4 = multiplicity v3 v4 + multiplicity (Bag v1) v4) with | Bag v3 => (fun (v3 : forall v3 : @A, @nat) (v4 : @A) => PeanoNat.Nat.add_comm (multiplicity (Bag v1) v4) (multiplicity (Bag v3) v4)) v3 end) v1 end) : forall (v0 v1 : @multiset) (v2 : @A), match munion v0 v1 as v3 in multiset return (@nat) with | Bag v3 => (fun v3 : forall v3 : @A, @nat => v3 v2) v3 end = match munion v1 v0 as v3 in multiset return (@nat) with | Bag v3 => (fun v3 : forall v3 : @A, @nat => v3 v2) v3 end) : forall (v0 v1 : @multiset) (v2 : @A), multiplicity (munion v0 v1) v2 = multiplicity (munion v1 v0) v2) : forall v0 v1 : @multiset, meq (munion v0 v1) (munion v1 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.munion_ass	100	0.179612	1	1	0	synth with cache (only 1: refine ((((fun v0 : @multiset => match v0 as v1 in multiset return (forall (v2 v3 : @multiset) (v4 : @A), match v1 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end + match v2 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end + match v3 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end = match v1 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end + (match v2 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end + match v3 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end)) with | Bag v1 => (fun (v1 : forall v1 : @A, @nat) (v2 : @multiset) => match v2 as v3 in multiset return (forall (v4 : @multiset) (v5 : @A), v1 v5 + match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end + match v4 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end = v1 v5 + (match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end + match v4 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end)) with | Bag v3 => (fun (v3 : forall v3 : @A, @nat) (v4 : @multiset) => match v4 as v5 in multiset return (forall v6 : @A, v1 v6 + v3 v6 + match v5 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end = v1 v6 + (v3 v6 + match v5 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end)) with | Bag v5 => (fun (v5 : forall v5 : @A, @nat) (v6 : @A) => eq_sym (PeanoNat.Nat.add_assoc (v1 v6) (v3 v6) (v5 v6))) v5 end) v3 end) v1 end) : forall (v0 v1 v2 : @multiset) (v3 : @A), multiplicity (Bag (fun v4 : @A => multiplicity (Bag (fun v5 : @A => multiplicity v0 v5 + multiplicity v1 v5)) v4 + multiplicity v2 v4)) v3 = multiplicity (Bag (fun v4 : @A => multiplicity v0 v4 + multiplicity (Bag (fun v5 : @A => multiplicity v1 v5 + multiplicity v2 v5)) v4)) v3) : forall (v0 v1 v2 : @multiset) (v3 : @A), multiplicity (munion (munion v0 v1) v2) v3 = multiplicity (munion v0 (munion v1 v2)) v3) : forall v0 v1 v2 : @multiset, meq (munion (munion v0 v1) v2) (munion v0 (munion v1 v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.meq_left	100	0.503728	1	1	0	synth with cache (only 1: refine ((((fun v0 : @multiset => match v0 as v1 in multiset return (forall (v2 v3 : @multiset) (v4 : forall v4 : @A, match v1 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end = match v2 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end) (v5 : @A), match v1 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end + match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end = match v2 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end + match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end) with | Bag v1 => (fun (v1 : forall v1 : @A, @nat) (v2 : @multiset) => match v2 as v3 in multiset return (forall (v4 : @multiset) (v5 : forall v5 : @A, v1 v5 = match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end) (v6 : @A), v1 v6 + match v4 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end = match v3 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end + match v4 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end) with | Bag v3 => (fun (v3 : forall v3 : @A, @nat) (v4 : @multiset) => match v4 as v5 in multiset return (forall (v6 : forall v6 : @A, v1 v6 = v3 v6) (v7 : @A), v1 v7 + match v5 as v8 in multiset return (@nat) with | Bag v8 => (fun v8 : forall v8 : @A, @nat => v8 v7) v8 end = v3 v7 + match v5 as v8 in multiset return (@nat) with | Bag v8 => (fun v8 : forall v8 : @A, @nat => v8 v7) v8 end) with | Bag v5 => (fun (v5 : forall v5 : @A, @nat) (v6 : forall v6 : @A, v1 v6 = v3 v6) (v7 : @A) => eq_ind (v1 v7) (fun v8 : @nat => v1 v7 + v5 v7 = v8 + v5 v7) eq_refl (v3 v7) (v6 v7)) v5 end) v3 end) v1 end) : forall (v0 v1 v2 : @multiset) (v3 : forall v3 : @A, multiplicity v0 v3 = multiplicity v1 v3) (v4 : @A), multiplicity (Bag (fun v5 : @A => multiplicity v0 v5 + multiplicity v2 v5)) v4 = multiplicity (Bag (fun v5 : @A => multiplicity v1 v5 + multiplicity v2 v5)) v4) : forall (v0 v1 v2 : @multiset) (v3 : forall v3 : @A, multiplicity v0 v3 = multiplicity v1 v3) (v4 : @A), multiplicity (munion v0 v2) v4 = multiplicity (munion v1 v2) v4) : forall (v0 v1 v2 : @multiset) (v3 : meq v0 v1), meq (munion v0 v2) (munion v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.meq_right	100	0.180202	1	1	0	synth with cache (only 1: refine ((((fun v0 : @multiset => match v0 as v1 in multiset return (forall (v2 v3 : @multiset) (v4 : forall v4 : @A, match v1 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end = match v2 as v5 in multiset return (@nat) with | Bag v5 => (fun v5 : forall v5 : @A, @nat => v5 v4) v5 end) (v5 : @A), match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end + match v1 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end = match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end + match v2 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end) with | Bag v1 => (fun (v1 : forall v1 : @A, @nat) (v2 : @multiset) => match v2 as v3 in multiset return (forall (v4 : @multiset) (v5 : forall v5 : @A, v1 v5 = match v3 as v6 in multiset return (@nat) with | Bag v6 => (fun v6 : forall v6 : @A, @nat => v6 v5) v6 end) (v6 : @A), match v4 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end + v1 v6 = match v4 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end + match v3 as v7 in multiset return (@nat) with | Bag v7 => (fun v7 : forall v7 : @A, @nat => v7 v6) v7 end) with | Bag v3 => (fun (v3 : forall v3 : @A, @nat) (v4 : @multiset) => match v4 as v5 in multiset return (forall (v6 : forall v6 : @A, v1 v6 = v3 v6) (v7 : @A), match v5 as v8 in multiset return (@nat) with | Bag v8 => (fun v8 : forall v8 : @A, @nat => v8 v7) v8 end + v1 v7 = match v5 as v8 in multiset return (@nat) with | Bag v8 => (fun v8 : forall v8 : @A, @nat => v8 v7) v8 end + v3 v7) with | Bag v5 => (fun (v5 : forall v5 : @A, @nat) (v6 : forall v6 : @A, v1 v6 = v3 v6) (v7 : @A) => eq_ind (v1 v7) (fun v8 : @nat => v5 v7 + v1 v7 = v5 v7 + v8) eq_refl (v3 v7) (v6 v7)) v5 end) v3 end) v1 end) : forall (v0 v1 v2 : @multiset) (v3 : forall v3 : @A, multiplicity v0 v3 = multiplicity v1 v3) (v4 : @A), multiplicity (Bag (fun v5 : @A => multiplicity v2 v5 + multiplicity v0 v5)) v4 = multiplicity (Bag (fun v5 : @A => multiplicity v2 v5 + multiplicity v1 v5)) v4) : forall (v0 v1 v2 : @multiset) (v3 : forall v3 : @A, multiplicity v0 v3 = multiplicity v1 v3) (v4 : @A), multiplicity (munion v2 v0) v4 = multiplicity (munion v2 v1) v4) : forall (v0 v1 v2 : @multiset) (v3 : meq v0 v1), meq (munion v2 v0) (munion v2 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.munion_rotate	100	0.064358	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @multiset => op_rotate (@multiset) (@munion) (@meq) (@munion_comm) (@munion_ass) (@meq_trans) (@meq_sym) v0 v1 v2 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.meq_congr	100	0.093215	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 : @multiset) (v4 : meq v0 v1) (v5 : meq v2 v3) => cong_congr (@multiset) (@munion) (@meq) (fun (v6 v7 v8 : @multiset) (v9 : meq v6 v7) => meq_left v8 v9) (fun (v6 v7 v8 : @multiset) (v9 : meq v6 v7) => meq_right v8 v9) (@meq_trans) v0 v1 v2 v3 v4 v5)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.munion_perm_left	100	0.119748	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @multiset => perm_left (@multiset) (@munion) (@meq) (fun v3 v4 : @multiset => munion_comm v3 v4) (fun v3 v4 v5 : @multiset => munion_ass v3 v4 v5) (fun (v3 v4 v5 : @multiset) (v6 : meq v3 v4) => meq_sym (meq_sym (meq_left v5 v6))) (@meq_trans) (fun (v3 v4 : @multiset) (v5 : meq v3 v4) => meq_sym v5) v0 v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.multiset_twist1	100	0.127177	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 v3 : @multiset => twist (@multiset) (@munion) (@meq) (fun v4 v5 : @multiset => munion_comm v4 v5) (fun v4 v5 v6 : @multiset => munion_ass v4 v5 v6) (fun (v4 v5 v6 : @multiset) (v7 : meq v4 v5) => meq_left v6 v7) (fun (v4 v5 v6 : @multiset) (v7 : meq v4 v5) => meq_right v6 v7) (@meq_trans) (fun (v4 v5 : @multiset) (v6 : meq v4 v5) => meq_sym v6) v0 v1 v2 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.multiset_twist2	100	0.132229	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 v3 : @multiset => meq_trans (meq_sym (munion_ass v0 (munion v1 v2) v3)) (meq_left v3 (munion_perm_left v0 v1 v2)))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.treesort_twist1	100	0.114268	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 : @multiset) (v5 : meq v4 (munion v1 v2)) => meq_trans (meq_right v0 (meq_left v3 v5)) (multiset_twist1 v0 v1 v2 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.treesort_twist2	100	0.116097	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 : @multiset) (v5 : meq v4 (munion v1 v2)) => meq_trans (meq_right v0 (meq_left v3 v5)) (multiset_twist2 v0 v1 v2 v3))).
coq-tactician-stdlib.8.11.dev	Coq.Sets.Multiset.multiset_defs.meq_singleton	100	0.167343	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @A) (v2 : eqA v0 v1) => ((fun v3 : @A => let v4 : {eqA v0 v3} + {~ eqA v0 v3} := Aeq_dec v0 v3 in match v4 as v5 in ({_} + {_}) return (match v5 as v6 in ({_} + {_}) return (@nat) with | left v6 => (fun v6 : eqA v0 v3 => 1) v6 | right v6 => (fun v6 : ~ eqA v0 v3 => 0) v6 end = match Aeq_dec v1 v3 as v6 in ({_} + {_}) return (@nat) with | left v6 => (fun v6 : eqA v1 v3 => 1) v6 | right v6 => (fun v6 : ~ eqA v1 v3 => 0) v6 end) with | left v5 => (fun v5 : eqA v0 v3 => decide_left (Aeq_dec v1 v3) ((fun v6 : eqA v0 v1 => Morphisms.subrelation_proper (Morphisms.PER_morphism (Equivalence_PER (@eqA_equiv))) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@eqA)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@eqA)) (@Morphisms.iff_impl_subrelation))) v0 v1 v6 v3 v3 (Morphisms.reflexive_proper_proxy Equivalence_Reflexive v3)) v2 v5) (fun v6 : {eqA v1 v3} + {~ eqA v1 v3} => 1 = match v6 as v7 in ({_} + {_}) return (@nat) with | left v7 => (fun v7 : eqA v1 v3 => 1) v7 | right v7 => (fun v7 : ~ eqA v1 v3 => 0) v7 end) (fun v6 : eqA v1 v3 => eq_refl)) v5 | right v5 => (fun v5 : ~ eqA v0 v3 => decide_right (Aeq_dec v1 v3) ((fun v6 : eqA v0 v1 => Morphisms.subrelation_proper (@Morphisms_Prop.not_iff_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_impl_subrelation)) (eqA v0 v3) (eqA v1 v3) (Morphisms.PER_morphism (Equivalence_PER (@eqA_equiv)) v0 v1 v6 v3 v3 (Morphisms.reflexive_proper_proxy Equivalence_Reflexive v3))) v2 v5) (fun v6 : {eqA v1 v3} + {~ eqA v1 v3} => 0 = match v6 as v7 in ({_} + {_}) return (@nat) with | left v7 => (fun v7 : eqA v1 v3 => 1) v7 | right v7 => (fun v7 : ~ eqA v1 v3 => 0) v7 end) (fun v6 : ~ eqA v1 v3 => eq_refl)) v5 end) : forall v3 : @A, multiplicity (SingletonBag v0) v3 = multiplicity (SingletonBag v1) v3) : meq (SingletonBag v0) (SingletonBag v1))).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.make_impl_true	100	0.099492	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : list v0) => list_ind (fun v3 : list v0 => make_impl v1 v3 (@True)) (@I : make_impl v1 nil (@True)) (fun (v3 : v0) (v4 : list v0) (v5 : make_impl v1 v4 (@True)) => (fun v6 : v1 v3 => v5) : make_impl v1 (v3 :: v4) (@True)) v2)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.make_impl_map	100	0.502539	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Type) (v2 : forall v2 : v0, Prop) (v3 : forall v3 : v0 * v1, Prop) (v4 : list (v0 * v1)) => list_ind (fun v5 : list (v0 * v1) => forall (v6 : Prop) (v7 : forall v7 : v0 * v1, v3 v7 <-> v2 (fst v7)), make_impl v3 v5 v6 <-> make_impl v2 (map fst v5) v6) ((fun (v5 : Prop) (v6 : forall v6 : v0 * v1, v3 v6 <-> v2 (fst v6)) => conj (fun v7 : v5 => v7) (fun v7 : v5 => v7)) : forall (v5 : Prop) (v6 : forall v6 : v0 * v1, v3 v6 <-> v2 (fst v6)), make_impl v3 nil v5 <-> make_impl v2 (map fst nil) v5) (fun (v5 : v0 * v1) (v6 : list (v0 * v1)) (v7 : forall (v7 : Prop) (v8 : forall v8 : v0 * v1, v3 v8 <-> v2 (fst v8)), make_impl v3 v6 v7 <-> make_impl v2 (map fst v6) v7) => (fun (v8 : Prop) (v9 : forall v9 : v0 * v1, v3 v9 <-> v2 (fst v9)) => (fun v10 : v3 v5 <-> v2 (fst v5) => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (forall v11 : v3 v5, make_impl v3 v6 v8) (forall v11 : v2 (fst v5), make_impl v3 v6 v8) (Morphisms_Prop.iff_iff_iff_impl_morphism (v3 v5) (v2 (fst v5)) v10 (make_impl v3 v6 v8) (make_impl v3 v6 v8) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (make_impl v3 v6 v8))) (forall v11 : v2 (fst v5), make_impl v2 (map fst v6) v8) (forall v11 : v2 (fst v5), make_impl v2 (map fst v6) v8) (Morphisms.eq_proper_proxy (forall v11 : v2 (fst v5), make_impl v2 (map fst v6) v8))) (v9 v5) ((fun v10 : make_impl v3 v6 v8 <-> make_impl v2 (map fst v6) v8 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (forall v11 : v2 (fst v5), make_impl v3 v6 v8) (forall v11 : v2 (fst v5), make_impl v2 (map fst v6) v8) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (v2 (fst v5))) (make_impl v3 v6 v8) (make_impl v2 (map fst v6) v8) v10) (forall v11 : v2 (fst v5), make_impl v2 (map fst v6) v8) (forall v11 : v2 (fst v5), make_impl v2 (map fst v6) v8) (Morphisms.eq_proper_proxy (forall v11 : v2 (fst v5), make_impl v2 (map fst v6) v8))) (v7 v8 v9) (prod_ind (fun v10 : v0 * v1 => (forall v11 : v2 (fst v10), make_impl v2 (map fst v6) v8) <-> (forall v11 : v2 (fst v10), make_impl v2 (map fst v6) v8)) (fun (v10 : v0) (v11 : v1) => conj (fun (v12 : forall v12 : v2 (fst (v10, v11)), make_impl v2 (map fst v6) v8) (v13 : v2 (fst (v10, v11))) => let v14 : make_impl v2 (map fst v6) v8 := v12 v13 in v14) (fun (v12 : forall v12 : v2 (fst (v10, v11)), make_impl v2 (map fst v6) v8) (v13 : v2 (fst (v10, v11))) => let v14 : make_impl v2 (map fst v6) v8 := v12 v13 in v14)) v5))) : forall (v8 : Prop) (v9 : forall v9 : v0 * v1, v3 v9 <-> v2 (fst v9)), make_impl v3 (v5 :: v6) v8 <-> make_impl v2 (map fst (v5 :: v6)) v8) v4)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.make_conj_cons	100	0.224904	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : v0) (v3 : list v0) => match v3 as v4 in (list _) return (make_conj v1 (v2 :: v4) <-> v1 v2 /\ make_conj v1 v4) with | nil => conj (fun v4 : v1 v2 => conj v4 (@I)) (fun v4 : v1 v2 /\ @True => and_ind (fun (v5 : v1 v2) (v6 : @True) => v5) v4) : make_conj v1 (v2 :: nil) <-> v1 v2 /\ make_conj v1 nil | v4 :: v5 => (fun (v4 : v0) (v5 : list v0) => conj (fun v6 : v1 v2 /\ match v5 as v6 in (list _) return Prop with | nil => v1 v4 | v6 :: v7 => (fun (v6 : v0) (v7 : list v0) => v1 v4 /\ make_conj v1 v5) v6 v7 end => and_ind (fun (v7 : v1 v2) (v8 : match v5 as v8 in (list _) return Prop with | nil => v1 v4 | v8 :: v9 => (fun (v8 : v0) (v9 : list v0) => v1 v4 /\ make_conj v1 v5) v8 v9 end) => conj v7 v8) v6) (fun v6 : v1 v2 /\ match v5 as v6 in (list _) return Prop with | nil => v1 v4 | v6 :: v7 => (fun (v6 : v0) (v7 : list v0) => v1 v4 /\ make_conj v1 v5) v6 v7 end => and_ind (fun (v7 : v1 v2) (v8 : match v5 as v8 in (list _) return Prop with | nil => v1 v4 | v8 :: v9 => (fun (v8 : v0) (v9 : list v0) => v1 v4 /\ make_conj v1 v5) v8 v9 end) => conj v7 v8) v6) : make_conj v1 (v2 :: v4 :: v5) <-> v1 v2 /\ make_conj v1 (v4 :: v5)) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.make_conj_impl	100	0.165784	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : list v0) => list_ind (fun v3 : list v0 => forall v4 : Prop, (forall v5 : make_conj v1 v3, v4) <-> make_impl v1 v3 v4) ((fun v3 : Prop => conj (fun v4 : forall v4 : @True, v3 => let v5 : v3 := let v5 : @True := @I in v4 v5 in (fun v6 : v3 => v6) v5) (fun (v4 : v3) (v5 : @True) => v4)) : forall v3 : Prop, (forall v4 : make_conj v1 nil, v3) <-> make_impl v1 nil v3) (fun (v3 : v0) (v4 : list v0) (v5 : forall v5 : Prop, (forall v6 : make_conj v1 v4, v5) <-> make_impl v1 v4 v5) => (fun v6 : Prop => match v4 as v7 in (list _) return (forall v8 : forall v8 : Prop, (forall v9 : make_conj v1 v7, v8) <-> make_impl v1 v7 v8, (forall v9 : match v7 as v9 in (list _) return Prop with | nil => v1 v3 | v9 :: v10 => (fun (v9 : v0) (v10 : list v0) => v1 v3 /\ make_conj v1 v7) v9 v10 end, v6) <-> (forall v9 : v1 v3, make_impl v1 v7 v6)) with | nil => fun v7 : forall v7 : Prop, (forall v8 : make_conj v1 nil, v7) <-> make_impl v1 nil v7 => conj (fun (v8 : forall v8 : v1 v3, v6) (v9 : v1 v3) => let v10 : v6 := v8 v9 in v10) (fun (v8 : forall v8 : v1 v3, v6) (v9 : v1 v3) => let v10 : v6 := v8 v9 in v10) : (forall v8 : v1 v3, v6) <-> (forall v8 : v1 v3, make_impl v1 nil v6) | v7 :: v8 => (fun (v7 : v0) (v8 : list v0) (v9 : forall v9 : Prop, (forall v10 : make_conj v1 (v7 :: v8), v9) <-> make_impl v1 (v7 :: v8) v9) => (fun v10 : (forall v10 : make_conj v1 (v7 :: v8), v6) <-> make_impl v1 (v7 :: v8) v6 => and_ind (fun (v11 : forall v11 : forall v11 : make_conj v1 (v7 :: v8), v6, make_impl v1 (v7 :: v8) v6) (v12 : forall (v12 : make_impl v1 (v7 :: v8) v6) (v13 : make_conj v1 (v7 :: v8)), v6) => conj (fun (v13 : forall v13 : v1 v3 /\ make_conj v1 (v7 :: v8), v6) (v14 : v1 v3) => let v15 : forall (v15 : v1 v3) (v16 : make_conj v1 (v7 :: v8)), v6 := fun (v15 : v1 v3) (v16 : make_conj v1 (v7 :: v8)) => v13 (conj v15 v16) in let v16 : forall v16 : make_conj v1 (v7 :: v8), v6 := v15 v14 in let v17 : make_impl v1 (v7 :: v8) v6 := v11 v16 in let v18 : forall v18 : make_conj v1 (v7 :: v8), v6 := v12 v17 in v17) (fun (v13 : forall v13 : v1 v3, make_impl v1 (v7 :: v8) v6) (v14 : v1 v3 /\ make_conj v1 (v7 :: v8)) => and_ind (fun (v15 : v1 v3) (v16 : make_conj v1 (v7 :: v8)) => let v17 : make_impl v1 (v7 :: v8) v6 := v13 v15 in let v18 : forall v18 : make_conj v1 (v7 :: v8), v6 := v12 v17 in let v19 : v6 := v18 v16 in v19) v14)) v10) (v9 v6)) v7 v8 end v5) : forall v6 : Prop, (forall v7 : make_conj v1 (v3 :: v4), v6) <-> make_impl v1 (v3 :: v4) v6) v2)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.make_conj_in	100	0.140910	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : list v0) => list_ind (fun v3 : list v0 => forall (v4 : make_conj v1 v3) (v5 : v0) (v6 : In v5 v3), v1 v5) ((fun (v3 : @True) (v4 : v0) (v5 : @False) => False_ind (v1 v4) v5) : forall (v3 : make_conj v1 nil) (v4 : v0) (v5 : In v4 nil), v1 v4) (fun (v3 : v0) (v4 : list v0) (v5 : forall (v5 : make_conj v1 v4) (v6 : v0) (v7 : In v6 v4), v1 v6) => (fun (v6 : match v4 as v6 in (list _) return Prop with | nil => v1 v3 | v6 :: v7 => (fun (v6 : v0) (v7 : list v0) => v1 v3 /\ make_conj v1 v4) v6 v7 end) (v7 : v0) (v8 : v3 = v7 \/ In v7 v4) => match v4 as v9 in (list _) return (forall (v10 : forall (v10 : make_conj v1 v9) (v11 : v0) (v12 : In v11 v9), v1 v11) (v11 : match v9 as v11 in (list _) return Prop with | nil => v1 v3 | v11 :: v12 => (fun (v11 : v0) (v12 : list v0) => v1 v3 /\ make_conj v1 v9) v11 v12 end) (v12 : v3 = v7 \/ In v7 v9), v1 v7) with | nil => fun (v9 : forall (v9 : make_conj v1 nil) (v10 : v0) (v11 : In v10 nil), v1 v10) (v10 : v1 v3) (v11 : v3 = v7 \/ In v7 nil) => match v11 as v12 in (_ \/ _) return (v1 v7) with | or_introl v12 => (fun v12 : v3 = v7 => eq_ind_r (fun v13 : v0 => forall v14 : v1 v13, v1 v7) (fun v13 : v1 v7 => v13) v12 v10) v12 | or_intror v12 => (fun v12 : @False => False_ind (v1 v7) v12) v12 end | v9 :: v10 => (fun (v9 : v0) (v10 : list v0) (v11 : forall (v11 : make_conj v1 (v9 :: v10)) (v12 : v0) (v13 : In v12 (v9 :: v10)), v1 v12) (v12 : v1 v3 /\ make_conj v1 (v9 :: v10)) (v13 : v3 = v7 \/ In v7 (v9 :: v10)) => match v12 as v14 in (_ /\ _) return (v1 v7) with | conj v14 v15 => (fun (v14 : v1 v3) (v15 : make_conj v1 (v9 :: v10)) => match v13 as v16 in (_ \/ _) return (v1 v7) with | or_introl v16 => (fun v16 : v3 = v7 => eq_ind_r (fun v17 : v0 => forall v18 : v1 v17, v1 v7) (fun v17 : v1 v7 => v17) v16 v14) v16 | or_intror v16 => (fun v16 : In v7 (v9 :: v10) => v11 v15 v7 v16) v16 end) v14 v15 end) v9 v10 end v5 v6 v8) : forall (v6 : make_conj v1 (v3 :: v4)) (v7 : v0) (v8 : In v7 (v3 :: v4)), v1 v7) v2)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.make_conj_app	100	0.271482	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : list v0) => list_ind (fun v3 : list v0 => forall v4 : list v0, make_conj v1 (v3 ++ v4) <-> make_conj v1 v3 /\ make_conj v1 v4) ((fun v3 : list v0 => conj (fun v4 : make_conj v1 v3 => conj (@I) v4) (fun v4 : @True /\ make_conj v1 v3 => and_ind (fun (v5 : @True) (v6 : make_conj v1 v3) => v6) v4)) : forall v3 : list v0, make_conj v1 (nil ++ v3) <-> make_conj v1 nil /\ make_conj v1 v3) (fun (v3 : v0) (v4 : list v0) (v5 : forall v5 : list v0, make_conj v1 (v4 ++ v5) <-> make_conj v1 v4 /\ make_conj v1 v5) (v6 : list v0) => (fun v7 : make_conj v1 (v3 :: v4 ++ v6) <-> v1 v3 /\ make_conj v1 (v4 ++ v6) => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (make_conj v1 (v3 :: v4 ++ v6)) (v1 v3 /\ make_conj v1 (v4 ++ v6)) v7 (make_conj v1 (v3 :: v4) /\ make_conj v1 v6) (make_conj v1 (v3 :: v4) /\ make_conj v1 v6) (Morphisms.eq_proper_proxy (make_conj v1 (v3 :: v4) /\ make_conj v1 v6))) (make_conj_cons v1 v3 (v4 ++ v6)) ((fun v7 : make_conj v1 (v4 ++ v6) <-> make_conj v1 v4 /\ make_conj v1 v6 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (v1 v3 /\ make_conj v1 (v4 ++ v6)) (v1 v3 /\ make_conj v1 v4 /\ make_conj v1 v6) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (v1 v3)) (make_conj v1 (v4 ++ v6)) (make_conj v1 v4 /\ make_conj v1 v6) v7) (make_conj v1 (v3 :: v4) /\ make_conj v1 v6) (make_conj v1 (v3 :: v4) /\ make_conj v1 v6) (Morphisms.eq_proper_proxy (make_conj v1 (v3 :: v4) /\ make_conj v1 v6))) (v5 v6) ((fun v7 : make_conj v1 (v3 :: v4) <-> v1 v3 /\ make_conj v1 v4 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (make_conj v1 (v3 :: v4) /\ make_conj v1 v6) ((v1 v3 /\ make_conj v1 v4) /\ make_conj v1 v6) (Morphisms_Prop.and_iff_morphism (make_conj v1 (v3 :: v4)) (v1 v3 /\ make_conj v1 v4) v7 (make_conj v1 v6) (make_conj v1 v6) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (make_conj v1 v6)))) (make_conj_cons v1 v3 v4) (conj (fun v7 : v1 v3 /\ make_conj v1 v4 /\ make_conj v1 v6 => and_ind (fun (v8 : v1 v3) (v9 : make_conj v1 v4 /\ make_conj v1 v6) => and_ind (fun (v10 : make_conj v1 v4) (v11 : make_conj v1 v6) => conj (conj v8 v10) v11) v9) v7) (fun v7 : (v1 v3 /\ make_conj v1 v4) /\ make_conj v1 v6 => and_ind (fun (v8 : v1 v3 /\ make_conj v1 v4) (v9 : make_conj v1 v6) => and_ind (fun (v10 : v1 v3) (v11 : make_conj v1 v4) => conj v10 (conj v11 v9)) v8) v7))))) v2)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.make_conj_rapp	100	0.269856	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 : v0, Prop) (v2 : list v0) => list_ind (fun v3 : list v0 => forall v4 : list v0, make_conj v1 (v3 +++ v4) <-> make_conj v1 (v3 ++ v4)) ((fun v3 : list v0 => conj (fun v4 : make_conj v1 v3 => v4) (fun v4 : make_conj v1 v3 => v4)) : forall v3 : list v0, make_conj v1 (nil +++ v3) <-> make_conj v1 (nil ++ v3)) (fun (v3 : v0) (v4 : list v0) (v5 : forall v5 : list v0, make_conj v1 (v4 +++ v5) <-> make_conj v1 (v4 ++ v5)) (v6 : list v0) => (fun v7 : make_conj v1 (v4 +++ v3 :: v6) <-> make_conj v1 (v4 ++ v3 :: v6) => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (make_conj v1 (v4 +++ v3 :: v6)) (make_conj v1 (v4 ++ v3 :: v6)) v7 (make_conj v1 ((v3 :: v4) ++ v6)) (make_conj v1 ((v3 :: v4) ++ v6)) (Morphisms.eq_proper_proxy (make_conj v1 ((v3 :: v4) ++ v6)))) (v5 (v3 :: v6)) ((fun v7 : make_conj v1 (v4 ++ v3 :: v6) <-> make_conj v1 v4 /\ make_conj v1 (v3 :: v6) => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (make_conj v1 (v4 ++ v3 :: v6)) (make_conj v1 v4 /\ make_conj v1 (v3 :: v6)) v7 (make_conj v1 ((v3 :: v4) ++ v6)) (make_conj v1 ((v3 :: v4) ++ v6)) (Morphisms.eq_proper_proxy (make_conj v1 ((v3 :: v4) ++ v6)))) (make_conj_app v1 v4 (v3 :: v6)) ((fun v7 : make_conj v1 (v3 :: v6) <-> v1 v3 /\ make_conj v1 v6 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (make_conj v1 v4 /\ make_conj v1 (v3 :: v6)) (make_conj v1 v4 /\ v1 v3 /\ make_conj v1 v6) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (make_conj v1 v4)) (make_conj v1 (v3 :: v6)) (v1 v3 /\ make_conj v1 v6) v7) (make_conj v1 ((v3 :: v4) ++ v6)) (make_conj v1 ((v3 :: v4) ++ v6)) (Morphisms.eq_proper_proxy (make_conj v1 ((v3 :: v4) ++ v6)))) (make_conj_cons v1 v3 v6) ((fun v7 : make_conj v1 (v3 :: v4 ++ v6) <-> v1 v3 /\ make_conj v1 (v4 ++ v6) => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (make_conj v1 (v3 :: v4 ++ v6)) (v1 v3 /\ make_conj v1 (v4 ++ v6)) v7) (make_conj_cons v1 v3 (v4 ++ v6)) ((fun v7 : make_conj v1 (v4 ++ v6) <-> make_conj v1 v4 /\ make_conj v1 v6 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (v1 v3 /\ make_conj v1 (v4 ++ v6)) (v1 v3 /\ make_conj v1 v4 /\ make_conj v1 v6) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.and_iff_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (v1 v3)) (make_conj v1 (v4 ++ v6)) (make_conj v1 v4 /\ make_conj v1 v6) v7)) (make_conj_app v1 v4 v6) (conj (fun v7 : make_conj v1 v4 /\ v1 v3 /\ make_conj v1 v6 => and_ind (fun (v8 : make_conj v1 v4) (v9 : v1 v3 /\ make_conj v1 v6) => and_ind (fun (v10 : v1 v3) (v11 : make_conj v1 v6) => conj v10 (conj v8 v11)) v9) v7) (fun v7 : v1 v3 /\ make_conj v1 v4 /\ make_conj v1 v6 => and_ind (fun (v8 : v1 v3) (v9 : make_conj v1 v4 /\ make_conj v1 v6) => and_ind (fun (v10 : make_conj v1 v4) (v11 : make_conj v1 v6) => conj v10 (conj v8 v11)) v9) v7))) : make_conj v1 v4 /\ v1 v3 /\ make_conj v1 v6 <-> make_conj v1 ((v3 :: v4) ++ v6)))) : make_conj v1 ((v3 :: v4) +++ v6) <-> make_conj v1 ((v3 :: v4) ++ v6)) v2)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.not_make_conj_cons	100	0.146884	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : list v0) (v3 : forall v3 : v0, Prop) (v4 : v3 v1 \/ ~ v3 v1) => (fun v5 : make_conj v3 (v1 :: v2) <-> v3 v1 /\ make_conj v3 v2 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (~ make_conj v3 (v1 :: v2)) (~ (v3 v1 /\ make_conj v3 v2)) (Morphisms_Prop.not_iff_morphism (make_conj v3 (v1 :: v2)) (v3 v1 /\ make_conj v3 v2) v5) (~ v3 v1 \/ ~ make_conj v3 v2) (~ v3 v1 \/ ~ make_conj v3 v2) (Morphisms.eq_proper_proxy (~ v3 v1 \/ ~ make_conj v3 v2))) (make_conj_cons v3 v1 v2) (or_ind (fun v5 : v3 v1 => conj (fun v6 : ~ (v3 v1 /\ make_conj v3 v2) => let v7 : forall (v7 : v3 v1) (v8 : make_conj v3 v2), @False := fun (v7 : v3 v1) (v8 : make_conj v3 v2) => v6 (conj v7 v8) in let v8 : forall v8 : make_conj v3 v2, @False := v7 v5 in or_intror ((fun v9 : make_conj v3 v2 => let v10 : @False := v8 v9 in False_ind (@False) v10) : ~ make_conj v3 v2)) (fun v6 : ~ v3 v1 \/ ~ make_conj v3 v2 => (fun v7 : v3 v1 /\ make_conj v3 v2 => and_ind (fun (v8 : v3 v1) (v9 : make_conj v3 v2) => or_ind (fun v10 : ~ v3 v1 => let v11 : @False := v10 v5 in False_ind (@False) v11) (fun v10 : ~ make_conj v3 v2 => let v11 : @False := v10 v9 in False_ind (@False) v11) v6) v7) : ~ (v3 v1 /\ make_conj v3 v2))) (fun v5 : ~ v3 v1 => conj (fun v6 : ~ (v3 v1 /\ make_conj v3 v2) => let v7 : forall (v7 : v3 v1) (v8 : make_conj v3 v2), @False := fun (v7 : v3 v1) (v8 : make_conj v3 v2) => v6 (conj v7 v8) in or_introl ((fun v8 : v3 v1 => let v9 : @False := v5 v8 in let v10 : forall v10 : make_conj v3 v2, @False := v7 v8 in False_ind (@False) v9) : ~ v3 v1)) (fun v6 : ~ v3 v1 \/ ~ make_conj v3 v2 => (fun v7 : v3 v1 /\ make_conj v3 v2 => and_ind (fun (v8 : v3 v1) (v9 : make_conj v3 v2) => or_ind (fun v10 : ~ v3 v1 => let v11 : @False := v5 v8 in let v12 : @False := v10 v8 in False_ind (@False) v12) (fun v10 : ~ make_conj v3 v2 => let v11 : @False := v5 v8 in let v12 : @False := v10 v9 in False_ind (@False) v12) v6) v7) : ~ (v3 v1 /\ make_conj v3 v2))) v4))).
coq-tactician-stdlib.8.11.dev	Coq.micromega.Refl.not_make_conj_app	100	0.371379	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : list v0) => list_ind (fun v2 : list v0 => forall (v3 : list v0) (v4 : forall v4 : v0, Prop) (v5 : forall v5 : v0, v4 v5 \/ ~ v4 v5), ~ make_conj v4 (v2 ++ v3) <-> ~ make_conj v4 v2 \/ ~ make_conj v4 v3) ((fun (v2 : list v0) (v3 : forall v3 : v0, Prop) (v4 : forall v4 : v0, v3 v4 \/ ~ v3 v4) => conj (fun v5 : ~ make_conj v3 v2 => or_intror ((fun v6 : make_conj v3 v2 => let v7 : @False := v5 v6 in False_ind (@False) v7) : ~ make_conj v3 v2)) (fun v5 : ~ @True \/ ~ make_conj v3 v2 => (fun v6 : make_conj v3 v2 => or_ind (fun v7 : ~ @True => let v8 : @False := let v8 : @True := @I in v7 v8 in (fun v9 : @False => False_ind (@False) v9) v8) (fun v7 : ~ make_conj v3 v2 => let v8 : @False := v7 v6 in False_ind (@False) v8) v5) : ~ make_conj v3 v2)) : forall (v2 : list v0) (v3 : forall v3 : v0, Prop) (v4 : forall v4 : v0, v3 v4 \/ ~ v3 v4), ~ make_conj v3 (nil ++ v2) <-> ~ make_conj v3 nil \/ ~ make_conj v3 v2) (fun (v2 : v0) (v3 : list v0) (v4 : forall (v4 : list v0) (v5 : forall v5 : v0, Prop) (v6 : forall v6 : v0, v5 v6 \/ ~ v5 v6), ~ make_conj v5 (v3 ++ v4) <-> ~ make_conj v5 v3 \/ ~ make_conj v5 v4) (v5 : list v0) (v6 : forall v6 : v0, Prop) (v7 : forall v7 : v0, v6 v7 \/ ~ v6 v7) => (fun v8 : ~ make_conj v6 (v2 :: v3 ++ v5) <-> ~ v6 v2 \/ ~ make_conj v6 (v3 ++ v5) => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (~ make_conj v6 (v2 :: v3 ++ v5)) (~ v6 v2 \/ ~ make_conj v6 (v3 ++ v5)) v8 (~ make_conj v6 (v2 :: v3) \/ ~ make_conj v6 v5) (~ make_conj v6 (v2 :: v3) \/ ~ make_conj v6 v5) (Morphisms.eq_proper_proxy (~ make_conj v6 (v2 :: v3) \/ ~ make_conj v6 v5))) (not_make_conj_cons v2 (v3 ++ v5) v6 (v7 v2)) ((fun v8 : ~ make_conj v6 (v2 :: v3) <-> ~ v6 v2 \/ ~ make_conj v6 v3 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (~ make_conj v6 (v2 :: v3) \/ ~ make_conj v6 v5) ((~ v6 v2 \/ ~ make_conj v6 v3) \/ ~ make_conj v6 v5) (Morphisms_Prop.or_iff_morphism (~ make_conj v6 (v2 :: v3)) (~ v6 v2 \/ ~ make_conj v6 v3) v8 (~ make_conj v6 v5) (~ make_conj v6 v5) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (~ make_conj v6 v5)))) (not_make_conj_cons v2 v3 v6 (v7 v2)) ((fun v8 : ~ make_conj v6 (v3 ++ v5) <-> ~ make_conj v6 v3 \/ ~ make_conj v6 v5 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (~ v6 v2 \/ ~ make_conj v6 (v3 ++ v5)) (~ v6 v2 \/ ~ make_conj v6 v3 \/ ~ make_conj v6 v5) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.or_iff_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (~ v6 v2)) (~ make_conj v6 (v3 ++ v5)) (~ make_conj v6 v3 \/ ~ make_conj v6 v5) v8) ((~ v6 v2 \/ ~ make_conj v6 v3) \/ ~ make_conj v6 v5) ((~ v6 v2 \/ ~ make_conj v6 v3) \/ ~ make_conj v6 v5) (Morphisms.eq_proper_proxy ((~ v6 v2 \/ ~ make_conj v6 v3) \/ ~ make_conj v6 v5))) (v4 v5 v6 v7) (conj (fun v8 : ~ v6 v2 \/ ~ make_conj v6 v3 \/ ~ make_conj v6 v5 => or_ind (fun v9 : ~ v6 v2 => or_introl (or_introl ((fun v10 : v6 v2 => let v11 : @False := v9 v10 in False_ind (@False) v11) : ~ v6 v2))) (fun v9 : ~ make_conj v6 v3 \/ ~ make_conj v6 v5 => or_ind (fun v10 : ~ make_conj v6 v3 => or_introl (or_intror ((fun v11 : make_conj v6 v3 => let v12 : @False := v10 v11 in False_ind (@False) v12) : ~ make_conj v6 v3))) (fun v10 : ~ make_conj v6 v5 => or_intror ((fun v11 : make_conj v6 v5 => let v12 : @False := v10 v11 in False_ind (@False) v12) : ~ make_conj v6 v5)) v9) v8) (fun v8 : (~ v6 v2 \/ ~ make_conj v6 v3) \/ ~ make_conj v6 v5 => or_ind (fun v9 : ~ v6 v2 \/ ~ make_conj v6 v3 => or_ind (fun v10 : ~ v6 v2 => or_introl ((fun v11 : v6 v2 => let v12 : @False := v10 v11 in False_ind (@False) v12) : ~ v6 v2)) (fun v10 : ~ make_conj v6 v3 => or_intror (or_introl ((fun v11 : make_conj v6 v3 => let v12 : @False := v10 v11 in False_ind (@False) v12) : ~ make_conj v6 v3))) v9) (fun v9 : ~ make_conj v6 v5 => or_intror (or_intror ((fun v10 : make_conj v6 v5 => let v11 : @False := v9 v10 in False_ind (@False) v11) : ~ make_conj v6 v5))) v8)))) : ~ make_conj v6 ((v2 :: v3) ++ v5) <-> ~ make_conj v6 (v2 :: v3) \/ ~ make_conj v6 v5) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.MOT_to_OT.eq_dec	100	0.084300	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @O.t => Compare_rec (P:=fun v2 : Compare (@O.lt) (@O.eq) v0 v1 => {O.eq v0 v1} + {~ O.eq v0 v1}) (fun v2 : O.lt v0 v1 => right (O.lt_not_eq v2)) (fun v2 : O.eq v0 v1 => left v2) (fun v2 : O.lt v1 v0 => right (let v3 : ~ O.eq v1 v0 := O.lt_not_eq v2 in (fun v4 : O.eq v0 v1 => v3 (O.eq_sym v4)) : ~ O.eq v0 v1)) (O.compare v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.eq_equiv	100	0.025701	1	1	0	synth with cache (only 1: refine {| Equivalence_Reflexive := @eq_refl; Equivalence_Symmetric := @eq_sym; Equivalence_Transitive := @eq_trans |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_antirefl	100	0.033431	1	1	0	synth with cache (only 1: refine (fun v0 : @t => (fun v1 : lt v0 v0 => False_ind (@False) (lt_not_eq v1 (eq_refl v0))) : ~ lt v0 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_strorder	100	0.028055	1	1	0	synth with cache (only 1: refine {| StrictOrder_Irreflexive := @lt_antirefl; StrictOrder_Transitive := @lt_trans |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_eq	100	0.085651	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : lt v0 v1) (v4 : eq v1 v2) => let v5 : Compare (@lt) (@eq) v0 v2 := compare v0 v2 in match v5 as v6 in (Compare _ _ _ _) return (lt v0 v2) with | LT v6 => (fun v6 : lt v0 v2 => v6) v6 | EQ v6 => (fun v6 : eq v0 v2 => False_ind (lt v0 v2) (lt_not_eq v3 (eq_trans v6 (eq_sym v4)))) v6 | GT v6 => (fun v6 : lt v2 v0 => False_ind (lt v0 v2) (lt_not_eq (lt_trans v6 v3) (eq_sym v4))) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.eq_lt	100	0.076472	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @t) (v3 : eq v0 v1) (v4 : lt v1 v2) => let v5 : Compare (@lt) (@eq) v0 v2 := compare v0 v2 in match v5 as v6 in (Compare _ _ _ _) return (lt v0 v2) with | LT v6 => (fun v6 : lt v0 v2 => v6) v6 | EQ v6 => (fun v6 : eq v0 v2 => False_ind (lt v0 v2) (lt_not_eq v4 (eq_trans (eq_sym v3) v6))) v6 | GT v6 => (fun v6 : lt v2 v0 => False_ind (lt v0 v2) (lt_not_eq (lt_trans v4 v6) (eq_sym v3))) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_compat	100	0.108987	1	1	0	synth with cache (only 1: refine (proper_sym_impl_iff_2 ((fun (v0 v1 : @t) (v2 : eq v0 v1) => symmetry v2) : Symmetric (@eq)) ((fun (v0 v1 : @t) (v2 : eq v0 v1) => symmetry v2) : Symmetric (@eq)) ((fun (v0 v1 : @t) (v2 : eq v0 v1) => (fun (v3 v4 : @t) (v5 : eq v3 v4) => (fun v6 : lt v0 v3 => eq_lt (eq_sym v2) (lt_eq v6 v5)) : impl (lt v0 v3) (lt v1 v4)) : (@eq ==> @impl)%signature (lt v0) (lt v1)) : Proper (@eq ==> @eq ==> @impl) (@lt)))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_total	100	0.093826	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => let v2 : Compare (@lt) (@eq) v0 v1 := compare v0 v1 in match v2 as v3 in (Compare _ _ _ _) return (lt v0 v1 \/ eq v0 v1 \/ lt v1 v0) with | LT v3 => (fun v3 : lt v0 v1 => or_introl v3) v3 | EQ v3 => (fun v3 : eq v0 v1 => or_intror (or_introl v3)) v3 | GT v3 => (fun v3 : lt v1 v0 => or_intror (or_intror v3)) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.IsTO.le_lteq	100	0.035831	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @t => reflexivity (lt v0 v1 \/ eq v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.le_eq	100	0.068161	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : ~ lt v0 v1) (v4 : eq v1 v2) => let v5 : TO.le v1 v0 := OrderTac.not_gt_le v3 in (fun v6 : lt v0 v2 => False_ind (@False) ((fun v7 : TO.le v2 v0 => (fun v8 : TO.lt v2 v2 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v7 v6)) (OrderTac.eq_le (OrderTac.eq_sym v4) v5))) : ~ lt v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.eq_le	100	0.074879	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : eq v0 v1) (v4 : ~ lt v1 v2) => let v5 : TO.le v2 v1 := OrderTac.not_gt_le v4 in (fun v6 : lt v0 v2 => False_ind (@False) ((fun v7 : TO.lt v1 v2 => (fun v8 : TO.lt v2 v2 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v5 v7)) (OrderTac.eq_lt (OrderTac.eq_sym v3) v6))) : ~ lt v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.neq_eq	100	0.075185	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : ~ eq v0 v1) (v4 : eq v1 v2) => (fun v5 : eq v0 v2 => False_ind (@False) ((fun v6 : ~ TO.eq v2 v1 => (fun v7 : ~ TO.eq v2 v2 => v7 (OrderTac.eq_refl v2)) (OrderTac.neq_eq v6 v4)) (OrderTac.eq_neq (OrderTac.eq_sym v5) v3))) : ~ eq v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.eq_neq	100	0.065460	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : eq v0 v1) (v4 : ~ eq v1 v2) => (fun v5 : eq v0 v2 => False_ind (@False) ((fun v6 : TO.eq v2 v1 => (fun v7 : ~ TO.eq v1 v1 => v7 (OrderTac.eq_refl v1)) (OrderTac.neq_eq v4 v6)) (OrderTac.eq_trans (OrderTac.eq_sym v5) v3))) : ~ eq v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.le_lt_trans	100	0.069811	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : ~ lt v1 v0) (v4 : lt v1 v2) => let v5 : TO.le v0 v1 := OrderTac.not_gt_le v3 in OrderTac.not_ge_lt ((fun v6 : TO.le v2 v0 => (fun v7 : TO.lt v0 v2 => (fun v8 : TO.lt v2 v2 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v6 v7)) (OrderTac.le_lt_trans v5 v4)) : ~ TO.le v2 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_le_trans	100	0.081455	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : lt v0 v1) (v4 : ~ lt v2 v1) => let v5 : TO.le v1 v2 := OrderTac.not_gt_le v4 in OrderTac.not_ge_lt ((fun v6 : TO.le v2 v0 => (fun v7 : TO.lt v2 v1 => (fun v8 : TO.lt v1 v1 => OrderTac.lt_irrefl v8) (OrderTac.le_lt_trans v5 v7)) (OrderTac.le_lt_trans v6 v3)) : ~ TO.le v2 v0))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.le_neq	100	0.069675	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : ~ lt v0 v1) (v3 : ~ eq v0 v1) => let v4 : TO.le v1 v0 := OrderTac.not_gt_le v2 in OrderTac.not_ge_lt ((fun v5 : TO.le v0 v1 => (fun v6 : TO.eq v1 v0 => (fun v7 : ~ TO.eq v0 v0 => v7 (OrderTac.eq_refl v0)) (OrderTac.neq_eq v3 v6)) (OrderTac.le_antisym v4 v5)) : ~ TO.le v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.le_trans	100	0.075598	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @t) (v3 : ~ lt v1 v0) (v4 : ~ lt v2 v1) => let v5 : TO.le v1 v2 := OrderTac.not_gt_le v4 in let v6 : TO.le v0 v1 := OrderTac.not_gt_le v3 in (fun v7 : lt v2 v0 => False_ind (@False) ((fun v8 : TO.lt v1 v0 => (fun v9 : TO.lt v0 v0 => OrderTac.lt_irrefl v9) (OrderTac.le_lt_trans v6 v8)) (OrderTac.le_lt_trans v5 v7))) : ~ lt v2 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.le_antisym	100	0.090339	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : ~ lt v1 v0) (v3 : ~ lt v0 v1) => let v4 : TO.le v1 v0 := OrderTac.not_gt_le v3 in let v5 : TO.le v0 v1 := OrderTac.not_gt_le v2 in OrderTac.not_neq_eq ((fun v6 : ~ TO.eq v0 v1 => (fun v7 : TO.eq v0 v1 => (fun v8 : ~ TO.eq v1 v1 => v8 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v7) v6)) (OrderTac.le_antisym v5 v4)) : ~ ~ TO.eq v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.neq_sym	100	0.049734	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : ~ eq v0 v1) => (fun v3 : eq v1 v0 => False_ind (@False) ((fun v4 : ~ TO.eq v0 v0 => v4 (OrderTac.eq_refl v0)) (OrderTac.neq_eq v2 v3))) : ~ eq v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_le	100	0.046801	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : lt v0 v1) => (fun v3 : lt v1 v0 => False_ind (@False) ((fun v4 : TO.lt v0 v0 => OrderTac.lt_irrefl v4) (OrderTac.lt_trans v2 v3))) : ~ lt v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.gt_not_eq	100	0.052859	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : lt v1 v0) => (fun v3 : eq v0 v1 => False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v2 v3))) : ~ eq v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.eq_not_lt	100	0.058956	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : eq v0 v1) => (fun v3 : lt v0 v1 => False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3))) : ~ lt v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.eq_not_gt	100	0.049919	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : eq v0 v1) => (fun v3 : lt v1 v0 => False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2))) : ~ lt v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_not_gt	100	0.044673	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @t) (v2 : lt v0 v1) => (fun v3 : lt v1 v0 => False_ind (@False) ((fun v4 : TO.lt v0 v0 => OrderTac.lt_irrefl v4) (OrderTac.lt_trans v2 v3))) : ~ lt v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.elim_compare_eq	100	0.118334	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : eq v0 v1) => match compare v0 v1 as v3 in (Compare _ _ _ _) return (exists v4 : eq v0 v1, v3 = EQ v4) with | LT v3 => (fun v3 : lt v0 v1 => False_ind (exists v4 : eq v0 v1, LT v3 = EQ v4) (False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v2) v3)))) v3 | EQ v3 => (fun v3 : eq v0 v1 => ex_intro (fun v4 : eq v0 v1 => EQ v3 = EQ v4) v3 Logic.eq_refl) v3 | GT v3 => (fun v3 : lt v1 v0 => False_ind (exists v4 : eq v0 v1, GT v3 = EQ v4) (False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v3 v2)))) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.elim_compare_lt	100	0.136784	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : lt v0 v1) => match compare v0 v1 as v3 in (Compare _ _ _ _) return (exists v4 : lt v0 v1, v3 = LT v4) with | LT v3 => (fun v3 : lt v0 v1 => ex_intro (fun v4 : lt v0 v1 => LT v3 = LT v4) v3 Logic.eq_refl) v3 | EQ v3 => (fun v3 : eq v0 v1 => False_ind (exists v4 : lt v0 v1, EQ v3 = LT v4) (False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.eq_lt (OrderTac.eq_sym v3) v2)))) v3 | GT v3 => (fun v3 : lt v1 v0 => False_ind (exists v4 : lt v0 v1, GT v3 = LT v4) (False_ind (@False) ((fun v4 : TO.lt v0 v0 => OrderTac.lt_irrefl v4) (OrderTac.lt_trans v2 v3)))) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.elim_compare_gt	100	0.120380	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @t) (v2 : lt v1 v0) => match compare v0 v1 as v3 in (Compare _ _ _ _) return (exists v4 : lt v1 v0, v3 = GT v4) with | LT v3 => (fun v3 : lt v0 v1 => False_ind (exists v4 : lt v1 v0, LT v3 = GT v4) (False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_trans v2 v3)))) v3 | EQ v3 => (fun v3 : eq v0 v1 => False_ind (exists v4 : lt v1 v0, EQ v3 = GT v4) (False_ind (@False) ((fun v4 : TO.lt v1 v1 => OrderTac.lt_irrefl v4) (OrderTac.lt_eq v2 v3)))) v3 | GT v3 => (fun v3 : lt v1 v0 => ex_intro (fun v4 : lt v1 v0 => GT v3 = GT v4) v3 Logic.eq_refl) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.lt_dec	100	0.072103	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @t => Compare_rec (P:=fun v2 : Compare (@lt) (@eq) v0 v1 => {lt v0 v1} + {~ lt v0 v1}) (fun v2 : lt v0 v1 => left v2) (fun v2 : eq v0 v1 => right (eq_not_gt (eq_sym v2))) (fun v2 : lt v1 v0 => right (lt_not_gt v2)) (compare v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.eqb_alt	100	0.197410	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @t => let v2 : {eq v0 v1} + {~ eq v0 v1} := eq_dec v0 v1 in match v2 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@bool) with | left v4 => (fun v4 : eq v0 v1 => @true) v4 | right v4 => (fun v4 : ~ eq v0 v1 => @false) v4 end = match compare v0 v1 as v4 in (Compare _ _ _ _) return (@bool) with | LT v4 => (fun v4 : lt v0 v1 => @false) v4 | EQ v4 => (fun v4 : eq v0 v1 => @true) v4 | GT v4 => (fun v4 : lt v1 v0 => @false) v4 end) with | left v3 => (fun v3 : eq v0 v1 => let v4 : Compare (@lt) (@eq) v0 v1 := compare v0 v1 in match v4 as v5 in (Compare _ _ _ _) return (@true = match v5 as v6 in (Compare _ _ _ _) return (@bool) with | LT v6 => (fun v6 : lt v0 v1 => @false) v6 | EQ v6 => (fun v6 : eq v0 v1 => @true) v6 | GT v6 => (fun v6 : lt v1 v0 => @false) v6 end) with | LT v5 => (fun v5 : lt v0 v1 => False_ind (@true = @false) ((fun v6 : TO.lt v1 v1 => OrderTac.lt_irrefl v6) (OrderTac.eq_lt (OrderTac.eq_sym v3) v5))) v5 | EQ v5 => (fun v5 : eq v0 v1 => Logic.eq_refl) v5 | GT v5 => (fun v5 : lt v1 v0 => False_ind (@true = @false) ((fun v6 : TO.lt v1 v1 => OrderTac.lt_irrefl v6) (OrderTac.lt_eq v5 v3))) v5 end) v3 | right v3 => (fun v3 : ~ eq v0 v1 => let v4 : Compare (@lt) (@eq) v0 v1 := compare v0 v1 in match v4 as v5 in (Compare _ _ _ _) return (@false = match v5 as v6 in (Compare _ _ _ _) return (@bool) with | LT v6 => (fun v6 : lt v0 v1 => @false) v6 | EQ v6 => (fun v6 : eq v0 v1 => @true) v6 | GT v6 => (fun v6 : lt v1 v0 => @false) v6 end) with | LT v5 => (fun v5 : lt v0 v1 => Logic.eq_refl) v5 | EQ v5 => (fun v5 : eq v0 v1 => False_ind (@false = @true) ((fun v6 : ~ TO.eq v1 v1 => v6 (OrderTac.eq_refl v1)) (OrderTac.eq_neq (OrderTac.eq_sym v5) v3))) v5 | GT v5 => (fun v5 : lt v1 v0 => Logic.eq_refl) v5 end) v3 end) : forall v0 v1 : @t, eqb v0 v1 = match compare v0 v1 as v2 in (Compare _ _ _ _) return (@bool) with | LT v2 => (fun v2 : lt v0 v1 => @false) v2 | EQ v2 => (fun v2 : eq v0 v1 => @true) v2 | GT v2 => (fun v2 : lt v1 v0 => @false) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.In_eq	100	0.046741	1	1	0	synth with cache (only 1: refine (InA_eqA (@eq_equiv))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.ListIn_In	100	0.036332	1	1	0	synth with cache (only 1: refine (In_InA (@eq_equiv))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.Inf_lt	100	0.045877	1	1	0	synth with cache (only 1: refine (InfA_ltA (@lt_strorder))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.Inf_eq	100	0.044389	1	1	0	synth with cache (only 1: refine (InfA_eqA (@eq_equiv) (ltA:=@lt) (@lt_compat))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.Sort_Inf_In	100	0.052904	1	1	0	synth with cache (only 1: refine (SortA_InfA_InA (@eq_equiv) (@lt_strorder) (@lt_compat))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.ListIn_Inf	100	0.037445	1	1	0	synth with cache (only 1: refine (In_InfA (ltA:=@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.In_Inf	100	0.044515	1	1	0	synth with cache (only 1: refine (InA_InfA (@eq_equiv) (ltA:=@lt))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.Inf_alt	100	0.050402	1	1	0	synth with cache (only 1: refine (InfA_alt (@eq_equiv) (@lt_strorder) (@lt_compat))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.OrderedTypeFacts.ForNotations.Sort_NoDup	100	0.034109	1	1	0	synth with cache (only 1: refine (SortA_NoDupA (@eq_equiv) (@lt_strorder) (@lt_compat))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqke_eqk	100	0.070546	1	1	0	synth with cache (only 1: refine (((fun v0 : key * @elt => prod_ind (fun v1 : key * @elt => forall (v2 : key * @elt) (v3 : eq (fst v1) (fst v2) /\ snd v1 = snd v2), eq (fst v1) (fst v2)) (fun (v1 : key) (v2 : @elt) (v3 : key * @elt) (v4 : eq (fst (v1, v2)) (fst v3) /\ snd (v1, v2) = snd v3) => and_ind (fun (v5 : eq (fst (v1, v2)) (fst v3)) (v6 : snd (v1, v2) = snd v3) => v5) v4) v0) : forall (v0 v1 : key * @elt) (v2 : eqke v0 v1), eq (fst v0) (fst v1)) : forall (v0 v1 : key * @elt) (v2 : eqke v0 v1), eqk v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_right_r	100	0.047858	1	1	0	synth with cache (only 1: refine (fun (v0 : key * @elt) (v1 : key) (v2 v3 : @elt) (v4 : ltk v0 (v1, v2)) => v4)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_right_l	100	0.049795	1	1	0	synth with cache (only 1: refine (fun (v0 : key * @elt) (v1 : key) (v2 v3 : @elt) (v4 : ltk (v1, v2) v0) => v4)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqk_refl	100	0.035512	1	1	0	synth with cache (only 1: refine (fun v0 : key * @elt => eq_refl (fst v0) : eqk v0 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqke_refl	100	0.054819	1	1	0	synth with cache (only 1: refine (fun v0 : key * @elt => conj (eq_refl (fst v0)) Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqk_sym	100	0.059382	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : key * @elt) (v2 : eqk v0 v1) => eq_sym v2 : eqk v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqke_sym	100	0.231395	1	1	0	synth with cache (only 1: refine ((fun v0 : key * @elt => prod_ind (fun v1 : key * @elt => forall (v2 : key * @elt) (v3 : eq (fst v1) (fst v2) /\ snd v1 = snd v2), eq (fst v2) (fst v1) /\ snd v2 = snd v1) (fun (v1 : key) (v2 : @elt) (v3 : key * @elt) (v4 : eq (fst (v1, v2)) (fst v3) /\ snd (v1, v2) = snd v3) => and_ind (fun (v5 : eq (fst (v1, v2)) (fst v3)) (v6 : snd (v1, v2) = snd v3) => conj (symmetry v5 : eq (fst v3) (fst (v1, v2))) (Logic.eq_sym v6 : snd v3 = snd (v1, v2))) v4) v0) : forall (v0 v1 : key * @elt) (v2 : eqke v0 v1), eqke v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqk_trans	100	0.070854	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : key * @elt) (v3 : eqk v0 v1) (v4 : eqk v1 v2) => eq_trans v3 v4 : eqk v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqke_trans	100	0.189321	1	1	0	synth with cache (only 1: refine ((fun v0 : key * @elt => prod_ind (fun v1 : key * @elt => forall (v2 v3 : key * @elt) (v4 : eq (fst v1) (fst v2) /\ snd v1 = snd v2) (v5 : eq (fst v2) (fst v3) /\ snd v2 = snd v3), eq (fst v1) (fst v3) /\ snd v1 = snd v3) (fun (v1 : key) (v2 : @elt) (v3 : key * @elt) => prod_ind (fun v4 : key * @elt => forall (v5 : key * @elt) (v6 : eq (fst (v1, v2)) (fst v4) /\ snd (v1, v2) = snd v4) (v7 : eq (fst v4) (fst v5) /\ snd v4 = snd v5), eq (fst (v1, v2)) (fst v5) /\ snd (v1, v2) = snd v5) (fun (v4 : key) (v5 : @elt) (v6 : key * @elt) (v7 : eq (fst (v1, v2)) (fst (v4, v5)) /\ snd (v1, v2) = snd (v4, v5)) (v8 : eq (fst (v4, v5)) (fst v6) /\ snd (v4, v5) = snd v6) => and_ind (fun (v9 : eq (fst (v1, v2)) (fst (v4, v5))) (v10 : snd (v1, v2) = snd (v4, v5)) => and_ind (fun (v11 : eq (fst (v4, v5)) (fst v6)) (v12 : snd (v4, v5) = snd v6) => conj (eq_trans v9 v11) (Logic.eq_trans v10 v12)) v8) v7) v3) v0) : forall (v0 v1 v2 : key * @elt) (v3 : eqke v0 v1) (v4 : eqke v1 v2), eqke v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_trans	100	0.069003	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : key * @elt) (v3 : ltk v0 v1) (v4 : ltk v1 v2) => lt_trans v3 v4 : ltk v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_not_eqk	100	0.095223	1	1	0	synth with cache (only 1: refine (((fun (v0 v1 : key * @elt) (v2 : lt (fst v0) (fst v1)) => lt_not_eq v2) : forall (v0 v1 : key * @elt) (v2 : ltk v0 v1), ~ eq (fst v0) (fst v1)) : forall (v0 v1 : key * @elt) (v2 : ltk v0 v1), ~ eqk v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_not_eqke	100	0.092589	1	1	0	synth with cache (only 1: refine (((fun v0 : key * @elt => prod_ind (fun v1 : key * @elt => forall (v2 : key * @elt) (v3 : lt (fst v1) (fst v2)), ~ (eq (fst v1) (fst v2) /\ snd v1 = snd v2)) (fun (v1 : key) (v2 : @elt) (v3 : key * @elt) (v4 : lt (fst (v1, v2)) (fst v3)) => (fun v5 : eq (fst (v1, v2)) (fst v3) /\ snd (v1, v2) = snd v3 => and_ind (fun (v6 : eq (fst (v1, v2)) (fst v3)) (v7 : snd (v1, v2) = snd v3) => lt_not_eq v4 v6 : @False) v5) : ~ (eq (fst (v1, v2)) (fst v3) /\ snd (v1, v2) = snd v3)) v0) : forall (v0 v1 : key * @elt) (v2 : ltk v0 v1), ~ (eq (fst v0) (fst v1) /\ snd v0 = snd v1)) : forall (v0 v1 : key * @elt) (v2 : ltk v0 v1), ~ eqke v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqk_equiv	100	0.092070	1	1	0	synth with cache (only 1: refine {| Equivalence_Reflexive := (fun v0 : key * @elt => eqk_refl v0) : Reflexive (@eqk); Equivalence_Symmetric := (fun (v0 v1 : key * @elt) (v2 : eqk v0 v1) => eqk_sym (e:=v0) (e':=v1) v2) : Symmetric (@eqk); Equivalence_Transitive := (fun (v0 v1 v2 : key * @elt) (v3 : eqk v0 v1) (v4 : eqk v1 v2) => eq_trans v3 v4 : eqk v0 v2) : Transitive (@eqk) |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqke_equiv	100	0.084702	1	1	0	synth with cache (only 1: refine {| Equivalence_Reflexive := (fun v0 : key * @elt => eqke_refl v0) : Reflexive (@eqke); Equivalence_Symmetric := (fun (v0 v1 : key * @elt) (v2 : eqke v0 v1) => eqke_sym (e:=v0) (e':=v1) v2) : Symmetric (@eqke); Equivalence_Transitive := (fun (v0 v1 v2 : key * @elt) (v3 : eqke v0 v1) (v4 : eqke v1 v2) => eqke_trans (e:=v0) (e':=v1) (e'':=v2) v3 v4) : Transitive (@eqke) |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_strorder	100	0.086794	1	1	0	synth with cache (only 1: refine {| StrictOrder_Irreflexive := (fun v0 : key * @elt => irreflexivity (x:=fst v0)) : Irreflexive (@ltk); StrictOrder_Transitive := (fun (v0 v1 v2 : key * @elt) (v3 : ltk v0 v1) (v4 : ltk v1 v2) => lt_trans v3 v4 : ltk v0 v2) : Transitive (@ltk) |}).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_compat	100	0.309877	1	1	0	synth with cache (only 1: refine ((fun v0 : key * @elt => match v0 as v1 in (_ * _)%type return (forall (v2 : key * @elt) (v3 : eqk v1 v2), (@eqk ==> @iff)%signature (ltk v1) (ltk v2)) with | (v1, v2) => (fun (v1 : key) (v2 : @elt) (v3 : key * @elt) => match v3 as v4 in (_ * _)%type return (forall v5 : eqk (v1, v2) v4, (@eqk ==> @iff)%signature (ltk (v1, v2)) (ltk v4)) with | (v4, v5) => (fun (v4 : key) (v5 : @elt) (v6 : eqk (v1, v2) (v4, v5)) => (fun v7 : key * @elt => match v7 as v8 in (_ * _)%type return (forall (v9 : key * @elt) (v10 : eqk v8 v9), ltk (v1, v2) v8 <-> ltk (v4, v5) v9) with | (v8, v9) => (fun (v8 : key) (v9 : @elt) (v10 : key * @elt) => match v10 as v11 in (_ * _)%type return (forall v12 : eqk (v8, v9) v11, ltk (v1, v2) (v8, v9) <-> ltk (v4, v5) v11) with | (v11, v12) => (fun (v11 : key) (v12 : @elt) (v13 : eqk (v8, v9) (v11, v12)) => (fun v14 : eq v1 v4 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (forall v15 : lt v1 v8, lt v4 v11) (forall v15 : lt v4 v8, lt v4 v11) (Morphisms_Prop.iff_iff_iff_impl_morphism (lt v1 v8) (lt v4 v8) (lt_compat v14 (reflexive_proper_proxy Equivalence_Reflexive v8)) (lt v4 v11) (lt v4 v11) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v11))) (forall v15 : lt v4 v11, lt v1 v8) (forall v15 : lt v4 v11, lt v4 v8) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v11)) (lt v1 v8) (lt v4 v8) (lt_compat v14 (reflexive_proper_proxy Equivalence_Reflexive v8)))) v6 ((fun v14 : eq v8 v11 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (forall v15 : lt v4 v8, lt v4 v11) (forall v15 : lt v4 v11, lt v4 v11) (Morphisms_Prop.iff_iff_iff_impl_morphism (lt v4 v8) (lt v4 v11) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v4) v8 v11 v14) (lt v4 v11) (lt v4 v11) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v11))) (forall v15 : lt v4 v11, lt v4 v8) (forall v15 : lt v4 v11, lt v4 v11) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v11)) (lt v4 v8) (lt v4 v11) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v4) v8 v11 v14))) v13 (conj (fun v14 : lt v4 v11 => v14) (fun v14 : lt v4 v11 => v14))) : ltk (v1, v2) (v8, v9) <-> ltk (v4, v5) (v11, v12)) v11 v12 end) v8 v9 end) : (@eqk ==> @iff)%signature (ltk (v1, v2)) (ltk (v4, v5))) v4 v5 end) v1 v2 end) : Proper (@eqk ==> @eqk ==> @iff) (@ltk))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_compat'	100	0.429895	1	1	0	synth with cache (only 1: refine ((fun v0 : key * @elt => match v0 as v1 in (_ * _)%type return (forall (v2 : key * @elt) (v3 : eqke v1 v2), (@eqke ==> @iff)%signature (ltk v1) (ltk v2)) with | (v1, v2) => (fun (v1 : key) (v2 : @elt) (v3 : key * @elt) => match v3 as v4 in (_ * _)%type return (forall v5 : eqke (v1, v2) v4, (@eqke ==> @iff)%signature (ltk (v1, v2)) (ltk v4)) with | (v4, v5) => (fun (v4 : key) (v5 : @elt) (v6 : eqke (v1, v2) (v4, v5)) => match v6 as v7 in (_ /\ _) return ((@eqke ==> @iff)%signature (ltk (v1, v2)) (ltk (v4, v5))) with | conj v7 v8 => (fun (v7 : eq (fst (v1, v2)) (fst (v4, v5))) (v8 : snd (v1, v2) = snd (v4, v5)) => (fun v9 : key * @elt => match v9 as v10 in (_ * _)%type return (forall (v11 : key * @elt) (v12 : eqke v10 v11), ltk (v1, v2) v10 <-> ltk (v4, v5) v11) with | (v10, v11) => (fun (v10 : key) (v11 : @elt) (v12 : key * @elt) => match v12 as v13 in (_ * _)%type return (forall v14 : eqke (v10, v11) v13, ltk (v1, v2) (v10, v11) <-> ltk (v4, v5) v13) with | (v13, v14) => (fun (v13 : key) (v14 : @elt) (v15 : eqke (v10, v11) (v13, v14)) => match v15 as v16 in (_ /\ _) return (ltk (v1, v2) (v10, v11) <-> ltk (v4, v5) (v13, v14)) with | conj v16 v17 => (fun (v16 : eq (fst (v10, v11)) (fst (v13, v14))) (v17 : snd (v10, v11) = snd (v13, v14)) => (fun v18 : eq v1 v4 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (forall v19 : lt v1 v10, lt v4 v13) (forall v19 : lt v4 v10, lt v4 v13) (Morphisms_Prop.iff_iff_iff_impl_morphism (lt v1 v10) (lt v4 v10) (lt_compat v18 (reflexive_proper_proxy Equivalence_Reflexive v10)) (lt v4 v13) (lt v4 v13) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v13))) (forall v19 : lt v4 v13, lt v1 v10) (forall v19 : lt v4 v13, lt v4 v10) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v13)) (lt v1 v10) (lt v4 v10) (lt_compat v18 (reflexive_proper_proxy Equivalence_Reflexive v10)))) v7 ((fun v18 : eq v10 v13 => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (forall v19 : lt v4 v10, lt v4 v13) (forall v19 : lt v4 v13, lt v4 v13) (Morphisms_Prop.iff_iff_iff_impl_morphism (lt v4 v10) (lt v4 v13) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v4) v10 v13 v18) (lt v4 v13) (lt v4 v13) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v13))) (forall v19 : lt v4 v13, lt v4 v10) (forall v19 : lt v4 v13, lt v4 v13) (Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (reflexive_proper_proxy (@iff_Reflexive) (lt v4 v13)) (lt v4 v10) (lt v4 v13) (Reflexive_partial_app_morphism (@lt_compat) (reflexive_proper_proxy Equivalence_Reflexive v4) v10 v13 v18))) v16 (conj (fun v18 : lt v4 v13 => v18) (fun v18 : lt v4 v13 => v18))) : ltk (v1, v2) (v10, v11) <-> ltk (v4, v5) (v13, v14)) v16 v17 end) v13 v14 end) v10 v11 end) : (@eqke ==> @iff)%signature (ltk (v1, v2)) (ltk (v4, v5))) v7 v8 end) v4 v5 end) v1 v2 end) : Proper (@eqke ==> @eqke ==> @iff) (@ltk))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqk_not_ltk	100	0.149934	1	1	0	synth with cache (only 1: refine ((((fun (v0 v1 : key * @elt) (v2 : eq (fst v0) (fst v1)) => eq_not_gt (eq_sym v2)) : forall (v0 v1 : key * @elt) (v2 : eq (fst v0) (fst v1)), ~ lt (fst v0) (fst v1)) : forall (v0 v1 : key * @elt) (v2 : eq (fst v0) (fst v1)), ~ ltk v0 v1) : forall (v0 v1 : key * @elt) (v2 : eqk v0 v1), ~ ltk v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.ltk_eqk	100	0.080733	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : key * @elt) (v3 : ltk v0 v1) (v4 : eqk v1 v2) => lt_eq v3 v4 : ltk v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.eqk_ltk	100	0.129921	1	1	0	synth with cache (only 1: refine (fun v0 : key * @elt => match v0 as v1 in (_ * _)%type return (forall (v2 v3 : key * @elt) (v4 : eqk v1 v2) (v5 : ltk v2 v3), ltk v1 v3) with | (v1, v2) => (fun (v1 : key) (v2 : @elt) (v3 : key * @elt) => match v3 as v4 in (_ * _)%type return (forall (v5 : key * @elt) (v6 : eqk (v1, v2) v4) (v7 : ltk v4 v5), ltk (v1, v2) v5) with | (v4, v5) => (fun (v4 : key) (v5 : @elt) (v6 : key * @elt) => match v6 as v7 in (_ * _)%type return (forall (v8 : eqk (v1, v2) (v4, v5)) (v9 : ltk (v4, v5) v7), ltk (v1, v2) v7) with | (v7, v8) => (fun (v7 : key) (v8 : @elt) => (((fun (v9 : eq v1 v4) (v10 : lt v4 v7) => eq_lt v9 v10) : forall (v9 : eq (fst (v1, v2)) (fst (v4, v5))) (v10 : lt (fst (v4, v5)) (fst (v7, v8))), lt (fst (v1, v2)) (fst (v7, v8))) : forall (v9 : eqk (v1, v2) (v4, v5)) (v10 : lt (fst (v4, v5)) (fst (v7, v8))), lt (fst (v1, v2)) (fst (v7, v8))) : forall (v9 : eqk (v1, v2) (v4, v5)) (v10 : ltk (v4, v5) (v7, v8)), ltk (v1, v2) (v7, v8)) v7 v8 end) v4 v5 end) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.InA_eqke_eqk	100	0.181829	1	1	0	synth with cache (only 1: refine ((fun (v0 : key * @elt) (v1 : list (key * @elt)) (v2 : InA (fun v2 v3 : key * @elt => eq (fst v2) (fst v3) /\ snd v2 = snd v3) v0 v1) => InA_ind (P:=fun v3 : list (key * @elt) => InA (@eqk) v0 v3) (fun (v3 : key * @elt) (v4 : list (key * @elt)) (v5 : eq (fst v0) (fst v3) /\ snd v0 = snd v3) => and_ind (fun (v6 : eq (fst v0) (fst v3)) (v7 : snd v0 = snd v3) => InA_cons_hd (eqA:=@eqk) (x:=v0) (y:=v3) v4 v6 : InA (@eqk) v0 (v3 :: v4)) v5) (fun (v3 : key * @elt) (v4 : list (key * @elt)) (v5 : InA (fun v5 v6 : key * @elt => eq (fst v5) (fst v6) /\ snd v5 = snd v6) v0 v4) (v6 : InA (@eqk) v0 v4) => prod_ind (fun v7 : key * @elt => InA (@eqk) v0 (v7 :: v4)) (fun (v7 : key) (v8 : @elt) => InA_cons_tl (v7, v8) v6 : InA (@eqk) v0 ((v7, v8) :: v4)) v3) v2) : forall (v0 : key * @elt) (v1 : list (key * @elt)) (v2 : InA (@eqke) v0 v1), InA (@eqk) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.In_alt	100	0.184386	1	1	0	synth with cache (only 1: refine (fun (v0 : key) (v1 : list (key * @elt)) => conj (fun v2 : In v0 v1 => ex_ind (fun (v3 : @elt) (v4 : MapsTo v0 v3 v1) => ex_intro (fun v5 : @elt => InA (@eqk) (v0, v5) v1) v3 (InA_eqke_eqk v4)) v2) (fun v2 : exists v2 : @elt, InA (@eqk) (v0, v2) v1 => ex_ind (fun (v3 : @elt) (v4 : InA (@eqk) (v0, v3) v1) => InA_ind (P:=fun v5 : list (key * @elt) => In v0 v5) (fun (v5 : key * @elt) (v6 : list (key * @elt)) (v7 : eqk (v0, v3) v5) => match v5 as v8 in (_ * _)%type return (forall v9 : eqk (v0, v3) v8, In v0 (v8 :: v6)) with | (v8, v9) => (fun (v8 : key) (v9 : @elt) (v10 : eqk (v0, v3) (v8, v9)) => ex_intro (fun v11 : @elt => MapsTo v0 v11 ((v8, v9) :: v6)) v9 (InA_cons_hd (eqA:=@eqke) (x:=(v0, v9)) (y:=(v8, v9)) v6 (conj v10 Logic.eq_refl) : MapsTo v0 v9 ((v8, v9) :: v6))) v8 v9 end v7) (fun (v5 : key * @elt) (v6 : list (key * @elt)) (v7 : InA (@eqk) (v0, v3) v6) (v8 : In v0 v6) => match v8 as v9 in (ex _) return (In v0 (v5 :: v6)) with | ex_intro _ v9 v10 => (fun (v9 : @elt) (v10 : MapsTo v0 v9 v6) => ex_intro (fun v11 : @elt => MapsTo v0 v11 (v5 :: v6)) v9 (InA_cons_tl v5 v10 : MapsTo v0 v9 (v5 :: v6))) v9 v10 end) v4) v2))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.MapsTo_eq	100	0.109704	1	1	0	synth with cache (only 1: refine (fun (v0 : list (key * @elt)) (v1 v2 : key) (v3 : @elt) (v4 : eq v1 v2) (v5 : MapsTo v1 v3 v0) => InA_eqA (@eqke_equiv) (y:=(v2, v3)) (conj v4 Logic.eq_refl : eqke (v1, v3) (v2, v3)) v5 : MapsTo v2 v3 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.In_eq	100	0.079272	1	1	0	synth with cache (only 1: refine (fun (v0 : list (key * @elt)) (v1 v2 : key) (v3 : eq v1 v2) (v4 : In v1 v0) => match v4 as v5 in (ex _) return (In v2 v0) with | ex_intro _ v5 v6 => (fun (v5 : @elt) (v6 : MapsTo v1 v5 v0) => ex_intro (fun v7 : @elt => MapsTo v2 v7 v0) v5 (MapsTo_eq (l:=v0) (e:=v5) v3 v6)) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Inf_eq	100	0.091271	1	1	0	synth with cache (only 1: refine (InfA_eqA (@eqk_equiv) (ltA:=@ltk) (@ltk_compat))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Inf_lt	100	0.074329	1	1	0	synth with cache (only 1: refine (InfA_ltA (@ltk_strorder))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Sort_Inf_In	100	0.073171	1	1	0	synth with cache (only 1: refine (SortA_InfA_InA (@eqk_equiv) (@ltk_strorder) (@ltk_compat))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Sort_Inf_NotIn	100	0.084069	1	1	0	synth with cache (only 1: refine (fun (v0 : list (key * @elt)) (v1 : key) (v2 : @elt) (v3 : Sorted (@ltk) v0) (v4 : HdRel (@ltk) (v1, v2) v0) => (fun v5 : In v1 v0 => match v5 as v6 in (ex _) return (@False) with | ex_intro _ v6 v7 => (fun (v6 : @elt) (v7 : MapsTo v1 v6 v0) => False_ind (@False) (ltk_not_eqk (e:=(v1, v2)) (e':=(v1, v6)) (Sort_Inf_In v3 v4 (InA_eqke_eqk v7)) ((eq_refl v1 : eq (fst (v1, v2)) (fst (v1, v6))) : eqk (v1, v2) (v1, v6)))) v6 v7 end) : ~ In v1 v0)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Sort_NoDupA	100	0.067849	1	1	0	synth with cache (only 1: refine (SortA_NoDupA (@eqk_equiv) (@ltk_strorder) (@ltk_compat))).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Sort_In_cons_1	100	0.266070	1	1	0	synth with cache (only 1: refine (fun (v0 : key * @elt) (v1 : list (key * @elt)) (v2 : key * @elt) (v3 : Sorted (@ltk) (v0 :: v1)) => let v4 : forall (v4 : v0 :: v1 = v0 :: v1) (v5 : InA (@eqk) v2 v1), ltk v0 v2 := match v3 as v5 in (Sorted _ v4) return (forall (v6 : v4 = v0 :: v1) (v7 : InA (@eqk) v2 v1), ltk v0 v2) with | Sorted_nil _ => fun v4 : nil = v0 :: v1 => (fun v5 : nil = v0 :: v1 => let v6 : @False := eq_ind nil (fun v6 : list (key * @elt) => match v6 as v7 in (list _) return Prop with | nil => @True | v7 :: v8 => (fun (v7 : key * @elt) (v8 : list (key * @elt)) => @False) v7 v8 end) (@I) (v0 :: v1) v5 in False_ind (forall v7 : InA (@eqk) v2 v1, ltk v0 v2) v6) v4 | @Sorted_cons _ _ v4 v5 v6 v7 => (fun (v4 : key * @elt) (v5 : list (key * @elt)) (v6 : Sorted (@ltk) v5) (v7 : HdRel (@ltk) v4 v5) (v8 : v4 :: v5 = v0 :: v1) => (fun v9 : v4 :: v5 = v0 :: v1 => let v10 : v5 = v1 := f_equal (fun v10 : list (key * @elt) => match v10 as v11 in (list _) return (list (key * @elt)) with | nil => v5 | v11 :: v12 => (fun (v11 : key * @elt) (v12 : list (key * @elt)) => v12) v11 v12 end) v9 in (let v11 : v4 = v0 := f_equal (fun v11 : list (key * @elt) => match v11 as v12 in (list _) return (key * @elt) with | nil => v4 | v12 :: v13 => (fun (v12 : key * @elt) (v13 : list (key * @elt)) => v12) v12 v13 end) v9 in (fun v12 : v4 = v0 => let v13 : v4 = v0 := v12 in eq_ind_r (fun v14 : key * @elt => forall (v15 : v5 = v1) (v16 : Sorted (@ltk) v5) (v17 : HdRel (@ltk) v14 v5) (v18 : InA (@eqk) v2 v1), ltk v0 v2) (fun v14 : v5 = v1 => let v15 : v5 = v1 := v14 in eq_ind_r (fun v16 : list (key * @elt) => forall (v17 : Sorted (@ltk) v16) (v18 : HdRel (@ltk) v0 v16) (v19 : InA (@eqk) v2 v1), ltk v0 v2) (fun (v16 : Sorted (@ltk) v1) (v17 : HdRel (@ltk) v0 v1) (v18 : InA (@eqk) v2 v1) => Sort_Inf_In v16 v17 v18) v15) v13) v11) v10) v8 v6 v7) v4 v5 v6 v7 end in v4 Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Sort_In_cons_2	100	0.324012	1	1	0	synth with cache (only 1: refine (fun (v0 : list (key * @elt)) (v1 v2 : key * @elt) (v3 : Sorted (@ltk) (v1 :: v0)) (v4 : InA (@eqk) v2 (v1 :: v0)) => let v5 : forall v5 : v1 :: v0 = v1 :: v0, ltk v1 v2 \/ eqk v1 v2 := match v4 as v6 in (InA _ _ v5) return (forall v7 : v5 = v1 :: v0, ltk v1 v2 \/ eqk v1 v2) with | @InA_cons_hd _ _ _ v5 v6 v7 => (fun (v5 : key * @elt) (v6 : list (key * @elt)) (v7 : eqk v2 v5) (v8 : v5 :: v6 = v1 :: v0) => (fun v9 : v5 :: v6 = v1 :: v0 => let v10 : v6 = v0 := f_equal (fun v10 : list (key * @elt) => match v10 as v11 in (list _) return (list (key * @elt)) with | nil => v6 | v11 :: v12 => (fun (v11 : key * @elt) (v12 : list (key * @elt)) => v12) v11 v12 end) v9 in (let v11 : v5 = v1 := f_equal (fun v11 : list (key * @elt) => match v11 as v12 in (list _) return (key * @elt) with | nil => v5 | v12 :: v13 => (fun (v12 : key * @elt) (v13 : list (key * @elt)) => v12) v12 v13 end) v9 in (fun v12 : v5 = v1 => let v13 : v5 = v1 := v12 in eq_ind_r (fun v14 : key * @elt => forall (v15 : v6 = v0) (v16 : eqk v2 v14), ltk v1 v2 \/ eqk v1 v2) (fun v14 : v6 = v0 => let v15 : v6 = v0 := v14 in eq_ind_r (fun v16 : list (key * @elt) => forall v17 : eqk v2 v1, ltk v1 v2 \/ eqk v1 v2) (fun v16 : eqk v2 v1 => or_intror (eqk_sym (e:=v2) (e':=v1) v16)) v15) v13) v11) v10) v8 v7) v5 v6 v7 | @InA_cons_tl _ _ _ v5 v6 v7 => (fun (v5 : key * @elt) (v6 : list (key * @elt)) (v7 : InA (@eqk) v2 v6) (v8 : v5 :: v6 = v1 :: v0) => (fun v9 : v5 :: v6 = v1 :: v0 => let v10 : v6 = v0 := f_equal (fun v10 : list (key * @elt) => match v10 as v11 in (list _) return (list (key * @elt)) with | nil => v6 | v11 :: v12 => (fun (v11 : key * @elt) (v12 : list (key * @elt)) => v12) v11 v12 end) v9 in (let v11 : v5 = v1 := f_equal (fun v11 : list (key * @elt) => match v11 as v12 in (list _) return (key * @elt) with | nil => v5 | v12 :: v13 => (fun (v12 : key * @elt) (v13 : list (key * @elt)) => v12) v12 v13 end) v9 in (fun v12 : v5 = v1 => let v13 : v5 = v1 := v12 in eq_ind_r (fun v14 : key * @elt => forall (v15 : v6 = v0) (v16 : InA (@eqk) v2 v6), ltk v1 v2 \/ eqk v1 v2) (fun v14 : v6 = v0 => let v15 : v6 = v0 := v14 in eq_ind_r (fun v16 : list (key * @elt) => forall v17 : InA (@eqk) v2 v16, ltk v1 v2 \/ eqk v1 v2) (fun v16 : InA (@eqk) v2 v0 => or_introl (Sort_In_cons_1 v3 v16)) v15) v13) v11) v10) v8 v7) v5 v6 v7 end in v5 Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.Sort_In_cons_3	100	0.308407	1	1	0	synth with cache (only 1: refine (fun (v0 : key) (v1 : list (key * @elt)) (v2 : key) (v3 : @elt) (v4 : Sorted (@ltk) ((v2, v3) :: v1)) => let v5 : forall (v5 : (v2, v3) :: v1 = (v2, v3) :: v1) (v6 : In v0 v1), ~ eq v0 v2 := match v4 as v6 in (Sorted _ v5) return (forall (v7 : v5 = (v2, v3) :: v1) (v8 : In v0 v1), ~ eq v0 v2) with | Sorted_nil _ => fun v5 : nil = (v2, v3) :: v1 => (fun v6 : nil = (v2, v3) :: v1 => let v7 : @False := eq_ind nil (fun v7 : list (key * @elt) => match v7 as v8 in (list _) return Prop with | nil => @True | v8 :: v9 => (fun (v8 : key * @elt) (v9 : list (key * @elt)) => @False) v8 v9 end) (@I) ((v2, v3) :: v1) v6 in False_ind (forall v8 : In v0 v1, ~ eq v0 v2) v7) v5 | @Sorted_cons _ _ v5 v6 v7 v8 => (fun (v5 : key * @elt) (v6 : list (key * @elt)) (v7 : Sorted (@ltk) v6) (v8 : HdRel (@ltk) v5 v6) (v9 : v5 :: v6 = (v2, v3) :: v1) => (fun v10 : v5 :: v6 = (v2, v3) :: v1 => let v11 : v6 = v1 := f_equal (fun v11 : list (key * @elt) => match v11 as v12 in (list _) return (list (key * @elt)) with | nil => v6 | v12 :: v13 => (fun (v12 : key * @elt) (v13 : list (key * @elt)) => v13) v12 v13 end) v10 in (let v12 : v5 = (v2, v3) := f_equal (fun v12 : list (key * @elt) => match v12 as v13 in (list _) return (key * @elt) with | nil => v5 | v13 :: v14 => (fun (v13 : key * @elt) (v14 : list (key * @elt)) => v13) v13 v14 end) v10 in (fun v13 : v5 = (v2, v3) => let v14 : v5 = (v2, v3) := v13 in eq_ind_r (fun v15 : key * @elt => forall (v16 : v6 = v1) (v17 : Sorted (@ltk) v6) (v18 : HdRel (@ltk) v15 v6) (v19 : In v0 v1), ~ eq v0 v2) (fun v15 : v6 = v1 => let v16 : v6 = v1 := v15 in eq_ind_r (fun v17 : list (key * @elt) => forall (v18 : Sorted (@ltk) v17) (v19 : HdRel (@ltk) (v2, v3) v17) (v20 : In v0 v1), ~ eq v0 v2) (fun (v17 : Sorted (@ltk) v1) (v18 : HdRel (@ltk) (v2, v3) v1) => (fun (v19 : In v0 v1) (v20 : eq v0 v2) => let v21 : @False := Sort_Inf_NotIn v17 v18 (In_eq (l:=v1) v20 v19) in match v21 as v22 in False return (@False) with end) : forall v19 : In v0 v1, ~ eq v0 v2) v16) v14) v12) v11) v9 v7 v8) v5 v6 v7 v8 end in v5 Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.In_inv	100	0.389530	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : key) (v2 : @elt) (v3 : list (key * @elt)) (v4 : In v0 ((v1, v2) :: v3)) => let v5 : eq v0 v1 \/ In v0 v3 := match v4 as v5 in (ex _) return (eq v0 v1 \/ In v0 v3) with | ex_intro _ v5 v6 => (fun (v5 : @elt) (v6 : MapsTo v0 v5 ((v1, v2) :: v3)) => (fun v7 : MapsTo v0 v5 ((v1, v2) :: v3) => let v8 : forall v8 : (v1, v2) :: v3 = (v1, v2) :: v3, eq v0 v1 \/ In v0 v3 := match v7 as v9 in (InA _ _ v8) return (forall v10 : v8 = (v1, v2) :: v3, eq v0 v1 \/ In v0 v3) with | @InA_cons_hd _ _ _ v8 v9 v10 => (fun (v8 : key * @elt) (v9 : list (key * @elt)) (v10 : eqke (v0, v5) v8) (v11 : v8 :: v9 = (v1, v2) :: v3) => (fun v12 : v8 :: v9 = (v1, v2) :: v3 => let v13 : v9 = v3 := f_equal (fun v13 : list (key * @elt) => match v13 as v14 in (list _) return (list (key * @elt)) with | nil => v9 | v14 :: v15 => (fun (v14 : key * @elt) (v15 : list (key * @elt)) => v15) v14 v15 end) v12 in (let v14 : v8 = (v1, v2) := f_equal (fun v14 : list (key * @elt) => match v14 as v15 in (list _) return (key * @elt) with | nil => v8 | v15 :: v16 => (fun (v15 : key * @elt) (v16 : list (key * @elt)) => v15) v15 v16 end) v12 in (fun v15 : v8 = (v1, v2) => let v16 : v8 = (v1, v2) := v15 in eq_ind_r (fun v17 : key * @elt => forall (v18 : v9 = v3) (v19 : eqke (v0, v5) v17), eq v0 v1 \/ In v0 v3) (fun v17 : v9 = v3 => let v18 : v9 = v3 := v17 in eq_ind_r (fun v19 : list (key * @elt) => forall v20 : eqke (v0, v5) (v1, v2), eq v0 v1 \/ In v0 v3) (fun v19 : eqke (v0, v5) (v1, v2) => match v19 as v20 in (_ /\ _) return (eq v0 v1 \/ In v0 v3) with | conj v20 v21 => (fun (v20 : eq (fst (v0, v5)) (fst (v1, v2))) (v21 : snd (v0, v5) = snd (v1, v2)) => or_introl v20 : eq v0 v1 \/ In v0 v3) v20 v21 end) v18) v16) v14) v13) v11 v10) v8 v9 v10 | @InA_cons_tl _ _ _ v8 v9 v10 => (fun (v8 : key * @elt) (v9 : list (key * @elt)) (v10 : InA (@eqke) (v0, v5) v9) (v11 : v8 :: v9 = (v1, v2) :: v3) => (fun v12 : v8 :: v9 = (v1, v2) :: v3 => let v13 : v9 = v3 := f_equal (fun v13 : list (key * @elt) => match v13 as v14 in (list _) return (list (key * @elt)) with | nil => v9 | v14 :: v15 => (fun (v14 : key * @elt) (v15 : list (key * @elt)) => v15) v14 v15 end) v12 in (let v14 : v8 = (v1, v2) := f_equal (fun v14 : list (key * @elt) => match v14 as v15 in (list _) return (key * @elt) with | nil => v8 | v15 :: v16 => (fun (v15 : key * @elt) (v16 : list (key * @elt)) => v15) v15 v16 end) v12 in (fun v15 : v8 = (v1, v2) => let v16 : v8 = (v1, v2) := v15 in eq_ind_r (fun v17 : key * @elt => forall (v18 : v9 = v3) (v19 : InA (@eqke) (v0, v5) v9), eq v0 v1 \/ In v0 v3) (fun v17 : v9 = v3 => let v18 : v9 = v3 := v17 in eq_ind_r (fun v19 : list (key * @elt) => forall v20 : InA (@eqke) (v0, v5) v19, eq v0 v1 \/ In v0 v3) (fun v19 : InA (@eqke) (v0, v5) v3 => or_intror (ex_intro (fun v20 : @elt => MapsTo v0 v20 v3) v5 v19 : In v0 v3)) v18) v16) v14) v13) v11 v10) v8 v9 v10 end in v8 Logic.eq_refl) v6) v5 v6 end in v5)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.In_inv_2	100	0.344571	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : key) (v2 v3 : @elt) (v4 : list (key * @elt)) (v5 : InA (@eqk) (v0, v2) ((v1, v3) :: v4)) => let v6 : forall (v6 : (v1, v3) :: v4 = (v1, v3) :: v4) (v7 : ~ eq v0 v1), InA (@eqk) (v0, v2) v4 := match v5 as v7 in (InA _ _ v6) return (forall (v8 : v6 = (v1, v3) :: v4) (v9 : ~ eq v0 v1), InA (@eqk) (v0, v2) v4) with | @InA_cons_hd _ _ _ v6 v7 v8 => (fun (v6 : key * @elt) (v7 : list (key * @elt)) (v8 : eqk (v0, v2) v6) (v9 : v6 :: v7 = (v1, v3) :: v4) => (fun v10 : v6 :: v7 = (v1, v3) :: v4 => let v11 : v7 = v4 := f_equal (fun v11 : list (key * @elt) => match v11 as v12 in (list _) return (list (key * @elt)) with | nil => v7 | v12 :: v13 => (fun (v12 : key * @elt) (v13 : list (key * @elt)) => v13) v12 v13 end) v10 in (let v12 : v6 = (v1, v3) := f_equal (fun v12 : list (key * @elt) => match v12 as v13 in (list _) return (key * @elt) with | nil => v6 | v13 :: v14 => (fun (v13 : key * @elt) (v14 : list (key * @elt)) => v13) v13 v14 end) v10 in (fun v13 : v6 = (v1, v3) => let v14 : v6 = (v1, v3) := v13 in eq_ind_r (fun v15 : key * @elt => forall (v16 : v7 = v4) (v17 : eqk (v0, v2) v15) (v18 : ~ eq v0 v1), InA (@eqk) (v0, v2) v4) (fun v15 : v7 = v4 => let v16 : v7 = v4 := v15 in eq_ind_r (fun v17 : list (key * @elt) => forall (v18 : eqk (v0, v2) (v1, v3)) (v19 : ~ eq v0 v1), InA (@eqk) (v0, v2) v4) (fun (v17 : eqk (v0, v2) (v1, v3)) (v18 : ~ eq v0 v1) => let v19 : @False := v18 v17 in False_ind (InA (@eqk) (v0, v2) v4) v19) v16) v14) v12) v11) v9 v8) v6 v7 v8 | @InA_cons_tl _ _ _ v6 v7 v8 => (fun (v6 : key * @elt) (v7 : list (key * @elt)) (v8 : InA (@eqk) (v0, v2) v7) (v9 : v6 :: v7 = (v1, v3) :: v4) => (fun v10 : v6 :: v7 = (v1, v3) :: v4 => let v11 : v7 = v4 := f_equal (fun v11 : list (key * @elt) => match v11 as v12 in (list _) return (list (key * @elt)) with | nil => v7 | v12 :: v13 => (fun (v12 : key * @elt) (v13 : list (key * @elt)) => v13) v12 v13 end) v10 in (let v12 : v6 = (v1, v3) := f_equal (fun v12 : list (key * @elt) => match v12 as v13 in (list _) return (key * @elt) with | nil => v6 | v13 :: v14 => (fun (v13 : key * @elt) (v14 : list (key * @elt)) => v13) v13 v14 end) v10 in (fun v13 : v6 = (v1, v3) => let v14 : v6 = (v1, v3) := v13 in eq_ind_r (fun v15 : key * @elt => forall (v16 : v7 = v4) (v17 : InA (@eqk) (v0, v2) v7) (v18 : ~ eq v0 v1), InA (@eqk) (v0, v2) v4) (fun v15 : v7 = v4 => let v16 : v7 = v4 := v15 in eq_ind_r (fun v17 : list (key * @elt) => forall (v18 : InA (@eqk) (v0, v2) v17) (v19 : ~ eq v0 v1), InA (@eqk) (v0, v2) v4) (fun (v17 : InA (@eqk) (v0, v2) v4) (v18 : ~ eq v0 v1) => v17) v16) v14) v12) v11) v9 v8) v6 v7 v8 end in v6 Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Structures.OrderedType.KeyOrderedType.Elt.In_inv_3	100	0.411914	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : key * @elt) (v2 : list (key * @elt)) (v3 : InA (@eqke) v0 (v1 :: v2)) => let v4 : forall (v4 : v1 :: v2 = v1 :: v2) (v5 : ~ eqk v0 v1), InA (@eqke) v0 v2 := match v3 as v5 in (InA _ _ v4) return (forall (v6 : v4 = v1 :: v2) (v7 : ~ eqk v0 v1), InA (@eqke) v0 v2) with | @InA_cons_hd _ _ _ v4 v5 v6 => (fun (v4 : key * @elt) (v5 : list (key * @elt)) (v6 : eqke v0 v4) (v7 : v4 :: v5 = v1 :: v2) => (fun v8 : v4 :: v5 = v1 :: v2 => let v9 : v5 = v2 := f_equal (fun v9 : list (key * @elt) => match v9 as v10 in (list _) return (list (key * @elt)) with | nil => v5 | v10 :: v11 => (fun (v10 : key * @elt) (v11 : list (key * @elt)) => v11) v10 v11 end) v8 in (let v10 : v4 = v1 := f_equal (fun v10 : list (key * @elt) => match v10 as v11 in (list _) return (key * @elt) with | nil => v4 | v11 :: v12 => (fun (v11 : key * @elt) (v12 : list (key * @elt)) => v11) v11 v12 end) v8 in (fun v11 : v4 = v1 => let v12 : v4 = v1 := v11 in eq_ind_r (fun v13 : key * @elt => forall (v14 : v5 = v2) (v15 : eqke v0 v13) (v16 : ~ eqk v0 v1), InA (@eqke) v0 v2) (fun v13 : v5 = v2 => let v14 : v5 = v2 := v13 in eq_ind_r (fun v15 : list (key * @elt) => forall (v16 : eqke v0 v1) (v17 : ~ eqk v0 v1), InA (@eqke) v0 v2) (fun (v15 : eqke v0 v1) (v16 : ~ eqk v0 v1) => and_ind (fun (v17 : eq match v0 as v17 in (_ * _)%type return key with | (v17, v18) => (fun (v17 : key) (v18 : @elt) => v17) v17 v18 end match v1 as v17 in (_ * _)%type return key with | (v17, v18) => (fun (v17 : key) (v18 : @elt) => v17) v17 v18 end) (v18 : match v0 as v18 in (_ * _)%type return (@elt) with | (v18, v19) => (fun (v18 : key) (v19 : @elt) => v19) v18 v19 end = match v1 as v18 in (_ * _)%type return (@elt) with | (v18, v19) => (fun (v18 : key) (v19 : @elt) => v19) v18 v19 end) => let v19 : @False := v16 v17 in False_ind (InA (@eqke) v0 v2) v19) v15) v14) v12) v10) v9) v7 v6) v4 v5 v6 | @InA_cons_tl _ _ _ v4 v5 v6 => (fun (v4 : key * @elt) (v5 : list (key * @elt)) (v6 : InA (@eqke) v0 v5) (v7 : v4 :: v5 = v1 :: v2) => (fun v8 : v4 :: v5 = v1 :: v2 => let v9 : v5 = v2 := f_equal (fun v9 : list (key * @elt) => match v9 as v10 in (list _) return (list (key * @elt)) with | nil => v5 | v10 :: v11 => (fun (v10 : key * @elt) (v11 : list (key * @elt)) => v11) v10 v11 end) v8 in (let v10 : v4 = v1 := f_equal (fun v10 : list (key * @elt) => match v10 as v11 in (list _) return (key * @elt) with | nil => v4 | v11 :: v12 => (fun (v11 : key * @elt) (v12 : list (key * @elt)) => v11) v11 v12 end) v8 in (fun v11 : v4 = v1 => let v12 : v4 = v1 := v11 in eq_ind_r (fun v13 : key * @elt => forall (v14 : v5 = v2) (v15 : InA (@eqke) v0 v5) (v16 : ~ eqk v0 v1), InA (@eqke) v0 v2) (fun v13 : v5 = v2 => let v14 : v5 = v2 := v13 in eq_ind_r (fun v15 : list (key * @elt) => forall (v16 : InA (@eqke) v0 v15) (v17 : ~ eqk v0 v1), InA (@eqke) v0 v2) (fun (v15 : InA (@eqke) v0 v2) (v16 : ~ eqk v0 v1) => v15) v14) v12) v10) v9) v7 v6) v4 v5 v6 end in v4 Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_equiv	100	0.168343	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even v0 = @true <-> Z.Even v0 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (Z.Even v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v1)) (Z.even_spec v0) match v0 as v1 in Z return (Zeven v1 <-> BinIntDef.Z.even v1 = @true) with | 0 => conj (fun v1 : @True => eq_refl) (fun v1 : @true = @true => @I) : Zeven 0 <-> BinIntDef.Z.even 0 = @true | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return (Zeven (Z.pos v2) <-> BinIntDef.Z.even (Z.pos v2) = @true) with | (v2~1)%positive => (fun v2 : @positive => conj (fun v3 : @False => False_ind (@false = @true) v3) (fun v3 : @false = @true => Bool.diff_false_true v3 : @False) : Zeven (Z.pos v2~1) <-> BinIntDef.Z.even (Z.pos v2~1) = @true) v2 | (v2~0)%positive => (fun v2 : @positive => conj (fun v3 : @True => eq_refl) (fun v3 : @true = @true => @I) : Zeven (Z.pos v2~0) <-> BinIntDef.Z.even (Z.pos v2~0) = @true) v2 | 1%positive => conj (fun v2 : @False => False_ind (@false = @true) v2) (fun v2 : @false = @true => Bool.diff_false_true v2 : @False) : Zeven 1 <-> BinIntDef.Z.even 1 = @true end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return (Zeven (Z.neg v2) <-> BinIntDef.Z.even (Z.neg v2) = @true) with | (v2~1)%positive => (fun v2 : @positive => conj (fun v3 : @False => False_ind (@false = @true) v3) (fun v3 : @false = @true => Bool.diff_false_true v3 : @False) : Zeven (Z.neg v2~1) <-> BinIntDef.Z.even (Z.neg v2~1) = @true) v2 | (v2~0)%positive => (fun v2 : @positive => conj (fun v3 : @True => eq_refl) (fun v3 : @true = @true => @I) : Zeven (Z.neg v2~0) <-> BinIntDef.Z.even (Z.neg v2~0) = @true) v2 | 1%positive => conj (fun v2 : @False => False_ind (@false = @true) v2) (fun v2 : @false = @true => Bool.diff_false_true v2 : @False) : Zeven (-1) <-> BinIntDef.Z.even (-1) = @true end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_equiv	100	0.201675	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.odd v0 = @true <-> Z.Odd v0 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (Z.Odd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v1)) (Z.odd_spec v0) match v0 as v1 in Z return (Zodd v1 <-> BinIntDef.Z.odd v1 = @true) with | 0 => conj (fun v1 : @False => False_ind (@false = @true) v1) (fun v1 : @false = @true => Bool.diff_false_true v1 : @False) : Zodd 0 <-> BinIntDef.Z.odd 0 = @true | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return (Zodd (Z.pos v2) <-> BinIntDef.Z.odd (Z.pos v2) = @true) with | (v2~1)%positive => (fun v2 : @positive => conj (fun v3 : @True => eq_refl) (fun v3 : @true = @true => @I) : Zodd (Z.pos v2~1) <-> BinIntDef.Z.odd (Z.pos v2~1) = @true) v2 | (v2~0)%positive => (fun v2 : @positive => conj (fun v3 : @False => False_ind (@false = @true) v3) (fun v3 : @false = @true => Bool.diff_false_true v3 : @False) : Zodd (Z.pos v2~0) <-> BinIntDef.Z.odd (Z.pos v2~0) = @true) v2 | 1%positive => conj (fun v2 : @True => eq_refl) (fun v2 : @true = @true => @I) : Zodd 1 <-> BinIntDef.Z.odd 1 = @true end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return (Zodd (Z.neg v2) <-> BinIntDef.Z.odd (Z.neg v2) = @true) with | (v2~1)%positive => (fun v2 : @positive => conj (fun v3 : @True => eq_refl) (fun v3 : @true = @true => @I) : Zodd (Z.neg v2~1) <-> BinIntDef.Z.odd (Z.neg v2~1) = @true) v2 | (v2~0)%positive => (fun v2 : @positive => conj (fun v3 : @False => False_ind (@false = @true) v3) (fun v3 : @false = @true => Bool.diff_false_true v3 : @False) : Zodd (Z.neg v2~0) <-> BinIntDef.Z.odd (Z.neg v2~0) = @true) v2 | 1%positive => conj (fun v2 : @True => eq_refl) (fun v2 : @true = @true => @I) : Zodd (-1) <-> BinIntDef.Z.odd (-1) = @true end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_bool_iff	100	0.112224	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even v0 = @true <-> Z.Even v0 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (BinIntDef.Z.even v0 = @true) (Z.Even v0) v1 (Zeven v0) (Zeven v0) (Morphisms.eq_proper_proxy (Zeven v0))) (Z.even_spec v0) ((fun v1 : Zeven v0 <-> Z.Even v0 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (Zeven v0) (Z.Even v0) v1) (Zeven_equiv v0) (RelationClasses.reflexivity (Z.Even v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_bool_iff	100	0.094997	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.odd v0 = @true <-> Z.Odd v0 => Morphisms.trans_co_eq_inv_impl_morphism (@RelationClasses.iff_Transitive) (BinIntDef.Z.odd v0 = @true) (Z.Odd v0) v1 (Zodd v0) (Zodd v0) (Morphisms.eq_proper_proxy (Zodd v0))) (Z.odd_spec v0) ((fun v1 : Zodd v0 <-> Z.Odd v0 => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER (@RelationClasses.iff_equivalence)) (Zodd v0) (Z.Odd v0) v1) (Zodd_equiv v0) (RelationClasses.reflexivity (Z.Odd v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_even_bool	100	0.042785	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (SYM1 Z.negb_even)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_odd_bool	100	0.042511	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (SYM1 Z.negb_odd)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_odd_dec	100	0.093273	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return ({Zeven v1} + {Zodd v1}) with | 0 => left (@I) : {Zeven 0} + {Zodd 0} | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return ({Zeven (Z.pos v2)} + {Zodd (Z.pos v2)}) with | (v2~1)%positive => (fun v2 : @positive => right (@I) : {Zeven (Z.pos v2~1)} + {Zodd (Z.pos v2~1)}) v2 | (v2~0)%positive => (fun v2 : @positive => left (@I) : {Zeven (Z.pos v2~0)} + {Zodd (Z.pos v2~0)}) v2 | 1%positive => right (@I) : {Zeven 1} + {Zodd 1} end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return ({Zeven (Z.neg v2)} + {Zodd (Z.neg v2)}) with | (v2~1)%positive => (fun v2 : @positive => right (@I) : {Zeven (Z.neg v2~1)} + {Zodd (Z.neg v2~1)}) v2 | (v2~0)%positive => (fun v2 : @positive => left (@I) : {Zeven (Z.neg v2~0)} + {Zodd (Z.neg v2~0)}) v2 | 1%positive => right (@I) : {Zeven (-1)} + {Zodd (-1)} end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_dec	100	0.117429	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return ({Zeven v1} + {~ Zeven v1}) with | 0 => left (@I) : {Zeven 0} + {~ Zeven 0} | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return ({Zeven (Z.pos v2)} + {~ Zeven (Z.pos v2)}) with | (v2~1)%positive => (fun v2 : @positive => right ((fun v3 : @False => let v4 : @False := match v3 as v4 in False return (@False) with end in v4) : ~ @False) : {Zeven (Z.pos v2~1)} + {~ Zeven (Z.pos v2~1)}) v2 | (v2~0)%positive => (fun v2 : @positive => left (@I) : {Zeven (Z.pos v2~0)} + {~ Zeven (Z.pos v2~0)}) v2 | 1%positive => right ((fun v2 : @False => let v3 : @False := match v2 as v3 in False return (@False) with end in v3) : ~ @False) : {Zeven 1} + {~ Zeven 1} end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return ({Zeven (Z.neg v2)} + {~ Zeven (Z.neg v2)}) with | (v2~1)%positive => (fun v2 : @positive => right ((fun v3 : @False => let v4 : @False := match v3 as v4 in False return (@False) with end in v4) : ~ @False) : {Zeven (Z.neg v2~1)} + {~ Zeven (Z.neg v2~1)}) v2 | (v2~0)%positive => (fun v2 : @positive => left (@I) : {Zeven (Z.neg v2~0)} + {~ Zeven (Z.neg v2~0)}) v2 | 1%positive => right ((fun v2 : @False => let v3 : @False := match v2 as v3 in False return (@False) with end in v3) : ~ @False) : {Zeven (-1)} + {~ Zeven (-1)} end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_dec	100	0.102418	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return ({Zodd v1} + {~ Zodd v1}) with | 0 => right ((fun v1 : @False => let v2 : @False := match v1 as v2 in False return (@False) with end in v2) : ~ @False) : {Zodd 0} + {~ Zodd 0} | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return ({Zodd (Z.pos v2)} + {~ Zodd (Z.pos v2)}) with | (v2~1)%positive => (fun v2 : @positive => left (@I) : {Zodd (Z.pos v2~1)} + {~ Zodd (Z.pos v2~1)}) v2 | (v2~0)%positive => (fun v2 : @positive => right ((fun v3 : @False => let v4 : @False := match v3 as v4 in False return (@False) with end in v4) : ~ @False) : {Zodd (Z.pos v2~0)} + {~ Zodd (Z.pos v2~0)}) v2 | 1%positive => left (@I) : {Zodd 1} + {~ Zodd 1} end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return ({Zodd (Z.neg v2)} + {~ Zodd (Z.neg v2)}) with | (v2~1)%positive => (fun v2 : @positive => left (@I) : {Zodd (Z.neg v2~1)} + {~ Zodd (Z.neg v2~1)}) v2 | (v2~0)%positive => (fun v2 : @positive => right ((fun v3 : @False => let v4 : @False := match v3 as v4 in False return (@False) with end in v4) : ~ @False) : {Zodd (Z.neg v2~0)} + {~ Zodd (Z.neg v2~0)}) v2 | 1%positive => left (@I) : {Zodd (-1)} + {~ Zodd (-1)} end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_not_Zodd	100	0.119292	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v1) (~ Zodd v0) (~ Zodd v0) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (~ Zodd v0))) (Zeven_bool_iff v0) ((fun v1 : BinIntDef.Z.odd v0 = @true <-> Zodd v0 => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (~ Zodd v0) (BinIntDef.Z.odd v0 <> @true) (Morphisms_Prop.not_iff_morphism (Zodd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v1))) (Zodd_bool_iff v0) (eq_ind (negb (BinIntDef.Z.odd v0)) (fun v1 : @bool => forall v2 : v1 = @true, BinIntDef.Z.odd v0 <> @true) (let v1 : @bool := BinIntDef.Z.odd v0 in match v1 as v2 in bool return (forall v3 : negb v2 = @true, v2 <> @true) with | true => fun v2 : negb (@true) = @true => (fun v3 : @true = @true => Bool.diff_false_true v2 : @False) : @true <> @true | false => fun v2 : negb (@false) = @true => (fun v3 : @false = @true => Bool.diff_false_true v3 : @False) : @false <> @true end) (BinIntDef.Z.even v0) (Z.negb_odd v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_not_Zeven	100	0.142530	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd v0)) (~ Zeven v0) (BinIntDef.Z.even v0 <> @true) (Morphisms_Prop.not_iff_morphism (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v1))) (Zeven_bool_iff v0) ((fun v1 : BinIntDef.Z.odd v0 = @true <-> Zodd v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zodd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v1) (BinIntDef.Z.even v0 <> @true) (BinIntDef.Z.even v0 <> @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 <> @true))) (Zodd_bool_iff v0) (eq_ind (negb (BinIntDef.Z.odd v0)) (fun v1 : @bool => forall v2 : BinIntDef.Z.odd v0 = @true, v1 <> @true) (let v1 : @bool := BinIntDef.Z.odd v0 in match v1 as v2 in bool return (forall v3 : v2 = @true, negb v2 <> @true) with | true => fun v2 : @true = @true => (fun v3 : negb (@true) = @true => Bool.diff_false_true v3 : @False) : negb (@true) <> @true | false => fun v2 : @false = @true => (fun v3 : negb (@false) = @true => Bool.diff_false_true v2 : @False) : negb (@false) <> @true end) (BinIntDef.Z.even v0) (Z.negb_odd v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_Sn	100	0.119531	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even (BinIntDef.Z.succ v0) = @true <-> Zeven (BinIntDef.Z.succ v0) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd v0)) (Zeven (BinIntDef.Z.succ v0)) (BinIntDef.Z.even (BinIntDef.Z.succ v0) = @true) (RelationClasses.symmetry v1)) (Zeven_bool_iff (BinIntDef.Z.succ v0)) ((fun v1 : BinIntDef.Z.odd v0 = @true <-> Zodd v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zodd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v1) (BinIntDef.Z.even (BinIntDef.Z.succ v0) = @true) (BinIntDef.Z.even (BinIntDef.Z.succ v0) = @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even (BinIntDef.Z.succ v0) = @true))) (Zodd_bool_iff v0) (eq_ind_r (fun v1 : @bool => forall v2 : BinIntDef.Z.odd v0 = @true, v1 = @true) (fun v1 : BinIntDef.Z.odd v0 = @true => v1) (Z.even_succ v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_Sn	100	0.132671	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v1) (Zodd (BinIntDef.Z.succ v0)) (Zodd (BinIntDef.Z.succ v0)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd (BinIntDef.Z.succ v0)))) (Zeven_bool_iff v0) ((fun v1 : BinIntDef.Z.odd (BinIntDef.Z.succ v0) = @true <-> Zodd (BinIntDef.Z.succ v0) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (Zodd (BinIntDef.Z.succ v0)) (BinIntDef.Z.odd (BinIntDef.Z.succ v0) = @true) (RelationClasses.symmetry v1)) (Zodd_bool_iff (BinIntDef.Z.succ v0)) (eq_ind_r (fun v1 : @bool => forall v2 : BinIntDef.Z.even v0 = @true, v1 = @true) (fun v1 : BinIntDef.Z.even v0 = @true => v1) (Z.odd_succ v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_pred	100	0.101249	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even (BinIntDef.Z.pred v0) = @true <-> Zeven (BinIntDef.Z.pred v0) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd v0)) (Zeven (BinIntDef.Z.pred v0)) (BinIntDef.Z.even (BinIntDef.Z.pred v0) = @true) (RelationClasses.symmetry v1)) (Zeven_bool_iff (BinIntDef.Z.pred v0)) ((fun v1 : BinIntDef.Z.odd v0 = @true <-> Zodd v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zodd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v1) (BinIntDef.Z.even (BinIntDef.Z.pred v0) = @true) (BinIntDef.Z.even (BinIntDef.Z.pred v0) = @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even (BinIntDef.Z.pred v0) = @true))) (Zodd_bool_iff v0) (eq_ind_r (fun v1 : @bool => forall v2 : BinIntDef.Z.odd v0 = @true, v1 = @true) (fun v1 : BinIntDef.Z.odd v0 = @true => v1) (Z.even_pred v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_pred	100	0.106351	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v1) (Zodd (BinIntDef.Z.pred v0)) (Zodd (BinIntDef.Z.pred v0)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd (BinIntDef.Z.pred v0)))) (Zeven_bool_iff v0) ((fun v1 : BinIntDef.Z.odd (BinIntDef.Z.pred v0) = @true <-> Zodd (BinIntDef.Z.pred v0) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (Zodd (BinIntDef.Z.pred v0)) (BinIntDef.Z.odd (BinIntDef.Z.pred v0) = @true) (RelationClasses.symmetry v1)) (Zodd_bool_iff (BinIntDef.Z.pred v0)) (eq_ind_r (fun v1 : @bool => forall v2 : BinIntDef.Z.even v0 = @true, v1 = @true) (fun v1 : BinIntDef.Z.even v0 = @true => v1) (Z.odd_pred v0))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_div2	100	0.230993	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v1) (v0 = 2 * BinIntDef.Z.div2 v0) (v0 = 2 * BinIntDef.Z.div2 v0) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (v0 = 2 * BinIntDef.Z.div2 v0))) (Zeven_bool_iff v0) (eq_ind (negb (BinIntDef.Z.odd v0)) (fun v1 : @bool => forall v2 : v1 = @true, v0 = 2 * BinIntDef.Z.div2 v0) ((fun v1 : negb (BinIntDef.Z.odd v0) = @true <-> BinIntDef.Z.odd v0 = @false => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (negb (BinIntDef.Z.odd v0) = @true) (BinIntDef.Z.odd v0 = @false) v1 (v0 = 2 * BinIntDef.Z.div2 v0) (v0 = 2 * BinIntDef.Z.div2 v0) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (v0 = 2 * BinIntDef.Z.div2 v0))) (Bool.negb_true_iff (BinIntDef.Z.odd v0)) (fun v1 : BinIntDef.Z.odd v0 = @false => (fun v2 : v0 = 2 * BinIntDef.Z.div2 v0 + match BinIntDef.Z.odd v0 as v2 in bool return (@Z) with | true => 1 | false => 0 end => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive v0 (2 * BinIntDef.Z.div2 v0 + match BinIntDef.Z.odd v0 as v3 in bool return (@Z) with | true => 1 | false => 0 end) v2 (2 * BinIntDef.Z.div2 v0) (2 * BinIntDef.Z.div2 v0) (Morphisms.eq_proper_proxy (2 * BinIntDef.Z.div2 v0))) (Zdiv2_odd_eqn v0) (eq_ind_r (fun v2 : @bool => 2 * BinIntDef.Z.div2 v0 + match v2 as v3 in bool return (@Z) with | true => 1 | false => 0 end = 2 * BinIntDef.Z.div2 v0) (eq_ind_r (fun v2 : @Z => v2 = 2 * BinIntDef.Z.div2 v0) eq_refl (Z.add_0_r (2 * BinIntDef.Z.div2 v0))) v1))) (BinIntDef.Z.even v0) (Z.negb_odd v0)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_div2	100	0.147244	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => (fun v1 : BinIntDef.Z.odd v0 = @true <-> Zodd v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zodd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v1) (v0 = 2 * BinIntDef.Z.div2 v0 + 1) (v0 = 2 * BinIntDef.Z.div2 v0 + 1) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (v0 = 2 * BinIntDef.Z.div2 v0 + 1))) (Zodd_bool_iff v0) (fun v1 : BinIntDef.Z.odd v0 = @true => (fun v2 : v0 = 2 * BinIntDef.Z.div2 v0 + match BinIntDef.Z.odd v0 as v2 in bool return (@Z) with | true => 1 | false => 0 end => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive v0 (2 * BinIntDef.Z.div2 v0 + match BinIntDef.Z.odd v0 as v3 in bool return (@Z) with | true => 1 | false => 0 end) v2 (2 * BinIntDef.Z.div2 v0 + 1) (2 * BinIntDef.Z.div2 v0 + 1) (Morphisms.eq_proper_proxy (2 * BinIntDef.Z.div2 v0 + 1))) (Zdiv2_odd_eqn v0) (eq_ind_r (fun v2 : @bool => 2 * BinIntDef.Z.div2 v0 + match v2 as v3 in bool return (@Z) with | true => 1 | false => 0 end = 2 * BinIntDef.Z.div2 v0 + 1) eq_refl v1)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zquot2_odd_eqn	100	0.213257	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (v1 = 2 * BinIntDef.Z.quot2 v1 + match BinIntDef.Z.odd v1 as v2 in bool return (@Z) with | true => BinIntDef.Z.sgn v1 | false => 0 end) with | 0 => eq_refl | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return (Z.pos v2 = 2 * BinIntDef.Z.quot2 (Z.pos v2) + match BinIntDef.Z.odd (Z.pos v2) as v3 in bool return (@Z) with | true => BinIntDef.Z.sgn (Z.pos v2) | false => 0 end) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return (Z.neg v2 = 2 * BinIntDef.Z.quot2 (Z.neg v2) + match BinIntDef.Z.odd (Z.neg v2) as v3 in bool return (@Z) with | true => BinIntDef.Z.sgn (Z.neg v2) | false => 0 end) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_quot2	100	0.150365	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @Z) (v1 : Zeven v0) => let v2 : forall (v2 : @Z) (v3 : Zeven v2), BinIntDef.Z.even v2 = @true := fun v2 : @Z => match Zeven_bool_iff v2 as v3 in (_ /\ _) return (forall v4 : Zeven v2, BinIntDef.Z.even v2 = @true) with | conj v3 v4 => (fun (v3 : forall v3 : BinIntDef.Z.even v2 = @true, Zeven v2) (v4 : forall v4 : Zeven v2, BinIntDef.Z.even v2 = @true) => v4) v3 v4 end in let v3 : BinIntDef.Z.even v0 = @true := v2 v0 v1 in (fun v4 : v0 = 2 * BinIntDef.Z.quot2 v0 + match BinIntDef.Z.odd v0 as v4 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive v0 (2 * BinIntDef.Z.quot2 v0 + match BinIntDef.Z.odd v0 as v5 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end) v4 (2 * BinIntDef.Z.quot2 v0) (2 * BinIntDef.Z.quot2 v0) (Morphisms.eq_proper_proxy (2 * BinIntDef.Z.quot2 v0))) (Zquot2_odd_eqn v0) (eq_ind_r (fun v4 : @bool => 2 * BinIntDef.Z.quot2 v0 + match v4 as v5 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end = 2 * BinIntDef.Z.quot2 v0) (eq_ind_r (fun v4 : @bool => 2 * BinIntDef.Z.quot2 v0 + match negb v4 as v5 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end = 2 * BinIntDef.Z.quot2 v0) (eq_ind_r (fun v4 : @Z => v4 = 2 * BinIntDef.Z.quot2 v0) eq_refl (Z.add_0_r (2 * BinIntDef.Z.quot2 v0))) v3) (Zodd_even_bool v0)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_quot2	100	0.326855	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @Z) (v1 : v0 >= 0) (v2 : Zodd v0) => let v3 : forall (v3 : @Z) (v4 : Zodd v3), BinIntDef.Z.odd v3 = @true := fun v3 : @Z => match Zodd_bool_iff v3 as v4 in (_ /\ _) return (forall v5 : Zodd v3, BinIntDef.Z.odd v3 = @true) with | conj v4 v5 => (fun (v4 : forall v4 : BinIntDef.Z.odd v3 = @true, Zodd v3) (v5 : forall v5 : Zodd v3, BinIntDef.Z.odd v3 = @true) => v5) v4 v5 end in let v4 : BinIntDef.Z.odd v0 = @true := v3 v0 v2 in (fun v5 : v0 = 2 * BinIntDef.Z.quot2 v0 + match BinIntDef.Z.odd v0 as v5 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive v0 (2 * BinIntDef.Z.quot2 v0 + match BinIntDef.Z.odd v0 as v6 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end) v5 (2 * BinIntDef.Z.quot2 v0 + 1) (2 * BinIntDef.Z.quot2 v0 + 1) (Morphisms.eq_proper_proxy (2 * BinIntDef.Z.quot2 v0 + 1))) (Zquot2_odd_eqn v0) (eq_ind_r (fun v5 : @bool => 2 * BinIntDef.Z.quot2 v0 + match v5 as v6 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end = 2 * BinIntDef.Z.quot2 v0 + 1) (let v5 : BinIntDef.Z.sgn v0 = 1 := match v0 as v5 in Z return (forall (v6 : v5 >= 0) (v7 : BinIntDef.Z.odd v5 = @true), BinIntDef.Z.sgn v5 = 1) with | 0 => fun (v5 : 0 >= 0) (v6 : BinIntDef.Z.odd 0 = @true) => let v7 : @False := v5 (let v7 : forall v7 : @true = @true, (0 ?= 0) = @Lt := match v6 as v8 in (_ = v7) return (forall v9 : v7 = @true, (0 ?= 0) = @Lt) with | eq_refl => fun v7 : BinIntDef.Z.odd 0 = @true => (fun v8 : BinIntDef.Z.odd 0 = @true => let v9 : @False := eq_ind (BinIntDef.Z.odd 0) (fun v9 : @bool => match v9 as v10 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v8 in False_ind ((0 ?= 0) = @Lt) v9) v7 end in v7 eq_refl) in match v7 as v8 in False return (BinIntDef.Z.sgn 0 = 1) with end | Z.pos v5 => (fun (v5 : @positive) (v6 : Z.pos v5 >= 0) (v7 : BinIntDef.Z.odd (Z.pos v5) = @true) => eq_refl) v5 | Z.neg v5 => (fun (v5 : @positive) (v6 : Z.neg v5 >= 0) (v7 : BinIntDef.Z.odd (Z.neg v5) = @true) => let v8 : @False := v6 eq_refl in match v8 as v9 in False return (BinIntDef.Z.sgn (Z.neg v5) = 1) with end) v5 end v1 v4 in (let v6 : 2 * BinIntDef.Z.quot2 v0 = 2 * BinIntDef.Z.quot2 v0 := eq_refl in (fun (v7 : 2 * BinIntDef.Z.quot2 v0 = 2 * BinIntDef.Z.quot2 v0) (v8 : BinIntDef.Z.sgn v0 = 1) => eq_trans (f_equal (fun v9 : forall v9 : @Z, @Z => v9 (BinIntDef.Z.sgn v0)) eq_refl) (f_equal (BinIntDef.Z.add (2 * BinIntDef.Z.quot2 v0)) v8)) v6) v5) v4))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_quot2_neg	100	0.290356	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @Z) (v1 : v0 <= 0) (v2 : Zodd v0) => let v3 : forall (v3 : @Z) (v4 : Zodd v3), BinIntDef.Z.odd v3 = @true := fun v3 : @Z => match Zodd_bool_iff v3 as v4 in (_ /\ _) return (forall v5 : Zodd v3, BinIntDef.Z.odd v3 = @true) with | conj v4 v5 => (fun (v4 : forall v4 : BinIntDef.Z.odd v3 = @true, Zodd v3) (v5 : forall v5 : Zodd v3, BinIntDef.Z.odd v3 = @true) => v5) v4 v5 end in let v4 : BinIntDef.Z.odd v0 = @true := v3 v0 v2 in (fun v5 : v0 = 2 * BinIntDef.Z.quot2 v0 + match BinIntDef.Z.odd v0 as v5 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive v0 (2 * BinIntDef.Z.quot2 v0 + match BinIntDef.Z.odd v0 as v6 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end) v5 (2 * BinIntDef.Z.quot2 v0 - 1) (2 * BinIntDef.Z.quot2 v0 - 1) (Morphisms.eq_proper_proxy (2 * BinIntDef.Z.quot2 v0 - 1))) (Zquot2_odd_eqn v0) (eq_ind_r (fun v5 : @bool => 2 * BinIntDef.Z.quot2 v0 + match v5 as v6 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end = 2 * BinIntDef.Z.quot2 v0 - 1) ((let v5 : BinIntDef.Z.sgn v0 = - (1) := match v0 as v5 in Z return (forall (v6 : v5 <= 0) (v7 : BinIntDef.Z.odd v5 = @true), BinIntDef.Z.sgn v5 = - (1)) with | 0 => fun (v5 : 0 <= 0) (v6 : BinIntDef.Z.odd 0 = @true) => let v7 : @False := v5 (let v7 : forall v7 : @true = @true, (0 ?= 0) = @Gt := match v6 as v8 in (_ = v7) return (forall v9 : v7 = @true, (0 ?= 0) = @Gt) with | eq_refl => fun v7 : BinIntDef.Z.odd 0 = @true => (fun v8 : BinIntDef.Z.odd 0 = @true => let v9 : @False := eq_ind (BinIntDef.Z.odd 0) (fun v9 : @bool => match v9 as v10 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v8 in False_ind ((0 ?= 0) = @Gt) v9) v7 end in v7 eq_refl) in match v7 as v8 in False return (BinIntDef.Z.sgn 0 = - (1)) with end | Z.pos v5 => (fun (v5 : @positive) (v6 : Z.pos v5 <= 0) (v7 : BinIntDef.Z.odd (Z.pos v5) = @true) => let v8 : @False := v6 eq_refl in match v8 as v9 in False return (BinIntDef.Z.sgn (Z.pos v5) = - (1)) with end) v5 | Z.neg v5 => (fun (v5 : @positive) (v6 : Z.neg v5 <= 0) (v7 : BinIntDef.Z.odd (Z.neg v5) = @true) => eq_refl) v5 end v1 v4 in (let v6 : 2 * BinIntDef.Z.quot2 v0 = 2 * BinIntDef.Z.quot2 v0 := eq_refl in (fun (v7 : 2 * BinIntDef.Z.quot2 v0 = 2 * BinIntDef.Z.quot2 v0) (v8 : BinIntDef.Z.sgn v0 = - (1)) => eq_trans (f_equal (fun v9 : forall v9 : @Z, @Z => v9 (BinIntDef.Z.sgn v0)) eq_refl) (f_equal (BinIntDef.Z.add (2 * BinIntDef.Z.quot2 v0)) v8)) v6) v5) : 2 * BinIntDef.Z.quot2 v0 + BinIntDef.Z.sgn v0 = 2 * BinIntDef.Z.quot2 v0 - 1) v4))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zquot2_opp	100	0.091131	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (BinIntDef.Z.quot2 (- v1) = - BinIntDef.Z.quot2 v1) with | 0 => eq_refl | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return (BinIntDef.Z.quot2 (- Z.pos v2) = - BinIntDef.Z.quot2 (Z.pos v2)) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return (BinIntDef.Z.quot2 (- Z.neg v2) = - BinIntDef.Z.quot2 (Z.neg v2)) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zquot2_quot	100	0.325636	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => let v1 : forall (v1 : @Z) (v2 : 0 < v1), BinIntDef.Z.quot2 v1 = v1  2 := fun (v1 : @Z) (v2 : 0 < v1) => Z.quot_unique v1 2 (BinIntDef.Z.quot2 v1) match BinIntDef.Z.odd v1 as v3 in bool return (@Z) with | true => BinIntDef.Z.sgn v1 | false => 0 end (Z.lt_le_incl 0 v1 v2) (eq_ind_r (fun v3 : @Z => 0 <= match BinIntDef.Z.odd v1 as v4 in bool return (@Z) with | true => v3 | false => 0 end < 2) (let v3 : @bool := BinIntDef.Z.odd v1 in match v3 as v4 in bool return (0 <= match v4 as v5 in bool return (@Z) with | true => 1 | false => 0 end < 2) with | true => conj ((fun v4 : (0 ?= 1) = @Gt => let v5 : forall v5 : @Gt = @Gt, @False := match v4 as v6 in (_ = v5) return (forall v7 : v5 = @Gt, @False) with | eq_refl => fun v5 : (0 ?= 1) = @Gt => (fun v6 : (0 ?= 1) = @Gt => let v7 : @False := eq_ind (0 ?= 1) (fun v7 : @comparison => match v7 as v8 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v6 in False_ind (@False) v7) v5 end in v5 eq_refl) : 0 <= 1) eq_refl | false => conj (RelationClasses.reflexivity 0) eq_refl end) (Z.sgn_pos v1 v2)) (Zquot2_odd_eqn v1) in let v2 : 0 < v0 \/ 0 = v0 \/ v0 < 0 := Z.lt_trichotomy 0 v0 in match v2 as v3 in (_ \/ _) return (BinIntDef.Z.quot2 v0 = v0  2) with | or_introl v3 => (fun v3 : 0 < v0 => v1 v0 v3) v3 | or_intror v3 => (fun v3 : 0 = v0 \/ v0 < 0 => match v3 as v4 in (_ \/ _) return (BinIntDef.Z.quot2 v0 = v0  2) with | or_introl v4 => (fun v4 : 0 = v0 => eq_ind 0 (fun v5 : @Z => BinIntDef.Z.quot2 v5 = v5  2) eq_refl v0 v4) v4 | or_intror v4 => (fun v4 : v0 < 0 => Z.opp_inj (BinIntDef.Z.quot2 v0) (v0  2) (eq_ind (- v0  2) (fun v5 : @Z => - BinIntDef.Z.quot2 v0 = v5) (eq_ind (BinIntDef.Z.quot2 (- v0)) (fun v5 : @Z => v5 = - v0  2) (v1 (- v0) (match v0 as v5 in Z return (forall v6 : v5 < 0, 0 < - v5) with | 0 => fun v5 : 0 < 0 => v5 | Z.pos v5 => (fun (v5 : @positive) (v6 : Z.pos v5 < 0) => v6) v5 | Z.neg v5 => (fun (v5 : @positive) (v6 : Z.neg v5 < 0) => v6) v5 end v4)) (- BinIntDef.Z.quot2 v0) (Zquot2_opp v0)) (- (v0  2)) (Z.quot_opp_l v0 2 ((fun v5 : 2 = 0 => let v6 : forall v6 : 0 = 0, @False := match v5 as v7 in (_ = v6) return (forall v8 : v6 = 0, @False) with | eq_refl => fun v6 : 2 = 0 => (fun v7 : 2 = 0 => let v8 : @False := eq_ind 2 (fun v8 : @Z => match v8 as v9 in Z return Prop with | 0 => @False | Z.pos v9 => (fun v9 : @positive => @True) v9 | Z.neg v9 => (fun v9 : @positive => @False) v9 end) (@I) 0 v7 in False_ind (@False) v8) v6 end in v6 eq_refl) : 2 <> 0)))) v4 end) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Z_modulo_2	100	0.137109	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => let v1 : {Zeven v0} + {Zodd v0} := Zeven_odd_dec v0 in match v1 as v2 in ({_} + {_}) return ({v3 : @Z | v0 = 2 * v3} + {v3 : @Z | v0 = 2 * v3 + 1}) with | left v2 => (fun v2 : Zeven v0 => inl (exist (fun v3 : @Z => v0 = 2 * v3) (BinIntDef.Z.div2 v0) (Zeven_div2 v0 v2))) v2 | right v2 => (fun v2 : Zodd v0 => inr (exist (fun v3 : @Z => v0 = 2 * v3 + 1) (BinIntDef.Z.div2 v0) (Zodd_div2 v0 v2))) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zsplit2	100	0.301662	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => let v1 : {v1 : @Z | v0 = 2 * v1} + {v1 : @Z | v0 = 2 * v1 + 1} := Z_modulo_2 v0 in match v1 as v2 in (_ + _)%type return {v3 : @Z * @Z | match v3 as v4 in (_ * _)%type return Prop with | (v4, v5) => (fun v4 v5 : @Z => v0 = v4 + v5 /\ (v4 = v5 \/ v5 = v4 + 1)) v4 v5 end} with | inl v2 => (fun v2 : {v2 : @Z | v0 = 2 * v2} => match v2 as v3 in (sig _) return {v4 : @Z * @Z | match v4 as v5 in (_ * _)%type return Prop with | (v5, v6) => (fun v5 v6 : @Z => v0 = v5 + v6 /\ (v5 = v6 \/ v6 = v5 + 1)) v5 v6 end} with | exist _ v3 v4 => (fun (v3 : @Z) (v4 : v0 = 2 * v3) => let v5 : v0 = v3 + v3 := eq_ind_r (fun v5 : @Z => v0 = v5) v4 (Z.add_diag v3) in exist (fun v6 : @Z * @Z => match v6 as v7 in (_ * _)%type return Prop with | (v7, v8) => (fun v7 v8 : @Z => v0 = v7 + v8 /\ (v7 = v8 \/ v8 = v7 + 1)) v7 v8 end) (v3, v3) (conj v5 (or_introl eq_refl))) v3 v4 end) v2 | inr v2 => (fun v2 : {v2 : @Z | v0 = 2 * v2 + 1} => match v2 as v3 in (sig _) return {v4 : @Z * @Z | match v4 as v5 in (_ * _)%type return Prop with | (v5, v6) => (fun v5 v6 : @Z => v0 = v5 + v6 /\ (v5 = v6 \/ v6 = v5 + 1)) v5 v6 end} with | exist _ v3 v4 => (fun (v3 : @Z) (v4 : v0 = 2 * v3 + 1) => let v5 : v0 = v3 + v3 + 1 := eq_ind_r (fun v5 : @Z => v0 = v5 + 1) v4 (Z.add_diag v3) in exist (fun v6 : @Z * @Z => match v6 as v7 in (_ * _)%type return Prop with | (v7, v8) => (fun v7 v8 : @Z => v0 = v7 + v8 /\ (v7 = v8 \/ v8 = v7 + 1)) v7 v8 end) (v3, v3 + 1) (conj (eq_ind_r (fun v6 : @Z => v0 = v6) v5 (Z.add_assoc v3 v3 1)) (or_intror eq_refl))) v3 v4 end) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_ex	100	0.061995	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @Z) (v1 : Zeven v0) => ex_intro (fun v2 : @Z => v0 = 2 * v2) (BinIntDef.Z.div2 v0) (Zeven_div2 v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_ex	100	0.065409	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : @Z) (v1 : Zodd v0) => ex_intro (fun v2 : @Z => v0 = 2 * v2 + 1) (BinIntDef.Z.div2 v0) (Zodd_div2 v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_2p	100	0.051387	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (Zeven (2 * v1)) with | 0 => @I | Z.pos v1 | Z.neg v1 => (fun v1 : @positive => @I) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_2p_plus_1	100	0.114196	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (Zodd (2 * v1 + 1)) with | 0 => @I | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return (Zodd (2 * Z.pos v2 + 1)) with | (v2~1)%positive | (v2~0)%positive => (fun v2 : @positive => @I) v2 | 1%positive => @I end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return (Zodd (2 * Z.neg v2 + 1)) with | (v2~1)%positive | (v2~0)%positive => (fun v2 : @positive => @I) v2 | 1%positive => @I end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_plus_Zodd	100	0.272240	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => (fun v2 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v2) (forall v3 : Zodd v1, Zodd (v0 + v1)) (forall v3 : Zodd v1, Zodd (v0 + v1)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (forall v3 : Zodd v1, Zodd (v0 + v1)))) (Zeven_bool_iff v0) ((fun v2 : BinIntDef.Z.odd v1 = @true <-> Zodd v1 => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (forall v3 : Zodd v1, Zodd (v0 + v1)) (forall v3 : BinIntDef.Z.odd v1 = @true, Zodd (v0 + v1)) (Morphisms_Prop.iff_iff_iff_impl_morphism (Zodd v1) (BinIntDef.Z.odd v1 = @true) (RelationClasses.symmetry v2) (Zodd (v0 + v1)) (Zodd (v0 + v1)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd (v0 + v1))))) (Zodd_bool_iff v1) ((fun v2 : BinIntDef.Z.odd (v0 + v1) = @true <-> Zodd (v0 + v1) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (forall v3 : BinIntDef.Z.odd v1 = @true, Zodd (v0 + v1)) (forall v3 : BinIntDef.Z.odd v1 = @true, BinIntDef.Z.odd (v0 + v1) = @true) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.odd v1 = @true)) (Zodd (v0 + v1)) (BinIntDef.Z.odd (v0 + v1) = @true) (RelationClasses.symmetry v2))) (Zodd_bool_iff (v0 + v1)) (eq_ind (negb (BinIntDef.Z.odd v0)) (fun v2 : @bool => forall (v3 : v2 = @true) (v4 : BinIntDef.Z.odd v1 = @true), BinIntDef.Z.odd (v0 + v1) = @true) ((fun v2 : negb (BinIntDef.Z.odd v0) = @true <-> BinIntDef.Z.odd v0 = @false => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (negb (BinIntDef.Z.odd v0) = @true) (BinIntDef.Z.odd v0 = @false) v2 (forall v3 : BinIntDef.Z.odd v1 = @true, BinIntDef.Z.odd (v0 + v1) = @true) (forall v3 : BinIntDef.Z.odd v1 = @true, BinIntDef.Z.odd (v0 + v1) = @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (forall v3 : BinIntDef.Z.odd v1 = @true, BinIntDef.Z.odd (v0 + v1) = @true))) (Bool.negb_true_iff (BinIntDef.Z.odd v0)) (fun (v2 : BinIntDef.Z.odd v0 = @false) (v3 : BinIntDef.Z.odd v1 = @true) => eq_ind_r (fun v4 : @bool => v4 = @true) (eq_ind_r (fun v4 : @bool => xorb v4 (BinIntDef.Z.odd v1) = @true) (eq_ind_r (fun v4 : @bool => xorb (@false) v4 = @true) eq_refl v3) v2) (Z.odd_add v0 v1))) (BinIntDef.Z.even v0) (Z.negb_odd v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_plus_Zeven	100	0.235035	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => (fun v2 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v2) (forall v3 : Zeven v1, Zeven (v0 + v1)) (forall v3 : Zeven v1, Zeven (v0 + v1)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (forall v3 : Zeven v1, Zeven (v0 + v1)))) (Zeven_bool_iff v0) ((fun v2 : BinIntDef.Z.even v1 = @true <-> Zeven v1 => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (forall v3 : Zeven v1, Zeven (v0 + v1)) (forall v3 : BinIntDef.Z.even v1 = @true, Zeven (v0 + v1)) (Morphisms_Prop.iff_iff_iff_impl_morphism (Zeven v1) (BinIntDef.Z.even v1 = @true) (RelationClasses.symmetry v2) (Zeven (v0 + v1)) (Zeven (v0 + v1)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zeven (v0 + v1))))) (Zeven_bool_iff v1) ((fun v2 : BinIntDef.Z.even (v0 + v1) = @true <-> Zeven (v0 + v1) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (forall v3 : BinIntDef.Z.even v1 = @true, Zeven (v0 + v1)) (forall v3 : BinIntDef.Z.even v1 = @true, BinIntDef.Z.even (v0 + v1) = @true) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v1 = @true)) (Zeven (v0 + v1)) (BinIntDef.Z.even (v0 + v1) = @true) (RelationClasses.symmetry v2))) (Zeven_bool_iff (v0 + v1)) (fun (v2 : BinIntDef.Z.even v0 = @true) (v3 : BinIntDef.Z.even v1 = @true) => eq_ind_r (fun v4 : @bool => v4 = @true) (eq_ind_r (fun v4 : @bool => Bool.eqb v4 (BinIntDef.Z.even v1) = @true) (eq_ind_r (fun v4 : @bool => Bool.eqb (@true) v4 = @true) eq_refl v3) v2) (Z.even_add v0 v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_plus_Zeven	100	0.083528	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : Zodd v0) (v3 : Zeven v1) => eq_ind_r (fun v4 : @Z => Zodd v4) (Zeven_plus_Zodd v1 v0 v3 v2) (Z.add_comm v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_plus_Zodd	100	0.317980	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => (fun v2 : BinIntDef.Z.even (v0 + v1) = @true <-> Zeven (v0 + v1) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd v0)) (forall v3 : Zodd v1, Zeven (v0 + v1)) (forall v3 : Zodd v1, BinIntDef.Z.even (v0 + v1) = @true) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd v1)) (Zeven (v0 + v1)) (BinIntDef.Z.even (v0 + v1) = @true) (RelationClasses.symmetry v2))) (Zeven_bool_iff (v0 + v1)) ((fun v2 : BinIntDef.Z.odd v0 = @true <-> Zodd v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zodd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v2) (forall v3 : Zodd v1, BinIntDef.Z.even (v0 + v1) = @true) (forall v3 : Zodd v1, BinIntDef.Z.even (v0 + v1) = @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (forall v3 : Zodd v1, BinIntDef.Z.even (v0 + v1) = @true))) (Zodd_bool_iff v0) ((fun v2 : BinIntDef.Z.odd v1 = @true <-> Zodd v1 => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.odd v0 = @true)) (forall v3 : Zodd v1, BinIntDef.Z.even (v0 + v1) = @true) (forall v3 : BinIntDef.Z.odd v1 = @true, BinIntDef.Z.even (v0 + v1) = @true) (Morphisms_Prop.iff_iff_iff_impl_morphism (Zodd v1) (BinIntDef.Z.odd v1 = @true) (RelationClasses.symmetry v2) (BinIntDef.Z.even (v0 + v1) = @true) (BinIntDef.Z.even (v0 + v1) = @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even (v0 + v1) = @true)))) (Zodd_bool_iff v1) (eq_ind (negb (BinIntDef.Z.even v0)) (fun v2 : @bool => forall (v3 : v2 = @true) (v4 : BinIntDef.Z.odd v1 = @true), BinIntDef.Z.even (v0 + v1) = @true) (eq_ind (negb (BinIntDef.Z.even v1)) (fun v2 : @bool => forall (v3 : negb (BinIntDef.Z.even v0) = @true) (v4 : v2 = @true), BinIntDef.Z.even (v0 + v1) = @true) ((fun v2 : negb (BinIntDef.Z.even v0) = @true <-> BinIntDef.Z.even v0 = @false => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (negb (BinIntDef.Z.even v0) = @true) (BinIntDef.Z.even v0 = @false) v2 (forall v3 : negb (BinIntDef.Z.even v1) = @true, BinIntDef.Z.even (v0 + v1) = @true) (forall v3 : negb (BinIntDef.Z.even v1) = @true, BinIntDef.Z.even (v0 + v1) = @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (forall v3 : negb (BinIntDef.Z.even v1) = @true, BinIntDef.Z.even (v0 + v1) = @true))) (Bool.negb_true_iff (BinIntDef.Z.even v0)) ((fun v2 : negb (BinIntDef.Z.even v1) = @true <-> BinIntDef.Z.even v1 = @false => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @false)) (forall v3 : negb (BinIntDef.Z.even v1) = @true, BinIntDef.Z.even (v0 + v1) = @true) (forall v3 : BinIntDef.Z.even v1 = @false, BinIntDef.Z.even (v0 + v1) = @true) (Morphisms_Prop.iff_iff_iff_impl_morphism (negb (BinIntDef.Z.even v1) = @true) (BinIntDef.Z.even v1 = @false) v2 (BinIntDef.Z.even (v0 + v1) = @true) (BinIntDef.Z.even (v0 + v1) = @true) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even (v0 + v1) = @true)))) (Bool.negb_true_iff (BinIntDef.Z.even v1)) (fun (v2 : BinIntDef.Z.even v0 = @false) (v3 : BinIntDef.Z.even v1 = @false) => eq_ind_r (fun v4 : @bool => v4 = @true) (eq_ind_r (fun v4 : @bool => Bool.eqb v4 (BinIntDef.Z.even v1) = @true) (eq_ind_r (fun v4 : @bool => Bool.eqb (@false) v4 = @true) eq_refl v3) v2) (Z.even_add v0 v1)))) (BinIntDef.Z.odd v1) (Z.negb_even v1)) (BinIntDef.Z.odd v0) (Z.negb_even v0)))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_mult_Zeven_l	100	0.195014	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => (fun v2 : BinIntDef.Z.even v0 = @true <-> Zeven v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zeven v0) (BinIntDef.Z.even v0 = @true) (RelationClasses.symmetry v2) (Zeven (v0 * v1)) (Zeven (v0 * v1)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zeven (v0 * v1)))) (Zeven_bool_iff v0) ((fun v2 : BinIntDef.Z.even (v0 * v1) = @true <-> Zeven (v0 * v1) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.even v0 = @true)) (Zeven (v0 * v1)) (BinIntDef.Z.even (v0 * v1) = @true) (RelationClasses.symmetry v2)) (Zeven_bool_iff (v0 * v1)) (fun v2 : BinIntDef.Z.even v0 = @true => eq_ind_r (fun v3 : @bool => v3 = @true) (eq_ind_r (fun v3 : @bool => (v3 || BinIntDef.Z.even v1)%bool = @true) eq_refl v2) (Z.even_mul v0 v1))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zeven_mult_Zeven_r	100	0.055214	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : Zeven v1) => eq_ind_r (fun v3 : @Z => Zeven v3) (Zeven_mult_Zeven_l v1 v0 v2) (Z.mul_comm v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zeven.Zodd_mult_Zodd	100	0.541331	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => (fun v2 : BinIntDef.Z.odd v0 = @true <-> Zodd v0 => Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation))) (Zodd v0) (BinIntDef.Z.odd v0 = @true) (RelationClasses.symmetry v2) (forall v3 : Zodd v1, Zodd (v0 * v1)) (forall v3 : Zodd v1, Zodd (v0 * v1)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (forall v3 : Zodd v1, Zodd (v0 * v1)))) (Zodd_bool_iff v0) ((fun v2 : BinIntDef.Z.odd v1 = @true <-> Zodd v1 => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.odd v0 = @true)) (forall v3 : Zodd v1, Zodd (v0 * v1)) (forall v3 : BinIntDef.Z.odd v1 = @true, Zodd (v0 * v1)) (Morphisms_Prop.iff_iff_iff_impl_morphism (Zodd v1) (BinIntDef.Z.odd v1 = @true) (RelationClasses.symmetry v2) (Zodd (v0 * v1)) (Zodd (v0 * v1)) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (Zodd (v0 * v1))))) (Zodd_bool_iff v1) ((fun v2 : BinIntDef.Z.odd (v0 * v1) = @true <-> Zodd (v0 * v1) => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl (@iff)) (@Morphisms.iff_flip_impl_subrelation)))) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.odd v0 = @true)) (forall v3 : BinIntDef.Z.odd v1 = @true, Zodd (v0 * v1)) (forall v3 : BinIntDef.Z.odd v1 = @true, BinIntDef.Z.odd (v0 * v1) = @true) (Morphisms.Reflexive_partial_app_morphism (@Morphisms_Prop.iff_iff_iff_impl_morphism) (Morphisms.reflexive_proper_proxy (@RelationClasses.iff_Reflexive) (BinIntDef.Z.odd v1 = @true)) (Zodd (v0 * v1)) (BinIntDef.Z.odd (v0 * v1) = @true) (RelationClasses.symmetry v2))) (Zodd_bool_iff (v0 * v1)) (fun (v2 : BinIntDef.Z.odd v0 = @true) (v3 : BinIntDef.Z.odd v1 = @true) => eq_ind_r (fun v4 : @bool => v4 = @true) (eq_ind_r (fun v4 : @bool => (v4 && BinIntDef.Z.odd v1)%bool = @true) (eq_ind_r (fun v4 : @bool => (@true && v4)%bool = @true) eq_refl v3) v2) (Z.odd_mul v0 v1)))))).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.ascii_dec	100	1.593397	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @ascii => ascii_rec (fun v2 : @ascii => forall v3 : @ascii, {v2 = v3} + {v2 <> v3}) (fun (v2 v3 v4 v5 v6 v7 v8 v9 : @bool) (v10 : @ascii) => match v10 as v11 in ascii return ({Ascii v2 v3 v4 v5 v6 v7 v8 v9 = v11} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> v11}) with | Ascii v11 v12 v13 v14 v15 v16 v17 v18 => (fun v11 v12 v13 v14 v15 v16 v17 v18 : @bool => sumbool_rec (fun v19 : {v2 = v11} + {v2 <> v11} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v19 : v2 = v11 => sumbool_rec (fun v20 : {v3 = v12} + {v3 <> v12} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v20 : v3 = v12 => sumbool_rec (fun v21 : {v4 = v13} + {v4 <> v13} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v21 : v4 = v13 => sumbool_rec (fun v22 : {v5 = v14} + {v5 <> v14} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v22 : v5 = v14 => sumbool_rec (fun v23 : {v6 = v15} + {v6 <> v15} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v23 : v6 = v15 => sumbool_rec (fun v24 : {v7 = v16} + {v7 <> v16} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v24 : v7 = v16 => sumbool_rec (fun v25 : {v8 = v17} + {v8 <> v17} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v25 : v8 = v17 => sumbool_rec (fun v26 : {v9 = v18} + {v9 <> v18} => {Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18} + {Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18}) (fun v26 : v9 = v18 => left (eq_ind_r (fun v27 : @bool => Ascii v27 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v27 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v27 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v27 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v14 v27 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v14 v15 v27 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v14 v15 v16 v27 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v14 v15 v16 v17 v27 = Ascii v11 v12 v13 v14 v15 v16 v17 v18) eq_refl v26) v25) v24) v23) v22) v21) v20) v19)) (fun v26 : v9 <> v18 => right (eq_ind_r (fun v27 : @bool => Ascii v27 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v27 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v27 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v27 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v14 v27 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v14 v15 v27 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v27 : @bool => Ascii v11 v12 v13 v14 v15 v16 v27 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) ((fun v27 : Ascii v11 v12 v13 v14 v15 v16 v17 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v26 (let v28 : v9 = v18 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v36) v29 v30 v31 v32 v33 v34 v35 v36 end) v27 in (fun v29 : v9 = v18 => v29) v28)) : Ascii v11 v12 v13 v14 v15 v16 v17 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) v25) v24) v23) v22) v21) v20) v19)) (bool_dec v9 v18)) (fun v25 : v8 <> v17 => right (eq_ind_r (fun v26 : @bool => Ascii v26 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v26 : @bool => Ascii v11 v26 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v26 : @bool => Ascii v11 v12 v26 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v26 : @bool => Ascii v11 v12 v13 v26 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v26 : @bool => Ascii v11 v12 v13 v14 v26 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v26 : @bool => Ascii v11 v12 v13 v14 v15 v26 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) ((fun v26 : Ascii v11 v12 v13 v14 v15 v16 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v25 (let v27 : v9 = v18 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v35) v28 v29 v30 v31 v32 v33 v34 v35 end) v26 in (let v28 : v8 = v17 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v35) v29 v30 v31 v32 v33 v34 v35 v36 end) v26 in (fun (v29 : v8 = v17) (v30 : v9 = v18) => v29) v28) v27)) : Ascii v11 v12 v13 v14 v15 v16 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) v24) v23) v22) v21) v20) v19)) (bool_dec v8 v17)) (fun v24 : v7 <> v16 => right (eq_ind_r (fun v25 : @bool => Ascii v25 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v25 : @bool => Ascii v11 v25 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v25 : @bool => Ascii v11 v12 v25 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v25 : @bool => Ascii v11 v12 v13 v25 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v25 : @bool => Ascii v11 v12 v13 v14 v25 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) ((fun v25 : Ascii v11 v12 v13 v14 v15 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v24 (let v26 : v9 = v18 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v34) v27 v28 v29 v30 v31 v32 v33 v34 end) v25 in (let v27 : v8 = v17 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v34) v28 v29 v30 v31 v32 v33 v34 v35 end) v25 in (let v28 : v7 = v16 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v34) v29 v30 v31 v32 v33 v34 v35 v36 end) v25 in (fun (v29 : v7 = v16) (v30 : v8 = v17) (v31 : v9 = v18) => v29) v28) v27) v26)) : Ascii v11 v12 v13 v14 v15 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) v23) v22) v21) v20) v19)) (bool_dec v7 v16)) (fun v23 : v6 <> v15 => right (eq_ind_r (fun v24 : @bool => Ascii v24 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v24 : @bool => Ascii v11 v24 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v24 : @bool => Ascii v11 v12 v24 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v24 : @bool => Ascii v11 v12 v13 v24 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) ((fun v24 : Ascii v11 v12 v13 v14 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v23 (let v25 : v9 = v18 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v33) v26 v27 v28 v29 v30 v31 v32 v33 end) v24 in (let v26 : v8 = v17 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v33) v27 v28 v29 v30 v31 v32 v33 v34 end) v24 in (let v27 : v7 = v16 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v33) v28 v29 v30 v31 v32 v33 v34 v35 end) v24 in (let v28 : v6 = v15 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v33) v29 v30 v31 v32 v33 v34 v35 v36 end) v24 in (fun (v29 : v6 = v15) (v30 : v7 = v16) (v31 : v8 = v17) (v32 : v9 = v18) => v29) v28) v27) v26) v25)) : Ascii v11 v12 v13 v14 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) v22) v21) v20) v19)) (bool_dec v6 v15)) (fun v22 : v5 <> v14 => right (eq_ind_r (fun v23 : @bool => Ascii v23 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v23 : @bool => Ascii v11 v23 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v23 : @bool => Ascii v11 v12 v23 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) ((fun v23 : Ascii v11 v12 v13 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v22 (let v24 : v9 = v18 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v32) v25 v26 v27 v28 v29 v30 v31 v32 end) v23 in (let v25 : v8 = v17 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v32) v26 v27 v28 v29 v30 v31 v32 v33 end) v23 in (let v26 : v7 = v16 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v32) v27 v28 v29 v30 v31 v32 v33 v34 end) v23 in (let v27 : v6 = v15 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v32) v28 v29 v30 v31 v32 v33 v34 v35 end) v23 in (let v28 : v5 = v14 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v32) v29 v30 v31 v32 v33 v34 v35 v36 end) v23 in (fun (v29 : v5 = v14) (v30 : v6 = v15) (v31 : v7 = v16) (v32 : v8 = v17) (v33 : v9 = v18) => v29) v28) v27) v26) v25) v24)) : Ascii v11 v12 v13 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) v21) v20) v19)) (bool_dec v5 v14)) (fun v21 : v4 <> v13 => right (eq_ind_r (fun v22 : @bool => Ascii v22 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) (eq_ind_r (fun v22 : @bool => Ascii v11 v22 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) ((fun v22 : Ascii v11 v12 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v21 (let v23 : v9 = v18 := f_equal (fun v23 : @ascii => match v23 as v24 in ascii return (@bool) with | Ascii v24 v25 v26 v27 v28 v29 v30 v31 => (fun v24 v25 v26 v27 v28 v29 v30 v31 : @bool => v31) v24 v25 v26 v27 v28 v29 v30 v31 end) v22 in (let v24 : v8 = v17 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v31) v25 v26 v27 v28 v29 v30 v31 v32 end) v22 in (let v25 : v7 = v16 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v31) v26 v27 v28 v29 v30 v31 v32 v33 end) v22 in (let v26 : v6 = v15 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v31) v27 v28 v29 v30 v31 v32 v33 v34 end) v22 in (let v27 : v5 = v14 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v31) v28 v29 v30 v31 v32 v33 v34 v35 end) v22 in (let v28 : v4 = v13 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v31) v29 v30 v31 v32 v33 v34 v35 v36 end) v22 in (fun (v29 : v4 = v13) (v30 : v5 = v14) (v31 : v6 = v15) (v32 : v7 = v16) (v33 : v8 = v17) (v34 : v9 = v18) => v29) v28) v27) v26) v25) v24) v23)) : Ascii v11 v12 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) v20) v19)) (bool_dec v4 v13)) (fun v20 : v3 <> v12 => right (eq_ind_r (fun v21 : @bool => Ascii v21 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) ((fun v21 : Ascii v11 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v20 (let v22 : v9 = v18 := f_equal (fun v22 : @ascii => match v22 as v23 in ascii return (@bool) with | Ascii v23 v24 v25 v26 v27 v28 v29 v30 => (fun v23 v24 v25 v26 v27 v28 v29 v30 : @bool => v30) v23 v24 v25 v26 v27 v28 v29 v30 end) v21 in (let v23 : v8 = v17 := f_equal (fun v23 : @ascii => match v23 as v24 in ascii return (@bool) with | Ascii v24 v25 v26 v27 v28 v29 v30 v31 => (fun v24 v25 v26 v27 v28 v29 v30 v31 : @bool => v30) v24 v25 v26 v27 v28 v29 v30 v31 end) v21 in (let v24 : v7 = v16 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v30) v25 v26 v27 v28 v29 v30 v31 v32 end) v21 in (let v25 : v6 = v15 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v30) v26 v27 v28 v29 v30 v31 v32 v33 end) v21 in (let v26 : v5 = v14 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v30) v27 v28 v29 v30 v31 v32 v33 v34 end) v21 in (let v27 : v4 = v13 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v30) v28 v29 v30 v31 v32 v33 v34 v35 end) v21 in (let v28 : v3 = v12 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v30) v29 v30 v31 v32 v33 v34 v35 v36 end) v21 in (fun (v29 : v3 = v12) (v30 : v4 = v13) (v31 : v5 = v14) (v32 : v6 = v15) (v33 : v7 = v16) (v34 : v8 = v17) (v35 : v9 = v18) => v29) v28) v27) v26) v25) v24) v23) v22)) : Ascii v11 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18) v19)) (bool_dec v3 v12)) (fun v19 : v2 <> v11 => right ((fun v20 : Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v11 v12 v13 v14 v15 v16 v17 v18 => v19 (let v21 : v9 = v18 := f_equal (fun v21 : @ascii => match v21 as v22 in ascii return (@bool) with | Ascii v22 v23 v24 v25 v26 v27 v28 v29 => (fun v22 v23 v24 v25 v26 v27 v28 v29 : @bool => v29) v22 v23 v24 v25 v26 v27 v28 v29 end) v20 in (let v22 : v8 = v17 := f_equal (fun v22 : @ascii => match v22 as v23 in ascii return (@bool) with | Ascii v23 v24 v25 v26 v27 v28 v29 v30 => (fun v23 v24 v25 v26 v27 v28 v29 v30 : @bool => v29) v23 v24 v25 v26 v27 v28 v29 v30 end) v20 in (let v23 : v7 = v16 := f_equal (fun v23 : @ascii => match v23 as v24 in ascii return (@bool) with | Ascii v24 v25 v26 v27 v28 v29 v30 v31 => (fun v24 v25 v26 v27 v28 v29 v30 v31 : @bool => v29) v24 v25 v26 v27 v28 v29 v30 v31 end) v20 in (let v24 : v6 = v15 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v29) v25 v26 v27 v28 v29 v30 v31 v32 end) v20 in (let v25 : v5 = v14 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v29) v26 v27 v28 v29 v30 v31 v32 v33 end) v20 in (let v26 : v4 = v13 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v29) v27 v28 v29 v30 v31 v32 v33 v34 end) v20 in (let v27 : v3 = v12 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v29) v28 v29 v30 v31 v32 v33 v34 v35 end) v20 in (let v28 : v2 = v11 := f_equal (fun v28 : @ascii => match v28 as v29 in ascii return (@bool) with | Ascii v29 v30 v31 v32 v33 v34 v35 v36 => (fun v29 v30 v31 v32 v33 v34 v35 v36 : @bool => v29) v29 v30 v31 v32 v33 v34 v35 v36 end) v20 in (fun (v29 : v2 = v11) (v30 : v3 = v12) (v31 : v4 = v13) (v32 : v5 = v14) (v33 : v6 = v15) (v34 : v7 = v16) (v35 : v8 = v17) (v36 : v9 = v18) => v29) v28) v27) v26) v25) v24) v23) v22) v21)) : Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v11 v12 v13 v14 v15 v16 v17 v18)) (bool_dec v2 v11)) v11 v12 v13 v14 v15 v16 v17 v18 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.eqb_spec	100	1.509460	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @ascii => match v0 as v2 in ascii return (reflect (v2 = v1) (v2 =? v1)%char) with | Ascii v2 v3 v4 v5 v6 v7 v8 v9 => (fun v2 v3 v4 v5 v6 v7 v8 v9 : @bool => match v1 as v10 in ascii return (reflect (Ascii v2 v3 v4 v5 v6 v7 v8 v9 = v10) (Ascii v2 v3 v4 v5 v6 v7 v8 v9 =? v10)%char) with | Ascii v10 v11 v12 v13 v14 v15 v16 v17 => (fun v10 v11 v12 v13 v14 v15 v16 v17 : @bool => match eqb_spec v2 v10 as v19 in (reflect _ v18) return (reflect (Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match match match match match v18 as v20 in bool return (@bool) with | true => Bool.eqb v3 v11 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v4 v12 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v5 v13 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v6 v14 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) with | ReflectT _ v18 => (fun v18 : v2 = v10 => eq_rec_r (fun v19 : @bool => reflect (Ascii v19 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match match match match Bool.eqb v3 v11 as v20 in bool return (@bool) with | true => Bool.eqb v4 v12 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v5 v13 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v6 v14 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v20 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) match eqb_spec v3 v11 as v20 in (reflect _ v19) return (reflect (Ascii v10 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match match match match v19 as v21 in bool return (@bool) with | true => Bool.eqb v4 v12 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v5 v13 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v6 v14 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) with | ReflectT _ v19 => (fun v19 : v3 = v11 => eq_rec_r (fun v20 : @bool => reflect (Ascii v10 v20 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match match match Bool.eqb v4 v12 as v21 in bool return (@bool) with | true => Bool.eqb v5 v13 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v6 v14 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v21 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) match eqb_spec v4 v12 as v21 in (reflect _ v20) return (reflect (Ascii v10 v11 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match match match v20 as v22 in bool return (@bool) with | true => Bool.eqb v5 v13 | false => @false end as v22 in bool return (@bool) with | true => Bool.eqb v6 v14 | false => @false end as v22 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v22 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v22 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) with | ReflectT _ v20 => (fun v20 : v4 = v12 => eq_rec_r (fun v21 : @bool => reflect (Ascii v10 v11 v21 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match match Bool.eqb v5 v13 as v22 in bool return (@bool) with | true => Bool.eqb v6 v14 | false => @false end as v22 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v22 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v22 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) match eqb_spec v5 v13 as v22 in (reflect _ v21) return (reflect (Ascii v10 v11 v12 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match match v21 as v23 in bool return (@bool) with | true => Bool.eqb v6 v14 | false => @false end as v23 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v23 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v23 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) with | ReflectT _ v21 => (fun v21 : v5 = v13 => eq_rec_r (fun v22 : @bool => reflect (Ascii v10 v11 v12 v22 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match Bool.eqb v6 v14 as v23 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v23 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v23 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) match eqb_spec v6 v14 as v23 in (reflect _ v22) return (reflect (Ascii v10 v11 v12 v13 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match match v22 as v24 in bool return (@bool) with | true => Bool.eqb v7 v15 | false => @false end as v24 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v24 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) with | ReflectT _ v22 => (fun v22 : v6 = v14 => eq_rec_r (fun v23 : @bool => reflect (Ascii v10 v11 v12 v13 v23 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match Bool.eqb v7 v15 as v24 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v24 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) match eqb_spec v7 v15 as v24 in (reflect _ v23) return (reflect (Ascii v10 v11 v12 v13 v14 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match match v23 as v25 in bool return (@bool) with | true => Bool.eqb v8 v16 | false => @false end as v25 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) with | ReflectT _ v23 => (fun v23 : v7 = v15 => eq_rec_r (fun v24 : @bool => reflect (Ascii v10 v11 v12 v13 v14 v24 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match Bool.eqb v8 v16 as v25 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) match eqb_spec v8 v16 as v25 in (reflect _ v24) return (reflect (Ascii v10 v11 v12 v13 v14 v15 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) match v24 as v26 in bool return (@bool) with | true => Bool.eqb v9 v17 | false => @false end) with | ReflectT _ v24 => (fun v24 : v8 = v16 => eq_rec_r (fun v25 : @bool => reflect (Ascii v10 v11 v12 v13 v14 v15 v25 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) (Bool.eqb v9 v17)) match eqb_spec v9 v17 as v26 in (reflect _ v25) return (reflect (Ascii v10 v11 v12 v13 v14 v15 v16 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) v25) with | ReflectT _ v25 => (fun v25 : v9 = v17 => eq_rec_r (fun v26 : @bool => reflect (Ascii v10 v11 v12 v13 v14 v15 v16 v26 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) (@true)) (ReflectT (Ascii v10 v11 v12 v13 v14 v15 v16 v17 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) eq_refl) v25) v25 | ReflectF _ v25 => (fun v25 : v9 <> v17 => ReflectF (Ascii v10 v11 v12 v13 v14 v15 v16 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v26 : Ascii v10 v11 v12 v13 v14 v15 v16 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v27 : v9 = v17 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v35) v28 v29 v30 v31 v32 v33 v34 v35 end) v26 in (fun v28 : v9 = v17 => False_ind (@False) (v25 v28)) v27) : Ascii v10 v11 v12 v13 v14 v15 v16 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v25 end v24) v24 | ReflectF _ v24 => (fun v24 : v8 <> v16 => ReflectF (Ascii v10 v11 v12 v13 v14 v15 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v25 : Ascii v10 v11 v12 v13 v14 v15 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v26 : v9 = v17 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v34) v27 v28 v29 v30 v31 v32 v33 v34 end) v25 in (let v27 : v8 = v16 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v34) v28 v29 v30 v31 v32 v33 v34 v35 end) v25 in (fun (v28 : v8 = v16) (v29 : v9 = v17) => False_ind (@False) (v24 v28)) v27) v26) : Ascii v10 v11 v12 v13 v14 v15 v8 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v24 end v23) v23 | ReflectF _ v23 => (fun v23 : v7 <> v15 => ReflectF (Ascii v10 v11 v12 v13 v14 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v24 : Ascii v10 v11 v12 v13 v14 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v25 : v9 = v17 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v33) v26 v27 v28 v29 v30 v31 v32 v33 end) v24 in (let v26 : v8 = v16 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v33) v27 v28 v29 v30 v31 v32 v33 v34 end) v24 in (let v27 : v7 = v15 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v33) v28 v29 v30 v31 v32 v33 v34 v35 end) v24 in (fun (v28 : v7 = v15) (v29 : v8 = v16) (v30 : v9 = v17) => False_ind (@False) (v23 v28)) v27) v26) v25) : Ascii v10 v11 v12 v13 v14 v7 v8 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v23 end v22) v22 | ReflectF _ v22 => (fun v22 : v6 <> v14 => ReflectF (Ascii v10 v11 v12 v13 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v23 : Ascii v10 v11 v12 v13 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v24 : v9 = v17 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v32) v25 v26 v27 v28 v29 v30 v31 v32 end) v23 in (let v25 : v8 = v16 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v32) v26 v27 v28 v29 v30 v31 v32 v33 end) v23 in (let v26 : v7 = v15 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v32) v27 v28 v29 v30 v31 v32 v33 v34 end) v23 in (let v27 : v6 = v14 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v32) v28 v29 v30 v31 v32 v33 v34 v35 end) v23 in (fun (v28 : v6 = v14) (v29 : v7 = v15) (v30 : v8 = v16) (v31 : v9 = v17) => False_ind (@False) (v22 v28)) v27) v26) v25) v24) : Ascii v10 v11 v12 v13 v6 v7 v8 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v22 end v21) v21 | ReflectF _ v21 => (fun v21 : v5 <> v13 => ReflectF (Ascii v10 v11 v12 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v22 : Ascii v10 v11 v12 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v23 : v9 = v17 := f_equal (fun v23 : @ascii => match v23 as v24 in ascii return (@bool) with | Ascii v24 v25 v26 v27 v28 v29 v30 v31 => (fun v24 v25 v26 v27 v28 v29 v30 v31 : @bool => v31) v24 v25 v26 v27 v28 v29 v30 v31 end) v22 in (let v24 : v8 = v16 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v31) v25 v26 v27 v28 v29 v30 v31 v32 end) v22 in (let v25 : v7 = v15 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v31) v26 v27 v28 v29 v30 v31 v32 v33 end) v22 in (let v26 : v6 = v14 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v31) v27 v28 v29 v30 v31 v32 v33 v34 end) v22 in (let v27 : v5 = v13 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v31) v28 v29 v30 v31 v32 v33 v34 v35 end) v22 in (fun (v28 : v5 = v13) (v29 : v6 = v14) (v30 : v7 = v15) (v31 : v8 = v16) (v32 : v9 = v17) => False_ind (@False) (v21 v28)) v27) v26) v25) v24) v23) : Ascii v10 v11 v12 v5 v6 v7 v8 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v21 end v20) v20 | ReflectF _ v20 => (fun v20 : v4 <> v12 => ReflectF (Ascii v10 v11 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v21 : Ascii v10 v11 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v22 : v9 = v17 := f_equal (fun v22 : @ascii => match v22 as v23 in ascii return (@bool) with | Ascii v23 v24 v25 v26 v27 v28 v29 v30 => (fun v23 v24 v25 v26 v27 v28 v29 v30 : @bool => v30) v23 v24 v25 v26 v27 v28 v29 v30 end) v21 in (let v23 : v8 = v16 := f_equal (fun v23 : @ascii => match v23 as v24 in ascii return (@bool) with | Ascii v24 v25 v26 v27 v28 v29 v30 v31 => (fun v24 v25 v26 v27 v28 v29 v30 v31 : @bool => v30) v24 v25 v26 v27 v28 v29 v30 v31 end) v21 in (let v24 : v7 = v15 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v30) v25 v26 v27 v28 v29 v30 v31 v32 end) v21 in (let v25 : v6 = v14 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v30) v26 v27 v28 v29 v30 v31 v32 v33 end) v21 in (let v26 : v5 = v13 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v30) v27 v28 v29 v30 v31 v32 v33 v34 end) v21 in (let v27 : v4 = v12 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v30) v28 v29 v30 v31 v32 v33 v34 v35 end) v21 in (fun (v28 : v4 = v12) (v29 : v5 = v13) (v30 : v6 = v14) (v31 : v7 = v15) (v32 : v8 = v16) (v33 : v9 = v17) => False_ind (@False) (v20 v28)) v27) v26) v25) v24) v23) v22) : Ascii v10 v11 v4 v5 v6 v7 v8 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v20 end v19) v19 | ReflectF _ v19 => (fun v19 : v3 <> v11 => ReflectF (Ascii v10 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v20 : Ascii v10 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v21 : v9 = v17 := f_equal (fun v21 : @ascii => match v21 as v22 in ascii return (@bool) with | Ascii v22 v23 v24 v25 v26 v27 v28 v29 => (fun v22 v23 v24 v25 v26 v27 v28 v29 : @bool => v29) v22 v23 v24 v25 v26 v27 v28 v29 end) v20 in (let v22 : v8 = v16 := f_equal (fun v22 : @ascii => match v22 as v23 in ascii return (@bool) with | Ascii v23 v24 v25 v26 v27 v28 v29 v30 => (fun v23 v24 v25 v26 v27 v28 v29 v30 : @bool => v29) v23 v24 v25 v26 v27 v28 v29 v30 end) v20 in (let v23 : v7 = v15 := f_equal (fun v23 : @ascii => match v23 as v24 in ascii return (@bool) with | Ascii v24 v25 v26 v27 v28 v29 v30 v31 => (fun v24 v25 v26 v27 v28 v29 v30 v31 : @bool => v29) v24 v25 v26 v27 v28 v29 v30 v31 end) v20 in (let v24 : v6 = v14 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v29) v25 v26 v27 v28 v29 v30 v31 v32 end) v20 in (let v25 : v5 = v13 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v29) v26 v27 v28 v29 v30 v31 v32 v33 end) v20 in (let v26 : v4 = v12 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v29) v27 v28 v29 v30 v31 v32 v33 v34 end) v20 in (let v27 : v3 = v11 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v29) v28 v29 v30 v31 v32 v33 v34 v35 end) v20 in (fun (v28 : v3 = v11) (v29 : v4 = v12) (v30 : v5 = v13) (v31 : v6 = v14) (v32 : v7 = v15) (v33 : v8 = v16) (v34 : v9 = v17) => False_ind (@False) (v19 v28)) v27) v26) v25) v24) v23) v22) v21) : Ascii v10 v3 v4 v5 v6 v7 v8 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v19 end v18) v18 | ReflectF _ v18 => (fun v18 : v2 <> v10 => ReflectF (Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) ((fun v19 : Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17 => let v20 : v9 = v17 := f_equal (fun v20 : @ascii => match v20 as v21 in ascii return (@bool) with | Ascii v21 v22 v23 v24 v25 v26 v27 v28 => (fun v21 v22 v23 v24 v25 v26 v27 v28 : @bool => v28) v21 v22 v23 v24 v25 v26 v27 v28 end) v19 in (let v21 : v8 = v16 := f_equal (fun v21 : @ascii => match v21 as v22 in ascii return (@bool) with | Ascii v22 v23 v24 v25 v26 v27 v28 v29 => (fun v22 v23 v24 v25 v26 v27 v28 v29 : @bool => v28) v22 v23 v24 v25 v26 v27 v28 v29 end) v19 in (let v22 : v7 = v15 := f_equal (fun v22 : @ascii => match v22 as v23 in ascii return (@bool) with | Ascii v23 v24 v25 v26 v27 v28 v29 v30 => (fun v23 v24 v25 v26 v27 v28 v29 v30 : @bool => v28) v23 v24 v25 v26 v27 v28 v29 v30 end) v19 in (let v23 : v6 = v14 := f_equal (fun v23 : @ascii => match v23 as v24 in ascii return (@bool) with | Ascii v24 v25 v26 v27 v28 v29 v30 v31 => (fun v24 v25 v26 v27 v28 v29 v30 v31 : @bool => v28) v24 v25 v26 v27 v28 v29 v30 v31 end) v19 in (let v24 : v5 = v13 := f_equal (fun v24 : @ascii => match v24 as v25 in ascii return (@bool) with | Ascii v25 v26 v27 v28 v29 v30 v31 v32 => (fun v25 v26 v27 v28 v29 v30 v31 v32 : @bool => v28) v25 v26 v27 v28 v29 v30 v31 v32 end) v19 in (let v25 : v4 = v12 := f_equal (fun v25 : @ascii => match v25 as v26 in ascii return (@bool) with | Ascii v26 v27 v28 v29 v30 v31 v32 v33 => (fun v26 v27 v28 v29 v30 v31 v32 v33 : @bool => v28) v26 v27 v28 v29 v30 v31 v32 v33 end) v19 in (let v26 : v3 = v11 := f_equal (fun v26 : @ascii => match v26 as v27 in ascii return (@bool) with | Ascii v27 v28 v29 v30 v31 v32 v33 v34 => (fun v27 v28 v29 v30 v31 v32 v33 v34 : @bool => v28) v27 v28 v29 v30 v31 v32 v33 v34 end) v19 in (let v27 : v2 = v10 := f_equal (fun v27 : @ascii => match v27 as v28 in ascii return (@bool) with | Ascii v28 v29 v30 v31 v32 v33 v34 v35 => (fun v28 v29 v30 v31 v32 v33 v34 v35 : @bool => v28) v28 v29 v30 v31 v32 v33 v34 v35 end) v19 in (fun (v28 : v2 = v10) (v29 : v3 = v11) (v30 : v4 = v12) (v31 : v5 = v13) (v32 : v6 = v14) (v33 : v7 = v15) (v34 : v8 = v16) (v35 : v9 = v17) => False_ind (@False) (v18 v28)) v27) v26) v25) v24) v23) v22) v21) v20) : Ascii v2 v3 v4 v5 v6 v7 v8 v9 <> Ascii v10 v11 v12 v13 v14 v15 v16 v17)) v18 end : reflect (Ascii v2 v3 v4 v5 v6 v7 v8 v9 = Ascii v10 v11 v12 v13 v14 v15 v16 v17) (Ascii v2 v3 v4 v5 v6 v7 v8 v9 =? Ascii v10 v11 v12 v13 v14 v15 v16 v17)%char) v10 v11 v12 v13 v14 v15 v16 v17 end) v2 v3 v4 v5 v6 v7 v8 v9 end)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.eqb_refl	100	0.071743	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @ascii => let v1 : reflect (v0 = v0) (v0 =? v0)%char := eqb_spec v0 v0 in let v2 : @bool := (v0 =? v0)%char in match v1 as v4 in (reflect _ v3) return (v3 = @true) with | ReflectT _ v3 => (fun v3 : v0 = v0 => eq_refl) v3 | ReflectF _ v3 => (fun v3 : v0 <> v0 => let v4 : v0 = v0 := eq_refl in False_ind (@false = @true) (v3 v4)) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.eqb_sym	100	0.088361	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @ascii => let v2 : reflect (v0 = v1) (v0 =? v1)%char := eqb_spec v0 v1 in let v3 : @bool := (v0 =? v1)%char in match v2 as v5 in (reflect _ v4) return (v4 = (v1 =? v0)%char) with | ReflectT _ v4 => (fun v4 : v0 = v1 => eq_ind_r (fun v5 : @ascii => @true = (v1 =? v5)%char) (let v5 : reflect (v1 = v1) (v1 =? v1)%char := eqb_spec v1 v1 in let v6 : @bool := (v1 =? v1)%char in match v5 as v8 in (reflect _ v7) return (@true = v7) with | ReflectT _ v7 => (fun v7 : v1 = v1 => eq_refl) v7 | ReflectF _ v7 => (fun v7 : v1 <> v1 => let v8 : v1 = v1 := eq_refl in False_ind (@true = @false) (v7 v8)) v7 end) v4) v4 | ReflectF _ v4 => (fun v4 : v0 <> v1 => let v5 : reflect (v1 = v0) (v1 =? v0)%char := eqb_spec v1 v0 in let v6 : @bool := (v1 =? v0)%char in match v5 as v8 in (reflect _ v7) return (@false = v7) with | ReflectT _ v7 => (fun v7 : v1 = v0 => let v8 : v0 = v1 := eq_sym v7 in False_ind (@false = @true) (v4 v8)) v7 | ReflectF _ v7 => (fun v7 : v1 <> v0 => eq_refl) v7 end) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.eqb_eq	100	0.087417	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @ascii => conj (let v2 : reflect (v0 = v1) (v0 =? v1)%char := eqb_spec v0 v1 in let v3 : @bool := (v0 =? v1)%char in match v2 as v5 in (reflect _ v4) return (forall v6 : v4 = @true, v0 = v1) with | ReflectT _ v4 => (fun (v4 : v0 = v1) (v5 : @true = @true) => v4) v4 | ReflectF _ v4 => (fun (v4 : v0 <> v1) (v5 : @false = @true) => let v6 : @false = @true := v5 in let v7 : @False := eq_ind (@false) (fun v7 : @bool => match v7 as v8 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v6 in False_ind (v0 = v1) v7) v4 end) (let v2 : reflect (v0 = v1) (v0 =? v1)%char := eqb_spec v0 v1 in let v3 : @bool := (v0 =? v1)%char in match v2 as v5 in (reflect _ v4) return (forall v6 : v0 = v1, v4 = @true) with | ReflectT _ v4 => (fun v4 v5 : v0 = v1 => eq_refl) v4 | ReflectF _ v4 => (fun (v4 : v0 <> v1) (v5 : v0 = v1) => let v6 : v0 = v1 := v5 in False_ind (@false = @true) (v4 v6)) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.eqb_neq	100	0.096646	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @ascii => conj (let v2 : reflect (v0 = v1) (v0 =? v1)%char := eqb_spec v0 v1 in let v3 : @bool := (v0 =? v1)%char in match v2 as v5 in (reflect _ v4) return (forall v6 : v4 = @false, v0 <> v1) with | ReflectT _ v4 => (fun (v4 : v0 = v1) (v5 : @true = @false) => (fun v6 : v0 = v1 => let v7 : @true = @false := v5 in let v8 : @False := eq_ind (@true) (fun v8 : @bool => match v8 as v9 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v7 in False_ind (@False) v8) : v0 <> v1) v4 | ReflectF _ v4 => (fun (v4 : v0 <> v1) (v5 : @false = @false) => (fun v6 : v0 = v1 => let v7 : v0 = v1 := v6 in False_ind (@False) (v4 v7)) : v0 <> v1) v4 end) (let v2 : reflect (v0 = v1) (v0 =? v1)%char := eqb_spec v0 v1 in let v3 : @bool := (v0 =? v1)%char in match v2 as v5 in (reflect _ v4) return (forall v6 : v0 <> v1, v4 = @false) with | ReflectT _ v4 => (fun (v4 : v0 = v1) (v5 : v0 <> v1) => let v6 : v0 = v1 := v4 in False_ind (@true = @false) (v5 v6)) v4 | ReflectF _ v4 => (fun v4 v5 : v0 <> v1 => eq_refl) v4 end))).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.eqb_compat	100	0.072063	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @ascii) (v2 : v0 = v1) => (fun (v3 v4 : @ascii) (v5 : v3 = v4) => eq_trans (f_equal (fun v6 : forall v6 : @ascii, @bool => v6 v3) (eq_trans (f_equal (fun v6 : forall v6 v7 : @ascii, @bool => v6 v0) eq_refl) (f_equal (@eqb) v2))) (f_equal (eqb v1) v5)) : Morphisms.respectful eq eq (eqb v0) (eqb v1)) : Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq eq)) (@eqb))).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.ascii_N_embedding	100	10.712139	1	1
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.N_ascii_embedding	100	64.578281	1	1
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.N_ascii_bounded	100	10.361122	1	1
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.ascii_nat_embedding	100	12.462977	1	1
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.nat_ascii_embedding	100	0.874953	1	1	0	synth with cache (only 1: refine (fun (v0 : @nat) (v1 : v0 < 256) => (eq_ind_r (fun v2 : @N => BinNatDef.N.to_nat v2 = v0) (Nat2N.id v0) (N_ascii_embedding (BinNatDef.N.of_nat v0) (eq_ind (v0 ?= 256) (fun v2 : @comparison => v2 = @Lt) (let v2 : forall (v2 v3 : @nat) (v4 : v2 < v3), (v2 ?= v3) = @Lt := fun v2 v3 : @nat => match Nat.compare_lt_iff v2 v3 as v4 in (_ /\ _) return (forall v5 : v2 < v3, (v2 ?= v3) = @Lt) with | conj v4 v5 => (fun (v4 : forall v4 : (v2 ?= v3) = @Lt, v2 < v3) (v5 : forall v5 : v2 < v3, (v2 ?= v3) = @Lt) => v5) v4 v5 end in v2 v0 256 v1) (BinNatDef.N.of_nat v0 ?= BinNatDef.N.of_nat 256)%N (Nat2N.inj_compare v0 256) : (BinNatDef.N.of_nat v0 < 256)%N)) : BinNatDef.N.to_nat (N_of_ascii (ascii_of_nat v0)) = v0) : nat_of_ascii (ascii_of_nat v0) = v0)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.nat_ascii_bounded	100	0.481761	1	1	0	synth with cache (only 1: refine (fun v0 : @ascii => (fun v1 : (BinNatDef.N.to_nat (N_of_ascii v0) ?= BinNatDef.N.to_nat 256) = @Lt <-> BinNatDef.N.to_nat (N_of_ascii v0) < BinNatDef.N.to_nat 256 => Morphisms.iff_flip_impl_subrelation (BinNatDef.N.to_nat (N_of_ascii v0) < BinNatDef.N.to_nat 256) ((BinNatDef.N.to_nat (N_of_ascii v0) ?= BinNatDef.N.to_nat 256) = @Lt) (RelationClasses.symmetry v1)) (Nat.compare_lt_iff (BinNatDef.N.to_nat (N_of_ascii v0)) (BinNatDef.N.to_nat 256)) (eq_ind (N_of_ascii v0 ?= 256)%N (fun v1 : @comparison => v1 = @Lt) ((fun v1 : (N_of_ascii v0 ?= 256)%N = @Lt <-> (N_of_ascii v0 < 256)%N => Morphisms.iff_flip_impl_subrelation ((N_of_ascii v0 ?= 256)%N = @Lt) (N_of_ascii v0 < 256)%N v1) (N.compare_lt_iff (N_of_ascii v0) 256) (N_ascii_bounded v0)) (BinNatDef.N.to_nat (N_of_ascii v0) ?= BinNatDef.N.to_nat 256) (N2Nat.inj_compare (N_of_ascii v0) 256)) : nat_of_ascii v0 < 256)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.ascii_of_byte_of_ascii	100	0.413032	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @ascii => match v0 as v1 in ascii return (match to_bits match v1 as v2 in ascii return (@byte) with | Ascii v2 v3 v4 v5 v6 v7 v8 v9 => (fun v2 v3 v4 v5 v6 v7 v8 v9 : @bool => of_bits (v2, (v3, (v4, (v5, (v6, (v7, (v8, v9)))))))) v2 v3 v4 v5 v6 v7 v8 v9 end as v2 in (_ * _)%type return (@ascii) with | (v2, v3) => (fun (v2 : @bool) (v3 : @bool * (@bool * (@bool * (@bool * (@bool * (@bool * @bool)))))) => match v3 as v4 in (_ * _)%type return (@ascii) with | (v4, v5) => (fun (v4 : @bool) (v5 : @bool * (@bool * (@bool * (@bool * (@bool * @bool))))) => match v5 as v6 in (_ * _)%type return (@ascii) with | (v6, v7) => (fun (v6 : @bool) (v7 : @bool * (@bool * (@bool * (@bool * @bool)))) => match v7 as v8 in (_ * _)%type return (@ascii) with | (v8, v9) => (fun (v8 : @bool) (v9 : @bool * (@bool * (@bool * @bool))) => match v9 as v10 in (_ * _)%type return (@ascii) with | (v10, v11) => (fun (v10 : @bool) (v11 : @bool * (@bool * @bool)) => match v11 as v12 in (_ * _)%type return (@ascii) with | (v12, v13) => (fun (v12 : @bool) (v13 : @bool * @bool) => match v13 as v14 in (_ * _)%type return (@ascii) with | (v14, v15) => (fun v14 v15 : @bool => Ascii v2 v4 v6 v8 v10 v12 v14 v15) v14 v15 end) v12 v13 end) v10 v11 end) v8 v9 end) v6 v7 end) v4 v5 end) v2 v3 end = v1) with | Ascii v1 v2 v3 v4 v5 v6 v7 v8 => (fun v1 v2 v3 v4 v5 v6 v7 v8 : @bool => eq_ind_r (fun v9 : @bool * (@bool * (@bool * (@bool * (@bool * (@bool * (@bool * @bool)))))) => match v9 as v10 in (_ * _)%type return (@ascii) with | (v10, v11) => (fun (v10 : @bool) (v11 : @bool * (@bool * (@bool * (@bool * (@bool * (@bool * @bool)))))) => match v11 as v12 in (_ * _)%type return (@ascii) with | (v12, v13) => (fun (v12 : @bool) (v13 : @bool * (@bool * (@bool * (@bool * (@bool * @bool))))) => match v13 as v14 in (_ * _)%type return (@ascii) with | (v14, v15) => (fun (v14 : @bool) (v15 : @bool * (@bool * (@bool * (@bool * @bool)))) => match v15 as v16 in (_ * _)%type return (@ascii) with | (v16, v17) => (fun (v16 : @bool) (v17 : @bool * (@bool * (@bool * @bool))) => match v17 as v18 in (_ * _)%type return (@ascii) with | (v18, v19) => (fun (v18 : @bool) (v19 : @bool * (@bool * @bool)) => match v19 as v20 in (_ * _)%type return (@ascii) with | (v20, v21) => (fun (v20 : @bool) (v21 : @bool * @bool) => match v21 as v22 in (_ * _)%type return (@ascii) with | (v22, v23) => (fun v22 v23 : @bool => Ascii v10 v12 v14 v16 v18 v20 v22 v23) v22 v23 end) v20 v21 end) v18 v19 end) v16 v17 end) v14 v15 end) v12 v13 end) v10 v11 end = Ascii v1 v2 v3 v4 v5 v6 v7 v8) eq_refl (to_bits_of_bits (v1, (v2, (v3, (v4, (v5, (v6, (v7, v8))))))))) v1 v2 v3 v4 v5 v6 v7 v8 end : ascii_of_byte (byte_of_ascii v0) = v0)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.byte_of_ascii_of_byte	100	4.367914	2	2
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.ascii_of_byte_via_N	100	1.493527	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @byte => match v0 as v1 in byte return (ascii_of_byte v1 = ascii_of_N (to_N v1)) with | "000"%byte => eq_refl | "001"%byte => eq_refl | "002"%byte => eq_refl | "003"%byte => eq_refl | "004"%byte => eq_refl | "005"%byte => eq_refl | "006"%byte => eq_refl | "007"%byte => eq_refl | "008"%byte => eq_refl | "009"%byte => eq_refl | "010"%byte => eq_refl | "011"%byte => eq_refl | "012"%byte => eq_refl | "013"%byte => eq_refl | "014"%byte => eq_refl | "015"%byte => eq_refl | "016"%byte => eq_refl | "017"%byte => eq_refl | "018"%byte => eq_refl | "019"%byte => eq_refl | "020"%byte => eq_refl | "021"%byte => eq_refl | "022"%byte => eq_refl | "023"%byte => eq_refl | "024"%byte => eq_refl | "025"%byte => eq_refl | "026"%byte => eq_refl | "027"%byte => eq_refl | "028"%byte => eq_refl | "029"%byte => eq_refl | "030"%byte => eq_refl | "031"%byte => eq_refl | " "%byte => eq_refl | "!"%byte => eq_refl | """"%byte => eq_refl | "#"%byte => eq_refl | "$"%byte => eq_refl | "%"%byte => eq_refl | "&"%byte => eq_refl | "'"%byte => eq_refl | "("%byte => eq_refl | ")"%byte => eq_refl | "*"%byte => eq_refl | "+"%byte => eq_refl | ","%byte => eq_refl | "-"%byte => eq_refl | "."%byte => eq_refl | "/"%byte => eq_refl | "0"%byte => eq_refl | "1"%byte => eq_refl | "2"%byte => eq_refl | "3"%byte => eq_refl | "4"%byte => eq_refl | "5"%byte => eq_refl | "6"%byte => eq_refl | "7"%byte => eq_refl | "8"%byte => eq_refl | "9"%byte => eq_refl | ":"%byte => eq_refl | ";"%byte => eq_refl | "<"%byte => eq_refl | "="%byte => eq_refl | ">"%byte => eq_refl | "?"%byte => eq_refl | "@"%byte => eq_refl | "A"%byte => eq_refl | "B"%byte => eq_refl | "C"%byte => eq_refl | "D"%byte => eq_refl | "E"%byte => eq_refl | "F"%byte => eq_refl | "G"%byte => eq_refl | "H"%byte => eq_refl | "I"%byte => eq_refl | "J"%byte => eq_refl | "K"%byte => eq_refl | "L"%byte => eq_refl | "M"%byte => eq_refl | "N"%byte => eq_refl | "O"%byte => eq_refl | "P"%byte => eq_refl | "Q"%byte => eq_refl | "R"%byte => eq_refl | "S"%byte => eq_refl | "T"%byte => eq_refl | "U"%byte => eq_refl | "V"%byte => eq_refl | "W"%byte => eq_refl | "X"%byte => eq_refl | "Y"%byte => eq_refl | "Z"%byte => eq_refl | "["%byte => eq_refl | "\"%byte => eq_refl | "]"%byte => eq_refl | "^"%byte => eq_refl | "_"%byte => eq_refl | "`"%byte => eq_refl | "a"%byte => eq_refl | "b"%byte => eq_refl | "c"%byte => eq_refl | "d"%byte => eq_refl | "e"%byte => eq_refl | "f"%byte => eq_refl | "g"%byte => eq_refl | "h"%byte => eq_refl | "i"%byte => eq_refl | "j"%byte => eq_refl | "k"%byte => eq_refl | "l"%byte => eq_refl | "m"%byte => eq_refl | "n"%byte => eq_refl | "o"%byte => eq_refl | "p"%byte => eq_refl | "q"%byte => eq_refl | "r"%byte => eq_refl | "s"%byte => eq_refl | "t"%byte => eq_refl | "u"%byte => eq_refl | "v"%byte => eq_refl | "w"%byte => eq_refl | "x"%byte => eq_refl | "y"%byte => eq_refl | "z"%byte => eq_refl | "{"%byte => eq_refl | "|"%byte => eq_refl | "}"%byte => eq_refl | "~"%byte => eq_refl | "127"%byte => eq_refl | "128"%byte => eq_refl | "129"%byte => eq_refl | "130"%byte => eq_refl | "131"%byte => eq_refl | "132"%byte => eq_refl | "133"%byte => eq_refl | "134"%byte => eq_refl | "135"%byte => eq_refl | "136"%byte => eq_refl | "137"%byte => eq_refl | "138"%byte => eq_refl | "139"%byte => eq_refl | "140"%byte => eq_refl | "141"%byte => eq_refl | "142"%byte => eq_refl | "143"%byte => eq_refl | "144"%byte => eq_refl | "145"%byte => eq_refl | "146"%byte => eq_refl | "147"%byte => eq_refl | "148"%byte => eq_refl | "149"%byte => eq_refl | "150"%byte => eq_refl | "151"%byte => eq_refl | "152"%byte => eq_refl | "153"%byte => eq_refl | "154"%byte => eq_refl | "155"%byte => eq_refl | "156"%byte => eq_refl | "157"%byte => eq_refl | "158"%byte => eq_refl | "159"%byte => eq_refl | "160"%byte => eq_refl | "161"%byte => eq_refl | "162"%byte => eq_refl | "163"%byte => eq_refl | "164"%byte => eq_refl | "165"%byte => eq_refl | "166"%byte => eq_refl | "167"%byte => eq_refl | "168"%byte => eq_refl | "169"%byte => eq_refl | "170"%byte => eq_refl | "171"%byte => eq_refl | "172"%byte => eq_refl | "173"%byte => eq_refl | "174"%byte => eq_refl | "175"%byte => eq_refl | "176"%byte => eq_refl | "177"%byte => eq_refl | "178"%byte => eq_refl | "179"%byte => eq_refl | "180"%byte => eq_refl | "181"%byte => eq_refl | "182"%byte => eq_refl | "183"%byte => eq_refl | "184"%byte => eq_refl | "185"%byte => eq_refl | "186"%byte => eq_refl | "187"%byte => eq_refl | "188"%byte => eq_refl | "189"%byte => eq_refl | "190"%byte => eq_refl | "191"%byte => eq_refl | "192"%byte => eq_refl | "193"%byte => eq_refl | "194"%byte => eq_refl | "195"%byte => eq_refl | "196"%byte => eq_refl | "197"%byte => eq_refl | "198"%byte => eq_refl | "199"%byte => eq_refl | "200"%byte => eq_refl | "201"%byte => eq_refl | "202"%byte => eq_refl | "203"%byte => eq_refl | "204"%byte => eq_refl | "205"%byte => eq_refl | "206"%byte => eq_refl | "207"%byte => eq_refl | "208"%byte => eq_refl | "209"%byte => eq_refl | "210"%byte => eq_refl | "211"%byte => eq_refl | "212"%byte => eq_refl | "213"%byte => eq_refl | "214"%byte => eq_refl | "215"%byte => eq_refl | "216"%byte => eq_refl | "217"%byte => eq_refl | "218"%byte => eq_refl | "219"%byte => eq_refl | "220"%byte => eq_refl | "221"%byte => eq_refl | "222"%byte => eq_refl | "223"%byte => eq_refl | "224"%byte => eq_refl | "225"%byte => eq_refl | "226"%byte => eq_refl | "227"%byte => eq_refl | "228"%byte => eq_refl | "229"%byte => eq_refl | "230"%byte => eq_refl | "231"%byte => eq_refl | "232"%byte => eq_refl | "233"%byte => eq_refl | "234"%byte => eq_refl | "235"%byte => eq_refl | "236"%byte => eq_refl | "237"%byte => eq_refl | "238"%byte => eq_refl | "239"%byte => eq_refl | "240"%byte => eq_refl | "241"%byte => eq_refl | "242"%byte => eq_refl | "243"%byte => eq_refl | "244"%byte => eq_refl | "245"%byte => eq_refl | "246"%byte => eq_refl | "247"%byte => eq_refl | "248"%byte => eq_refl | "249"%byte => eq_refl | "250"%byte => eq_refl | "251"%byte => eq_refl | "252"%byte => eq_refl | "253"%byte => eq_refl | "254"%byte => eq_refl | "255"%byte => eq_refl end)).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.ascii_of_byte_via_nat	100	1.322361	2	2
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.byte_of_ascii_via_N	100	2.067817	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @ascii => eq_ind (ascii_of_byte (byte_of_ascii v0)) (fun v1 : @ascii => Some (byte_of_ascii v1) = of_N (N_of_ascii v1)) (let v1 : @byte := byte_of_ascii v0 in match v1 as v2 in byte return (Some (byte_of_ascii (ascii_of_byte v2)) = of_N (N_of_ascii (ascii_of_byte v2))) with | "000"%byte => eq_refl | "001"%byte => eq_refl | "002"%byte => eq_refl | "003"%byte => eq_refl | "004"%byte => eq_refl | "005"%byte => eq_refl | "006"%byte => eq_refl | "007"%byte => eq_refl | "008"%byte => eq_refl | "009"%byte => eq_refl | "010"%byte => eq_refl | "011"%byte => eq_refl | "012"%byte => eq_refl | "013"%byte => eq_refl | "014"%byte => eq_refl | "015"%byte => eq_refl | "016"%byte => eq_refl | "017"%byte => eq_refl | "018"%byte => eq_refl | "019"%byte => eq_refl | "020"%byte => eq_refl | "021"%byte => eq_refl | "022"%byte => eq_refl | "023"%byte => eq_refl | "024"%byte => eq_refl | "025"%byte => eq_refl | "026"%byte => eq_refl | "027"%byte => eq_refl | "028"%byte => eq_refl | "029"%byte => eq_refl | "030"%byte => eq_refl | "031"%byte => eq_refl | " "%byte => eq_refl | "!"%byte => eq_refl | """"%byte => eq_refl | "#"%byte => eq_refl | "$"%byte => eq_refl | "%"%byte => eq_refl | "&"%byte => eq_refl | "'"%byte => eq_refl | "("%byte => eq_refl | ")"%byte => eq_refl | "*"%byte => eq_refl | "+"%byte => eq_refl | ","%byte => eq_refl | "-"%byte => eq_refl | "."%byte => eq_refl | "/"%byte => eq_refl | "0"%byte => eq_refl | "1"%byte => eq_refl | "2"%byte => eq_refl | "3"%byte => eq_refl | "4"%byte => eq_refl | "5"%byte => eq_refl | "6"%byte => eq_refl | "7"%byte => eq_refl | "8"%byte => eq_refl | "9"%byte => eq_refl | ":"%byte => eq_refl | ";"%byte => eq_refl | "<"%byte => eq_refl | "="%byte => eq_refl | ">"%byte => eq_refl | "?"%byte => eq_refl | "@"%byte => eq_refl | "A"%byte => eq_refl | "B"%byte => eq_refl | "C"%byte => eq_refl | "D"%byte => eq_refl | "E"%byte => eq_refl | "F"%byte => eq_refl | "G"%byte => eq_refl | "H"%byte => eq_refl | "I"%byte => eq_refl | "J"%byte => eq_refl | "K"%byte => eq_refl | "L"%byte => eq_refl | "M"%byte => eq_refl | "N"%byte => eq_refl | "O"%byte => eq_refl | "P"%byte => eq_refl | "Q"%byte => eq_refl | "R"%byte => eq_refl | "S"%byte => eq_refl | "T"%byte => eq_refl | "U"%byte => eq_refl | "V"%byte => eq_refl | "W"%byte => eq_refl | "X"%byte => eq_refl | "Y"%byte => eq_refl | "Z"%byte => eq_refl | "["%byte => eq_refl | "\"%byte => eq_refl | "]"%byte => eq_refl | "^"%byte => eq_refl | "_"%byte => eq_refl | "`"%byte => eq_refl | "a"%byte => eq_refl | "b"%byte => eq_refl | "c"%byte => eq_refl | "d"%byte => eq_refl | "e"%byte => eq_refl | "f"%byte => eq_refl | "g"%byte => eq_refl | "h"%byte => eq_refl | "i"%byte => eq_refl | "j"%byte => eq_refl | "k"%byte => eq_refl | "l"%byte => eq_refl | "m"%byte => eq_refl | "n"%byte => eq_refl | "o"%byte => eq_refl | "p"%byte => eq_refl | "q"%byte => eq_refl | "r"%byte => eq_refl | "s"%byte => eq_refl | "t"%byte => eq_refl | "u"%byte => eq_refl | "v"%byte => eq_refl | "w"%byte => eq_refl | "x"%byte => eq_refl | "y"%byte => eq_refl | "z"%byte => eq_refl | "{"%byte => eq_refl | "|"%byte => eq_refl | "}"%byte => eq_refl | "~"%byte => eq_refl | "127"%byte => eq_refl | "128"%byte => eq_refl | "129"%byte => eq_refl | "130"%byte => eq_refl | "131"%byte => eq_refl | "132"%byte => eq_refl | "133"%byte => eq_refl | "134"%byte => eq_refl | "135"%byte => eq_refl | "136"%byte => eq_refl | "137"%byte => eq_refl | "138"%byte => eq_refl | "139"%byte => eq_refl | "140"%byte => eq_refl | "141"%byte => eq_refl | "142"%byte => eq_refl | "143"%byte => eq_refl | "144"%byte => eq_refl | "145"%byte => eq_refl | "146"%byte => eq_refl | "147"%byte => eq_refl | "148"%byte => eq_refl | "149"%byte => eq_refl | "150"%byte => eq_refl | "151"%byte => eq_refl | "152"%byte => eq_refl | "153"%byte => eq_refl | "154"%byte => eq_refl | "155"%byte => eq_refl | "156"%byte => eq_refl | "157"%byte => eq_refl | "158"%byte => eq_refl | "159"%byte => eq_refl | "160"%byte => eq_refl | "161"%byte => eq_refl | "162"%byte => eq_refl | "163"%byte => eq_refl | "164"%byte => eq_refl | "165"%byte => eq_refl | "166"%byte => eq_refl | "167"%byte => eq_refl | "168"%byte => eq_refl | "169"%byte => eq_refl | "170"%byte => eq_refl | "171"%byte => eq_refl | "172"%byte => eq_refl | "173"%byte => eq_refl | "174"%byte => eq_refl | "175"%byte => eq_refl | "176"%byte => eq_refl | "177"%byte => eq_refl | "178"%byte => eq_refl | "179"%byte => eq_refl | "180"%byte => eq_refl | "181"%byte => eq_refl | "182"%byte => eq_refl | "183"%byte => eq_refl | "184"%byte => eq_refl | "185"%byte => eq_refl | "186"%byte => eq_refl | "187"%byte => eq_refl | "188"%byte => eq_refl | "189"%byte => eq_refl | "190"%byte => eq_refl | "191"%byte => eq_refl | "192"%byte => eq_refl | "193"%byte => eq_refl | "194"%byte => eq_refl | "195"%byte => eq_refl | "196"%byte => eq_refl | "197"%byte => eq_refl | "198"%byte => eq_refl | "199"%byte => eq_refl | "200"%byte => eq_refl | "201"%byte => eq_refl | "202"%byte => eq_refl | "203"%byte => eq_refl | "204"%byte => eq_refl | "205"%byte => eq_refl | "206"%byte => eq_refl | "207"%byte => eq_refl | "208"%byte => eq_refl | "209"%byte => eq_refl | "210"%byte => eq_refl | "211"%byte => eq_refl | "212"%byte => eq_refl | "213"%byte => eq_refl | "214"%byte => eq_refl | "215"%byte => eq_refl | "216"%byte => eq_refl | "217"%byte => eq_refl | "218"%byte => eq_refl | "219"%byte => eq_refl | "220"%byte => eq_refl | "221"%byte => eq_refl | "222"%byte => eq_refl | "223"%byte => eq_refl | "224"%byte => eq_refl | "225"%byte => eq_refl | "226"%byte => eq_refl | "227"%byte => eq_refl | "228"%byte => eq_refl | "229"%byte => eq_refl | "230"%byte => eq_refl | "231"%byte => eq_refl | "232"%byte => eq_refl | "233"%byte => eq_refl | "234"%byte => eq_refl | "235"%byte => eq_refl | "236"%byte => eq_refl | "237"%byte => eq_refl | "238"%byte => eq_refl | "239"%byte => eq_refl | "240"%byte => eq_refl | "241"%byte => eq_refl | "242"%byte => eq_refl | "243"%byte => eq_refl | "244"%byte => eq_refl | "245"%byte => eq_refl | "246"%byte => eq_refl | "247"%byte => eq_refl | "248"%byte => eq_refl | "249"%byte => eq_refl | "250"%byte => eq_refl | "251"%byte => eq_refl | "252"%byte => eq_refl | "253"%byte => eq_refl | "254"%byte => eq_refl | "255"%byte => eq_refl end) v0 (ascii_of_byte_of_ascii v0))).
coq-tactician-stdlib.8.11.dev	Coq.Strings.Ascii.byte_of_ascii_via_nat	100	2.200976	2	2
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_0_r	100	0.077440	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (v1  0 = 0) with | 0 => eq_refl | Z.pos v1 | Z.neg v1 => (fun v1 : @positive => eq_refl) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_0_r	100	0.075296	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (BinIntDef.Z.rem v1 0 = v1) with | 0 => eq_refl | Z.pos v1 => (fun v1 : @positive => eq_refl) v1 | Z.neg v1 => (fun v1 : @positive => eq_refl) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_0_l	100	0.075983	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (BinIntDef.Z.rem 0 v1 = 0) with | 0 => eq_refl | Z.pos v1 | Z.neg v1 => (fun v1 : @positive => eq_refl) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_0_l	100	0.068108	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (0  v1 = 0) with | 0 => eq_refl | Z.pos v1 | Z.neg v1 => (fun v1 : @positive => eq_refl) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_rem_same	100	0.076171	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @Z => let v1 : v0 = 0 \/ v0 <> 0 := Z.eq_decidable v0 0 in match v1 as v2 in (_ \/ _) return (BinIntDef.Z.rem v0 v0 = 0) with | or_introl v2 => (fun v2 : v0 = 0 => eq_ind_r (fun v3 : @Z => BinIntDef.Z.rem v3 v3 = 0) (eq_ind_r (fun v3 : @Z => v3 = 0) (let v3 : 0 = 0 := let v3 : list (@ZMicromega.ZArithProof) := nil in let v4 : VarMap.t (@Z) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v5 v3 (eq_refl : ZMicromega.ZTautoChecker v5 v3 = @true) (VarMap.find 0 v4) in v3) (Zrem_0_l 0)) v2) v2 | or_intror v2 => (fun v2 : v0 <> 0 => Z.rem_same v0 v2) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_rem_mult	100	0.091193	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (BinIntDef.Z.rem (v0 * v1) v1 = 0) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => BinIntDef.Z.rem (v0 * v4) v4 = 0) (eq_ind_r (fun v4 : @Z => v4 = 0) (let v4 : forall v4 : @Z, v4 * 0 = 0 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc 0); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0) (Zrem_0_r (v0 * 0))) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.rem_mul v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_opp_l	100	0.097475	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (- v0  v1 = - (v0  v1)) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => - v0  v4 = - (v0  v4)) (eq_ind_r (fun v4 : @Z => v4 = - (v0  0)) (eq_ind_r (fun v4 : @Z => 0 = - v4) (let v4 : 0 = - 0 := let v4 : list (@ZMicromega.ZArithProof) := nil in let v5 : VarMap.t (@Z) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEc 0) |} (@tt) in ZMicromega.ZTautoChecker_sound v6 v4 (eq_refl : ZMicromega.ZTautoChecker v6 v4 = @true) (VarMap.find 0 v5) in v4) (Zquot_0_r v0)) (Zquot_0_r (- v0))) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.quot_opp_l v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_opp_r	100	0.094297	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (v0  - v1 = - (v0  v1)) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => v0  - v4 = - (v0  v4)) (eq_ind_r (fun v4 : @Z => v4 = - (v0  0)) (eq_ind_r (fun v4 : @Z => 0 = - v4) (let v4 : 0 = - 0 := let v4 : list (@ZMicromega.ZArithProof) := nil in let v5 : VarMap.t (@Z) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEc 0) |} (@tt) in ZMicromega.ZTautoChecker_sound v6 v4 (eq_refl : ZMicromega.ZTautoChecker v6 v4 = @true) (VarMap.find 0 v5) in v4) (Zquot_0_r v0)) (Zquot_0_r v0)) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.quot_opp_r v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_opp_l	100	0.095343	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (BinIntDef.Z.rem (- v0) v1 = - BinIntDef.Z.rem v0 v1) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => BinIntDef.Z.rem (- v0) v4 = - BinIntDef.Z.rem v0 v4) (eq_ind_r (fun v4 : @Z => v4 = - BinIntDef.Z.rem v0 0) (eq_ind_r (fun v4 : @Z => - v0 = - v4) (let v4 : forall v4 : @Z, - v4 = - v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEX 1); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 1) |} (@tt) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0) (Zrem_0_r v0)) (Zrem_0_r (- v0))) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.rem_opp_l v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_opp_r	100	0.101368	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (BinIntDef.Z.rem v0 (- v1) = BinIntDef.Z.rem v0 v1) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => BinIntDef.Z.rem v0 (- v4) = BinIntDef.Z.rem v0 v4) (eq_ind_r (fun v4 : @Z => v4 = BinIntDef.Z.rem v0 0) (eq_ind_r (fun v4 : @Z => v0 = v4) (let v4 : forall v4 : @Z, v4 = v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0) (Zrem_0_r v0)) (Zrem_0_r v0)) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.rem_opp_r v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_opp_opp	100	0.112655	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (- v0  - v1 = v0  v1) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => - v0  - v4 = v0  v4) (eq_ind_r (fun v4 : @Z => v4 = v0  0) (eq_ind_r (fun v4 : @Z => 0 = v4) (let v4 : 0 = 0 := let v4 : list (@ZMicromega.ZArithProof) := nil in let v5 : VarMap.t (@Z) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v6 v4 (eq_refl : ZMicromega.ZTautoChecker v6 v4 = @true) (VarMap.find 0 v5) in v4) (Zquot_0_r v0)) (Zquot_0_r (- v0))) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.quot_opp_opp v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_opp_opp	100	0.117385	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (BinIntDef.Z.rem (- v0) (- v1) = - BinIntDef.Z.rem v0 v1) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => BinIntDef.Z.rem (- v0) (- v4) = - BinIntDef.Z.rem v0 v4) (eq_ind_r (fun v4 : @Z => v4 = - BinIntDef.Z.rem v0 0) (eq_ind_r (fun v4 : @Z => - v0 = - v4) (let v4 : forall v4 : @Z, - v4 = - v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEX 1); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 1) |} (@tt) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0) (Zrem_0_r v0)) (Zrem_0_r (- v0))) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.rem_opp_opp v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_sgn	100	0.309661	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (0 <= BinIntDef.Z.sgn (BinIntDef.Z.rem v0 v1) * BinIntDef.Z.sgn v0) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => 0 <= BinIntDef.Z.sgn (BinIntDef.Z.rem v0 v4) * BinIntDef.Z.sgn v0) (eq_ind_r (fun v4 : @Z => 0 <= BinIntDef.Z.sgn v4 * BinIntDef.Z.sgn v0) (let v4 : 0 < v0 /\ BinIntDef.Z.sgn v0 = 1 \/ 0 = v0 /\ BinIntDef.Z.sgn v0 = 0 \/ v0 < 0 /\ BinIntDef.Z.sgn v0 = - (1) := Z.sgn_spec v0 in let v5 : @Z := BinIntDef.Z.sgn v0 in let v6 : forall (v6 v7 v8 : Prop) (v9 : @Z) (v10 : v8 /\ v9 = 1 \/ v7 /\ v9 = 0 \/ v6 /\ v9 = - (1)), 0 <= v9 * v9 := fun (v6 v7 v8 : Prop) (v9 : @Z) => let v10 : list (@ZMicromega.ZArithProof) := (ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.PX (EnvRing.Pc (-1)) 1 (EnvRing.Pc 0)) (RingMicromega.PsatzIn (@Z) 1)) (RingMicromega.PsatzIn (@Z) 0)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.PX (EnvRing.Pc (-1)) 1 (EnvRing.Pc 1)) (RingMicromega.PsatzIn (@Z) 1)) (RingMicromega.PsatzIn (@Z) 0)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.PX (EnvRing.Pc (-1)) 1 (EnvRing.Pc (-1))) (RingMicromega.PsatzIn (@Z) 1)) (RingMicromega.PsatzIn (@Z) 0)) (@ZMicromega.DoneProof) :: nil)%list in let v11 : VarMap.t (@Z) := VarMap.Elt v9 in let v12 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.D (Tauto.Cj (Tauto.X v8) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 1 |} (@tt))) (Tauto.D (Tauto.Cj (Tauto.X v7) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) (Tauto.Cj (Tauto.X v6) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEc 1) |} (@tt))))) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 1) |} (@tt)) in ZMicromega.ZTautoChecker_sound v12 v10 (eq_refl : ZMicromega.ZTautoChecker v12 v10 = @true) (VarMap.find 0 v11) in v6 (v0 < 0) (0 = v0) (0 < v0) v5 v4) (Zrem_0_r v0)) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => let v4 : BinIntDef.Z.rem v0 v1 = 0 \/ BinIntDef.Z.rem v0 v1 <> 0 := Z.eq_decidable (BinIntDef.Z.rem v0 v1) 0 in match v4 as v5 in (_ \/ _) return (0 <= BinIntDef.Z.sgn (BinIntDef.Z.rem v0 v1) * BinIntDef.Z.sgn v0) with | or_introl v5 => (fun v5 : BinIntDef.Z.rem v0 v1 = 0 => eq_ind_r (fun v6 : @Z => 0 <= BinIntDef.Z.sgn v6 * BinIntDef.Z.sgn v0) (let v6 : 0 < v0 /\ BinIntDef.Z.sgn v0 = 1 \/ 0 = v0 /\ BinIntDef.Z.sgn v0 = 0 \/ v0 < 0 /\ BinIntDef.Z.sgn v0 = - (1) := Z.sgn_spec v0 in let v7 : @Z := BinIntDef.Z.sgn v0 in let v8 : forall v8 : @Z, 0 <= 0 * v8 := fun v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Elt v8 in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEX 1) |} (@tt) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v8 v7) v5) v5 | or_intror v5 => (fun v5 : BinIntDef.Z.rem v0 v1 <> 0 => eq_ind_r (fun v6 : @Z => 0 <= v6 * BinIntDef.Z.sgn v0) (Z.square_nonneg (BinIntDef.Z.sgn v0)) (Z.rem_sign_nz v0 v1 v3 v5)) v5 end) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_sgn2	100	0.110147	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (0 <= BinIntDef.Z.rem v0 v1 * v0) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => 0 <= BinIntDef.Z.rem v0 v4 * v0) (eq_ind_r (fun v4 : @Z => 0 <= v4 * v0) (Z.square_nonneg v0) (Zrem_0_r v0)) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.rem_sign_mul v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_lt_pos	100	0.780786	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : v1 <> 0) => (fun (v4 : forall (v4 : v1 <> 0) (v5 : 0 <= v0), 0 <= BinIntDef.Z.rem v0 v1) (v5 : forall v5 : v1 <> 0, BinIntDef.Z.abs (BinIntDef.Z.rem v0 v1) < BinIntDef.Z.abs v1) => let v6 : @Z := BinIntDef.Z.rem v0 v1 in let v7 : v6 = BinIntDef.Z.rem v0 v1 := eq_refl in let v8 : 0 <= v6 /\ BinIntDef.Z.abs v6 = v6 \/ v6 < 0 /\ BinIntDef.Z.abs v6 = - v6 := Z.abs_spec v6 in let v9 : @Z := BinIntDef.Z.abs v6 in let v10 : 0 <= v1 /\ BinIntDef.Z.abs v1 = v1 \/ v1 < 0 /\ BinIntDef.Z.abs v1 = - v1 := Z.abs_spec v1 in let v11 : @Z := BinIntDef.Z.abs v1 in let v12 : forall (v12 v13 v14 v15 v16 : @Z) (v17 : 0 <= v13 /\ v15 = v13 \/ v13 < 0 /\ v15 = - v13) (v18 : 0 <= v16 /\ v12 = v16 \/ v16 < 0 /\ v12 = - v16) (v19 : forall v19 : forall v19 : v13 = 0, @False, v12 < v15) (v20 : forall (v20 : forall v20 : v13 = 0, @False) (v21 : 0 <= v14), 0 <= v16) (v21 : forall v21 : v13 = 0, @False) (v22 : 0 <= v14), 0 <= v16 < v15 := fun v12 v13 v14 v15 v16 : @Z => let v17 : list (@ZMicromega.ZArithProof) := (ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)) (RingMicromega.PsatzIn (@Z) 0)) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 7) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 4) (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3))))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 4)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 7)) (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)) (RingMicromega.PsatzIn (@Z) 0))) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 7) (RingMicromega.PsatzIn (@Z) 4))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 7)) (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)) (RingMicromega.PsatzIn (@Z) 0))) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 7) (RingMicromega.PsatzIn (@Z) 4))) (@ZMicromega.DoneProof) :: nil)%list in let v18 : VarMap.t (@Z) := VarMap.Branch (VarMap.Branch (VarMap.Elt v13) v15 (VarMap.Elt v12)) v16 (VarMap.Elt v14) in let v19 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.D (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 4 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 4 |} (@tt))) (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 4) |} (@tt)))) None (Tauto.I (Tauto.D (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 6; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 6; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 1) |} (@tt)))) None (Tauto.I (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 6; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt))) None (Tauto.I (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 3 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)))) None (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 3 |} (@tt)) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)))))))) in ZMicromega.ZTautoChecker_sound v19 v17 (eq_refl : ZMicromega.ZTautoChecker v19 v17 = @true) (VarMap.find 0 v18) in v12 v9 v1 v0 v11 v6 v10 v8 v5 v4 v3 v2) (Z.rem_nonneg v0 v1) (Z.rem_bound_abs v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_lt_neg	100	1.176378	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : v0 <= 0) (v3 : v1 <> 0) => (fun (v4 : forall (v4 : v1 <> 0) (v5 : v0 <= 0), BinIntDef.Z.rem v0 v1 <= 0) (v5 : forall v5 : v1 <> 0, BinIntDef.Z.abs (BinIntDef.Z.rem v0 v1) < BinIntDef.Z.abs v1) => let v6 : @Z := BinIntDef.Z.rem v0 v1 in let v7 : v6 = BinIntDef.Z.rem v0 v1 := eq_refl in let v8 : 0 <= v6 /\ BinIntDef.Z.abs v6 = v6 \/ v6 < 0 /\ BinIntDef.Z.abs v6 = - v6 := Z.abs_spec v6 in let v9 : @Z := BinIntDef.Z.abs v6 in let v10 : 0 <= v1 /\ BinIntDef.Z.abs v1 = v1 \/ v1 < 0 /\ BinIntDef.Z.abs v1 = - v1 := Z.abs_spec v1 in let v11 : @Z := BinIntDef.Z.abs v1 in let v12 : forall (v12 v13 v14 v15 v16 : @Z) (v17 : 0 <= v13 /\ v16 = v13 \/ v13 < 0 /\ v16 = - v13) (v18 : 0 <= v15 /\ v12 = v15 \/ v15 < 0 /\ v12 = - v15) (v19 : forall v19 : forall v19 : v13 = 0, @False, v12 < v16) (v20 : forall (v20 : forall v20 : v13 = 0, @False) (v21 : v14 <= 0), v15 <= 0) (v21 : forall v21 : v13 = 0, @False) (v22 : v14 <= 0), - v16 < v15 <= 0 := fun v12 v13 v14 v15 v16 : @Z => let v17 : list (@ZMicromega.ZArithProof) := (ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 7)) (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)) (RingMicromega.PsatzIn (@Z) 0))) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 7) (RingMicromega.PsatzIn (@Z) 4))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 7)) (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)) (RingMicromega.PsatzIn (@Z) 0))) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 7) (RingMicromega.PsatzIn (@Z) 4))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 4)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 4)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3)) (RingMicromega.PsatzIn (@Z) 2)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 7)) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 5) (RingMicromega.PsatzIn (@Z) 0))) (RingMicromega.PsatzIn (@Z) 2)) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 6) (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 7)) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 5) (RingMicromega.PsatzIn (@Z) 0))) (RingMicromega.PsatzIn (@Z) 2)) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 6) (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 7)) (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 5)) (RingMicromega.PsatzIn (@Z) 0))) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 7) (RingMicromega.PsatzIn (@Z) 4))) (@ZMicromega.DoneProof) :: nil)%list in let v18 : VarMap.t (@Z) := VarMap.Branch (VarMap.Branch (VarMap.Elt v13) v15 (VarMap.Elt v12)) v16 (VarMap.Elt v14) in let v19 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.D (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 4 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 4 |} (@tt))) (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 4) |} (@tt)))) None (Tauto.I (Tauto.D (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 6; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt))) (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 6; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 2) |} (@tt)))) None (Tauto.I (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 6; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) None (Tauto.I (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 3; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)))) None (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 3; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEX 1); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)))))))) in ZMicromega.ZTautoChecker_sound v19 v17 (eq_refl : ZMicromega.ZTautoChecker v19 v17 = @true) (VarMap.find 0 v18) in v12 v9 v1 v0 v6 v11 v10 v8 v5 v4 v3 v2) (Z.rem_nonpos v0 v1) (Z.rem_bound_abs v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_lt_pos_pos	100	0.306680	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : 0 < v1) => (fun v4 : forall (v4 : 0 <= v0) (v5 : v1 <> 0), 0 <= BinIntDef.Z.rem v0 v1 < BinIntDef.Z.abs v1 => let v5 : 0 <= v1 /\ BinIntDef.Z.abs v1 = v1 \/ v1 < 0 /\ BinIntDef.Z.abs v1 = - v1 := Z.abs_spec v1 in let v6 : @Z := BinIntDef.Z.abs v1 in let v7 : forall (v7 v8 : Prop) (v9 v10 v11 v12 : @Z) (v13 : v8 /\ v9 = v11 \/ v11 < 0 /\ v7) (v14 : forall (v14 : 0 <= v10) (v15 : forall v15 : v11 = 0, @False), 0 <= v12 < v9) (v15 : 0 < v11) (v16 : 0 <= v10), 0 <= v12 < v11 := fun (v7 v8 : Prop) (v9 v10 v11 v12 : @Z) => let v13 : list (@ZMicromega.ZArithProof) := (ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 5) (RingMicromega.PsatzIn (@Z) 0)) (RingMicromega.PsatzIn (@Z) 3)) (@ZMicromega.DoneProof) :: nil)%list in let v14 : VarMap.t (@Z) := VarMap.Branch (VarMap.Branch (VarMap.Elt v9) v11 VarMap.Empty) v12 (VarMap.Elt v10) in let v15 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.D (Tauto.Cj (Tauto.X v8) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt))) (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) (Tauto.X v7))) None (Tauto.I (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 3 |} (@tt)) None (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 4 |} (@tt))))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 3 |} (@tt)) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)))))) in ZMicromega.ZTautoChecker_sound v15 v13 (eq_refl : ZMicromega.ZTautoChecker v15 v13 = @true) (VarMap.find 0 v14) in v7 (v6 = - v1) (0 <= v1) v6 v0 v1 (BinIntDef.Z.rem v0 v1) v5 v4 v3 v2) (Zrem_lt_pos v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_lt_pos_neg	100	0.281838	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : v1 < 0) => (fun v4 : forall (v4 : 0 <= v0) (v5 : v1 <> 0), 0 <= BinIntDef.Z.rem v0 v1 < BinIntDef.Z.abs v1 => let v5 : 0 <= v1 /\ BinIntDef.Z.abs v1 = v1 \/ v1 < 0 /\ BinIntDef.Z.abs v1 = - v1 := Z.abs_spec v1 in let v6 : @Z := BinIntDef.Z.abs v1 in let v7 : forall (v7 : Prop) (v8 v9 v10 v11 : @Z) (v12 : 0 <= v10 /\ v7 \/ v10 < 0 /\ v8 = - v10) (v13 : forall (v13 : 0 <= v9) (v14 : forall v14 : v10 = 0, @False), 0 <= v11 < v8) (v14 : v10 < 0) (v15 : 0 <= v9), 0 <= v11 < - v10 := fun (v7 : Prop) (v8 v9 v10 v11 : @Z) => let v12 : list (@ZMicromega.ZArithProof) := (ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 2) (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 2) (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 3))) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 5) (RingMicromega.PsatzIn (@Z) 0)) (RingMicromega.PsatzIn (@Z) 3)) (@ZMicromega.DoneProof) :: nil)%list in let v13 : VarMap.t (@Z) := VarMap.Branch (VarMap.Branch (VarMap.Elt v8) v10 VarMap.Empty) v11 (VarMap.Elt v9) in let v14 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.D (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) (Tauto.X v7)) (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 2) |} (@tt)))) None (Tauto.I (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 3 |} (@tt)) None (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 4 |} (@tt))))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 3 |} (@tt)) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEopp (EnvRing.PEX 2) |} (@tt)))))) in ZMicromega.ZTautoChecker_sound v14 v12 (eq_refl : ZMicromega.ZTautoChecker v14 v12 = @true) (VarMap.find 0 v13) in v7 (v6 = v1) v6 v0 v1 (BinIntDef.Z.rem v0 v1) v5 v4 v3 v2) (Zrem_lt_pos v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_lt_neg_pos	100	0.299294	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : v0 <= 0) (v3 : 0 < v1) => (fun v4 : forall (v4 : v0 <= 0) (v5 : v1 <> 0), - BinIntDef.Z.abs v1 < BinIntDef.Z.rem v0 v1 <= 0 => let v5 : 0 <= v1 /\ BinIntDef.Z.abs v1 = v1 \/ v1 < 0 /\ BinIntDef.Z.abs v1 = - v1 := Z.abs_spec v1 in let v6 : @Z := BinIntDef.Z.abs v1 in let v7 : forall (v7 v8 : Prop) (v9 v10 v11 v12 : @Z) (v13 : v8 /\ v9 = v12 \/ v12 < 0 /\ v7) (v14 : forall (v14 : v10 <= 0) (v15 : forall v15 : v12 = 0, @False), - v9 < v11 <= 0) (v15 : 0 < v12) (v16 : v10 <= 0), - v12 < v11 <= 0 := fun (v7 v8 : Prop) (v9 v10 v11 v12 : @Z) => let v13 : list (@ZMicromega.ZArithProof) := (ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@Z) 5) (RingMicromega.PsatzIn (@Z) 0)) (RingMicromega.PsatzIn (@Z) 4)) (@ZMicromega.DoneProof) :: nil)%list in let v14 : VarMap.t (@Z) := VarMap.Branch (VarMap.Branch (VarMap.Elt v9) v11 VarMap.Empty) v12 (VarMap.Elt v10) in let v15 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.D (Tauto.Cj (Tauto.X v8) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 4; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) (Tauto.X v7))) None (Tauto.I (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 3; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) None (Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEX 4); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 3; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEX 1); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 2; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)))))) in ZMicromega.ZTautoChecker_sound v15 v13 (eq_refl : ZMicromega.ZTautoChecker v15 v13 = @true) (VarMap.find 0 v14) in v7 (v6 = - v1) (0 <= v1) v6 v0 (BinIntDef.Z.rem v0 v1) v1 v5 v4 v3 v2) (Zrem_lt_neg v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_lt_neg_neg	100	0.573480	2	2
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Remainder_equiv	100	6.435642	1	1
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_mod_unique_full	100	1.943972	2	2
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_unique_full	100	0.119483	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : Remainder v0 v1 v3) (v5 : v0 = v1 * v2 + v3) => let v6 : v2 = v0  v1 /\ v3 = BinIntDef.Z.rem v0 v1 := Zquot_mod_unique_full v0 v1 v2 v3 v4 v5 in match v6 as v7 in (_ /\ _) return (v2 = v0  v1) with | conj v7 v8 => (fun (v7 : v2 = v0  v1) (v8 : v3 = BinIntDef.Z.rem v0 v1) => v7) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_unique_full	100	0.107500	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 v3 : @Z) (v4 : Remainder v0 v1 v3) (v5 : v0 = v1 * v2 + v3) => let v6 : v2 = v0  v1 /\ v3 = BinIntDef.Z.rem v0 v1 := Zquot_mod_unique_full v0 v1 v2 v3 v4 v5 in match v6 as v7 in (_ /\ _) return (v3 = BinIntDef.Z.rem v0 v1) with | conj v7 v8 => (fun (v7 : v2 = v0  v1) (v8 : v3 = BinIntDef.Z.rem v0 v1) => v8) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_quot_pos	100	0.213834	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : 0 <= v1) => let v4 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v4 as v5 in (_ \/ _) return (0 <= v0  v1) with | or_introl v5 => (fun v5 : v1 = 0 => eq_ind_r (fun v6 : @Z => forall v7 : 0 <= v6, 0 <= v0  v6) (fun v6 : 0 <= 0 => eq_ind_r (fun v7 : @Z => 0 <= v7) (let v7 : 0 <= 0 := let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Empty in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v7) (Zquot_0_r v0)) v5 v3) v5 | or_intror v5 => (fun v5 : v1 <> 0 => Z.quot_pos v0 v1 (let v6 : forall (v6 : @Z) (v7 : 0 <= v6), 0 <= v6 := fun v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Elt v6 in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v6 v0 v2) (let v6 : forall (v6 : @Z) (v7 : forall v7 : v6 = 0, @False) (v8 : 0 <= v6), 0 < v6 := fun v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Elt v6 in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v6 v1 v5 v3)) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_quot_lt	100	0.132758	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 < v0) (v3 : 2 <= v1) => Z.quot_lt v0 v1 (let v4 : forall (v4 : @Z) (v5 : 0 < v4), 0 < v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0 v2) (let v4 : forall (v4 : @Z) (v5 : 2 <= v4), 1 < v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 2; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 1; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v1 v3))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_quot_monotone	100	0.274229	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= v2) (v4 : v0 <= v1) => let v5 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v5 as v6 in (_ \/ _) return (v0  v2 <= v1  v2) with | or_introl v6 => (fun v6 : v2 = 0 => eq_ind_r (fun v7 : @Z => forall v8 : 0 <= v7, v0  v7 <= v1  v7) (fun v7 : 0 <= 0 => eq_ind_r (fun v8 : @Z => v8 <= v1  0) (eq_ind_r (fun v8 : @Z => 0 <= v8) (let v8 : 0 <= 0 := let v8 : list (@ZMicromega.ZArithProof) := nil in let v9 : VarMap.t (@Z) := VarMap.Empty in let v10 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v10 v8 (eq_refl : ZMicromega.ZTautoChecker v10 v8 = @true) (VarMap.find 0 v9) in v8) (Zquot_0_r v1)) (Zquot_0_r v0)) v6 v3) v6 | or_intror v6 => (fun v6 : v2 <> 0 => Z.quot_le_mono v0 v1 v2 (let v7 : forall (v7 : @Z) (v8 : forall v8 : v7 = 0, @False) (v9 : 0 <= v7), 0 < v7 := fun v7 : @Z => let v8 : list (@ZMicromega.ZArithProof) := nil in let v9 : VarMap.t (@Z) := VarMap.Elt v7 in let v10 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) in ZMicromega.ZTautoChecker_sound v10 v8 (eq_refl : ZMicromega.ZTautoChecker v10 v8 = @true) (VarMap.find 0 v9) in v7 v2 v6 v3) (let v7 : forall (v7 v8 : @Z) (v9 : v8 <= v7), v8 <= v7 := fun v7 v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v7) v8 VarMap.Empty in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v7 v1 v0 v4)) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_mult_quot_le	100	0.145716	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) => let v3 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v3 as v4 in (_ \/ _) return (0 <= v1 * (v0  v1) <= v0) with | or_introl v4 => (fun v4 : v1 = 0 => eq_ind_r (fun v5 : @Z => 0 <= v5 * (v0  v5) <= v0) (eq_ind_r (fun v5 : @Z => 0 <= 0 * v5 <= v0) (let v5 : forall (v5 : @Z) (v6 : 0 <= v5), 0 <= 0 * 0 <= v5 := fun v5 : @Z => let v6 : list (@ZMicromega.ZArithProof) := nil in let v7 : VarMap.t (@Z) := VarMap.Elt v5 in let v8 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEc 0) |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEc 0); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) in ZMicromega.ZTautoChecker_sound v8 v6 (eq_refl : ZMicromega.ZTautoChecker v8 v6 = @true) (VarMap.find 0 v7) in v5 v0 v2) (Zquot_0_r v0)) v4) v4 | or_intror v4 => (fun v4 : v1 <> 0 => Z.mul_quot_le v0 v1 v2 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_mult_quot_ge	100	0.141538	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : v0 <= 0) => let v3 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v3 as v4 in (_ \/ _) return (v0 <= v1 * (v0  v1) <= 0) with | or_introl v4 => (fun v4 : v1 = 0 => eq_ind_r (fun v5 : @Z => v0 <= v5 * (v0  v5) <= 0) (eq_ind_r (fun v5 : @Z => v0 <= 0 * v5 <= 0) (let v5 : forall (v5 : @Z) (v6 : v5 <= 0), v5 <= 0 * 0 <= 0 := fun v5 : @Z => let v6 : list (@ZMicromega.ZArithProof) := nil in let v7 : VarMap.t (@Z) := VarMap.Elt v5 in let v8 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) None (Tauto.Cj (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEc 0) |} (@tt)) (Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEc 0); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) in ZMicromega.ZTautoChecker_sound v8 v6 (eq_refl : ZMicromega.ZTautoChecker v8 v6 = @true) (VarMap.find 0 v7) in v5 v0 v2) (Zquot_0_r v0)) v4) v4 | or_intror v4 => (fun v4 : v1 <> 0 => Z.mul_quot_ge v0 v1 v2 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_quot_exact_full	100	0.205093	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (v0 = v1 * (v0  v1) <-> BinIntDef.Z.rem v0 v1 = 0) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => v0 = v4 * (v0  v4) <-> BinIntDef.Z.rem v0 v4 = 0) (eq_ind_r (fun v4 : @Z => v0 = 0 * v4 <-> BinIntDef.Z.rem v0 0 = 0) (eq_ind_r (fun v4 : @Z => v0 = 0 * 0 <-> v4 = 0) (let v4 : forall v4 : @Z, (forall v5 : v4 = 0 * 0, v4 = 0) /\ (forall v5 : v4 = 0, v4 = 0 * 0) := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := (ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 1)) (RingMicromega.PsatzIn (@Z) 0)) (@ZMicromega.DoneProof) :: ZMicromega.RatProof (RingMicromega.PsatzAdd (RingMicromega.PsatzMulC (EnvRing.Pc (-1)) (RingMicromega.PsatzIn (@Z) 1)) (RingMicromega.PsatzIn (@Z) 0)) (@ZMicromega.DoneProof) :: nil)%list in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.Cj (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEc 0) |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEc 0) |} (@tt))) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0) (Zrem_0_r v0)) (Zquot_0_r v0)) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.quot_exact v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_le	100	0.241204	2	2	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : 0 <= v1) => let v4 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v4 as v5 in (_ \/ _) return (BinIntDef.Z.rem v0 v1 <= v0) with | or_introl v5 => (fun v5 : v1 = 0 => eq_ind_r (fun v6 : @Z => forall v7 : 0 <= v6, BinIntDef.Z.rem v0 v6 <= v0) (fun v6 : 0 <= 0 => eq_ind_r (fun v7 : @Z => v7 <= v0) (let v7 : forall v7 : @Z, v7 <= v7 := fun v7 : @Z => let v8 : list (@ZMicromega.ZArithProof) := nil in let v9 : VarMap.t (@Z) := VarMap.Elt v7 in let v10 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt) in ZMicromega.ZTautoChecker_sound v10 v8 (eq_refl : ZMicromega.ZTautoChecker v10 v8 = @true) (VarMap.find 0 v9) in v7 v0) (Zrem_0_r v0)) v5 v3) v5 | or_intror v5 => (fun v5 : v1 <> 0 => Z.rem_le v0 v1 (let v6 : forall (v6 : @Z) (v7 : 0 <= v6), 0 <= v6 := fun v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Elt v6 in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v6 v0 v2) (let v6 : forall (v6 : @Z) (v7 : forall v7 : v6 = 0, @False) (v8 : 0 <= v6), 0 < v6 := fun v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Elt v6 in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v6 v1 v5 v3)) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_le_upper_bound	100	0.068757	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => eq_ind_r (fun v3 : @Z => forall (v4 : 0 < v1) (v5 : v0 <= v3), v0  v1 <= v2) (Z.quot_le_upper_bound v0 v1 v2) (Z.mul_comm v2 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_lt_upper_bound	100	0.073345	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => eq_ind_r (fun v3 : @Z => forall (v4 : 0 <= v0) (v5 : 0 < v1) (v6 : v0 < v3), v0  v1 < v2) (Z.quot_lt_upper_bound v0 v1 v2) (Z.mul_comm v2 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_le_lower_bound	100	0.060863	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => eq_ind_r (fun v3 : @Z => forall (v4 : 0 < v1) (v5 : v3 <= v0), v2 <= v0  v1) (Z.quot_le_lower_bound v0 v1 v2) (Z.mul_comm v2 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_sgn	100	0.426278	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => match v0 as v1 in Z return (forall v2 : @Z, 0 <= BinIntDef.Z.sgn (v1  v2) * BinIntDef.Z.sgn v1 * BinIntDef.Z.sgn v2) with | 0 => fun v1 : @Z => match v1 as v2 in Z return (0 <= BinIntDef.Z.sgn (0  v2) * BinIntDef.Z.sgn 0 * BinIntDef.Z.sgn v2) with | 0 => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (0  0) * BinIntDef.Z.sgn 0 * BinIntDef.Z.sgn 0 | Z.pos v2 => (fun v2 : @positive => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (0  Z.pos v2) * BinIntDef.Z.sgn 0 * BinIntDef.Z.sgn (Z.pos v2)) v2 | Z.neg v2 => (fun v2 : @positive => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (0  Z.neg v2) * BinIntDef.Z.sgn 0 * BinIntDef.Z.sgn (Z.neg v2)) v2 end | Z.pos v1 => (fun (v1 : @positive) (v2 : @Z) => match v2 as v3 in Z return (0 <= BinIntDef.Z.sgn (Z.pos v1  v3) * BinIntDef.Z.sgn (Z.pos v1) * BinIntDef.Z.sgn v3) with | 0 => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (Z.pos v1  0) * BinIntDef.Z.sgn (Z.pos v1) * BinIntDef.Z.sgn 0 | Z.pos v3 => (fun v3 : @positive => (((let v4 : @N * @N := BinNatDef.N.pos_div_eucl v1 (N.pos v3) in match v4 as v5 in (_ * _)%type return (0 <= BinIntDef.Z.sgn (fst match v5 as v6 in (_ * _)%type return (@Z * @Z) with | (v6, v7) => (fun v6 v7 : @N => (BinIntDef.Z.of_N v6, BinIntDef.Z.of_N v7)) v6 v7 end) * 1 * 1) with | (v5, v6) => (fun v5 v6 : @N => match v5 as v7 in N return (0 <= BinIntDef.Z.sgn (BinIntDef.Z.of_N v7) * 1 * 1) with | 0%N => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (BinIntDef.Z.of_N 0) * 1 * 1 | N.pos v7 => (fun v7 : @positive => Pos2Z.is_nonneg 1 : 0 <= BinIntDef.Z.sgn (BinIntDef.Z.of_N (N.pos v7)) * 1 * 1) v7 end : 0 <= BinIntDef.Z.sgn (fst (BinIntDef.Z.of_N v5, BinIntDef.Z.of_N v6)) * 1 * 1) v5 v6 end) : 0 <= BinIntDef.Z.sgn (fst (BinIntDef.Z.quotrem (Z.pos v1) (Z.pos v3))) * 1 * 1) : 0 <= BinIntDef.Z.sgn (Z.pos v1  Z.pos v3) * 1 * 1) : 0 <= BinIntDef.Z.sgn (Z.pos v1  Z.pos v3) * BinIntDef.Z.sgn (Z.pos v1) * BinIntDef.Z.sgn (Z.pos v3)) v3 | Z.neg v3 => (fun v3 : @positive => (((let v4 : @N * @N := BinNatDef.N.pos_div_eucl v1 (N.pos v3) in match v4 as v5 in (_ * _)%type return (0 <= BinIntDef.Z.sgn (fst match v5 as v6 in (_ * _)%type return (@Z * @Z) with | (v6, v7) => (fun v6 v7 : @N => (- BinIntDef.Z.of_N v6, BinIntDef.Z.of_N v7)) v6 v7 end) * 1 * -1) with | (v5, v6) => (fun v5 v6 : @N => match v5 as v7 in N return (0 <= BinIntDef.Z.sgn (- BinIntDef.Z.of_N v7) * 1 * -1) with | 0%N => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (- BinIntDef.Z.of_N 0) * 1 * -1 | N.pos v7 => (fun v7 : @positive => Pos2Z.is_nonneg 1 : 0 <= BinIntDef.Z.sgn (- BinIntDef.Z.of_N (N.pos v7)) * 1 * -1) v7 end : 0 <= BinIntDef.Z.sgn (fst (- BinIntDef.Z.of_N v5, BinIntDef.Z.of_N v6)) * 1 * -1) v5 v6 end) : 0 <= BinIntDef.Z.sgn (fst (BinIntDef.Z.quotrem (Z.pos v1) (Z.neg v3))) * 1 * -1) : 0 <= BinIntDef.Z.sgn (Z.pos v1  Z.neg v3) * 1 * -1) : 0 <= BinIntDef.Z.sgn (Z.pos v1  Z.neg v3) * BinIntDef.Z.sgn (Z.pos v1) * BinIntDef.Z.sgn (Z.neg v3)) v3 end) v1 | Z.neg v1 => (fun (v1 : @positive) (v2 : @Z) => match v2 as v3 in Z return (0 <= BinIntDef.Z.sgn (Z.neg v1  v3) * BinIntDef.Z.sgn (Z.neg v1) * BinIntDef.Z.sgn v3) with | 0 => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (Z.neg v1  0) * BinIntDef.Z.sgn (Z.neg v1) * BinIntDef.Z.sgn 0 | Z.pos v3 => (fun v3 : @positive => (((let v4 : @N * @N := BinNatDef.N.pos_div_eucl v1 (N.pos v3) in match v4 as v5 in (_ * _)%type return (0 <= BinIntDef.Z.sgn (fst match v5 as v6 in (_ * _)%type return (@Z * @Z) with | (v6, v7) => (fun v6 v7 : @N => (- BinIntDef.Z.of_N v6, - BinIntDef.Z.of_N v7)) v6 v7 end) * -1 * 1) with | (v5, v6) => (fun v5 v6 : @N => match v5 as v7 in N return (0 <= BinIntDef.Z.sgn (- BinIntDef.Z.of_N v7) * -1 * 1) with | 0%N => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (- BinIntDef.Z.of_N 0) * -1 * 1 | N.pos v7 => (fun v7 : @positive => Pos2Z.is_nonneg 1 : 0 <= BinIntDef.Z.sgn (- BinIntDef.Z.of_N (N.pos v7)) * -1 * 1) v7 end : 0 <= BinIntDef.Z.sgn (fst (- BinIntDef.Z.of_N v5, - BinIntDef.Z.of_N v6)) * -1 * 1) v5 v6 end) : 0 <= BinIntDef.Z.sgn (fst (BinIntDef.Z.quotrem (Z.neg v1) (Z.pos v3))) * -1 * 1) : 0 <= BinIntDef.Z.sgn (Z.neg v1  Z.pos v3) * -1 * 1) : 0 <= BinIntDef.Z.sgn (Z.neg v1  Z.pos v3) * BinIntDef.Z.sgn (Z.neg v1) * BinIntDef.Z.sgn (Z.pos v3)) v3 | Z.neg v3 => (fun v3 : @positive => (((let v4 : @N * @N := BinNatDef.N.pos_div_eucl v1 (N.pos v3) in match v4 as v5 in (_ * _)%type return (0 <= BinIntDef.Z.sgn (fst match v5 as v6 in (_ * _)%type return (@Z * @Z) with | (v6, v7) => (fun v6 v7 : @N => (BinIntDef.Z.of_N v6, - BinIntDef.Z.of_N v7)) v6 v7 end) * -1 * -1) with | (v5, v6) => (fun v5 v6 : @N => match v5 as v7 in N return (0 <= BinIntDef.Z.sgn (BinIntDef.Z.of_N v7) * -1 * -1) with | 0%N => Z.le_refl 0 : 0 <= BinIntDef.Z.sgn (BinIntDef.Z.of_N 0) * -1 * -1 | N.pos v7 => (fun v7 : @positive => Pos2Z.is_nonneg 1 : 0 <= BinIntDef.Z.sgn (BinIntDef.Z.of_N (N.pos v7)) * -1 * -1) v7 end : 0 <= BinIntDef.Z.sgn (fst (BinIntDef.Z.of_N v5, - BinIntDef.Z.of_N v6)) * -1 * -1) v5 v6 end) : 0 <= BinIntDef.Z.sgn (fst (BinIntDef.Z.quotrem (Z.neg v1) (Z.neg v3))) * -1 * -1) : 0 <= BinIntDef.Z.sgn (Z.neg v1  Z.neg v3) * -1 * -1) : 0 <= BinIntDef.Z.sgn (Z.neg v1  Z.neg v3) * BinIntDef.Z.sgn (Z.neg v1) * BinIntDef.Z.sgn (Z.neg v3)) v3 end) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_rem_plus	100	0.135055	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= (v0 + v1 * v2) * v0) => let v4 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v4 as v5 in (_ \/ _) return (BinIntDef.Z.rem (v0 + v1 * v2) v2 = BinIntDef.Z.rem v0 v2) with | or_introl v5 => (fun v5 : v2 = 0 => eq_ind_r (fun v6 : @Z => forall v7 : 0 <= (v0 + v1 * v6) * v0, BinIntDef.Z.rem (v0 + v1 * v6) v6 = BinIntDef.Z.rem v0 v6) (fun v6 : 0 <= (v0 + v1 * 0) * v0 => eq_ind_r (fun v7 : @Z => v7 = BinIntDef.Z.rem v0 0) (eq_ind_r (fun v7 : @Z => v0 + v1 * 0 = v7) (let v7 : forall v7 v8 : @Z, v8 + v7 * 0 = v8 := fun v7 v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v7) v8 VarMap.Empty in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEmul (EnvRing.PEX 2) (EnvRing.PEc 0)); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v7 v1 v0) (Zrem_0_r v0)) (Zrem_0_r (v0 + v1 * 0))) v5 v3) v5 | or_intror v5 => (fun v5 : v2 <> 0 => Z.rem_add v0 v1 v2 v5 v3) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_quot_plus	100	0.073714	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= (v0 + v1 * v2) * v0) (v4 : v2 <> 0) => Z.quot_add v0 v1 v2 v4 v3)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Z_quot_plus_l	100	0.084798	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= (v0 * v1 + v2) * v2) (v4 v5 : v1 <> 0) => Z.quot_add_l v0 v1 v2 v5 v3)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_mult_cancel_r	100	0.100052	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : v2 <> 0) => let v4 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v4 as v5 in (_ \/ _) return (v0 * v2  (v1 * v2) = v0  v1) with | or_introl v5 => (fun v5 : v1 = 0 => eq_ind_r (fun v6 : @Z => v0 * v2  (v6 * v2) = v0  v6) (eq_ind_r (fun v6 : @Z => v6 = v0  0) (eq_ind_r (fun v6 : @Z => 0 = v6) (let v6 : 0 = 0 := let v6 : list (@ZMicromega.ZArithProof) := nil in let v7 : VarMap.t (@Z) := VarMap.Empty in let v8 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v8 v6 (eq_refl : ZMicromega.ZTautoChecker v8 v6 = @true) (VarMap.find 0 v7) in v6) (Zquot_0_r v0)) (Zquot_0_r (v0 * v2))) v5) v5 | or_intror v5 => (fun v5 : v1 <> 0 => Z.quot_mul_cancel_r v0 v1 v2 v5 v3) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_mult_cancel_l	100	0.108848	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : v2 <> 0) => eq_ind_r (fun v4 : @Z => v2 * v0  v4 = v0  v1) (let v4 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v4 as v5 in (_ \/ _) return (v2 * v0  (v1 * v2) = v0  v1) with | or_introl v5 => (fun v5 : v1 = 0 => eq_ind_r (fun v6 : @Z => v2 * v0  (v6 * v2) = v0  v6) (eq_ind_r (fun v6 : @Z => v6 = v0  0) (eq_ind_r (fun v6 : @Z => 0 = v6) (let v6 : 0 = 0 := let v6 : list (@ZMicromega.ZArithProof) := nil in let v7 : VarMap.t (@Z) := VarMap.Empty in let v8 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v8 v6 (eq_refl : ZMicromega.ZTautoChecker v8 v6 = @true) (VarMap.find 0 v7) in v6) (Zquot_0_r v0)) (Zquot_0_r (v2 * v0))) v5) v5 | or_intror v5 => (fun v5 : v1 <> 0 => eq_ind_r (fun v6 : @Z => v2 * v0  v6 = v0  v1) (Z.quot_mul_cancel_l v0 v1 v2 v5 v3) (Z.mul_comm v1 v2)) v5 end) (Z.mul_comm v2 v1))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zmult_rem_distr_l	100	0.220740	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => let v3 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v3 as v4 in (_ \/ _) return (BinIntDef.Z.rem (v2 * v0) (v2 * v1) = v2 * BinIntDef.Z.rem v0 v1) with | or_introl v4 => (fun v4 : v2 = 0 => eq_ind_r (fun v5 : @Z => BinIntDef.Z.rem (v5 * v0) (v5 * v1) = v5 * BinIntDef.Z.rem v0 v1) (eq_ind_r (fun v5 : @Z => v5 = 0 * BinIntDef.Z.rem v0 v1) (let v5 : forall v5 : @Z, 0 = 0 * v5 := fun v5 : @Z => let v6 : list (@ZMicromega.ZArithProof) := nil in let v7 : VarMap.t (@Z) := VarMap.Elt v5 in let v8 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEc 0) (EnvRing.PEX 1) |} (@tt) in ZMicromega.ZTautoChecker_sound v8 v6 (eq_refl : ZMicromega.ZTautoChecker v8 v6 = @true) (VarMap.find 0 v7) in v5 (BinIntDef.Z.rem v0 v1)) (Zrem_0_l (0 * v1))) v4) v4 | or_intror v4 => (fun v4 : v2 <> 0 => eq_ind_r (fun v5 : @Z => BinIntDef.Z.rem (v2 * v0) v5 = v2 * BinIntDef.Z.rem v0 v1) (let v5 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v5 as v6 in (_ \/ _) return (BinIntDef.Z.rem (v2 * v0) (v1 * v2) = v2 * BinIntDef.Z.rem v0 v1) with | or_introl v6 => (fun v6 : v1 = 0 => eq_ind_r (fun v7 : @Z => BinIntDef.Z.rem (v2 * v0) (v7 * v2) = v2 * BinIntDef.Z.rem v0 v7) (eq_ind_r (fun v7 : @Z => v7 = v2 * BinIntDef.Z.rem v0 0) (eq_ind_r (fun v7 : @Z => v2 * v0 = v2 * v7) (let v7 : forall v7 v8 : @Z, v8 * v7 = v8 * v7 := fun v7 v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v7) v8 VarMap.Empty in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v7 v0 v2) (Zrem_0_r v0)) (Zrem_0_r (v2 * v0))) v6) v6 | or_intror v6 => (fun v6 : v1 <> 0 => eq_ind_r (fun v7 : @Z => BinIntDef.Z.rem (v2 * v0) v7 = v2 * BinIntDef.Z.rem v0 v1) (Z.mul_rem_distr_l v0 v1 v2 v6 v4) (Z.mul_comm v1 v2)) v6 end) (Z.mul_comm v2 v1)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zmult_rem_distr_r	100	0.216883	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => let v3 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v3 as v4 in (_ \/ _) return (BinIntDef.Z.rem (v0 * v2) (v1 * v2) = BinIntDef.Z.rem v0 v1 * v2) with | or_introl v4 => (fun v4 : v1 = 0 => eq_ind_r (fun v5 : @Z => BinIntDef.Z.rem (v0 * v2) (v5 * v2) = BinIntDef.Z.rem v0 v5 * v2) (eq_ind_r (fun v5 : @Z => v5 = BinIntDef.Z.rem v0 0 * v2) (eq_ind_r (fun v5 : @Z => v0 * v2 = v5 * v2) (let v5 : forall v5 v6 : @Z, v6 * v5 = v6 * v5 := fun v5 v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v5) v6 VarMap.Empty in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v5 v2 v0) (Zrem_0_r v0)) (Zrem_0_r (v0 * v2))) v4) v4 | or_intror v4 => (fun v4 : v1 <> 0 => eq_ind_r (fun v5 : @Z => BinIntDef.Z.rem (v0 * v2) v5 = BinIntDef.Z.rem v0 v1 * v2) (let v5 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v5 as v6 in (_ \/ _) return (BinIntDef.Z.rem (v0 * v2) (v2 * v1) = BinIntDef.Z.rem v0 v1 * v2) with | or_introl v6 => (fun v6 : v2 = 0 => eq_ind_r (fun v7 : @Z => BinIntDef.Z.rem (v0 * v7) (v7 * v1) = BinIntDef.Z.rem v0 v1 * v7) (eq_ind_r (fun v7 : @Z => v7 = BinIntDef.Z.rem v0 v1 * 0) (let v7 : forall v7 v8 : @Z, v8 * 0 = v7 * 0 := fun v7 v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v7) v8 VarMap.Empty in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc 0); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 2) (EnvRing.PEc 0) |} (@tt) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v7 (BinIntDef.Z.rem v0 v1) v0) (Zrem_0_r (v0 * 0))) v6) v6 | or_intror v6 => (fun v6 : v2 <> 0 => eq_ind_r (fun v7 : @Z => BinIntDef.Z.rem (v0 * v2) v7 = BinIntDef.Z.rem v0 v1 * v2) (Z.mul_rem_distr_r v0 v1 v2 v4 v6) (Z.mul_comm v2 v1)) v6 end) (Z.mul_comm v1 v2)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_rem	100	0.125095	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (BinIntDef.Z.rem (BinIntDef.Z.rem v0 v1) v1 = BinIntDef.Z.rem v0 v1) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => BinIntDef.Z.rem (BinIntDef.Z.rem v0 v4) v4 = BinIntDef.Z.rem v0 v4) (eq_ind_r (fun v4 : @Z => v4 = BinIntDef.Z.rem v0 0) (eq_ind_r (fun v4 : @Z => v4 = v4) (let v4 : forall v4 : @Z, v4 = v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0) (Zrem_0_r v0)) (Zrem_0_r (BinIntDef.Z.rem v0 0))) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => Z.rem_rem v0 v1 v3) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zmult_rem	100	0.122929	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => let v3 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v3 as v4 in (_ \/ _) return (BinIntDef.Z.rem (v0 * v1) v2 = BinIntDef.Z.rem (BinIntDef.Z.rem v0 v2 * BinIntDef.Z.rem v1 v2) v2) with | or_introl v4 => (fun v4 : v2 = 0 => eq_ind_r (fun v5 : @Z => BinIntDef.Z.rem (v0 * v1) v5 = BinIntDef.Z.rem (BinIntDef.Z.rem v0 v5 * BinIntDef.Z.rem v1 v5) v5) (eq_ind_r (fun v5 : @Z => v5 = BinIntDef.Z.rem (BinIntDef.Z.rem v0 0 * BinIntDef.Z.rem v1 0) 0) (eq_ind_r (fun v5 : @Z => v0 * v1 = v5) (eq_ind_r (fun v5 : @Z => v0 * v1 = v5 * BinIntDef.Z.rem v1 0) (eq_ind_r (fun v5 : @Z => v0 * v1 = v0 * v5) (let v5 : forall v5 v6 : @Z, v6 * v5 = v6 * v5 := fun v5 v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v5) v6 VarMap.Empty in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v5 v1 v0) (Zrem_0_r v1)) (Zrem_0_r v0)) (Zrem_0_r (BinIntDef.Z.rem v0 0 * BinIntDef.Z.rem v1 0))) (Zrem_0_r (v0 * v1))) v4) v4 | or_intror v4 => (fun v4 : v2 <> 0 => Z.mul_rem v0 v1 v2 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zplus_rem	100	0.142527	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= v0 * v1) => let v4 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v4 as v5 in (_ \/ _) return (BinIntDef.Z.rem (v0 + v1) v2 = BinIntDef.Z.rem (BinIntDef.Z.rem v0 v2 + BinIntDef.Z.rem v1 v2) v2) with | or_introl v5 => (fun v5 : v2 = 0 => eq_ind_r (fun v6 : @Z => BinIntDef.Z.rem (v0 + v1) v6 = BinIntDef.Z.rem (BinIntDef.Z.rem v0 v6 + BinIntDef.Z.rem v1 v6) v6) (eq_ind_r (fun v6 : @Z => v6 = BinIntDef.Z.rem (BinIntDef.Z.rem v0 0 + BinIntDef.Z.rem v1 0) 0) (eq_ind_r (fun v6 : @Z => v0 + v1 = v6) (eq_ind_r (fun v6 : @Z => v0 + v1 = v6 + BinIntDef.Z.rem v1 0) (eq_ind_r (fun v6 : @Z => v0 + v1 = v0 + v6) (let v6 : forall v6 v7 : @Z, v7 + v6 = v7 + v6 := fun v6 v7 : @Z => let v8 : list (@ZMicromega.ZArithProof) := nil in let v9 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v6) v7 VarMap.Empty in let v10 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v10 v8 (eq_refl : ZMicromega.ZTautoChecker v10 v8 = @true) (VarMap.find 0 v9) in v6 v1 v0) (Zrem_0_r v1)) (Zrem_0_r v0)) (Zrem_0_r (BinIntDef.Z.rem v0 0 + BinIntDef.Z.rem v1 0))) (Zrem_0_r (v0 + v1))) v5) v5 | or_intror v5 => (fun v5 : v2 <> 0 => Z.add_rem v0 v1 v2 v5 v3) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zplus_rem_idemp_l	100	0.130708	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= v0 * v1) => let v4 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v4 as v5 in (_ \/ _) return (BinIntDef.Z.rem (BinIntDef.Z.rem v0 v2 + v1) v2 = BinIntDef.Z.rem (v0 + v1) v2) with | or_introl v5 => (fun v5 : v2 = 0 => eq_ind_r (fun v6 : @Z => BinIntDef.Z.rem (BinIntDef.Z.rem v0 v6 + v1) v6 = BinIntDef.Z.rem (v0 + v1) v6) (eq_ind_r (fun v6 : @Z => v6 = BinIntDef.Z.rem (v0 + v1) 0) (eq_ind_r (fun v6 : @Z => v6 + v1 = BinIntDef.Z.rem (v0 + v1) 0) (eq_ind_r (fun v6 : @Z => v0 + v1 = v6) (let v6 : forall v6 v7 : @Z, v7 + v6 = v7 + v6 := fun v6 v7 : @Z => let v8 : list (@ZMicromega.ZArithProof) := nil in let v9 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v6) v7 VarMap.Empty in let v10 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v10 v8 (eq_refl : ZMicromega.ZTautoChecker v10 v8 = @true) (VarMap.find 0 v9) in v6 v1 v0) (Zrem_0_r (v0 + v1))) (Zrem_0_r v0)) (Zrem_0_r (BinIntDef.Z.rem v0 0 + v1))) v5) v5 | or_intror v5 => (fun v5 : v2 <> 0 => Z.add_rem_idemp_l v0 v1 v2 v5 v3) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zplus_rem_idemp_r	100	0.124712	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= v0 * v1) => let v4 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v4 as v5 in (_ \/ _) return (BinIntDef.Z.rem (v1 + BinIntDef.Z.rem v0 v2) v2 = BinIntDef.Z.rem (v1 + v0) v2) with | or_introl v5 => (fun v5 : v2 = 0 => eq_ind_r (fun v6 : @Z => BinIntDef.Z.rem (v1 + BinIntDef.Z.rem v0 v6) v6 = BinIntDef.Z.rem (v1 + v0) v6) (eq_ind_r (fun v6 : @Z => v6 = BinIntDef.Z.rem (v1 + v0) 0) (eq_ind_r (fun v6 : @Z => v1 + v6 = BinIntDef.Z.rem (v1 + v0) 0) (eq_ind_r (fun v6 : @Z => v1 + v0 = v6) (let v6 : forall v6 v7 : @Z, v7 + v6 = v7 + v6 := fun v6 v7 : @Z => let v8 : list (@ZMicromega.ZArithProof) := nil in let v9 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v6) v7 VarMap.Empty in let v10 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v10 v8 (eq_refl : ZMicromega.ZTautoChecker v10 v8 = @true) (VarMap.find 0 v9) in v6 v0 v1) (Zrem_0_r (v1 + v0))) (Zrem_0_r v0)) (Zrem_0_r (v1 + BinIntDef.Z.rem v0 0))) v5) v5 | or_intror v5 => (fun v5 : v2 <> 0 => Z.add_rem_idemp_r v1 v0 v2 v5 (eq_ind_r (fun v6 : @Z => 0 <= v6) v3 (Z.mul_comm v1 v0))) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zmult_rem_idemp_l	100	0.130214	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => let v3 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v3 as v4 in (_ \/ _) return (BinIntDef.Z.rem (BinIntDef.Z.rem v0 v2 * v1) v2 = BinIntDef.Z.rem (v0 * v1) v2) with | or_introl v4 => (fun v4 : v2 = 0 => eq_ind_r (fun v5 : @Z => BinIntDef.Z.rem (BinIntDef.Z.rem v0 v5 * v1) v5 = BinIntDef.Z.rem (v0 * v1) v5) (eq_ind_r (fun v5 : @Z => v5 = BinIntDef.Z.rem (v0 * v1) 0) (eq_ind_r (fun v5 : @Z => v5 * v1 = BinIntDef.Z.rem (v0 * v1) 0) (eq_ind_r (fun v5 : @Z => v0 * v1 = v5) (let v5 : forall v5 v6 : @Z, v6 * v5 = v6 * v5 := fun v5 v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v5) v6 VarMap.Empty in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v5 v1 v0) (Zrem_0_r (v0 * v1))) (Zrem_0_r v0)) (Zrem_0_r (BinIntDef.Z.rem v0 0 * v1))) v4) v4 | or_intror v4 => (fun v4 : v2 <> 0 => Z.mul_rem_idemp_l v0 v1 v2 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zmult_rem_idemp_r	100	0.116804	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => let v3 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v3 as v4 in (_ \/ _) return (BinIntDef.Z.rem (v1 * BinIntDef.Z.rem v0 v2) v2 = BinIntDef.Z.rem (v1 * v0) v2) with | or_introl v4 => (fun v4 : v2 = 0 => eq_ind_r (fun v5 : @Z => BinIntDef.Z.rem (v1 * BinIntDef.Z.rem v0 v5) v5 = BinIntDef.Z.rem (v1 * v0) v5) (eq_ind_r (fun v5 : @Z => v5 = BinIntDef.Z.rem (v1 * v0) 0) (eq_ind_r (fun v5 : @Z => v1 * v5 = BinIntDef.Z.rem (v1 * v0) 0) (eq_ind_r (fun v5 : @Z => v1 * v0 = v5) (let v5 : forall v5 v6 : @Z, v6 * v5 = v6 * v5 := fun v5 v6 : @Z => let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Branch (VarMap.Elt v5) v6 VarMap.Empty in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEX 2) |} (@tt) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v5 v0 v1) (Zrem_0_r (v1 * v0))) (Zrem_0_r v0)) (Zrem_0_r (v1 * BinIntDef.Z.rem v0 0))) v4) v4 | or_intror v4 => (fun v4 : v2 <> 0 => Z.mul_rem_idemp_r v1 v0 v2 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_Zquot	100	0.148694	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @Z => let v3 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v3 as v4 in (_ \/ _) return (v0  v1  v2 = v0  (v1 * v2)) with | or_introl v4 => (fun v4 : v1 = 0 => eq_ind_r (fun v5 : @Z => v0  v5  v2 = v0  (v5 * v2)) (eq_ind_r (fun v5 : @Z => v5  v2 = v0  (0 * v2)) (eq_ind_r (fun v5 : @Z => 0  v2 = v5) eq_refl (Zquot_0_r v0)) (Zquot_0_r v0)) v4) v4 | or_intror v4 => (fun v4 : v1 <> 0 => eq_ind_r (fun v5 : @Z => v0  v1  v2 = v0  v5) (let v5 : v2 = 0 \/ v2 <> 0 := Z.eq_decidable v2 0 in match v5 as v6 in (_ \/ _) return (v0  v1  v2 = v0  (v2 * v1)) with | or_introl v6 => (fun v6 : v2 = 0 => eq_ind_r (fun v7 : @Z => v0  v1  v7 = v0  (v7 * v1)) (eq_ind_r (fun v7 : @Z => v7 = v0  (0 * v1)) (eq_ind_r (fun v7 : @Z => 0 = v7) (let v7 : 0 = 0 := let v7 : list (@ZMicromega.ZArithProof) := nil in let v8 : VarMap.t (@Z) := VarMap.Empty in let v9 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v9 v7 (eq_refl : ZMicromega.ZTautoChecker v9 v7 = @true) (VarMap.find 0 v8) in v7) (Zquot_0_r v0)) (Zquot_0_r (v0  v1))) v6) v6 | or_intror v6 => (fun v6 : v2 <> 0 => eq_ind_r (fun v7 : @Z => v0  v1  v2 = v0  v7) (Z.quot_quot v0 v1 v2 v4 v6) (Z.mul_comm v2 v1)) v6 end) (Z.mul_comm v1 v2)) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_mult_le	100	0.274991	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @Z) (v3 : 0 <= v0) (v4 : 0 <= v1) (v5 : 0 <= v2) => let v6 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v6 as v7 in (_ \/ _) return (v2 * (v0  v1) <= v2 * v0  v1) with | or_introl v7 => (fun v7 : v1 = 0 => eq_ind_r (fun v8 : @Z => forall v9 : 0 <= v8, v2 * (v0  v8) <= v2 * v0  v8) (fun v8 : 0 <= 0 => eq_ind_r (fun v9 : @Z => v2 * v9 <= v2 * v0  0) (eq_ind_r (fun v9 : @Z => v2 * 0 <= v9) (let v9 : 0 <= v2 * 0 := Z.mul_nonneg_nonneg v2 0 v5 v8 in let v10 : forall v10 : @Z, v10 * 0 <= 0 := fun v10 : @Z => let v11 : list (@ZMicromega.ZArithProof) := nil in let v12 : VarMap.t (@Z) := VarMap.Elt v10 in let v13 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc 0); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt) in ZMicromega.ZTautoChecker_sound v13 v11 (eq_refl : ZMicromega.ZTautoChecker v13 v11 = @true) (VarMap.find 0 v12) in v10 v2) (Zquot_0_r (v2 * v0))) (Zquot_0_r v0)) v7 v4) v7 | or_intror v7 => (fun v7 : v1 <> 0 => Z.quot_mul_le v0 v1 v2 (let v8 : forall (v8 : @Z) (v9 : 0 <= v8), 0 <= v8 := fun v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Elt v8 in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v8 v0 v3) (let v8 : forall (v8 : @Z) (v9 : forall v9 : v8 = 0, @False) (v10 : 0 <= v8), 0 < v8 := fun v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Elt v8 in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt))) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v8 v1 v7 v4) (let v8 : forall (v8 : @Z) (v9 : 0 <= v8), 0 <= v8 := fun v8 : @Z => let v9 : list (@ZMicromega.ZArithProof) := nil in let v10 : VarMap.t (@Z) := VarMap.Elt v8 in let v11 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v11 v9 (eq_refl : ZMicromega.ZTautoChecker v11 v9 = @true) (VarMap.find 0 v10) in v8 v2 v5)) v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_divides	100	0.267616	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @Z => let v2 : v1 = 0 \/ v1 <> 0 := Z.eq_decidable v1 0 in match v2 as v3 in (_ \/ _) return (BinIntDef.Z.rem v0 v1 = 0 <-> (exists v4 : @Z, v0 = v1 * v4)) with | or_introl v3 => (fun v3 : v1 = 0 => eq_ind_r (fun v4 : @Z => BinIntDef.Z.rem v0 v4 = 0 <-> (exists v5 : @Z, v0 = v4 * v5)) (eq_ind_r (fun v4 : @Z => v4 = 0 <-> (exists v5 : @Z, v0 = 0 * v5)) (conj (fun v4 : v0 = 0 => let v5 : @Z := v0 in (fun v6 : @Z => ex_intro (fun v7 : @Z => v0 = 0 * v7) v6 v4) v5) (fun v4 : exists v4 : @Z, v0 = 0 * v4 => ex_ind (fun (v5 : @Z) (v6 : v0 = 0 * v5) => v6) v4)) (Zrem_0_r v0)) v3) v3 | or_intror v3 => (fun v3 : v1 <> 0 => (fun v4 : BinIntDef.Z.rem v0 v1 = 0 <-> (v1 | v0) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (BinIntDef.Z.rem v0 v1 = 0) (v1 | v0) v4 (exists v5 : @Z, v0 = v1 * v5) (exists v5 : @Z, v0 = v1 * v5) (eq_proper_proxy (exists v5 : @Z, v0 = v1 * v5))) (Z.rem_divide v0 v1 v3) (conj (fun v4 : (v1 | v0) => match v4 as v5 in (ex _) return (exists v6 : @Z, v0 = v1 * v6) with | ex_intro _ v5 v6 => (fun (v5 : @Z) (v6 : v0 = v5 * v1) => ex_intro (fun v7 : @Z => v0 = v1 * v7) v5 (eq_ind_r (fun v7 : @Z => v7 = v1 * v5) (eq_sym (Z.mul_comm v1 v5)) v6)) v5 v6 end) (fun v4 : exists v4 : @Z, v0 = v1 * v4 => match v4 as v5 in (ex _) return (v1 | v0) with | ex_intro _ v5 v6 => (fun (v5 : @Z) (v6 : v0 = v1 * v5) => ex_intro (fun v7 : @Z => v0 = v7 * v1) v5 (eq_ind_r (fun v7 : @Z => v7 = v5 * v1) (eq_sym (Z.mul_comm v5 v1)) v6)) v5 v6 end))) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot2_odd_remainder	100	1.816871	1	1
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_odd	100	0.103036	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => eq_sym (Zrem_unique_full v0 2 (BinIntDef.Z.quot2 v0) match BinIntDef.Z.odd v0 as v1 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end (Zquot2_odd_remainder v0) (Zquot2_odd_eqn v0)))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_even	100	0.120059	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => eq_ind_r (fun v1 : @Z => v1 = match BinIntDef.Z.even v0 as v2 in bool return (@Z) with | true => 0 | false => BinIntDef.Z.sgn v0 end) (eq_ind_r (fun v1 : @bool => match v1 as v2 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end = match BinIntDef.Z.even v0 as v2 in bool return (@Z) with | true => 0 | false => BinIntDef.Z.sgn v0 end) (let v1 : @bool := BinIntDef.Z.even v0 in match v1 as v2 in bool return (match negb v2 as v3 in bool return (@Z) with | true => BinIntDef.Z.sgn v0 | false => 0 end = match v2 as v3 in bool return (@Z) with | true => 0 | false => BinIntDef.Z.sgn v0 end) with | true => eq_refl | false => eq_refl end) (Zodd_even_bool v0)) (Zrem_odd v0))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zeven_rem	100	0.205429	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => eq_ind_r (fun v1 : @Z => BinIntDef.Z.even v0 = (v1 =? 0)) match v0 as v1 in Z return (BinIntDef.Z.even v1 = (match BinIntDef.Z.even v1 as v2 in bool return (@Z) with | true => 0 | false => BinIntDef.Z.sgn v1 end =? 0)) with | 0 => eq_refl | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return (BinIntDef.Z.even (Z.pos v2) = (match BinIntDef.Z.even (Z.pos v2) as v3 in bool return (@Z) with | true => 0 | false => BinIntDef.Z.sgn (Z.pos v2) end =? 0)) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return (BinIntDef.Z.even (Z.neg v2) = (match BinIntDef.Z.even (Z.neg v2) as v3 in bool return (@Z) with | true => 0 | false => BinIntDef.Z.sgn (Z.neg v2) end =? 0)) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 end (Zrem_even v0))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zodd_rem	100	0.201186	1	1	0	synth with cache (only 1: refine (fun v0 : @Z => eq_ind_r (fun v1 : @Z => BinIntDef.Z.odd v0 = negb (v1 =? 0)) match v0 as v1 in Z return (BinIntDef.Z.odd v1 = negb (match BinIntDef.Z.odd v1 as v2 in bool return (@Z) with | true => BinIntDef.Z.sgn v1 | false => 0 end =? 0)) with | 0 => eq_refl | Z.pos v1 => (fun v1 : @positive => match v1 as v2 in positive return (BinIntDef.Z.odd (Z.pos v2) = negb (match BinIntDef.Z.odd (Z.pos v2) as v3 in bool return (@Z) with | true => BinIntDef.Z.sgn (Z.pos v2) | false => 0 end =? 0)) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 | Z.neg v1 => (fun v1 : @positive => match v1 as v2 in positive return (BinIntDef.Z.odd (Z.neg v2) = negb (match BinIntDef.Z.odd (Z.neg v2) as v3 in bool return (@Z) with | true => BinIntDef.Z.sgn (Z.neg v2) | false => 0 end =? 0)) with | (v2~1)%positive => (fun v2 : @positive => eq_refl) v2 | (v2~0)%positive => (fun v2 : @positive => eq_refl) v2 | 1%positive => eq_refl end) v1 end (Zrem_odd v0))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquotrem_Zdiv_eucl_pos	100	0.300949	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : 0 < v1) => Zdiv_mod_unique v1 (v0  v1) (v0 / v1) (BinIntDef.Z.rem v0 v1) (v0 mod v1) (Zrem_lt_pos v0 v1 (let v4 : forall (v4 : @Z) (v5 : 0 <= v4), 0 <= v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v0 v2) (let v4 : forall (v4 : @Z) (v5 : 0 < v4) (v6 : v4 = 0), @False := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v1 v3)) (eq_ind_r (fun v4 : @Z => 0 <= v0 mod v1 < v4) (Z_mod_lt v0 v1 (let v4 : forall (v4 : @Z) (v5 : 0 < v4), v4 > 0 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v1 v3)) (Z.abs_eq v1 (let v4 : forall (v4 : @Z) (v5 : 0 < v4), 0 <= v4 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v1 v3))) (eq_ind v0 (fun v4 : @Z => v1 * (v0  v1) + BinIntDef.Z.rem v0 v1 = v4) (eq_sym (Z.quot_rem v0 v1 (let v4 : forall (v4 : @Z) (v5 : 0 < v4) (v6 : v4 = 0), @False := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.N (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpEq; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt))) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v1 v3))) (v1 * (v0 / v1) + v0 mod v1) (Z_div_mod_eq v0 v1 (let v4 : forall (v4 : @Z) (v5 : 0 < v4), v4 > 0 := fun v4 : @Z => let v5 : list (@ZMicromega.ZArithProof) := nil in let v6 : VarMap.t (@Z) := VarMap.Elt v4 in let v7 : Tauto.BFormula (RingMicromega.Formula (@Z)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEc 0; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 1 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc 0 |} (@tt)) in ZMicromega.ZTautoChecker_sound v7 v5 (eq_refl : ZMicromega.ZTautoChecker v7 v5 = @true) (VarMap.find 0 v6) in v4 v1 v3))))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zquot_Zdiv_pos	100	0.106987	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : 0 <= v1) => match (fun v4 : 0 <= v1 <-> 0 < v1 \/ 0 = v1 => iff_impl_subrelation (0 <= v1) (0 < v1 \/ 0 = v1) v4) (Z.lt_eq_cases 0 v1) v3 as v4 in (_ \/ _) return (v0  v1 = v0 / v1) with | or_introl v4 => (fun v4 : 0 < v1 => (fun v5 : v0  v1 = v0 / v1 /\ BinIntDef.Z.rem v0 v1 = v0 mod v1 => and_ind (fun (v6 : v0  v1 = v0 / v1) (v7 : BinIntDef.Z.rem v0 v1 = v0 mod v1) => v6) v5) (Zquotrem_Zdiv_eucl_pos v0 v1 v2 v4)) v4 | or_intror v4 => (fun v4 : 0 = v1 => eq_ind 0 (fun v5 : @Z => v0  v5 = v0 / v5) (eq_ind_r (fun v5 : @Z => v5 = v0 / 0) (eq_ind_r (fun v5 : @Z => 0 = v5) eq_refl (Zdiv_0_r v0)) (Zquot_0_r v0)) v1 v4) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_Zmod_pos	100	0.096208	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : 0 <= v0) (v3 : 0 < v1) => (fun v4 : v0  v1 = v0 / v1 /\ BinIntDef.Z.rem v0 v1 = v0 mod v1 => and_ind (fun (v5 : v0  v1 = v0 / v1) (v6 : BinIntDef.Z.rem v0 v1 = v0 mod v1) => v6) v4) (Zquotrem_Zdiv_eucl_pos v0 v1 v2 v3))).
coq-tactician-stdlib.8.11.dev	Coq.ZArith.Zquot.Zrem_Zmod_zero	100	0.109706	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : v1 <> 0) => (fun v3 : BinIntDef.Z.rem v0 v1 = 0 <-> (exists v3 : @Z, v0 = v1 * v3) => trans_co_eq_inv_impl_morphism (@iff_Transitive) (BinIntDef.Z.rem v0 v1 = 0) (exists v4 : @Z, v0 = v1 * v4) v3 (v0 mod v1 = 0) (v0 mod v1 = 0) (eq_proper_proxy (v0 mod v1 = 0))) (Zrem_divides v0 v1) ((fun v3 : v0 mod v1 = 0 <-> (exists v3 : @Z, v0 = v1 * v3) => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (v0 mod v1 = 0) (exists v4 : @Z, v0 = v1 * v4) v3) (Zmod_divides v0 v1 ((fun v3 : v1 = 0 => let v4 : @False := v2 v3 in False_ind (@False) v4) : v1 <> 0)) (conj (fun v3 : exists v3 : @Z, v0 = v1 * v3 => v3) (fun v3 : exists v3 : @Z, v0 = v1 * v3 => v3))))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Cyclic.Int31.Ring31.Int31_canonic	100	0.103032	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @int31) (v2 : phi v0 = phi v1) => eq_ind (phi_inv (phi v0)) (fun v3 : @int31 => v3 = v1) (eq_ind (phi_inv (phi v1)) (fun v3 : @int31 => phi_inv (phi v0) = v3) (eq_ind_r (fun v3 : @Z => phi_inv v3 = phi_inv (phi v1)) eq_refl v2) v1 (phi_inv_phi v1)) v0 (phi_inv_phi v0))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Cyclic.Int31.Ring31.ring_theory_switch_eq	100	0.092485	1	1	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : forall v1 v2 : v0, Prop) (v2 : forall v2 v3 : v0, Prop) (v3 v4 : v0) (v5 : forall v5 v6 : v0, v0) (v6 : forall v6 v7 : v0, v0) (v7 : forall v7 v8 : v0, v0) (v8 : forall v8 : v0, v0) (v9 : forall (v9 v10 : v0) (v11 : v1 v9 v10), v2 v9 v10) (v10 : ring_theory v3 v4 v5 v6 v7 v8 v1) => {| Radd_0_l := fun v11 : v0 => v9 (v5 v3 v11) v11 (let v12 : forall v12 : v0, v1 (v5 v3 v12) v12 := Radd_0_l v10 in v12 v11); Radd_comm := fun v11 v12 : v0 => v9 (v5 v11 v12) (v5 v12 v11) (let v13 : forall v13 v14 : v0, v1 (v5 v13 v14) (v5 v14 v13) := Radd_comm v10 in v13 v11 v12); Radd_assoc := fun v11 v12 v13 : v0 => v9 (v5 v11 (v5 v12 v13)) (v5 (v5 v11 v12) v13) (let v14 : forall v14 v15 v16 : v0, v1 (v5 v14 (v5 v15 v16)) (v5 (v5 v14 v15) v16) := Radd_assoc v10 in v14 v11 v12 v13); Rmul_1_l := fun v11 : v0 => v9 (v6 v4 v11) v11 (let v12 : forall v12 : v0, v1 (v6 v4 v12) v12 := Rmul_1_l v10 in v12 v11); Rmul_comm := fun v11 v12 : v0 => v9 (v6 v11 v12) (v6 v12 v11) (let v13 : forall v13 v14 : v0, v1 (v6 v13 v14) (v6 v14 v13) := Rmul_comm v10 in v13 v11 v12); Rmul_assoc := fun v11 v12 v13 : v0 => v9 (v6 v11 (v6 v12 v13)) (v6 (v6 v11 v12) v13) (let v14 : forall v14 v15 v16 : v0, v1 (v6 v14 (v6 v15 v16)) (v6 (v6 v14 v15) v16) := Rmul_assoc v10 in v14 v11 v12 v13); Rdistr_l := fun v11 v12 v13 : v0 => v9 (v6 (v5 v11 v12) v13) (v5 (v6 v11 v13) (v6 v12 v13)) (let v14 : forall v14 v15 v16 : v0, v1 (v6 (v5 v14 v15) v16) (v5 (v6 v14 v16) (v6 v15 v16)) := Rdistr_l v10 in v14 v11 v12 v13); Rsub_def := fun v11 v12 : v0 => v9 (v7 v11 v12) (v5 v11 (v8 v12)) (let v13 : forall v13 v14 : v0, v1 (v7 v13 v14) (v5 v13 (v8 v14)) := Rsub_def v10 in v13 v11 v12); Ropp_def := fun v11 : v0 => v9 (v5 v11 (v8 v11)) v3 (let v12 : forall v12 : v0, v1 (v5 v12 (v8 v12)) v3 := Ropp_def v10 in v12 v11) |})).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Cyclic.Int31.Ring31.Int31Ring	100	0.196921	1	1	0	synth with cache (only 1: refine (ring_theory_switch_eq (@int31) (fun v0 v1 : @int31 => phi v0 = phi v1) eq ZnZ.zero ZnZ.one ZnZ.add ZnZ.mul ZnZ.sub ZnZ.opp (@Int31_canonic) (@Int31ring.CyclicRing))).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Cyclic.Int31.Ring31.eqb31_eq	100	0.198915	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @int31 => eq_ind_r (fun v2 : @comparison => match v2 as v3 in comparison return (@bool) with | Eq => @true | _ => @false end = @true <-> v0 = v1) (conj match Z.compare_spec (phi v0) (phi v1) as v3 in (CompareSpec _ _ _ v2) return (forall v4 : match v2 as v4 in comparison return (@bool) with | Eq => @true | _ => @false end = @true, v0 = v1) with | CompEq _ _ v2 => (fun (v2 : phi v0 = phi v1) (v3 : @true = @true) => Int31_canonic v0 v1 v2) v2 | CompLt _ _ v2 => (fun (v2 : (phi v0 < phi v1)%Z) (v3 : @false = @true) => let v4 : forall v4 : @true = @true, v0 = v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, v0 = v1) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (v0 = v1) v6) v4 end in v4 eq_refl) v2 | CompGt _ _ v2 => (fun (v2 : (phi v1 < phi v0)%Z) (v3 : @false = @true) => let v4 : forall v4 : @true = @true, v0 = v1 := match v3 as v5 in (_ = v4) return (forall v6 : v4 = @true, v0 = v1) with | eq_refl => fun v4 : @false = @true => (fun v5 : @false = @true => let v6 : @False := eq_ind (@false) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v5 in False_ind (v0 = v1) v6) v4 end in v4 eq_refl) v2 end (fun v2 : v0 = v1 => eq_ind_r (fun v3 : @int31 => match (phi v3 ?= phi v1)%Z as v4 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) (eq_ind_r (fun v3 : @comparison => match v3 as v4 in comparison return (@bool) with | Eq => @true | _ => @false end = @true) eq_refl (Z.compare_refl (phi v1))) v2)) (spec_compare v0 v1)) : forall v0 v1 : @int31, eqb31 v0 v1 = @true <-> v0 = v1)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Cyclic.Int31.Ring31.eqb31_correct	100	0.105601	1	1	0	synth with cache (only 1: refine (let v0 : forall (v0 v1 : @int31) (v2 : eqb31 v0 v1 = @true), v0 = v1 := fun v0 v1 : @int31 => match eqb31_eq v0 v1 as v2 in (_ /\ _) return (forall v3 : eqb31 v0 v1 = @true, v0 = v1) with | conj v2 v3 => (fun (v2 : forall v2 : eqb31 v0 v1 = @true, v0 = v1) (v3 : forall v3 : v0 = v1, eqb31 v0 v1 = @true) => v2) v2 v3 end in v0)).
coq-tactician-stdlib.8.11.dev	Coq.Numbers.Cyclic.Int31.Ring31.TestRing.test	100	0.426639	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.is_upper_bound_dec	100	0.181290	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @CReal, Prop) (v1 : @CReal) (v2 : @sig_forall_dec_T) (v3 : @sig_not_dec_T) => let v4 : {~ ~ ~ (exists v4 : @CReal, v0 v4 /\ CRealLtProp v1 v4)} + {~ ~ (exists v4 : @CReal, v0 v4 /\ CRealLtProp v1 v4)} := v3 (~ (exists v4 : @CReal, v0 v4 /\ CRealLtProp v1 v4)) in match v4 as v5 in ({_} + {_}) return ({is_upper_bound v0 v1} + {~ is_upper_bound v0 v1}) with | left v5 => (fun v5 : ~ ~ ~ (exists v5 : @CReal, v0 v5 /\ CRealLtProp v1 v5) => left ((fun (v6 : @CReal) (v7 : v0 v6) => let v8 : (v1 < v6) + (forall v8 : v1 < v6, @False) := CRealLt_lpo_dec v1 v6 v2 in match v8 as v9 in (_ + _)%type return (v6 <= v1) with | inl v9 => (fun v9 : v1 < v6 => False_ind (v6 <= v1) (v5 ((fun v10 : ~ (exists v10 : @CReal, v0 v10 /\ CRealLtProp v1 v10) => v10 (ex_intro (fun v11 : @CReal => v0 v11 /\ CRealLtProp v1 v11) v6 (conj v7 match v9 as v11 in (sig _) return (CRealLtProp v1 v6) with | exist _ v11 v12 => (fun (v11 : @positive) (v12 : (2 # v11 < proj1_sig v6 (BinPosDef.Pos.to_nat v11) - proj1_sig v1 (BinPosDef.Pos.to_nat v11))%Q) => ex_intro (fun v13 : @positive => (2 # v13 < proj1_sig v6 (BinPosDef.Pos.to_nat v13) - proj1_sig v1 (BinPosDef.Pos.to_nat v13))%Q) v11 v12) v11 v12 end))) : ~ ~ (exists v10 : @CReal, v0 v10 /\ CRealLtProp v1 v10)))) v9 | inr v9 => (fun v9 : forall v9 : v1 < v6, @False => v9) v9 end) : is_upper_bound v0 v1)) v5 | right v5 => (fun v5 : ~ ~ (exists v5 : @CReal, v0 v5 /\ CRealLtProp v1 v5) => right ((fun v6 : is_upper_bound v0 v1 => v5 ((fun v7 : exists v7 : @CReal, v0 v7 /\ CRealLtProp v1 v7 => match v7 as v8 in (ex _) return (@False) with | ex_intro _ v8 v9 => (fun (v8 : @CReal) (v9 : v0 v8 /\ CRealLtProp v1 v8) => match v9 as v10 in (_ /\ _) return (@False) with | conj v10 v11 => (fun (v10 : v0 v8) (v11 : CRealLtProp v1 v8) => let v12 : v8 <= v1 := v6 v8 v10 in let v13 : v1 < v8 := CRealLtEpsilon v1 v8 v11 in False_ind (@False) (v12 v13)) v10 v11 end) v8 v9 end) : ~ (exists v7 : @CReal, v0 v7 /\ CRealLtProp v1 v7))) : ~ is_upper_bound v0 v1)) v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.is_upper_bound_epsilon	100	0.114353	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @CReal, Prop) (v1 : @sig_forall_dec_T) (v2 : @sig_not_dec_T) (v3 : exists v3 : @CReal, is_upper_bound v0 v3) => constructive_indefinite_ground_description_nat (fun v4 : @nat => is_upper_bound v0 (inject_Q (BinIntDef.Z.of_nat v4 # 1))) (fun v4 : @nat => is_upper_bound_dec v0 (inject_Q (BinIntDef.Z.of_nat v4 # 1)) v1 v2) match v3 as v4 in (ex _) return (exists v5 : @nat, is_upper_bound v0 (inject_Q (BinIntDef.Z.of_nat v5 # 1))) with | ex_intro _ v4 v5 => (fun (v4 : @CReal) (v5 : is_upper_bound v0 v4) => let v6 : {v6 : @positive & v4 < inject_Q (Z.pos v6 # 1)} := Rup_pos v4 in match v6 as v7 in (sigT _) return (exists v8 : @nat, is_upper_bound v0 (inject_Q (BinIntDef.Z.of_nat v8 # 1))) with | existT _ v7 v8 => (fun (v7 : @positive) (v8 : v4 < inject_Q (Z.pos v7 # 1)) => ex_intro (fun v9 : @nat => is_upper_bound v0 (inject_Q (BinIntDef.Z.of_nat v9 # 1))) (BinPosDef.Pos.to_nat v7) ((fun (v9 : @CReal) (v10 : v0 v9) => let v11 : v9 <= v4 := v5 v9 v10 in CRealLt_asym v9 (inject_Q (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v7) # 1)) (CReal_le_lt_trans v9 v4 (inject_Q (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v7) # 1)) v11 (eq_rec_r (fun v12 : @Z => v4 < inject_Q (v12 # 1)) v8 (positive_nat_Z v7)))) : is_upper_bound v0 (inject_Q (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v7) # 1)))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.is_upper_bound_not_epsilon	100	1.274714	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.DDlow_below_up	100	0.078917	1	1	0	synth with cache (only 1: refine (fun (v0 : @DedekindDecCut) (v1 v2 : @Q) (v3 : DDupcut v0 v1) (v4 : ~ DDupcut v0 v2) => let v5 : {(v2 < v1)%Q} + {(v1 <= v2)%Q} := Qlt_le_dec v2 v1 in match v5 as v6 in ({_} + {_}) return (v2 < v1)%Q with | left v6 => (fun v6 : (v2 < v1)%Q => v6) v6 | right v6 => (fun v6 : (v1 <= v2)%Q => False_ind (v2 < v1)%Q (v4 (DDinterval v0 v1 v2 v6 v3))) v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.DDcut_limit_fix	100	0.041352	2	2
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.DDcut_limit	100	0.994574	1	1	0	synth with cache (only 1: refine (fun (v0 : @DedekindDecCut) (v1 : @Q) (v2 : (0 < v1)%Q) => let v3 : {v3 : @positive | ((DDhigh v0 - DDlow v0) / v1 < Z.pos v3 # 1)%Q} := Qarchimedean ((DDhigh v0 - DDlow v0) / v1) in match v3 as v4 in (sig _) return {v5 : @Q | DDupcut v0 v5 /\ ~ DDupcut v0 (v5 - v1)} with | exist _ v4 v5 => (fun (v4 : @positive) (v5 : ((DDhigh v0 - DDlow v0) / v1 < Z.pos v4 # 1)%Q) => DDcut_limit_fix v0 v1 (BinPosDef.Pos.to_nat v4) v2 (let v6 : forall (v6 : (0 < v1)%Q) (v7 : ((DDhigh v0 - DDlow v0) / v1 < Z.pos v4 # 1)%Q), ((DDhigh v0 - DDlow v0) / v1 * v1 < (Z.pos v4 # 1) * v1)%Q := fun v6 : (0 < v1)%Q => match Qmult_lt_r ((DDhigh v0 - DDlow v0) / v1) (Z.pos v4 # 1) v1 v6 as v7 in (_ /\ _) return (forall v8 : ((DDhigh v0 - DDlow v0) / v1 < Z.pos v4 # 1)%Q, ((DDhigh v0 - DDlow v0) / v1 * v1 < (Z.pos v4 # 1) * v1)%Q) with | conj v7 v8 => (fun (v7 : forall v7 : ((DDhigh v0 - DDlow v0) / v1 * v1 < (Z.pos v4 # 1) * v1)%Q, ((DDhigh v0 - DDlow v0) / v1 < Z.pos v4 # 1)%Q) (v8 : forall v8 : ((DDhigh v0 - DDlow v0) / v1 < Z.pos v4 # 1)%Q, ((DDhigh v0 - DDlow v0) / v1 * v1 < (Z.pos v4 # 1) * v1)%Q) => v8) v7 v8 end in let v7 : ((DDhigh v0 - DDlow v0) / v1 * v1 < (Z.pos v4 # 1) * v1)%Q := v6 v2 v5 in DDinterval v0 (DDhigh v0) (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1) (Qlt_le_weak (DDhigh v0) (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1) (let v8 : forall v8 : (- DDlow v0 + DDhigh v0 < - DDlow v0 + (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1))%Q, (DDhigh v0 < DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q := match Qplus_lt_r (DDhigh v0) (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1) (- DDlow v0) as v8 in (_ /\ _) return (forall v9 : (- DDlow v0 + DDhigh v0 < - DDlow v0 + (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1))%Q, (DDhigh v0 < DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q) with | conj v8 v9 => (fun (v8 : forall v8 : (- DDlow v0 + DDhigh v0 < - DDlow v0 + (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1))%Q, (DDhigh v0 < DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q) (v9 : forall v9 : (DDhigh v0 < DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q, (- DDlow v0 + DDhigh v0 < - DDlow v0 + (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1))%Q) => v8) v8 v9 end in v8 ((fun v9 : (- DDlow v0 + (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1) == - DDlow v0 + DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (- DDlow v0 + DDhigh v0)%Q) (- DDlow v0 + (DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1))%Q (- DDlow v0 + DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q v9) (Qplus_assoc (- DDlow v0) (DDlow v0) ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)) ((fun v9 : (DDlow v0 + - DDlow v0 == - DDlow v0 + DDlow v0)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (- DDlow v0 + DDhigh v0)%Q) (- DDlow v0 + DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q (DDlow v0 + - DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q (Qplus_comp (- DDlow v0 + DDlow v0)%Q (DDlow v0 + - DDlow v0)%Q (symmetry v9) ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q (reflexive_proper_proxy Equivalence_Reflexive ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q))) (Qplus_comm (DDlow v0) (- DDlow v0)) ((fun v9 : (DDlow v0 + - DDlow v0 == 0)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (- DDlow v0 + DDhigh v0)%Q) (DDlow v0 + - DDlow v0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q (0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q (Qplus_comp (DDlow v0 + - DDlow v0)%Q 0 v9 ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q (reflexive_proper_proxy Equivalence_Reflexive ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q))) (Qplus_opp_r (DDlow v0)) ((fun v9 : (0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1 == (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive (- DDlow v0 + DDhigh v0)%Q) (0 + (BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q v9) (Qplus_0_l ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)) ((fun v9 : (- DDlow v0 + DDhigh v0 == DDhigh v0 + - DDlow v0)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_flip_impl_subrelation))) (- DDlow v0 + DDhigh v0)%Q (DDhigh v0 + - DDlow v0)%Q v9 ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q (reflexive_proper_proxy Equivalence_Reflexive ((BinIntDef.Z.of_nat (BinPosDef.Pos.to_nat v4) # 1) * v1)%Q)) (Qplus_comm (- DDlow v0) (DDhigh v0)) (eq_ind_r (fun v9 : @Z => (DDhigh v0 + - DDlow v0 < (v9 # 1) * v1)%Q) ((fun v9 : ((DDhigh v0 - DDlow v0) * 1 == DDhigh v0 - DDlow v0)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_impl_subrelation))) ((DDhigh v0 - DDlow v0) * 1)%Q (DDhigh v0 - DDlow v0)%Q v9 ((Z.pos v4 # 1) * v1)%Q ((Z.pos v4 # 1) * v1)%Q (reflexive_proper_proxy Equivalence_Reflexive ((Z.pos v4 # 1) * v1)%Q)) (Qmult_1_r (DDhigh v0 - DDlow v0)) ((fun v9 : (v1 * / v1 == 1)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_impl_subrelation))) ((DDhigh v0 - DDlow v0) * (v1 * / v1))%Q ((DDhigh v0 - DDlow v0) * 1)%Q (Reflexive_partial_app_morphism (@Qmult_comp) (reflexive_proper_proxy Equivalence_Reflexive (DDhigh v0 - DDlow v0)%Q) (v1 * / v1)%Q 1 v9) ((Z.pos v4 # 1) * v1)%Q ((Z.pos v4 # 1) * v1)%Q (reflexive_proper_proxy Equivalence_Reflexive ((Z.pos v4 # 1) * v1)%Q)) (Qmult_inv_r v1 ((fun v9 : (v1 == 0)%Q => Qlt_irrefl 0 ((fun v10 : (v1 == 0)%Q => Reflexive_partial_app_morphism (subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_impl_subrelation)))) (reflexive_proper_proxy Equivalence_Reflexive 0) v1 0 v10) v9 v2)) : ~ (v1 == 0)%Q)) ((fun v9 : (/ v1 * v1 == v1 * / v1)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_impl_subrelation))) ((DDhigh v0 - DDlow v0) * (/ v1 * v1))%Q ((DDhigh v0 - DDlow v0) * (v1 * / v1))%Q (Reflexive_partial_app_morphism (@Qmult_comp) (reflexive_proper_proxy Equivalence_Reflexive (DDhigh v0 - DDlow v0)%Q) (/ v1 * v1)%Q (v1 * / v1)%Q v9) ((Z.pos v4 # 1) * v1)%Q ((Z.pos v4 # 1) * v1)%Q (reflexive_proper_proxy Equivalence_Reflexive ((Z.pos v4 # 1) * v1)%Q)) (Qmult_comm (/ v1) v1) ((fun v9 : ((DDhigh v0 - DDlow v0) * (/ v1 * v1) == (DDhigh v0 - DDlow v0) * / v1 * v1)%Q => subrelation_proper (@Qlt_compat) (@tt) (subrelation_respectful (subrelation_refl (@Qeq)) (subrelation_respectful (subrelation_refl (@Qeq)) (@iff_impl_subrelation))) ((DDhigh v0 - DDlow v0) * / v1 * v1)%Q ((DDhigh v0 - DDlow v0) * (/ v1 * v1))%Q (symmetry v9) ((Z.pos v4 # 1) * v1)%Q ((Z.pos v4 # 1) * v1)%Q (reflexive_proper_proxy Equivalence_Reflexive ((Z.pos v4 # 1) * v1)%Q)) (Qmult_assoc (DDhigh v0 - DDlow v0) (/ v1) v1) v7)))) (positive_nat_Z v4))))))))) (DDhighProp v0))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.glb_dec_Q	100	9.057942	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.is_upper_bound_glb	100	0.539832	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @CReal, Prop) (v1 : @sig_not_dec_T) (v2 : @sig_forall_dec_T) (v3 : exists v3 : @CReal, v0 v3) (v4 : exists v4 : @CReal, is_upper_bound v0 v4) => let v5 : {v5 : @nat | is_upper_bound v0 (inject_Q (BinIntDef.Z.of_nat v5 # 1))} := is_upper_bound_epsilon v0 v2 v1 v4 in match v5 as v6 in (sig _) return {v7 : @CReal | forall v8 : @Q, (forall v9 : v7 < inject_Q v8, is_upper_bound v0 (inject_Q v8)) /\ (forall v9 : inject_Q v8 < v7, ~ is_upper_bound v0 (inject_Q v8))} with | exist _ v6 v7 => (fun (v6 : @nat) (v7 : is_upper_bound v0 (inject_Q (BinIntDef.Z.of_nat v6 # 1))) => let v8 : {v8 : @nat | ~ is_upper_bound v0 (- inject_Q (BinIntDef.Z.of_nat v8 # 1))} := is_upper_bound_not_epsilon v0 v2 v1 v3 in match v8 as v9 in (sig _) return {v10 : @CReal | forall v11 : @Q, (forall v12 : v10 < inject_Q v11, is_upper_bound v0 (inject_Q v11)) /\ (forall v12 : inject_Q v11 < v10, ~ is_upper_bound v0 (inject_Q v11))} with | exist _ v9 v10 => (fun (v9 : @nat) (v10 : ~ is_upper_bound v0 (- inject_Q (BinIntDef.Z.of_nat v9 # 1))) => let v11 : forall v11 : @Q, Prop := fun v11 : @Q => is_upper_bound v0 (inject_Q v11) in let v12 : forall v12 : @Q, {v11 v12} + {~ v11 v12} := fun v12 : @Q => is_upper_bound_dec v0 (inject_Q v12) v2 v1 in let v13 : forall (v13 v14 : @Q) (v15 : (v13 <= v14)%Q) (v16 : v11 v13), v11 v14 := fun (v13 v14 : @Q) (v15 : (v13 <= v14)%Q) (v16 : v11 v13) => (fun (v17 : @CReal) (v18 : v0 v17) => let v19 : v17 <= inject_Q v13 := v16 v17 v18 in (fun v20 : inject_Q v14 < v17 => v19 (CReal_le_lt_trans (inject_Q v13) (inject_Q v14) v17 (inject_Q_le v13 v14 v15) v20)) : v17 <= inject_Q v14) : v11 v14 in let v14 : v11 (BinIntDef.Z.of_nat v6 # 1)%Q := (fun (v14 : @CReal) (v15 : v0 v14) => v7 v14 v15) : v11 (BinIntDef.Z.of_nat v6 # 1)%Q in let v15 : ~ v11 (- BinIntDef.Z.of_nat v9 # 1)%Q := (fun v15 : v11 (- BinIntDef.Z.of_nat v9 # 1)%Q => v10 ((fun (v16 : @CReal) (v17 : v0 v16) => let v18 : v16 <= inject_Q (- BinIntDef.Z.of_nat v9 # 1) := v15 v16 v17 in (fun v19 : inject_Q (- (BinIntDef.Z.of_nat v9 # 1)) == - inject_Q (BinIntDef.Z.of_nat v9 # 1) => Reflexive_partial_app_morphism (subrelation_proper (@CRealLe_morph_Proper) (@tt) (subrelation_respectful (subrelation_refl (@CRealEq)) (subrelation_respectful (subrelation_refl (@CRealEq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) v16) (- inject_Q (BinIntDef.Z.of_nat v9 # 1)) (inject_Q (- (BinIntDef.Z.of_nat v9 # 1))) (symmetry v19)) (opp_inject_Q (BinIntDef.Z.of_nat v9 # 1)) v18) : is_upper_bound v0 (- inject_Q (BinIntDef.Z.of_nat v9 # 1)))) : ~ v11 (- BinIntDef.Z.of_nat v9 # 1)%Q in let v16 : forall (v16 v17 : @Q) (v18 : (v16 == v17)%Q) (v19 : v11 v16), v11 v17 := fun (v16 v17 : @Q) (v18 : (v16 == v17)%Q) (v19 : v11 v16) => (fun (v20 : @CReal) (v21 : v0 v20) => let v22 : v20 <= inject_Q v16 := v19 v20 v21 in (fun v23 : (v16 == v17)%Q => Reflexive_partial_app_morphism (subrelation_proper (@CRealLe_morph_Proper) (@tt) (subrelation_respectful (subrelation_refl (@CRealEq)) (subrelation_respectful (subrelation_refl (@CRealEq)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@CRealEq_rel_Reflexive) v20) (inject_Q v17) (inject_Q v16) (inject_Q_morph_Proper v17 v16 (symmetry v23))) v18 v22) : v11 v17 in let v17 : {v17 : @CReal | forall v18 : @Q, (forall v19 : v17 < inject_Q v18, DDupcut {| DDupcut := v11; DDproper := v16; DDlow := - BinIntDef.Z.of_nat v9 # 1; DDhigh := BinIntDef.Z.of_nat v6 # 1; DDdec := v12; DDinterval := v13; DDhighProp := v14; DDlowProp := v15 |} v18) /\ (forall v19 : inject_Q v18 < v17, ~ DDupcut {| DDupcut := v11; DDproper := v16; DDlow := - BinIntDef.Z.of_nat v9 # 1; DDhigh := BinIntDef.Z.of_nat v6 # 1; DDdec := v12; DDinterval := v13; DDhighProp := v14; DDlowProp := v15 |} v18)} := glb_dec_Q {| DDupcut := v11; DDproper := v16; DDlow := - BinIntDef.Z.of_nat v9 # 1; DDhigh := BinIntDef.Z.of_nat v6 # 1; DDdec := v12; DDinterval := v13; DDhighProp := v14; DDlowProp := v15 |} in match v17 as v18 in (sig _) return {v19 : @CReal | forall v20 : @Q, (forall v21 : v19 < inject_Q v20, is_upper_bound v0 (inject_Q v20)) /\ (forall v21 : inject_Q v20 < v19, ~ is_upper_bound v0 (inject_Q v20))} with | exist _ v18 v19 => (fun (v18 : @CReal) (v19 : forall v19 : @Q, (forall v20 : v18 < inject_Q v19, DDupcut {| DDupcut := v11; DDproper := v16; DDlow := - BinIntDef.Z.of_nat v9 # 1; DDhigh := BinIntDef.Z.of_nat v6 # 1; DDdec := v12; DDinterval := v13; DDhighProp := v14; DDlowProp := v15 |} v19) /\ (forall v20 : inject_Q v19 < v18, ~ DDupcut {| DDupcut := v11; DDproper := v16; DDlow := - BinIntDef.Z.of_nat v9 # 1; DDhigh := BinIntDef.Z.of_nat v6 # 1; DDdec := v12; DDinterval := v13; DDhighProp := v14; DDlowProp := v15 |} v19)) => exist (fun v20 : @CReal => forall v21 : @Q, (forall v22 : v20 < inject_Q v21, is_upper_bound v0 (inject_Q v21)) /\ (forall v22 : inject_Q v21 < v20, ~ is_upper_bound v0 (inject_Q v21))) v18 (fun v20 : @Q => conj (fun v21 : v18 < inject_Q v20 => let v22 : forall (v22 : @Q) (v23 : v18 < inject_Q v22), v11 v22 := fun v22 : @Q => match v19 v22 as v23 in (_ /\ _) return (forall v24 : v18 < inject_Q v22, v11 v22) with | conj v23 v24 => (fun (v23 : forall v23 : v18 < inject_Q v22, v11 v22) (v24 : forall v24 : inject_Q v22 < v18, ~ v11 v22) => v23) v23 v24 end in v22 v20 v21) (fun v21 : inject_Q v20 < v18 => (fun v22 : is_upper_bound v0 (inject_Q v20) => let v23 : (forall v23 : v18 < inject_Q v20, v11 v20) /\ (forall v23 : inject_Q v20 < v18, ~ v11 v20) := v19 v20 in match v23 as v24 in (_ /\ _) return (@False) with | conj v24 v25 => (fun (v24 : forall v24 : v18 < inject_Q v20, v11 v20) (v25 : forall v25 : inject_Q v20 < v18, ~ v11 v20) => v25 v21 v22) v24 v25 end) : ~ is_upper_bound v0 (inject_Q v20)))) v18 v19 end) v9 v10 end) v6 v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.is_upper_bound_closed	100	0.425619	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @CReal, Prop) (v1 : @sig_forall_dec_T) (v2 : @sig_not_dec_T) (v3 : exists v3 : @CReal, v0 v3) (v4 : exists v4 : @CReal, is_upper_bound v0 v4) => conj ((fun (v5 : @CReal) (v6 : v0 v5) => let v7 : {v7 : @CReal | forall v8 : @Q, (forall v9 : v7 < inject_Q v8, is_upper_bound v0 (inject_Q v8)) /\ (forall v9 : inject_Q v8 < v7, ~ is_upper_bound v0 (inject_Q v8))} := is_upper_bound_glb v0 v2 v1 v3 v4 in match v7 as v8 in (sig _) return (v5 <= proj1_sig v8) with | exist _ v8 v9 => (fun (v8 : @CReal) (v9 : forall v9 : @Q, (forall v10 : v8 < inject_Q v9, is_upper_bound v0 (inject_Q v9)) /\ (forall v10 : inject_Q v9 < v8, ~ is_upper_bound v0 (inject_Q v9))) => ((fun v10 : v8 < v5 => let v11 : {v11 : @Q & v8 < inject_Q v11 < v5} := FQ_dense v8 v5 v10 in match v11 as v12 in (sigT _) return (@False) with | existT _ v12 v13 => (fun (v12 : @Q) (v13 : v8 < inject_Q v12 < v5) => match v13 as v14 in (_ * _)%type return (@False) with | (v14, v15) => (fun (v14 : v8 < inject_Q v12) (v15 : inject_Q v12 < v5) => let v16 : (forall v16 : v8 < inject_Q v12, is_upper_bound v0 (inject_Q v12)) /\ (forall v16 : inject_Q v12 < v8, ~ is_upper_bound v0 (inject_Q v12)) := v9 v12 in match v16 as v17 in (_ /\ _) return (@False) with | conj v17 v18 => (fun (v17 : forall v17 : v8 < inject_Q v12, is_upper_bound v0 (inject_Q v12)) (v18 : forall v18 : inject_Q v12 < v8, ~ is_upper_bound v0 (inject_Q v12)) => let v19 : v5 <= inject_Q v12 := v17 v14 v5 v6 in False_ind (@False) (v19 v15)) v17 v18 end) v14 v15 end) v12 v13 end) : v5 <= v8) : v5 <= proj1_sig (exist (fun v10 : @CReal => forall v11 : @Q, (forall v12 : v10 < inject_Q v11, is_upper_bound v0 (inject_Q v11)) /\ (forall v12 : inject_Q v11 < v10, ~ is_upper_bound v0 (inject_Q v11))) v8 v9)) v8 v9 end) : is_upper_bound v0 (proj1_sig (is_upper_bound_glb v0 v2 v1 v3 v4))) (fun (v5 : @CReal) (v6 : is_upper_bound v0 v5) => let v7 : {v7 : @CReal | forall v8 : @Q, (forall v9 : v7 < inject_Q v8, is_upper_bound v0 (inject_Q v8)) /\ (forall v9 : inject_Q v8 < v7, ~ is_upper_bound v0 (inject_Q v8))} := is_upper_bound_glb v0 v2 v1 v3 v4 in match v7 as v8 in (sig _) return (proj1_sig v8 <= v5) with | exist _ v8 v9 => (fun (v8 : @CReal) (v9 : forall v9 : @Q, (forall v10 : v8 < inject_Q v9, is_upper_bound v0 (inject_Q v9)) /\ (forall v10 : inject_Q v9 < v8, ~ is_upper_bound v0 (inject_Q v9))) => ((fun v10 : v5 < v8 => let v11 : {v11 : @Q & v5 < inject_Q v11 < v8} := FQ_dense v5 v8 v10 in match v11 as v12 in (sigT _) return (@False) with | existT _ v12 v13 => (fun (v12 : @Q) (v13 : v5 < inject_Q v12 < v8) => match v13 as v14 in (_ * _)%type return (@False) with | (v14, v15) => (fun (v14 : v5 < inject_Q v12) (v15 : inject_Q v12 < v8) => let v16 : (forall v16 : v8 < inject_Q v12, is_upper_bound v0 (inject_Q v12)) /\ (forall v16 : inject_Q v12 < v8, ~ is_upper_bound v0 (inject_Q v12)) := v9 v12 in match v16 as v17 in (_ /\ _) return (@False) with | conj v17 v18 => (fun (v17 : forall v17 : v8 < inject_Q v12, is_upper_bound v0 (inject_Q v12)) (v18 : forall v18 : inject_Q v12 < v8, ~ is_upper_bound v0 (inject_Q v12)) => v18 v15 ((fun (v19 : @CReal) (v20 : v0 v19) => let v21 : v19 <= v5 := v6 v19 v20 in (fun v22 : inject_Q v12 < v19 => v21 (CReal_lt_trans v5 (inject_Q v12) v19 v14 v22)) : v19 <= inject_Q v12) : is_upper_bound v0 (inject_Q v12))) v17 v18 end) v14 v15 end) v12 v13 end) : v8 <= v5) : proj1_sig (exist (fun v10 : @CReal => forall v11 : @Q, (forall v12 : v10 < inject_Q v11, is_upper_bound v0 (inject_Q v11)) /\ (forall v12 : inject_Q v11 < v10, ~ is_upper_bound v0 (inject_Q v11))) v8 v9) <= v5) v8 v9 end))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.sig_lub	100	0.138649	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @CReal, Prop) (v1 : @sig_forall_dec_T) (v2 : @sig_not_dec_T) (v3 : exists v3 : @CReal, v0 v3) (v4 : exists v4 : @CReal, is_upper_bound v0 v4) => let v5 : is_lub v0 (proj1_sig (is_upper_bound_glb v0 v2 v1 v3 v4)) := is_upper_bound_closed v0 v1 v2 v3 v4 in let v6 : {v6 : @CReal | forall v7 : @Q, (forall v8 : v6 < inject_Q v7, is_upper_bound v0 (inject_Q v7)) /\ (forall v8 : inject_Q v7 < v6, ~ is_upper_bound v0 (inject_Q v7))} := is_upper_bound_glb v0 v2 v1 v3 v4 in match v6 as v7 in (sig _) return (forall v8 : is_lub v0 (proj1_sig v7), {v9 : @CReal | is_lub v0 v9}) with | exist _ v7 v8 => (fun (v7 : @CReal) (v8 : forall v8 : @Q, (forall v9 : v7 < inject_Q v8, is_upper_bound v0 (inject_Q v8)) /\ (forall v9 : inject_Q v8 < v7, ~ is_upper_bound v0 (inject_Q v8))) (v9 : is_lub v0 (proj1_sig (exist (fun v9 : @CReal => forall v10 : @Q, (forall v11 : v9 < inject_Q v10, is_upper_bound v0 (inject_Q v10)) /\ (forall v11 : inject_Q v10 < v9, ~ is_upper_bound v0 (inject_Q v10))) v7 v8))) => exist (fun v10 : @CReal => is_lub v0 v10) v7 v9) v7 v8 end v5)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ConstructiveRealsLUB.CR_sig_lub	100	0.563866	1	1	0	synth with cache (only 1: refine (fun (v0 : @ConstructiveReals) (v1 : forall v1 : CRcarrier v0, Prop) (v2 : forall (v2 v3 : CRcarrier v0) (v4 : orderEq (CRcarrier v0) (CRlt v0) v2 v3), v1 v2 <-> v1 v3) (v3 : @sig_forall_dec_T) (v4 : @sig_not_dec_T) (v5 : exists v5 : CRcarrier v0, v1 v5) (v6 : exists v6 : CRcarrier v0, CRis_upper_bound v0 v1 v6) => let v7 : {v7 : @CReal | is_lub (fun v8 : @CReal => v1 (CauchyMorph v0 v8)) v7} := sig_lub (fun v7 : @CReal => v1 (CauchyMorph v0 v7)) v3 v4 match v5 as v7 in (ex _) return (exists v8 : @CReal, v1 (CauchyMorph v0 v8)) with | ex_intro _ v7 v8 => (fun (v7 : CRcarrier v0) (v8 : v1 v7) => ex_intro (fun v9 : @CReal => v1 (CauchyMorph v0 v9)) (CauchyMorph_inv v0 v7) (let v9 : v1 (CauchyMorph v0 (CauchyMorph_inv v0 v7)) <-> v1 v7 := v2 (CauchyMorph v0 (CauchyMorph_inv v0 v7)) v7 (CauchyMorph_surject v0 v7) in match v9 as v10 in (_ /\ _) return (v1 (CauchyMorph v0 (CauchyMorph_inv v0 v7))) with | conj v10 v11 => (fun (v10 : forall v10 : v1 (CauchyMorph v0 (CauchyMorph_inv v0 v7)), v1 v7) (v11 : forall v11 : v1 v7, v1 (CauchyMorph v0 (CauchyMorph_inv v0 v7))) => v11 v8) v10 v11 end)) v7 v8 end match v6 as v7 in (ex _) return (exists v8 : @CReal, is_upper_bound (fun v9 : @CReal => v1 (CauchyMorph v0 v9)) v8) with | ex_intro _ v7 v8 => (fun (v7 : CRcarrier v0) (v8 : CRis_upper_bound v0 v1 v7) => ex_intro (fun v9 : @CReal => is_upper_bound (fun v10 : @CReal => v1 (CauchyMorph v0 v10)) v9) (CauchyMorph_inv v0 v7) ((fun (v9 : @CReal) (v10 : v1 (CauchyMorph v0 v9)) => let v11 : forall v11 : CRlt v0 v7 (CauchyMorph v0 v9), @False := v8 (CauchyMorph v0 v9) v10 in (fun v12 : CauchyMorph_inv v0 v7 < v9 => v11 (let v13 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v7)) (CauchyMorph v0 v9) := CauchyMorph_increasing v0 (CauchyMorph_inv v0 v7) v9 v12 in CRle_lt_trans v0 v7 (CauchyMorph v0 (CauchyMorph_inv v0 v7)) (CauchyMorph v0 v9) (let v14 : forall v14 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v7)) v7, @False := match CauchyMorph_surject v0 v7 as v14 in (_ /\ _) return (forall v15 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v7)) v7, @False) with | conj v14 v15 => (fun (v14 : forall v14 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v7)) v7, @False) (v15 : forall v15 : CRlt v0 v7 (CauchyMorph v0 (CauchyMorph_inv v0 v7)), @False) => v14) v14 v15 end in v14) v13)) : v9 <= CauchyMorph_inv v0 v7) : is_upper_bound (fun v9 : @CReal => v1 (CauchyMorph v0 v9)) (CauchyMorph_inv v0 v7))) v7 v8 end in match v7 as v8 in (sig _) return {v9 : CRcarrier v0 | CRis_upper_bound v0 v1 v9 /\ (forall (v10 : CRcarrier v0) (v11 : CRis_upper_bound v0 v1 v10) (v12 : CRlt v0 v10 v9), @False)} with | exist _ v8 v9 => (fun (v8 : @CReal) (v9 : is_lub (fun v9 : @CReal => v1 (CauchyMorph v0 v9)) v8) => exist (fun v10 : CRcarrier v0 => CRis_upper_bound v0 v1 v10 /\ (forall (v11 : CRcarrier v0) (v12 : CRis_upper_bound v0 v1 v11) (v13 : CRlt v0 v11 v10), @False)) (CauchyMorph v0 v8) match v9 as v10 in (_ /\ _) return (CRis_upper_bound v0 v1 (CauchyMorph v0 v8) /\ (forall (v11 : CRcarrier v0) (v12 : CRis_upper_bound v0 v1 v11) (v13 : CRlt v0 v11 (CauchyMorph v0 v8)), @False)) with | conj v10 v11 => (fun (v10 : is_upper_bound (fun v10 : @CReal => v1 (CauchyMorph v0 v10)) v8) (v11 : forall (v11 : @CReal) (v12 : is_upper_bound (fun v12 : @CReal => v1 (CauchyMorph v0 v12)) v11), v8 <= v11) => conj ((fun (v12 : CRcarrier v0) (v13 : v1 v12) (v14 : CRlt v0 (CauchyMorph v0 v8) v12) => let v15 : forall v15 : (fun v15 : @CReal => v1 (CauchyMorph v0 v15)) (CauchyMorph_inv v0 v12), CauchyMorph_inv v0 v12 <= v8 := v10 (CauchyMorph_inv v0 v12) in let v16 : v1 (CauchyMorph v0 (CauchyMorph_inv v0 v12)) <-> v1 v12 := v2 (CauchyMorph v0 (CauchyMorph_inv v0 v12)) v12 (CauchyMorph_surject v0 v12) in match v16 as v17 in (_ /\ _) return (@False) with | conj v17 v18 => (fun (v17 : forall v17 : v1 (CauchyMorph v0 (CauchyMorph_inv v0 v12)), v1 v12) (v18 : forall v18 : v1 v12, v1 (CauchyMorph v0 (CauchyMorph_inv v0 v12))) => let v19 : CauchyMorph_inv v0 v12 <= v8 := v15 (v18 v13) in v19 (let v20 : CauchyMorph_inv v0 (CauchyMorph v0 v8) < CauchyMorph_inv v0 v12 := CauchyMorph_inv_increasing v0 (CauchyMorph v0 v8) v12 v14 in (fun v21 : CauchyMorph_inv v0 (CauchyMorph v0 v8) == v8 => CMorphisms.subrelation_proper (@CRealLt_morph) (@tt) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (@CMorphisms.iffT_arrow_subrelation))) (CauchyMorph_inv v0 (CauchyMorph v0 v8)) v8 v21 (CauchyMorph_inv v0 v12) (CauchyMorph_inv v0 v12) (CMorphisms.reflexive_proper_proxy CRelationClasses.Equivalence_Reflexive (CauchyMorph_inv v0 v12))) (CauchyMorph_inject v0 v8) v20)) v17 v18 end) : CRis_upper_bound v0 v1 (CauchyMorph v0 v8)) (fun (v12 : CRcarrier v0) (v13 : CRis_upper_bound v0 v1 v12) (v14 : CRlt v0 v12 (CauchyMorph v0 v8)) => v11 (CauchyMorph_inv v0 v12) ((fun (v15 : @CReal) (v16 : v1 (CauchyMorph v0 v15)) => (fun v17 : CauchyMorph_inv v0 v12 < v15 => let v18 : forall (v18 : v1 (CauchyMorph v0 v15)) (v19 : CRlt v0 v12 (CauchyMorph v0 v15)), @False := v13 (CauchyMorph v0 v15) in v18 v16 (let v19 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v12)) (CauchyMorph v0 v15) := CauchyMorph_increasing v0 (CauchyMorph_inv v0 v12) v15 v17 in CRle_lt_trans v0 v12 (CauchyMorph v0 (CauchyMorph_inv v0 v12)) (CauchyMorph v0 v15) (let v20 : forall v20 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v12)) v12, @False := match CauchyMorph_surject v0 v12 as v20 in (_ /\ _) return (forall v21 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v12)) v12, @False) with | conj v20 v21 => (fun (v20 : forall v20 : CRlt v0 (CauchyMorph v0 (CauchyMorph_inv v0 v12)) v12, @False) (v21 : forall v21 : CRlt v0 v12 (CauchyMorph v0 (CauchyMorph_inv v0 v12)), @False) => v20) v20 v21 end in v20) v19)) : v15 <= CauchyMorph_inv v0 v12) : is_upper_bound (fun v15 : @CReal => v1 (CauchyMorph v0 v15)) (CauchyMorph_inv v0 v12)) (let v15 : CauchyMorph_inv v0 v12 < CauchyMorph_inv v0 (CauchyMorph v0 v8) := CauchyMorph_inv_increasing v0 v12 (CauchyMorph v0 v8) v14 in (fun v16 : CauchyMorph_inv v0 (CauchyMorph v0 v8) == v8 => CMorphisms.Reflexive_partial_app_morphism (CMorphisms.subrelation_proper (@CRealLt_morph) (@tt) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (CMorphisms.subrelation_respectful (CMorphisms.subrelation_refl (@CRealEq)) (@CMorphisms.iffT_arrow_subrelation)))) (CMorphisms.reflexive_proper_proxy CRelationClasses.Equivalence_Reflexive (CauchyMorph_inv v0 v12)) (CauchyMorph_inv v0 (CauchyMorph v0 v8)) v8 v16) (CauchyMorph_inject v0 v8) v15))) v10 v11 end) v8 v9 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.DiscrR.Rlt_R0_R2	100	0.038238	1	1	0	synth with cache (only 1: refine (lt_0_INR 2 (Nat.lt_0_succ 1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.DiscrR.IZR_eq	100	0.052935	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Z) (v2 : v0 = v1) => eq_ind_r (fun v3 : @Z => IZR v3 = IZR v1) eq_refl v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ROrderedType.Req_dec	100	0.100927	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : {v0 < v1} + {v0 = v1} + {v1 < v0} := total_order_T v0 v1 in match v2 as v3 in (_ + {_}) return ({v0 = v1} + {v0 <> v1}) with | inleft v3 => (fun v3 : {v0 < v1} + {v0 = v1} => match v3 as v4 in ({_} + {_}) return ({v0 = v1} + {v0 <> v1}) with | left v4 => (fun v4 : v0 < v1 => right ((fun v5 : v0 = v1 => eq_ind_r (fun v6 : @R => forall v7 : v6 < v1, @False) (fun v6 : v1 < v1 => False_ind (@False) (Rlt_irrefl v1 v6)) v5 v4) : v0 <> v1)) v4 | right v4 => (fun v4 : v0 = v1 => left v4) v4 end) v3 | inright v3 => (fun v3 : v1 < v0 => right ((fun v4 : v0 = v1 => eq_ind_r (fun v5 : @R => forall v6 : v1 < v5, @False) (fun v5 : v1 < v1 => False_ind (@False) (Rlt_irrefl v1 v5)) v4 v3) : v0 <> v1)) v3 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ROrderedType.Reqb_eq	100	0.105529	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (let v2 : {v0 = v1} + {v0 <> v1} := Req_dec v0 v1 in match v2 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@bool) with | left v4 => (fun v4 : v0 = v1 => @true) v4 | right v4 => (fun v4 : v0 <> v1 => @false) v4 end = @true <-> v0 = v1) with | left v3 => (fun v3 : v0 = v1 => conj (fun v4 : @true = @true => v3) (fun v4 : v0 = v1 => eq_refl) : @true = @true <-> v0 = v1) v3 | right v3 => (fun v3 : v0 <> v1 => conj (fun v4 : @false = @true => let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (v0 = v1) v5) (fun v4 : v0 = v1 => False_ind (@false = @true) (v3 v4))) v3 end) : Reqb v0 v1 = @true <-> v0 = v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ROrderedType.Rcompare_spec	100	0.128049	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (let v2 : {v0 < v1} + {v0 = v1} + {v1 < v0} := total_order_T v0 v1 in match v2 as v3 in (_ + {_}) return (CompareSpec (v0 = v1) (v0 < v1) (v1 < v0) match v3 as v4 in (_ + {_}) return (@comparison) with | inleft v4 => (fun v4 : {v0 < v1} + {v0 = v1} => match v4 as v5 in ({_} + {_}) return (@comparison) with | left v5 => (fun v5 : v0 < v1 => @Lt) v5 | right v5 => (fun v5 : v0 = v1 => @Eq) v5 end) v4 | inright v4 => (fun v4 : v1 < v0 => @Gt) v4 end) with | inleft v3 => (fun v3 : {v0 < v1} + {v0 = v1} => match v3 as v4 in ({_} + {_}) return (CompareSpec (v0 = v1) (v0 < v1) (v1 < v0) match v4 as v5 in ({_} + {_}) return (@comparison) with | left v5 => (fun v5 : v0 < v1 => @Lt) v5 | right v5 => (fun v5 : v0 = v1 => @Eq) v5 end) with | left v4 => (fun v4 : v0 < v1 => CompLt (v0 = v1) (v1 < v0) v4) v4 | right v4 => (fun v4 : v0 = v1 => CompEq (v0 < v1) (v1 < v0) v4) v4 end) v3 | inright v3 => (fun v3 : v1 < v0 => CompGt (v0 = v1) (v0 < v1) v3) v3 end) : CompareSpec (v0 = v1) (v0 < v1) (v1 < v0) (Rcompare v0 v1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ROrderedType.R_as_OT.lt_strorder	100	0.034676	1	1	0	synth with cache (only 1: refine {| StrictOrder_Irreflexive := @Rlt_irrefl; StrictOrder_Transitive := @Rlt_trans |}).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ROrderedType.R_as_OT.lt_compat	100	0.115884	1	1	0	synth with cache (only 1: refine (((((fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => (forall v7 : v6 < v3, v1 < v4) /\ (forall v7 : v1 < v4, v6 < v3)) (eq_ind_r (fun v6 : @R => (forall v7 : v1 < v6, v1 < v4) /\ (forall v7 : v1 < v4, v1 < v6)) (conj (fun v6 : v1 < v4 => v6) (fun v6 : v1 < v4 => v6)) v5) v2) : forall (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4), v0 < v3 <-> v1 < v4) : forall (v0 v1 : @R) (v2 : v0 = v1), (Logic.eq ==> @iff)%signature (Rlt v0) (Rlt v1)) : (Logic.eq ==> Logic.eq ==> @iff)%signature (@Rlt) (@Rlt)) : Proper (Logic.eq ==> Logic.eq ==> @iff) (@Rlt))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.ROrderedType.R_as_OT.le_lteq	100	0.081258	1	1	0	synth with cache (only 1: refine ((fun v0 v1 : @R => reflexivity (v0 < v1 \/ v0 = v1)) : forall v0 v1 : @R, v0 <= v1 <-> v0 < v1 \/ v0 = v1)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Rsrt	100	0.126581	1	1	0	synth with cache (only 1: refine {| Radd_0_l := @Rplus_0_l; Radd_comm := @Rplus_comm; Radd_assoc := fun v0 v1 v2 : @R => eq_ind_r (fun v3 : @R => (v0 + (v1 + v2))%R = v3) eq_refl (Rplus_assoc v0 v1 v2); Rmul_1_l := @Rmult_1_l; Rmul_comm := @Rmult_comm; Rmul_assoc := fun v0 v1 v2 : @R => eq_ind_r (fun v3 : @R => (v0 * (v1 * v2))%R = v3) eq_refl (Rmult_assoc v0 v1 v2); Rdistr_l := fun v0 v1 v2 : @R => eq_ind_r (fun v3 : @R => v3 = (v0 * v2 + v1 * v2)%R) (eq_ind_r (fun v3 : @R => v3 = (v0 * v2 + v1 * v2)%R) (eq_ind_r (fun v3 : @R => (v3 + v2 * v1)%R = (v0 * v2 + v1 * v2)%R) (eq_ind_r (fun v3 : @R => (v0 * v2 + v3)%R = (v0 * v2 + v1 * v2)%R) eq_refl (Rmult_comm v2 v1)) (Rmult_comm v2 v0)) (Rmult_plus_distr_l v2 v0 v1)) (Rmult_comm (v0 + v1) v2); Rsub_def := fun v0 v1 : @R => eq_refl; Ropp_def := @Rplus_opp_r |}).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Rsor	100	0.267999	1	1	0	synth with cache (only 1: refine {| SORsetoid := {| Equivalence_Reflexive := fun v0 : @R => eq_refl; Equivalence_Symmetric := (fun (v0 v1 : @R) (v2 : v0 = v1) => eq_sym v2) : Symmetric eq; Equivalence_Transitive := (fun (v0 v1 v2 : @R) (v3 : v0 = v1) (v4 : v1 = v2) => eq_ind_r (fun v5 : @R => v5 = v2) (eq_ind_r (fun v5 : @R => v5 = v2) eq_refl v4) v3) : Transitive eq |}; SORplus_wd := fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 + v3 = v1 + v4) (eq_ind_r (fun v6 : @R => v1 + v6 = v1 + v4) eq_refl v5) v2; SORtimes_wd := fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 * v3 = v1 * v4) (eq_ind_r (fun v6 : @R => v1 * v6 = v1 * v4) eq_refl v5) v2; SORopp_wd := fun (v0 v1 : @R) (v2 : v0 = v1) => eq_ind_r (fun v3 : @R => - v3 = - v1) eq_refl v2; SORle_wd := fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 <= v3 <-> v1 <= v4) (eq_ind_r (fun v6 : @R => v1 <= v6 <-> v1 <= v4) (conj (fun v6 : v1 <= v4 => v6) (fun v6 : v1 <= v4 => v6)) v5) v2; SORlt_wd := fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 < v3 <-> v1 < v4) (eq_ind_r (fun v6 : @R => v1 < v6 <-> v1 < v4) (conj (fun v6 : v1 < v4 => v6) (fun v6 : v1 < v4 => v6)) v5) v2; SORrt := @Rsrt; SORle_refl := fun v0 : @R => Req_le_sym v0 v0 eq_refl : v0 <= v0; SORle_antisymm := fun (v0 v1 : @R) (v2 : v0 <= v1) (v3 : v1 <= v0) => Rle_antisym v0 v1 v2 v3 : v0 = v1; SORle_trans := fun (v0 v1 v2 : @R) (v3 : v0 <= v1) (v4 : v1 <= v2) => Rle_trans v0 v1 v2 v3 v4; SORlt_le_neq := fun v0 v1 : @R => conj (fun v2 : v0 < v1 => conj (Rlt_le v0 v1 v2 : v0 <= v1) ((fun v3 : v0 = v1 => eq_ind_r (fun v4 : @R => forall v5 : v4 < v1, @False) (fun v4 : v1 < v1 => Rlt_irrefl v1 v4) v3 v2 : @False) : v0 <> v1)) (fun v2 : v0 <= v1 /\ v0 <> v1 => and_ind (fun (v3 : v0 <= v1) (v4 : v0 <> v1) => Rnot_le_lt v1 v0 ((fun v5 : v1 <= v0 => v4 (Rle_antisym v0 v1 v3 v5)) : ~ v1 <= v0)) v2); SORlt_trichotomy := fun v0 v1 : @R => let v2 : {v0 < v1} + {v0 = v1} + {v1 < v0} := total_order_T v0 v1 in match v2 as v3 in (_ + {_}) return (v0 < v1 \/ v0 = v1 \/ v1 < v0) with | inleft v3 => (fun v3 : {v0 < v1} + {v0 = v1} => match v3 as v4 in ({_} + {_}) return (v0 < v1 \/ v0 = v1 \/ v1 < v0) with | left v4 => (fun v4 : v0 < v1 => or_introl v4) v4 | right v4 => (fun v4 : v0 = v1 => or_intror (or_introl v4)) v4 end) v3 | inright v3 => (fun v3 : v1 < v0 => or_intror (or_intror v3)) v3 end; SORplus_le_mono_l := fun (v0 v1 v2 : @R) (v3 : v0 <= v1) => Rplus_le_compat_l v2 v0 v1 v3 : v2 + v0 <= v2 + v1; SORtimes_pos_pos := fun (v0 v1 : @R) (v2 : @R0 < v0) (v3 : @R0 < v1) => Rmult_lt_0_compat v0 v1 v2 v3; SORneq_0_1 := (fun v0 : @R0 = @R1 => R1_neq_R0 (eq_sym v0) : @False) : @R0 <> @R1 |}).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Rinv_1	100	0.062866	1	1	0	synth with cache (only 1: refine (fun v0 : @R => eq_ind_r (fun v1 : @R => v0 * v1 = v0) (Rmult_1_r v0) (@Rinv_1))).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Qeq_true	100	0.050930	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Q) (v2 : Qeq_bool v0 v1 = @true) => Qeq_eqR v0 v1 (Qeq_bool_eq v0 v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Qeq_false	100	0.071855	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Q) (v2 : Qeq_bool v0 v1 = @false) => let v3 : ~ v0 == v1 := Qeq_bool_neq v0 v1 v2 in (fun v4 : Q2R v0 = Q2R v1 => match v3 (eqR_Qeq v0 v1 v4) as v5 in False return (@False) with end) : Q2R v0 <> Q2R v1)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Qle_true	100	0.051829	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Q) (v2 : Qle_bool v0 v1 = @true) => Qle_Rle v0 v1 (Qle_bool_imp_le v0 v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q2R_0	100	0.044469	1	1	0	synth with cache (only 1: refine (Rmult_0_l (/ IZR (QDen 0)))).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q2R_1	100	0.052905	1	1	0	synth with cache (only 1: refine (Rinv_1 (@R1) : Q2R 1 = IZR 1)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q2R_inv_ext	100	0.136110	1	1	0	synth with cache (only 1: refine (fun v0 : @Q => (match Qeq_bool v0 0 as v1 in bool return (forall v2 : Qeq_bool v0 0 = v1, Q2R (/ v0) = match v1 as v3 in bool return (@R) with | true => IZR 0 | false => / Q2R v0 end) with | true => fun v1 : Qeq_bool v0 0 = @true => let v2 : v0 == 0 := Qeq_bool_eq v0 0 v1 in match v0 as v3 in Q return (forall v4 : v3 == 0, Q2R (/ v3) = IZR 0) with | v3 # v4 => (fun (v3 : @Z) (v4 : @positive) (v5 : v3 # v4 == 0) => (let v6 : v3 = 0%Z := eq_ind (v3 * 1)%Z (fun v6 : @Z => v6 = 0%Z) v5 v3 (Z.mul_1_r v3) in eq_ind_r (fun v7 : @Z => Q2R (/ (v7 # v4)) = IZR 0) (Rmult_0_l (/ IZR (QDen (/ (0 # v4))))) v6) : Q2R (/ (v3 # v4)) = IZR 0) v3 v4 end v2 | false => fun v1 : Qeq_bool v0 0 = @false => Q2R_inv v0 (Qeq_bool_neq v0 0 v1) end : forall v1 : Qeq_bool v0 0 = Qeq_bool v0 0, Q2R (/ v0) = match Qeq_bool v0 0 as v2 in bool return (@R) with | true => IZR 0 | false => / Q2R v0 end) eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.QSORaddon	100	0.111854	1	1	0	synth with cache (only 1: refine {| SORrm := {| morph0 := @Q2R_0; morph1 := @Q2R_1; morph_add := fun v0 v1 : @Q => Q2R_plus v0 v1; morph_sub := fun v0 v1 : @Q => Q2R_minus v0 v1; morph_mul := fun v0 v1 : @Q => Q2R_mult v0 v1; morph_opp := fun v0 : @Q => Q2R_opp v0; morph_eq := fun (v0 v1 : @Q) (v2 : Qeq_bool v0 v1 = @true) => Qeq_true v0 v1 v2 |}; SORpower := @R_power_theory; SORcneqb_morph := @Qeq_false; SORcleb_morph := @Qle_true |}).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.is_neg_true	100	0.135703	1	1	0	synth with cache (only 1: refine (fun v0 : @Z + @nat => match v0 as v1 in (_ + _)%type return (forall v2 : is_neg v1 = @true, (z_of_exp v1 < 0)%Z) with | inl v1 => (fun v1 : @Z => match v1 as v2 in Z return (forall v3 : match v2 as v3 in Z return (@bool) with | 0%Z => @false | Z.pos v3 => (fun v3 : @positive => @false) v3 | Z.neg v3 => (fun v3 : @positive => @true) v3 end = @true, (v2 < 0)%Z) with | 0%Z => fun v2 : @false = @true => let v3 : @false = @true := v2 in let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (0 < 0)%Z v4 | Z.pos v2 => (fun (v2 : @positive) (v3 : @false = @true) => let v4 : @false = @true := v3 in let v5 : @False := eq_ind (@false) (fun v5 : @bool => match v5 as v6 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v4 in False_ind (Z.pos v2 < 0)%Z v5) v2 | Z.neg v2 => (fun (v2 : @positive) (v3 : @true = @true) => eq_refl) v2 end : forall v2 : is_neg (inl v1) = @true, (z_of_exp (inl v1) < 0)%Z) v1 | inr v1 => (fun v1 : @nat => (fun v2 : @false = @true => let v3 : @false = @true := v2 in let v4 : @False := eq_ind (@false) (fun v4 : @bool => match v4 as v5 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v3 in False_ind (BinIntDef.Z.of_nat v1 < 0)%Z v4) : forall v2 : is_neg (inr v1) = @true, (z_of_exp (inr v1) < 0)%Z) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.is_neg_false	100	0.174311	1	1	0	synth with cache (only 1: refine (fun v0 : @Z + @nat => match v0 as v1 in (_ + _)%type return (forall v2 : is_neg v1 = @false, (z_of_exp v1 >= 0)%Z) with | inl v1 => (fun v1 : @Z => match v1 as v2 in Z return (forall v3 : match v2 as v3 in Z return (@bool) with | 0%Z => @false | Z.pos v3 => (fun v3 : @positive => @false) v3 | Z.neg v3 => (fun v3 : @positive => @true) v3 end = @false, (v2 >= 0)%Z) with | 0%Z => (fun (v2 : @false = @false) (v3 : @Eq = @Lt) => let v4 : @Eq = @Lt := v3 in let v5 : @False := eq_ind (@Eq) (fun v5 : @comparison => match v5 as v6 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v4 in False_ind (@False) v5) : forall v2 : @false = @false, (0 >= 0)%Z | Z.pos v2 => (fun v2 : @positive => (fun (v3 : @false = @false) (v4 : @Gt = @Lt) => let v5 : @Gt = @Lt := v4 in let v6 : @False := eq_ind (@Gt) (fun v6 : @comparison => match v6 as v7 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v5 in False_ind (@False) v6) : forall v3 : @false = @false, (Z.pos v2 >= 0)%Z) v2 | Z.neg v2 => (fun (v2 : @positive) (v3 : @true = @false) => (fun v4 : (Z.neg v2 ?= 0)%Z = @Lt => let v5 : @true = @false := v3 in let v6 : @False := eq_ind (@true) (fun v6 : @bool => match v6 as v7 in bool return Prop with | true => @True | false => @False end) (@I) (@false) v5 in False_ind (@False) v6) : (Z.neg v2 >= 0)%Z) v2 end : forall v2 : is_neg (inl v1) = @false, (z_of_exp (inl v1) >= 0)%Z) v1 | inr v1 => (fun v1 : @nat => (fun (v2 : (0 <= BinIntDef.Z.of_nat v1)%Z) (v3 : @false = @false) => Z.le_ge 0 (BinIntDef.Z.of_nat v1) v2) (Zle_0_nat v1) : forall v2 : is_neg (inr v1) = @false, (z_of_exp (inr v1) >= 0)%Z) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q2R_m_Proper	100	0.950760	1	1	0	synth with cache (only 1: refine (((fun v0 : @Q => match v0 as v1 in Q return (forall (v2 : @Q) (v3 : (Qnum v1 * QDen v2)%Z = (Qnum v2 * QDen v1)%Z), IZR (Qnum v1) * / IZR (QDen v1) = IZR (Qnum v2) * / IZR (QDen v2)) with | v1 # v2 => (fun (v1 : @Z) (v2 : @positive) (v3 : @Q) => match v3 as v4 in Q return (forall v5 : (Qnum (v1 # v2) * QDen v4)%Z = (Qnum v4 * QDen (v1 # v2))%Z, IZR (Qnum (v1 # v2)) * / IZR (QDen (v1 # v2)) = IZR (Qnum v4) * / IZR (QDen v4)) with | v4 # v5 => (fun (v4 : @Z) (v5 : @positive) => ((fun v6 : (v1 * Z.pos v5)%Z = (v4 * Z.pos v2)%Z => let v7 : @R := IZR v1 in let v8 : IZR (Z.pos v2) <> IZR 0 := IZR_nz v2 in let v9 : @R := IZR (Z.pos v2) in let v10 : @R := IZR v4 in let v11 : IZR (Z.pos v5) <> IZR 0 := IZR_nz v5 in let v12 : @R := IZR (Z.pos v5) in let v13 : v7 * v12 = v10 * v9 := (((eq_ind (IZR (v1 * Z.pos v5)) (fun v13 : @R => v13 = IZR v4 * IZR (Z.pos v2)) (eq_ind (IZR (v4 * Z.pos v2)) (fun v13 : @R => IZR (v1 * Z.pos v5) = v13) (let v13 : (v1 * Z.pos v5)%Z = (v4 * Z.pos v2)%Z := v6 in (fun v14 : (v1 * Z.pos v5)%Z = (v4 * Z.pos v2)%Z => eq_trans (f_equal (fun v15 : forall v15 : @Z, @R => v15 (v1 * Z.pos v5)%Z) eq_refl) (f_equal (@IZR) v14)) v13) (IZR v4 * IZR (Z.pos v2)) (mult_IZR v4 (Z.pos v2))) (IZR v1 * IZR (Z.pos v5)) (mult_IZR v1 (Z.pos v5)) : IZR v1 * v12 = IZR v4 * IZR (Z.pos v2)) : IZR v1 * v12 = v10 * IZR (Z.pos v2)) : IZR v1 * v12 = v10 * v9) : v7 * v12 = v10 * v9 in let v14 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v15 : forall (v15 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v16 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v14 = v15) (v17 : linear (@Z)) (v18 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEmul (FEX (@Z) 1) (FEinv (FEX (@Z) 2))) = v17) (v19 : linear (@Z)) (v20 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEmul (FEX (@Z) 3) (FEinv (FEX (@Z) 4))) = v19) (v21 : rsplit (@Z)) (v22 : split 0%Z 1%Z (@BinIntDef.Z.mul) (@Zeq_bool) (denum v17) (denum v19) = v21) (v23 : Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) to_nat (@pow) (@get_signZ) (v7 :: v9 :: v10 :: v12 :: nil) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v15 (Ring_polynom.PEmul (num v17) (rsplit_right v21))) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) to_nat (@pow) (@get_signZ) (v7 :: v9 :: v10 :: v12 :: nil) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v15 (Ring_polynom.PEmul (num v19) (rsplit_left v21)))) (v24 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) to_nat (@pow) (v7 :: v9 :: v10 :: v12 :: nil) (condition v17 ++ condition v19)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) to_nat (@pow) (v7 :: v9 :: v10 :: v12 :: nil) (FEmul (FEX (@Z) 1) (FEinv (FEX (@Z) 2))) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) to_nat (@pow) (v7 :: v9 :: v10 :: v12 :: nil) (FEmul (FEX (@Z) 3) (FEinv (FEX (@Z) 4))) := RField_field_lemma3 (@ring_subst_niter) (v7 :: v9 :: v10 :: v12 :: nil) v14 (FEmul (FEX (@Z) 1) (FEinv (FEX (@Z) 2))) (FEmul (FEX (@Z) 3) (FEinv (FEX (@Z) 4))) (@I) in let v16 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v17 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v14 = v16 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v14 = v16 in let v18 : linear (@Z) := {| num := Ring_polynom.PEX (@Z) 1; denum := Ring_polynom.PEX (@Z) 2; condition := Ring_polynom.PEX (@Z) 2 :: nil |} in let v19 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEmul (FEX (@Z) 1) (FEinv (FEX (@Z) 2))) = v18 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEmul (FEX (@Z) 1) (FEinv (FEX (@Z) 2))) = v18 in let v20 : linear (@Z) := {| num := Ring_polynom.PEX (@Z) 3; denum := Ring_polynom.PEX (@Z) 4; condition := Ring_polynom.PEX (@Z) 4 :: nil |} in let v21 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEmul (FEX (@Z) 3) (FEinv (FEX (@Z) 4))) = v20 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEmul (FEX (@Z) 3) (FEinv (FEX (@Z) 4))) = v20 in let v22 : rsplit (@Z) := {| rsplit_left := Ring_polynom.PEX (@Z) 2; rsplit_common := Ring_polynom.PEc 1%Z; rsplit_right := Ring_polynom.PEX (@Z) 4 |} in let v23 : split 0%Z 1%Z (@BinIntDef.Z.mul) (@Zeq_bool) (denum v18) (denum v20) = v22 := eq_refl : split 0%Z 1%Z (@BinIntDef.Z.mul) (@Zeq_bool) (denum v18) (denum v20) = v22 in v15 v16 v17 v18 v19 v20 v21 v22 v23 (eq_ind_r (fun v24 : @R => v24 = v9 * v10) (let v24 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v25 : list (@R) := (v10 :: v9 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v25 v24 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 1)) (@I) (eq_refl : (let v26 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v24 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v26 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v26 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 1)))) = @true)) v13 : Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) to_nat (@pow) (@get_signZ) (v7 :: v9 :: v10 :: v12 :: nil) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v16 (Ring_polynom.PEmul (num v18) (rsplit_right v22))) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) to_nat (@pow) (@get_signZ) (v7 :: v9 :: v10 :: v12 :: nil) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v16 (Ring_polynom.PEmul (num v20) (rsplit_left v22)))) (RField_lemma5 (v7 :: v9 :: v10 :: v12 :: nil) (condition v18 ++ condition v20) (fun (v24 : forall v24 : list (Ring_polynom.PExpr (@Z)), Prop) (v25 : v24 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) to_nat (@pow) (v7 :: v9 :: v10 :: v12 :: nil)) => eq_ind_r (fun v26 : forall v26 : list (Ring_polynom.PExpr (@Z)), Prop => v26 (Ring_polynom.PEX (@Z) 4 :: Ring_polynom.PEX (@Z) 2 :: nil)%list) (conj v11 v8 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) to_nat (@pow) (v7 :: v9 :: v10 :: v12 :: nil) (Ring_polynom.PEX (@Z) 4 :: Ring_polynom.PEX (@Z) 2 :: nil)) v25 : v24 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v18 ++ condition v20) nil)))) : forall v6 : (v1 * QDen (v4 # v5))%Z = (v4 * QDen (v1 # v2))%Z, IZR v1 * / IZR (QDen (v1 # v2)) = IZR v4 * / IZR (QDen (v4 # v5))) : forall v6 : (Qnum (v1 # v2) * QDen (v4 # v5))%Z = (Qnum (v4 # v5) * QDen (v1 # v2))%Z, IZR (Qnum (v1 # v2)) * / IZR (QDen (v1 # v2)) = IZR (Qnum (v4 # v5)) * / IZR (QDen (v4 # v5))) v4 v5 end) v1 v2 end) : forall (v0 v1 : @Q) (v2 : (Qnum v0 * QDen v1)%Z = (Qnum v1 * QDen v0)%Z), Q2R v0 = Q2R v1) : forall (v0 v1 : @Q) (v2 : v0 == v1), Q2R v0 = Q2R v1)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q2R_pow_pos	100	0.283438	1	1	0	synth with cache (only 1: refine (fun (v0 : @Q) (v1 : @positive) => positive_ind (fun v2 : @positive => Q2R (pow_pos (@Qmult) v0 v2) = pow_pos (@Rmult) (Q2R v0) v2) (fun (v2 : @positive) (v3 : Q2R (pow_pos (@Qmult) v0 v2) = pow_pos (@Rmult) (Q2R v0) v2) => eq_ind (Q2R (pow_pos (@Qmult) v0 v2)) (fun v4 : @R => Q2R (v0 * (pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2)) = Q2R v0 * (v4 * v4)) (eq_ind_r (fun v4 : @R => v4 = Q2R v0 * (Q2R (pow_pos (@Qmult) v0 v2) * Q2R (pow_pos (@Qmult) v0 v2))) (eq_ind_r (fun v4 : @R => Q2R v0 * v4 = Q2R v0 * (Q2R (pow_pos (@Qmult) v0 v2) * Q2R (pow_pos (@Qmult) v0 v2))) eq_refl (Q2R_mult (pow_pos (@Qmult) v0 v2) (pow_pos (@Qmult) v0 v2))) (Q2R_mult v0 (pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2))) (pow_pos (@Rmult) (Q2R v0) v2) v3 : Q2R (pow_pos (@Qmult) v0 v2~1) = pow_pos (@Rmult) (Q2R v0) v2~1) (fun (v2 : @positive) (v3 : Q2R (pow_pos (@Qmult) v0 v2) = pow_pos (@Rmult) (Q2R v0) v2) => eq_ind (Q2R (pow_pos (@Qmult) v0 v2)) (fun v4 : @R => Q2R (pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2) = v4 * v4) (eq_ind_r (fun v4 : @R => v4 = Q2R (pow_pos (@Qmult) v0 v2) * Q2R (pow_pos (@Qmult) v0 v2)) eq_refl (Q2R_mult (pow_pos (@Qmult) v0 v2) (pow_pos (@Qmult) v0 v2))) (pow_pos (@Rmult) (Q2R v0) v2) v3 : Q2R (pow_pos (@Qmult) v0 v2~0) = pow_pos (@Rmult) (Q2R v0) v2~0) (eq_refl : Q2R (pow_pos (@Qmult) v0 1) = pow_pos (@Rmult) (Q2R v0) 1) v1)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q2R_pow_N	100	0.097820	1	1	0	synth with cache (only 1: refine (fun (v0 : @Q) (v1 : @N) => match v1 as v2 in N return (Q2R (pow_N 1%Q (@Qmult) v0 v2) = pow_N (IZR 1) (@Rmult) (Q2R v0) v2) with | 0%N => @Q2R_1 : Q2R (pow_N 1%Q (@Qmult) v0 0) = pow_N (IZR 1) (@Rmult) (Q2R v0) 0 | N.pos v2 => (fun v2 : @positive => Q2R_pow_pos v0 v2 : Q2R (pow_N 1%Q (@Qmult) v0 (N.pos v2)) = pow_N (IZR 1) (@Rmult) (Q2R v0) (N.pos v2)) v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Qmult_integral	100	0.277325	1	1	0	synth with cache (only 1: refine (fun v0 : @Q => match v0 as v1 in Q return (forall (v2 : @Q) (v3 : v1 * v2 == 0), v1 == 0 \/ v2 == 0) with | v1 # v2 => (fun (v1 : @Z) (v2 : @positive) (v3 : @Q) => match v3 as v4 in Q return (forall v5 : (v1 # v2) * v4 == 0, v1 # v2 == 0 \/ v4 == 0) with | v4 # v5 => (fun (v4 : @Z) (v5 : @positive) => (((fun v6 : (v1 * 1 * (v4 * 1))%Z = 0%Z <-> (v1 * 1)%Z = 0%Z \/ (v4 * 1)%Z = 0%Z => Reflexive_partial_app_morphism (subrelation_proper (@Morphisms_Prop.iff_iff_iff_impl_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation)))) (reflexive_proper_proxy (@iff_Reflexive) ((v1 * v4 * 1)%Z = 0%Z)) ((v1 * 1)%Z = 0%Z \/ (v4 * 1)%Z = 0%Z) ((v1 * 1 * (v4 * 1))%Z = 0%Z) (symmetry v6)) (Z.mul_eq_0 (v1 * 1) (v4 * 1)) (eq_ind_r (fun v6 : @Z => forall v7 : v6 = 0%Z, (v1 * 1 * (v4 * 1))%Z = 0%Z) (eq_ind_r (fun v6 : @Z => forall v7 : (v1 * v4)%Z = 0%Z, (v6 * (v4 * 1))%Z = 0%Z) (eq_ind_r (fun v6 : @Z => forall v7 : (v1 * v4)%Z = 0%Z, (v1 * v6)%Z = 0%Z) (fun v6 : (v1 * v4)%Z = 0%Z => v6) (Z.mul_1_r v4)) (Z.mul_1_r v1)) (Z.mul_1_r (v1 * v4))) : forall v6 : (Qnum (Qnum (v1 # v2) * Qnum (v4 # v5) # Qden (v1 # v2) * Qden (v4 # v5)) * QDen 0)%Z = (Qnum 0 * QDen (Qnum (v1 # v2) * Qnum (v4 # v5) # Qden (v1 # v2) * Qden (v4 # v5)))%Z, (Qnum (v1 # v2) * QDen 0)%Z = (Qnum 0 * QDen (v1 # v2))%Z \/ (Qnum (v4 # v5) * QDen 0)%Z = (Qnum 0 * QDen (v4 # v5))%Z) : forall v6 : (Qnum ((v1 # v2) * (v4 # v5)) * QDen 0)%Z = (Qnum 0 * QDen ((v1 # v2) * (v4 # v5)))%Z, (Qnum (v1 # v2) * QDen 0)%Z = (Qnum 0 * QDen (v1 # v2))%Z \/ (Qnum (v4 # v5) * QDen 0)%Z = (Qnum 0 * QDen (v4 # v5))%Z) : forall v6 : (v1 # v2) * (v4 # v5) == 0, v1 # v2 == 0 \/ v4 # v5 == 0) v4 v5 end) v1 v2 end)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Qpower_positive_eq_zero	100	0.268353	1	1	0	synth with cache (only 1: refine ((fun (v0 : @Q) (v1 : @positive) => positive_ind (fun v2 : @positive => forall v3 : pow_pos (@Qmult) v0 v2 == 0, v0 == 0) (fun (v2 : @positive) (v3 : forall v3 : pow_pos (@Qmult) v0 v2 == 0, v0 == 0) => (fun v4 : v0 * (pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2) == 0 => let v5 : v0 == 0 \/ pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2 == 0 := Qmult_integral v0 (pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2) v4 in match v5 as v6 in (_ \/ _) return (v0 == 0) with | or_introl v6 => (fun v6 : v0 == 0 => v6) v6 | or_intror v6 => (fun v6 : pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2 == 0 => let v7 : pow_pos (@Qmult) v0 v2 == 0 \/ pow_pos (@Qmult) v0 v2 == 0 := Qmult_integral (pow_pos (@Qmult) v0 v2) (pow_pos (@Qmult) v0 v2) v6 in match v7 as v8 in (_ \/ _) return (v0 == 0) with | or_introl v8 | or_intror v8 => (fun v8 : pow_pos (@Qmult) v0 v2 == 0 => let v9 : v0 == 0 := v3 v8 in v9) v8 end) v6 end) : forall v4 : pow_pos (@Qmult) v0 v2~1 == 0, v0 == 0) (fun (v2 : @positive) (v3 : forall v3 : pow_pos (@Qmult) v0 v2 == 0, v0 == 0) => (fun v4 : pow_pos (@Qmult) v0 v2 * pow_pos (@Qmult) v0 v2 == 0 => let v5 : pow_pos (@Qmult) v0 v2 == 0 \/ pow_pos (@Qmult) v0 v2 == 0 := Qmult_integral (pow_pos (@Qmult) v0 v2) (pow_pos (@Qmult) v0 v2) v4 in match v5 as v6 in (_ \/ _) return (v0 == 0) with | or_introl v6 | or_intror v6 => (fun v6 : pow_pos (@Qmult) v0 v2 == 0 => let v7 : v0 == 0 := v3 v6 in v7) v6 end) : forall v4 : pow_pos (@Qmult) v0 v2~0 == 0, v0 == 0) ((fun v2 : v0 == 0 => v2) : forall v2 : pow_pos (@Qmult) v0 1 == 0, v0 == 0) v1) : forall (v0 : @Q) (v1 : @positive) (v2 : Qpower_positive v0 v1 == 0), v0 == 0)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Qpower_positive_zero	100	0.228464	1	1	0	synth with cache (only 1: refine (fun v0 : @positive => positive_ind (fun v1 : @positive => Qpower_positive 0 v1 == 0) (fun (v1 : @positive) (v2 : Qpower_positive 0 v1 == 0) => (fun v3 : Qpower_positive 0 v1 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (0 * (Qpower_positive 0 v1 * Qpower_positive 0 v1))%Q (0 * (0 * 0))%Q (Reflexive_partial_app_morphism (@Qmult_comp) (reflexive_proper_proxy Equivalence_Reflexive 0%Q) (Qpower_positive 0 v1 * Qpower_positive 0 v1)%Q (0 * 0)%Q (Qmult_comp (Qpower_positive 0 v1) 0%Q v3 (Qpower_positive 0 v1) 0%Q v3)) 0%Q 0%Q (eq_proper_proxy 0%Q)) v2 (reflexivity 0%Q) : Qpower_positive 0 v1~1 == 0) (fun (v1 : @positive) (v2 : Qpower_positive 0 v1 == 0) => (fun v3 : Qpower_positive 0 v1 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (Qpower_positive 0 v1 * Qpower_positive 0 v1)%Q (0 * 0)%Q (Qmult_comp (Qpower_positive 0 v1) 0%Q v3 (Qpower_positive 0 v1) 0%Q v3) 0%Q 0%Q (eq_proper_proxy 0%Q)) v2 (reflexivity 0%Q) : Qpower_positive 0 v1~0 == 0) (reflexivity 0%Q : Qpower_positive 0 1 == 0) v0)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q2RpowerRZ	100	0.387293	1	1	0	synth with cache (only 1: refine (fun (v0 : @Q) (v1 : @Z) (v2 : ~ v0 == 0 \/ (v1 >= 0)%Z) => let v3 : power_theory 1%Q (@Qmult) (@Qeq) (@BinIntDef.Z.of_N) (@Qpower) := @Qpower_theory in match v3 as v4 in (power_theory _ _ _ _ _) return (Q2R (v0 ^ v1) = powerRZ (Q2R v0) v1) with | {| rpow_pow_N := v4 |} => (fun v4 : forall (v4 : @Q) (v5 : @N), v4 ^ BinIntDef.Z.of_N v5 == pow_N 1%Q (@Qmult) v4 v5 => let v5 : power_theory (IZR 1) (@Rmult) eq to_nat (@pow) := @R_power_theory in match v5 as v6 in (power_theory _ _ _ _ _) return (Q2R (v0 ^ v1) = powerRZ (Q2R v0) v1) with | {| rpow_pow_N := v6 |} => (fun v6 : forall (v6 : @R) (v7 : @N), v6 ^ to_nat v7 = pow_N (IZR 1) (@Rmult) v6 v7 => (match v1 as v7 in Z return (forall v8 : ~ v0 == 0 \/ (v7 >= 0)%Z, Q2R match v7 as v9 in Z return (@Q) with | 0%Z => 1 | Z.pos v9 => (fun v9 : @positive => Qpower_positive v0 v9) v9 | Z.neg v9 => (fun v9 : @positive => (/ Qpower_positive v0 v9)%Q) v9 end = match v7 as v9 in Z return (@R) with | 0%Z => IZR 1 | Z.pos v9 => (fun v9 : @positive => Q2R v0 ^ BinPosDef.Pos.to_nat v9) v9 | Z.neg v9 => (fun v9 : @positive => / Q2R v0 ^ BinPosDef.Pos.to_nat v9) v9 end) with | 0%Z => fun v7 : ~ v0 == 0 \/ (0 >= 0)%Z => @Q2R_1 | Z.pos v7 => (fun (v7 : @positive) (v8 : ~ v0 == 0 \/ (Z.pos v7 >= 0)%Z) => eq_ind (BinIntDef.Z.of_N (N.pos v7)) (fun v9 : @Z => Q2R (v0 ^ v9) = Q2R v0 ^ BinPosDef.Pos.to_nat v7) (eq_ind (to_nat (N.pos v7)) (fun v9 : @nat => Q2R (v0 ^ BinIntDef.Z.of_N (N.pos v7)) = Q2R v0 ^ v9) ((fun v9 : v0 ^ BinIntDef.Z.of_N (N.pos v7) == pow_N 1%Q (@Qmult) v0 (N.pos v7) => trans_co_eq_inv_impl_morphism eq_Transitive (Q2R (v0 ^ BinIntDef.Z.of_N (N.pos v7))) (Q2R (pow_N 1%Q (@Qmult) v0 (N.pos v7))) (Q2R_m_Proper (v0 ^ BinIntDef.Z.of_N (N.pos v7))%Q (pow_N 1%Q (@Qmult) v0 (N.pos v7)) v9) (Q2R v0 ^ to_nat (N.pos v7)) (Q2R v0 ^ to_nat (N.pos v7)) (eq_proper_proxy (Q2R v0 ^ to_nat (N.pos v7)))) (v4 v0 (N.pos v7)) (eq_ind_r (fun v9 : @R => Q2R (pow_N 1%Q (@Qmult) v0 (N.pos v7)) = v9) (Q2R_pow_N v0 (N.pos v7)) (v6 (Q2R v0) (N.pos v7)))) (BinPosDef.Pos.to_nat v7) (positive_N_nat v7)) (Z.pos v7) (N2Z.inj_pos v7)) v7 | Z.neg v7 => (fun (v7 : @positive) (v8 : ~ v0 == 0 \/ (Z.neg v7 >= 0)%Z) => eq_ind_r (fun v9 : @R => v9 = / Q2R v0 ^ BinPosDef.Pos.to_nat v7) (eq_ind (to_nat (N.pos v7)) (fun v9 : @nat => / Q2R (pow_pos (@Qmult) v0 v7) = / Q2R v0 ^ v9) (eq_ind_r (fun v9 : @R => / Q2R (pow_pos (@Qmult) v0 v7) = / v9) (eq_ind_r (fun v9 : @R => / v9 = / pow_pos (@Rmult) (Q2R v0) v7) eq_refl (Q2R_pow_pos v0 v7) : / Q2R (pow_pos (@Qmult) v0 v7) = / pow_N (IZR 1) (@Rmult) (Q2R v0) (N.pos v7)) (v6 (Q2R v0) (N.pos v7))) (BinPosDef.Pos.to_nat v7) (positive_N_nat v7) : / Q2R (Qpower_positive v0 v7) = / Q2R v0 ^ BinPosDef.Pos.to_nat v7) (Q2R_inv (Qpower_positive v0 v7) ((fun v9 : Qpower_positive v0 v7 == 0 => let v10 : v0 == 0 := Qpower_positive_eq_zero v0 v7 v9 in match v8 as v11 in (_ \/ _) return (@False) with | or_introl v11 => (fun v11 : ~ v0 == 0 => v11 v10) v11 | or_intror v11 => (fun v11 : (Z.neg v7 >= 0)%Z => v11 eq_refl) v11 end) : ~ Qpower_positive v0 v7 == 0))) v7 end v2 : Q2R match v1 as v7 in Z return (@Q) with | 0%Z => 1 | Z.pos v7 => (fun v7 : @positive => Qpower_positive v0 v7) v7 | Z.neg v7 => (fun v7 : @positive => (/ Qpower_positive v0 v7)%Q) v7 end = powerRZ (Q2R v0) v1) : Q2R (v0 ^ v1) = powerRZ (Q2R v0) v1) v6 end) v4 end)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Qpower0	100	0.126378	0	1
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Q_of_RcstR	100	2.043903	1	1	0	synth with cache (only 1: refine (fun v0 : @Rcst => Rcst_ind (fun v1 : @Rcst => Q2R (Q_of_Rcst v1) = R_of_Rcst v1) (@Q2R_0 : Q2R (Q_of_Rcst (@C0)) = R_of_Rcst (@C0)) (@Q2R_1 : Q2R (Q_of_Rcst (@C1)) = R_of_Rcst (@C1)) (fun v1 : @Q => eq_refl : Q2R (Q_of_Rcst (CQ v1)) = R_of_Rcst (CQ v1)) (fun v1 : @Z => ((eq_ind_r (fun v2 : @R => v2 = IZR v1) eq_refl (Rinv_1 (IZR v1)) : IZR (Qnum (v1 # 1)) * / IZR (QDen (v1 # 1)) = IZR v1) : Q2R (v1 # 1) = IZR v1) : Q2R (Q_of_Rcst (CZ v1)) = R_of_Rcst (CZ v1)) (fun (v1 : @Rcst) (v2 : Q2R (Q_of_Rcst v1) = R_of_Rcst v1) (v3 : @Rcst) (v4 : Q2R (Q_of_Rcst v3) = R_of_Rcst v3) => eq_ind (Q2R (Q_of_Rcst v1)) (fun v5 : @R => Q2R (Q_of_Rcst v1 + Q_of_Rcst v3) = v5 + R_of_Rcst v3) (eq_ind (Q2R (Q_of_Rcst v3)) (fun v5 : @R => Q2R (Q_of_Rcst v1 + Q_of_Rcst v3) = Q2R (Q_of_Rcst v1) + v5) (Q2R_plus (Q_of_Rcst v1) (Q_of_Rcst v3)) (R_of_Rcst v3) v4) (R_of_Rcst v1) v2 : Q2R (Q_of_Rcst (CPlus v1 v3)) = R_of_Rcst (CPlus v1 v3)) (fun (v1 : @Rcst) (v2 : Q2R (Q_of_Rcst v1) = R_of_Rcst v1) (v3 : @Rcst) (v4 : Q2R (Q_of_Rcst v3) = R_of_Rcst v3) => eq_ind (Q2R (Q_of_Rcst v1)) (fun v5 : @R => Q2R (Q_of_Rcst v1 - Q_of_Rcst v3) = v5 - R_of_Rcst v3) (eq_ind (Q2R (Q_of_Rcst v3)) (fun v5 : @R => Q2R (Q_of_Rcst v1 - Q_of_Rcst v3) = Q2R (Q_of_Rcst v1) - v5) (Q2R_minus (Q_of_Rcst v1) (Q_of_Rcst v3)) (R_of_Rcst v3) v4) (R_of_Rcst v1) v2 : Q2R (Q_of_Rcst (CMinus v1 v3)) = R_of_Rcst (CMinus v1 v3)) (fun (v1 : @Rcst) (v2 : Q2R (Q_of_Rcst v1) = R_of_Rcst v1) (v3 : @Rcst) (v4 : Q2R (Q_of_Rcst v3) = R_of_Rcst v3) => eq_ind (Q2R (Q_of_Rcst v1)) (fun v5 : @R => Q2R (Q_of_Rcst v1 * Q_of_Rcst v3) = v5 * R_of_Rcst v3) (eq_ind (Q2R (Q_of_Rcst v3)) (fun v5 : @R => Q2R (Q_of_Rcst v1 * Q_of_Rcst v3) = Q2R (Q_of_Rcst v1) * v5) (Q2R_mult (Q_of_Rcst v1) (Q_of_Rcst v3)) (R_of_Rcst v3) v4) (R_of_Rcst v1) v2 : Q2R (Q_of_Rcst (CMult v1 v3)) = R_of_Rcst (CMult v1 v3)) (fun (v1 : @Rcst) (v2 : Q2R (Q_of_Rcst v1) = R_of_Rcst v1) (v3 : @Z + @nat) => match v3 as v4 in (_ + _)%type return (Q2R (Q_of_Rcst v1 ^ z_of_exp v4) = match v4 as v5 in (_ + _)%type return (@R) with | inl v5 => (fun v5 : @Z => match CPowR0 v5 v1 as v6 in bool return (@R) with | true => @R0 | false => powerRZ (R_of_Rcst v1) v5 end) v5 | inr v5 => (fun v5 : @nat => R_of_Rcst v1 ^ v5) v5 end) with | inl v4 => (fun v4 : @Z => let v5 : @bool := CPowR0 v4 v1 in let v6 : CPowR0 v4 v1 = v5 := eq_refl in match v5 as v7 in bool return (forall v8 : CPowR0 v4 v1 = v7, Q2R (Q_of_Rcst v1 ^ z_of_exp (inl v4)) = match v7 as v9 in bool return (@R) with | true => @R0 | false => powerRZ (R_of_Rcst v1) v4 end) with | true => fun v7 : CPowR0 v4 v1 = @true => match (fun v8 : (v4 <? 0)%Z && Qeq_bool (Q_of_Rcst v1) 0 = @true <-> (v4 <? 0)%Z = @true /\ Qeq_bool (Q_of_Rcst v1) 0 = @true => iff_impl_subrelation ((v4 <? 0)%Z && Qeq_bool (Q_of_Rcst v1) 0 = @true) ((v4 <? 0)%Z = @true /\ Qeq_bool (Q_of_Rcst v1) 0 = @true) v8) (andb_true_iff (v4 <? 0)%Z (Qeq_bool (Q_of_Rcst v1) 0)) v7 as v8 in (_ /\ _) return (Q2R (Q_of_Rcst v1 ^ z_of_exp (inl v4)) = @R0) with | conj v8 v9 => (fun (v8 : (v4 <? 0)%Z = @true) (v9 : Qeq_bool (Q_of_Rcst v1) 0 = @true) => let v10 : Q_of_Rcst v1 == 0 := Qeq_bool_eq (Q_of_Rcst v1) 0 v9 in (fun v11 : Q_of_Rcst v1 == 0 => trans_co_eq_inv_impl_morphism eq_Transitive (Q2R (Q_of_Rcst v1 ^ z_of_exp (inl v4))) (Q2R (0 ^ z_of_exp (inl v4))) (Q2R_m_Proper (Q_of_Rcst v1 ^ z_of_exp (inl v4))%Q (0 ^ z_of_exp (inl v4))%Q (Qpower_comp (Q_of_Rcst v1) 0%Q v11 (z_of_exp (inl v4)) (z_of_exp (inl v4)) (eq_proper_proxy (z_of_exp (inl v4))))) (@R0) (@R0) (eq_proper_proxy (@R0))) v10 ((fun v11 : 0 ^ v4 == 0 => trans_co_eq_inv_impl_morphism eq_Transitive (Q2R (0 ^ v4)) (Q2R 0) (Q2R_m_Proper (0 ^ v4)%Q 0%Q v11) (@R0) (@R0) (eq_proper_proxy (@R0))) (Qpower0 v4 ((fun v11 : v4 = 0%Z => eq_ind_r (fun v12 : @Z => forall v13 : (v12 < 0)%Z, @False) (fun v12 : (0 < 0)%Z => let v13 : (0 + 1 <= 0)%Z := Zlt_le_add_1 0 0 v12 in let v14 : (0 <= 0 - (0 + 1))%Z := Zle_minus_le_0 0 (0 + 1) v13 in let v15 : (0 <= 0 - (0 + 1) + (0 - (0 + 1)))%Z := add_le (0 - (0 + 1)) (0 - (0 + 1)) v14 v14 in let v16 : Prop := @False in (let v17 : list (@Z) := (0%Z :: (0 - (0 + 1) + (0 - (0 + 1)))%Z :: nil)%list in (((fun v18 : v17 = (0%Z :: (0 - (0 + 1) + (0 - (0 + 1)))%Z :: nil)%list => let v19 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v20 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v21 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v19 = v20 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v19 = v20 in let v22 : forall (v22 : Ring_polynom.PExpr (@Z)) (v23 : Ring_polynom.Pol (@Z)) (v24 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 v22 = v23), Ring_polynom.PEeval 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) nil v22 = Ring_polynom.Pphi_pow 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0%Z 1%Z (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) nil v23 := Zr_ring_lemma2 (@ring_subst_niter) v19 nil (@I) v21 in let v23 : Ring_polynom.Pol (@Z) := Ring_polynom.Pc 0%Z in let v24 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEc 0%Z) = v23 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEc 0%Z) = v23 in let v25 : Ring_polynom.PEeval 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) nil (Ring_polynom.PEc 0%Z) = Ring_polynom.Pphi_pow 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0%Z 1%Z (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) nil v23 := v22 (Ring_polynom.PEc 0%Z) v23 v24 in let v26 : Ring_polynom.Pol (@Z) := Ring_polynom.Pc (-2)%Z in let v27 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z)))) = v26 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z)))) = v26 in let v28 : Ring_polynom.PEeval 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) nil (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z)))) = Ring_polynom.Pphi_pow 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0%Z 1%Z (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) nil v26 := v22 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 1%Z)))) v26 v27 in eq_ind_r (fun v29 : @Z => forall v30 : (0 <= v29)%Z, v16) (fun v29 : (0 <= -2)%Z => (let v30 : @False := eq_ind (@false) (fun v30 : @bool => match v30 as v31 in bool return Prop with | true => @False | false => @True end) (@I) (@true) ((fun v30 : (0 <=? -2)%Z = @true <-> (0 <= -2)%Z => iff_impl_subrelation (0 <= -2)%Z ((0 <=? -2)%Z = @true) (symmetry v30)) (Z.leb_le 0 (-2)) v29) in False_ind (@False) v30) : v16) v28) : forall (v18 : v17 = (0%Z :: (0 - (0 + 1) + (0 - (0 + 1)))%Z :: nil)%list) (v19 : (0 <= 0 - (0 + 1) + (0 - (0 + 1)))%Z), v16) : forall (v18 : v17 = v17) (v19 : (0 <= 0 - (0 + 1) + (0 - (0 + 1)))%Z), v16) eq_refl) v15) v11 ((fun v12 : (v4 <? 0)%Z = @true <-> (v4 < 0)%Z => iff_impl_subrelation ((v4 <? 0)%Z = @true) (v4 < 0)%Z v12) (Z.ltb_lt v4 0) v8)) : v4 <> 0%Z)) (@Q2R_0) : Q2R (0 ^ z_of_exp (inl v4)) = @R0)) v8 v9 end | false => fun v7 : CPowR0 v4 v1 = @false => eq_ind_r (fun v8 : @R => v8 = powerRZ (R_of_Rcst v1) v4) (eq_ind_r (fun v8 : @R => powerRZ v8 (z_of_exp (inl v4)) = powerRZ (R_of_Rcst v1) v4) eq_refl v2) (Q2RpowerRZ (Q_of_Rcst v1) (z_of_exp (inl v4)) match (fun v8 : (v4 <? 0)%Z && Qeq_bool (Q_of_Rcst v1) 0 = @false <-> (v4 <? 0)%Z = @false \/ Qeq_bool (Q_of_Rcst v1) 0 = @false => iff_impl_subrelation ((v4 <? 0)%Z && Qeq_bool (Q_of_Rcst v1) 0 = @false) ((v4 <? 0)%Z = @false \/ Qeq_bool (Q_of_Rcst v1) 0 = @false) v8) (andb_false_iff (v4 <? 0)%Z (Qeq_bool (Q_of_Rcst v1) 0)) v7 as v8 in (_ \/ _) return (~ Q_of_Rcst v1 == 0 \/ (z_of_exp (inl v4) >= 0)%Z) with | or_introl v8 => (fun v8 : (v4 <? 0)%Z = @false => (let v9 : forall (v9 v10 : @Z) (v11 : (v9 <? v10)%Z = @false), (v10 <= v9)%Z := fun v9 v10 : @Z => match Z.ltb_ge v9 v10 as v11 in (_ /\ _) return (forall v12 : (v9 <? v10)%Z = @false, (v10 <= v9)%Z) with | conj v11 v12 => (fun (v11 : forall v11 : (v9 <? v10)%Z = @false, (v10 <= v9)%Z) (v12 : forall v12 : (v10 <= v9)%Z, (v9 <? v10)%Z = @false) => v11) v11 v12 end in let v10 : (0 <= v4)%Z := v9 v4 0%Z v8 in or_intror (Z.le_ge 0 v4 (elim_concl_le 0 v4 (fun v11 : (v4 < 0)%Z => let v12 : (v4 + 1 <= 0)%Z := Zlt_le_add_1 v4 0 v11 in let v13 : (0 <= 0 - (v4 + 1))%Z := Zle_minus_le_0 0 (v4 + 1) v12 in let v14 : (0 <= v4 + (0 - (v4 + 1)))%Z := add_le v4 (0 - (v4 + 1)) v10 v13 in let v15 : Prop := @False in (let v16 : list (@Z) := (0%Z :: (v4 + (0 - (v4 + 1)))%Z :: nil)%list in (((fun v17 : v16 = (0%Z :: (v4 + (0 - (v4 + 1)))%Z :: nil)%list => let v18 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v19 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v20 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v18 = v19 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v18 = v19 in let v21 : forall (v21 : Ring_polynom.PExpr (@Z)) (v22 : Ring_polynom.Pol (@Z)) (v23 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 v21 = v22), Ring_polynom.PEeval 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (v4 :: nil) v21 = Ring_polynom.Pphi_pow 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0%Z 1%Z (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) (v4 :: nil) v22 := Zr_ring_lemma2 (@ring_subst_niter) v18 (v4 :: nil) (@I) v20 in let v22 : Ring_polynom.Pol (@Z) := Ring_polynom.Pc 0%Z in let v23 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEc 0%Z) = v22 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEc 0%Z) = v22 in let v24 : Ring_polynom.PEeval 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (v4 :: nil) (Ring_polynom.PEc 0%Z) = Ring_polynom.Pphi_pow 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0%Z 1%Z (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) (v4 :: nil) v22 := v21 (Ring_polynom.PEc 0%Z) v22 v23 in let v25 : Ring_polynom.Pol (@Z) := Ring_polynom.Pc (-1)%Z in let v26 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) = v25 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) = v25 in let v27 : Ring_polynom.PEeval 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (v4 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) = Ring_polynom.Pphi_pow 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) 0%Z 1%Z (@Zeq_bool) (IDphi (R:=@Z)) (@BinIntDef.Z.of_N) (@BinIntDef.Z.pow) (@get_signZ) (v4 :: nil) v25 := v21 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) v25 v26 in eq_ind_r (fun v28 : @Z => forall v29 : (0 <= v28)%Z, v15) (fun v28 : (0 <= - (1))%Z => (let v29 : @False := eq_ind (@false) (fun v29 : @bool => match v29 as v30 in bool return Prop with | true => @False | false => @True end) (@I) (@true) ((fun v29 : (0 <=? - (1))%Z = @true <-> (0 <= - (1))%Z => iff_impl_subrelation (0 <= - (1))%Z ((0 <=? - (1))%Z = @true) (symmetry v29)) (Z.leb_le 0 (- (1))) v28) in False_ind (@False) v29) : v15) v27) : forall (v17 : v16 = (0%Z :: (v4 + (0 - (v4 + 1)))%Z :: nil)%list) (v18 : (0 <= v4 + (0 - (v4 + 1)))%Z), v15) : forall (v17 : v16 = v16) (v18 : (0 <= v4 + (0 - (v4 + 1)))%Z), v15) eq_refl) v14)))) : ~ Q_of_Rcst v1 == 0 \/ (z_of_exp (inl v4) >= 0)%Z) v8 | or_intror v8 => (fun v8 : Qeq_bool (Q_of_Rcst v1) 0 = @false => or_introl (Qeq_bool_neq (Q_of_Rcst v1) 0 v8)) v8 end) end v6) v4 | inr v4 => (fun v4 : @nat => eq_ind (Q2R (Q_of_Rcst v1)) (fun v5 : @R => Q2R (Q_of_Rcst v1 ^ BinIntDef.Z.of_nat v4) = v5 ^ v4) (let v5 : power_theory 1%Q (@Qmult) (@Qeq) (@BinIntDef.Z.of_N) (@Qpower) := @Qpower_theory in match v5 as v6 in (power_theory _ _ _ _ _) return (Q2R (Q_of_Rcst v1 ^ BinIntDef.Z.of_nat v4) = Q2R (Q_of_Rcst v1) ^ v4) with | {| rpow_pow_N := v6 |} => (fun v6 : forall (v6 : @Q) (v7 : @N), v6 ^ BinIntDef.Z.of_N v7 == pow_N 1%Q (@Qmult) v6 v7 => eq_ind (BinIntDef.Z.of_N (BinNatDef.N.of_nat v4)) (fun v7 : @Z => Q2R (Q_of_Rcst v1 ^ v7) = Q2R (Q_of_Rcst v1) ^ v4) ((fun v7 : Q_of_Rcst v1 ^ BinIntDef.Z.of_N (BinNatDef.N.of_nat v4) == pow_N 1%Q (@Qmult) (Q_of_Rcst v1) (BinNatDef.N.of_nat v4) => trans_co_eq_inv_impl_morphism eq_Transitive (Q2R (Q_of_Rcst v1 ^ BinIntDef.Z.of_N (BinNatDef.N.of_nat v4))) (Q2R (pow_N 1%Q (@Qmult) (Q_of_Rcst v1) (BinNatDef.N.of_nat v4))) (Q2R_m_Proper (Q_of_Rcst v1 ^ BinIntDef.Z.of_N (BinNatDef.N.of_nat v4))%Q (pow_N 1%Q (@Qmult) (Q_of_Rcst v1) (BinNatDef.N.of_nat v4)) v7) (Q2R (Q_of_Rcst v1) ^ v4) (Q2R (Q_of_Rcst v1) ^ v4) (eq_proper_proxy (Q2R (Q_of_Rcst v1) ^ v4))) (v6 (Q_of_Rcst v1) (BinNatDef.N.of_nat v4)) (let v7 : power_theory (IZR 1) (@Rmult) eq to_nat (@pow) := @R_power_theory in match v7 as v8 in (power_theory _ _ _ _ _) return (Q2R (pow_N 1%Q (@Qmult) (Q_of_Rcst v1) (BinNatDef.N.of_nat v4)) = Q2R (Q_of_Rcst v1) ^ v4) with | {| rpow_pow_N := v8 |} => (fun v8 : forall (v8 : @R) (v9 : @N), v8 ^ to_nat v9 = pow_N (IZR 1) (@Rmult) v8 v9 => (fun v9 : to_nat (BinNatDef.N.of_nat v4) = v4 => trans_sym_co_inv_impl_morphism (Equivalence_PER eq_equivalence) (Q2R (Q_of_Rcst v1) ^ v4) (Q2R (Q_of_Rcst v1) ^ to_nat (BinNatDef.N.of_nat v4)) (Reflexive_partial_app_morphism (reflexive_proper (@pow)) (eq_proper_proxy (Q2R (Q_of_Rcst v1))) v4 (to_nat (BinNatDef.N.of_nat v4)) (symmetry v9))) (Nnat.Nat2N.id v4) (eq_ind_r (fun v9 : @R => Q2R (pow_N 1%Q (@Qmult) (Q_of_Rcst v1) (BinNatDef.N.of_nat v4)) = v9) (Q2R_pow_N (Q_of_Rcst v1) (BinNatDef.N.of_nat v4)) (v8 (Q2R (Q_of_Rcst v1)) (BinNatDef.N.of_nat v4)))) v8 end)) (BinIntDef.Z.of_nat v4) (nat_N_Z v4)) v6 end) (R_of_Rcst v1) v2 : Q2R (Q_of_Rcst v1 ^ z_of_exp (inr v4)) = R_of_Rcst v1 ^ v4) v4 end : Q2R (Q_of_Rcst (CPow v1 v3)) = R_of_Rcst (CPow v1 v3)) (fun (v1 : @Rcst) (v2 : Q2R (Q_of_Rcst v1) = R_of_Rcst v1) => eq_ind (Q2R (Q_of_Rcst v1)) (fun v3 : @R => Q2R (/ Q_of_Rcst v1) = match CInvR0 v1 as v4 in bool return (@R) with | true => @R0 | false => / v3 end) (Q2R_inv_ext (Q_of_Rcst v1) : Q2R (/ Q_of_Rcst v1) = match CInvR0 v1 as v3 in bool return (@R) with | true => @R0 | false => / Q2R (Q_of_Rcst v1) end) (R_of_Rcst v1) v2 : Q2R (Q_of_Rcst (CInv v1)) = R_of_Rcst (CInv v1)) (fun (v1 : @Rcst) (v2 : Q2R (Q_of_Rcst v1) = R_of_Rcst v1) => eq_ind (Q2R (Q_of_Rcst v1)) (fun v3 : @R => Q2R (- Q_of_Rcst v1) = - v3) (Q2R_opp (Q_of_Rcst v1)) (R_of_Rcst v1) v2 : Q2R (Q_of_Rcst (COpp v1)) = R_of_Rcst (COpp v1)) v0)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Reval_formula_compat	100	0.805542	1	1	0	synth with cache (only 1: refine (fun (v0 : PolEnv (@R)) (v1 : Formula (@Rcst)) => match v1 as v2 in (Formula _) return (match v2 as v3 in (Formula _) return Prop with | {| Flhs := v3; Fop := v4; Frhs := v5 |} => (fun (v3 : PExpr (@Rcst)) (v4 : @Op2) (v5 : PExpr (@Rcst)) => Reval_op2 v4 (Reval_expr v0 v3) (Reval_expr v0 v5)) v3 v4 v5 end <-> Reval_formula' v0 v2) with | {| Flhs := v2; Fop := v3; Frhs := v4 |} => (fun (v2 : PExpr (@Rcst)) (v3 : @Op2) (v4 : PExpr (@Rcst)) => (conj match v3 as v5 in Op2 return (forall v6 : Reval_op2 v5 (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4), eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := v5; Frhs := v4 |}) with | OpEq => (fun v5 : eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2 = eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4 => v5) : forall v5 : Reval_op2 (@OpEq) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4), eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpEq; Frhs := v4 |} | OpNEq => (fun v5 : eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2 <> eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4 => v5) : forall v5 : Reval_op2 (@OpNEq) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4), eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpNEq; Frhs := v4 |} | OpLe => (fun v5 : eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2 <= eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4 => v5) : forall v5 : Reval_op2 (@OpLe) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4), eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpLe; Frhs := v4 |} | OpGe => Rge_le (eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v2) (eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v4) : forall v5 : Reval_op2 (@OpGe) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4), eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpGe; Frhs := v4 |} | OpLt => (fun v5 : eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2 < eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4 => v5) : forall v5 : Reval_op2 (@OpLt) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4), eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpLt; Frhs := v4 |} | OpGt => (fun v5 : eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2 > eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4 => v5) : forall v5 : Reval_op2 (@OpGt) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4), eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpGt; Frhs := v4 |} end match v3 as v5 in Op2 return (forall v6 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := v5; Frhs := v4 |}, Reval_op2 v5 (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4)) with | OpEq => (fun v5 : eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v2 = eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v4 => v5) : forall v5 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpEq; Frhs := v4 |}, Reval_op2 (@OpEq) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4) | OpNEq => (fun v5 : eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v2 <> eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v4 => v5) : forall v5 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpNEq; Frhs := v4 |}, Reval_op2 (@OpNEq) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4) | OpLe => (fun v5 : eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v2 <= eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v4 => v5) : forall v5 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpLe; Frhs := v4 |}, Reval_op2 (@OpLe) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4) | OpGe => Rle_ge (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) : forall v5 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpGe; Frhs := v4 |}, Reval_op2 (@OpGe) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4) | OpLt => (fun v5 : eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v2 < eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v4 => v5) : forall v5 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpLt; Frhs := v4 |}, Reval_op2 (@OpLt) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4) | OpGt => (fun v5 : eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v4 < eval_sexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) to_nat (@pow) (@R_of_Rcst) v0 v2 => v5) : forall v5 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := @OpGt; Frhs := v4 |}, Reval_op2 (@OpGt) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v2) (eval_pexpr (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@R_of_Rcst) to_nat (@pow) v0 v4) end : Reval_op2 v3 (Reval_expr v0 v2) (Reval_expr v0 v4) <-> eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v0 {| Flhs := v2; Fop := v3; Frhs := v4 |}) : Reval_op2 v3 (Reval_expr v0 v2) (Reval_expr v0 v4) <-> Reval_formula' v0 {| Flhs := v2; Fop := v3; Frhs := v4 |}) v2 v3 v4 end : Reval_formula v0 v1 <-> Reval_formula' v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.Reval_nformula_dec	100	0.071804	1	1	0	synth with cache (only 1: refine (fun (v0 : PolEnv (@R)) (v1 : NFormula (@Q)) => eval_nformula_dec (@Rsor) (@Q2R) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.RWeakChecker_sound	100	0.073548	1	1	0	synth with cache (only 1: refine (fun (v0 : list (NFormula (@Q))) (v1 : @RWitness) (v2 : RWeakChecker v0 v1 = @true) (v3 : PolEnv (@R)) => checker_nf_sound (@Rsor) (@QSORaddon) v0 v1 v2 v3 : make_impl (Qeval_nformula v3) v0 (@False))).
coq-tactician-stdlib.8.11.dev	Coq.micromega.RMicromega.RTautoChecker_sound	100	0.914423	1	1	0	synth with cache (only 1: refine (fun (v0 : BFormula (Formula (@Rcst))) (v1 : list (@RWitness)) => (fun (v2 : tauto_checker (@runsat) (@rdeduce) (Rnormalise (@unit)) (Rnegate (@unit)) (fun v2 : list (NFormula (@Q) * @unit) => RWeakChecker (map fst v2)) (map_bformula (map_Formula (@Q_of_Rcst)) v0) v1 = @true) (v3 : PolEnv (@R)) => let v4 : eval_f (fun v4 : Prop => v4) (QReval_formula v3) (map_bformula (map_Formula (@Q_of_Rcst)) v0) := tauto_checker_sound (@runsat) (@rdeduce) (Rnormalise (@unit)) (Rnegate (@unit)) (@Qeval_nformula) (@Reval_nformula_dec) (fun v4 : NFormula (@Q) => match v4 as v5 in (_ * _)%type return (forall (v6 : runsat v5 = @true) (v7 : PolEnv (@R)) (v8 : Qeval_nformula v7 v5), @False) with | (v5, v6) => (fun (v5 : PolC (@Q)) (v6 : @Op1) => check_inconsistent_sound (@Rsor) (@QSORaddon) v5 v6) v5 v6 end) ((fun (v4 v5 v6 : NFormula (@Q)) (v7 : nformula_plus_nformula 0%Q (@Qplus) (@Qeq_bool) v4 v5 = Some v6) (v8 : PolEnv (@R)) (v9 : Qeval_nformula v8 v4) (v10 : Qeval_nformula v8 v5) => nformula_plus_nformula_correct (@Rsor) (@QSORaddon) v8 v4 v5 v9 v10 v7) : forall (v4 v5 v6 : NFormula (@Q)) (v7 : rdeduce v4 v5 = Some v6) (v8 : PolEnv (@R)) (v9 : Qeval_nformula v8 v4) (v10 : Qeval_nformula v8 v5), Qeval_nformula v8 v6) (@QReval_formula) (let v4 : forall (v4 : Type) (v5 : PolEnv (@R)) (v6 : Formula (@Q)) (v7 : v4) (v8 : eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v5 (cnf_normalise 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v6 v7)), eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v5 v6 := fun (v4 : Type) (v5 : PolEnv (@R)) (v6 : Formula (@Q)) (v7 : v4) => match cnf_normalise_correct (@Rsor) (@QSORaddon) v5 v6 v7 as v8 in (_ /\ _) return (forall v9 : eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v5 (cnf_normalise 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v6 v7), eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v5 v6) with | conj v8 v9 => (fun (v8 : forall v8 : eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v5 (cnf_normalise 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v6 v7), eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v5 v6) (v9 : forall v9 : eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v5 v6, eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v5 (cnf_normalise 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v6 v7)) => v8) v8 v9 end in v4 (@unit)) (fun (v4 : PolEnv (@R)) (v5 : Formula (@Q)) (v6 : @unit) (v7 : eval_cnf (@Qeval_nformula) v4 (Rnegate (@unit) v5 v6)) => let v8 : forall (v8 : Type) (v9 : PolEnv (@R)) (v10 : Formula (@Q)) (v11 : v8) (v12 : eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v9 (cnf_negate 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v10 v11)), ~ eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v9 v10 := fun (v8 : Type) (v9 : PolEnv (@R)) (v10 : Formula (@Q)) (v11 : v8) => match cnf_negate_correct (@Rsor) (@QSORaddon) v9 v10 v11 as v12 in (_ /\ _) return (forall v13 : eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v9 (cnf_negate 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v10 v11), ~ eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v9 v10) with | conj v12 v13 => (fun (v12 : forall v12 : eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v9 (cnf_negate 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v10 v11), ~ eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v9 v10) (v13 : forall v13 : ~ eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v9 v10, eval_cnf (eval_nformula (@R0) (@Rplus) (@Rmult) eq (@Rle) (@Rlt) (@Q2R)) v9 (cnf_negate 0%Q 1%Q (@Qplus) (@Qmult) (@Qminus) (@Qopp) (@Qeq_bool) (@Qle_bool) v10 v11)) => v12) v12 v13 end in v8 (@unit) v4 v5 v6 v7) (fun v4 : list (NFormula (@Q) * @unit) => RWeakChecker (map fst v4)) (fun (v4 : list (NFormula (@Q) * @unit)) (v5 : @RWitness) => (fun (v6 : RWeakChecker (map fst v4) v5 = @true) (v7 : PolEnv (@R)) => (fun v8 : make_impl (fun v8 : NFormula (@Q) * @unit => Qeval_nformula v7 (fst v8)) v4 (@False) <-> make_impl (Qeval_nformula v7) (map fst v4) (@False) => iff_flip_impl_subrelation (make_impl (fun v9 : NFormula (@Q) * @unit => Qeval_nformula v7 (fst v9)) v4 (@False)) (make_impl (Qeval_nformula v7) (map fst v4) (@False)) v8) (make_impl_map (Qeval_nformula v7) (fun v8 : NFormula (@Q) * @unit => Qeval_nformula v7 (fst v8)) v4 (@False) (fun v8 : NFormula (@Q) * @unit => prod_ind (fun v9 : NFormula (@Q) * @unit => Qeval_nformula v7 (fst v9) <-> Qeval_nformula v7 (fst v9)) (fun (v9 : NFormula (@Q)) (v10 : @unit) => conj (fun v11 : Qeval_nformula v7 (fst (v9, v10)) => v11) (fun v11 : Qeval_nformula v7 (fst (v9, v10)) => v11)) v8)) (RWeakChecker_sound (map fst v4) v5 v6 v7)) : forall (v6 : RWeakChecker (map fst v4) v5 = @true) (v7 : PolEnv (@R)), make_impl (eval_tt (@Qeval_nformula) v7) v4 (@False)) (map_bformula (map_Formula (@Q_of_Rcst)) v0) v1 v2 v3 in let v5 : eval_bf (fun v5 : Formula (@Rcst) => QReval_formula v3 (map_Formula (@Q_of_Rcst) v5)) v0 := eq_ind (eval_bf (QReval_formula v3) (map_bformula (map_Formula (@Q_of_Rcst)) v0)) (fun v5 : Prop => v5) v4 (eval_bf (fun v5 : Formula (@Rcst) => QReval_formula v3 (map_Formula (@Q_of_Rcst) v5)) v0) (eval_bf_map (map_Formula (@Q_of_Rcst)) (QReval_formula v3) v0) in (fun v6 : eval_f (fun v6 : Prop => v6) (fun v6 : Formula (@Rcst) => QReval_formula v3 (map_Formula (@Q_of_Rcst) v6)) v0 <-> eval_f (fun v6 : Prop => v6) (Reval_formula v3) v0 => iff_impl_subrelation (eval_f (fun v7 : Prop => v7) (fun v7 : Formula (@Rcst) => QReval_formula v3 (map_Formula (@Q_of_Rcst) v7)) v0) (eval_f (fun v7 : Prop => v7) (Reval_formula v3) v0) v6) (eval_f_morph (fun v6 : Prop => v6) (fun v6 : Formula (@Rcst) => QReval_formula v3 (map_Formula (@Q_of_Rcst) v6)) (Reval_formula v3) v0 (fun v6 : Formula (@Rcst) => eq_ind (eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v3 v6) (fun v7 : Prop => v7 <-> Reval_formula v3 v6) ((fun v7 : Reval_formula v3 v6 <-> Reval_formula' v3 v6 => trans_sym_co_inv_impl_morphism (Equivalence_PER (@iff_equivalence)) (Reval_formula v3 v6) (Reval_formula' v3 v6) v7) (Reval_formula_compat v3 v6) (conj (fun v7 : eval_sformula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) to_nat (@pow) (@R_of_Rcst) v3 v6 => v7) (fun v7 : Reval_formula' v3 v6 => v7))) (eval_formula (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) v3 (map_Formula (@Q_of_Rcst) v6)) (eval_formulaSC (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@Rle) (@Rlt) (@Q2R) to_nat (@pow) (@Q_of_Rcst) (@R_of_Rcst) (fun v7 : @Rcst => eq_ind_r (fun v8 : @R => R_of_Rcst v7 = v8) eq_refl (Q_of_RcstR v7)) v3 v6) : QReval_formula v3 (map_Formula (@Q_of_Rcst) v6) <-> Reval_formula v3 v6)) v5) : forall (v2 : RTautoChecker v0 v1 = @true) (v3 : PolEnv (@R)), eval_bf (Reval_formula v3) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.SeqSeries.sum_maj1	100	2.871797	1	1	0	synth with cache (only 1: refine (fun (v0 : forall (v0 : @nat) (v1 : @R), @R) (v1 : forall v1 : @nat, @R) (v2 v3 v4 : @R) (v5 : @nat) (v6 : Un_cv (fun v6 : @nat => SP v0 v6 v2) v3) (v7 : Un_cv (fun v7 : @nat => sum_f_R0 v1 v7) v4) (v8 : forall v8 : @nat, Rabs (v0 v8 v2) <= v1 v8) => let v9 : {v9 : @R | Un_cv (fun v10 : @nat => sum_f_R0 (fun v11 : @nat => v0 (S v5 + v11)%nat v2) v10) v9} := exist (fun v9 : @R => Un_cv (fun v10 : @nat => sum_f_R0 (fun v11 : @nat => v0 (S v5 + v11)%nat v2) v10) v9) (v3 - SP v0 v5 v2) ((fun (v9 : @R) (v10 : v9 > IZR 0) => ex_ind (fun (v11 : @nat) (v12 : forall (v12 : @nat) (v13 : (v12 >= v11)%nat), R_dist (SP v0 v12 v2) v3 < v9) => ex_intro (fun v13 : @nat => forall (v14 : @nat) (v15 : (v14 >= v13)%nat), R_dist (sum_f_R0 (fun v16 : @nat => v0 (S v5 + v16)%nat v2) v14) (v3 - SP v0 v5 v2) < v9) v11 (fun (v13 : @nat) (v14 : (v13 >= v11)%nat) => ((let v15 : sum_f_R0 (fun v15 : @nat => v0 v15 v2) v5 + sum_f_R0 (fun v15 : @nat => v0 (S v5 + v15)%nat v2) v13 - v3 = sum_f_R0 (fun v15 : @nat => v0 (S v5 + v15)%nat v2) v13 - (v3 - sum_f_R0 (fun v15 : @nat => v0 v15 v2) v5) := let v15 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v16 : list (@R) := (sum_f_R0 (fun v16 : @nat => v0 v16 v2) v5 :: sum_f_R0 (fun v16 : @nat => v0 (S v5 + v16)%nat v2) v13 :: v3 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v16 v15 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))) (@I) (eq_refl : (let v17 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v15 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v17 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v17 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))))) = @true) in eq_ind (sum_f_R0 (fun v16 : @nat => v0 v16 v2) v5 + sum_f_R0 (fun v16 : @nat => v0 (S v5 + v16)%nat v2) v13 - v3) (fun v16 : @R => Rabs v16 < v9) (let v16 : sum_f_R0 (fun v16 : @nat => v0 v16 v2) (S (v5 + v13)) = sum_f_R0 (fun v16 : @nat => v0 v16 v2) v5 + sum_f_R0 (fun v16 : @nat => v0 (S v5 + v16)%nat v2) v13 := let v16 : (0 <= v5)%nat := Nat.le_0_l v5 in (let v17 : (v5 < S (v5 + v13))%nat := le_lt_n_Sm v5 (v5 + v13) (le_plus_l v5 v13) in (fun (v18 : (v5 < S (v5 + v13))%nat) (v19 : (0 <= v5)%nat) => let v20 : sigma (fun v20 : @nat => v0 v20 v2) 0 (S (v5 + v13)) = sigma (fun v20 : @nat => v0 v20 v2) 0 v5 + sigma (fun v20 : @nat => v0 v20 v2) (S v5) (S (v5 + v13)) := sigma_split (fun v20 : @nat => v0 v20 v2) v19 v18 in let v21 : sum_f_R0 (fun v21 : @nat => v0 (0 + v21)%nat v2) (S (v5 + v13)) = sum_f_R0 (fun v21 : @nat => v0 (0 + v21)%nat v2) (v5 - 0) + sum_f_R0 (fun v21 : @nat => v0 (S v5 + v21)%nat v2) (S (v5 + v13) - S v5) := eq_ind_r (fun v21 : @nat => sum_f_R0 (fun v22 : @nat => v0 (0 + v22)%nat v2) v21 = sum_f_R0 (fun v22 : @nat => v0 (0 + v22)%nat v2) (v5 - 0) + sum_f_R0 (fun v22 : @nat => v0 (S v5 + v22)%nat v2) (S (v5 + v13) - S v5)) v20 (minus_n_O (S (v5 + v13))) in let v22 : sum_f_R0 (fun v22 : @nat => v0 (0 + v22)%nat v2) (S (v5 + v13)) = sum_f_R0 (fun v22 : @nat => v0 (0 + v22)%nat v2) v5 + sum_f_R0 (fun v22 : @nat => v0 (S v5 + v22)%nat v2) (S (v5 + v13) - S v5) := eq_ind_r (fun v22 : @nat => sum_f_R0 (fun v23 : @nat => v0 (0 + v23)%nat v2) (S (v5 + v13)) = sum_f_R0 (fun v23 : @nat => v0 (0 + v23)%nat v2) v22 + sum_f_R0 (fun v23 : @nat => v0 (S v5 + v23)%nat v2) (S (v5 + v13) - S v5)) v21 (minus_n_O v5) in let v23 : sum_f_R0 (fun v23 : @nat => v0 (0 + v23)%nat v2) (S (v5 + v13)) = sum_f_R0 (fun v23 : @nat => v0 v23 v2) (S (v5 + v13)) := sum_eq (fun v23 : @nat => v0 (0 + v23)%nat v2) (fun v23 : @nat => v0 v23 v2) (S (v5 + v13)) (fun (v23 : @nat) (v24 : (v23 <= S (v5 + v13))%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v24 : @nat => v0 (0 + v24)%nat v2) (S (v5 + v13))) (fun v24 : @R => v24 = sum_f_R0 (fun v25 : @nat => v0 v25 v2) v5 + sum_f_R0 (fun v25 : @nat => v0 (S v5 + v25)%nat v2) v13) (let v24 : sum_f_R0 (fun v24 : @nat => v0 (0 + v24)%nat v2) v5 = sum_f_R0 (fun v24 : @nat => v0 v24 v2) v5 := sum_eq (fun v24 : @nat => v0 (0 + v24)%nat v2) (fun v24 : @nat => v0 v24 v2) v5 (fun (v24 : @nat) (v25 : (v24 <= v5)%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v25 : @nat => v0 (0 + v25)%nat v2) v5) (fun v25 : @R => sum_f_R0 (fun v26 : @nat => v0 (0 + v26)%nat v2) (S (v5 + v13)) = v25 + sum_f_R0 (fun v26 : @nat => v0 (S v5 + v26)%nat v2) v13) (let v25 : (S (v5 + v13) - S v5)%nat = v13 := INR_eq (S (v5 + v13) - S v5) v13 (eq_ind_r (fun v25 : @R => v25 = INR v13) (eq_ind_r (fun v25 : @R => v25 - INR (S v5) = INR v13) (eq_ind_r (fun v25 : @R => INR (v5 + v13) + IZR 1 - v25 = INR v13) (eq_ind_r (fun v25 : @R => v25 + IZR 1 - (INR v5 + IZR 1) = INR v13) (let v25 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v26 : list (@R) := (INR v5 :: INR v13 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v26 v25 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEX (@Z) 2) (@I) (eq_refl : (let v27 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v25 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEX (@Z) 2))) = @true)) (plus_INR v5 v13)) (S_INR v5)) (S_INR (v5 + v13))) (minus_INR (S (v5 + v13)) (S v5) (le_n_S v5 (v5 + v13) (le_plus_l v5 v13)))) in (fun v26 : (S (v5 + v13) - S v5)%nat = v13 => let v27 : sum_f_R0 (fun v27 : @nat => v0 (0 + v27)%nat v2) (S (v5 + v13)) = sum_f_R0 (fun v27 : @nat => v0 (0 + v27)%nat v2) v5 + sum_f_R0 (fun v27 : @nat => v0 (S v5 + v27)%nat v2) v13 := eq_ind (S (v5 + v13) - S v5)%nat (fun v27 : @nat => sum_f_R0 (fun v28 : @nat => v0 (0 + v28)%nat v2) (S (v5 + v13)) = sum_f_R0 (fun v28 : @nat => v0 (0 + v28)%nat v2) v5 + sum_f_R0 (fun v28 : @nat => v0 (S v5 + v28)%nat v2) v27) v22 v13 v26 in v27) v25) (sum_f_R0 (fun v25 : @nat => v0 v25 v2) v5) v24) (sum_f_R0 (fun v24 : @nat => v0 v24 v2) (S (v5 + v13))) v23) v17) v16 in eq_ind (sum_f_R0 (fun v17 : @nat => v0 v17 v2) (S (v5 + v13))) (fun v17 : @R => Rabs (v17 - v3) < v9) (v12 (S (v5 + v13)) (Nat.le_trans v11 v13 (S (v5 + v13)) v14 (Nat.le_trans v13 (v5 + v13) (S (v5 + v13)) (le_plus_r v5 v13) (Nat.le_succ_diag_r (v5 + v13))) : (S (v5 + v13) >= v11)%nat)) (sum_f_R0 (fun v17 : @nat => v0 v17 v2) v5 + sum_f_R0 (fun v17 : @nat => v0 (S v5 + v17)%nat v2) v13) v16) (sum_f_R0 (fun v16 : @nat => v0 (S v5 + v16)%nat v2) v13 - (v3 - sum_f_R0 (fun v16 : @nat => v0 v16 v2) v5)) v15) : Rabs (sum_f_R0 (fun v15 : @nat => v0 (S v5 + v15)%nat v2) v13 - (v3 - SP v0 v5 v2)) < v9) : R_dist (sum_f_R0 (fun v15 : @nat => v0 (S v5 + v15)%nat v2) v13) (v3 - SP v0 v5 v2) < v9)) (v6 v9 v10)) : Un_cv (fun v9 : @nat => sum_f_R0 (fun v10 : @nat => v0 (S v5 + v10)%nat v2) v9) (v3 - SP v0 v5 v2)) in (fun v10 : {v10 : @R | Un_cv (fun v11 : @nat => sum_f_R0 (fun v12 : @nat => v0 (S v5 + v12)%nat v2) v11) v10} => let v11 : {v11 : @R | Un_cv (fun v12 : @nat => sum_f_R0 (fun v13 : @nat => v1 (S v5 + v13)%nat) v12) v11} := exist (fun v11 : @R => Un_cv (fun v12 : @nat => sum_f_R0 (fun v13 : @nat => v1 (S v5 + v13)%nat) v12) v11) (v4 - sum_f_R0 v1 v5) ((fun (v11 : @R) (v12 : v11 > IZR 0) => ex_ind (fun (v13 : @nat) (v14 : forall (v14 : @nat) (v15 : (v14 >= v13)%nat), R_dist (sum_f_R0 v1 v14) v4 < v11) => ex_intro (fun v15 : @nat => forall (v16 : @nat) (v17 : (v16 >= v15)%nat), R_dist (sum_f_R0 (fun v18 : @nat => v1 (S v5 + v18)%nat) v16) (v4 - sum_f_R0 v1 v5) < v11) v13 (fun (v15 : @nat) (v16 : (v15 >= v13)%nat) => (let v17 : sum_f_R0 v1 v5 + sum_f_R0 (fun v17 : @nat => v1 (S v5 + v17)%nat) v15 - v4 = sum_f_R0 (fun v17 : @nat => v1 (S v5 + v17)%nat) v15 - (v4 - sum_f_R0 v1 v5) := let v17 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v18 : list (@R) := (sum_f_R0 v1 v5 :: sum_f_R0 (fun v18 : @nat => v1 (S v5 + v18)%nat) v15 :: v4 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v18 v17 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))) (@I) (eq_refl : (let v19 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v17 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))))) = @true) in eq_ind (sum_f_R0 v1 v5 + sum_f_R0 (fun v18 : @nat => v1 (S v5 + v18)%nat) v15 - v4) (fun v18 : @R => Rabs v18 < v11) (let v18 : sum_f_R0 v1 (S (v5 + v15)) = sum_f_R0 v1 v5 + sum_f_R0 (fun v18 : @nat => v1 (S v5 + v18)%nat) v15 := let v18 : (0 <= v5)%nat := Nat.le_0_l v5 in (let v19 : (v5 < S (v5 + v15))%nat := le_lt_n_Sm v5 (v5 + v15) (le_plus_l v5 v15) in (fun (v20 : (v5 < S (v5 + v15))%nat) (v21 : (0 <= v5)%nat) => let v22 : sigma v1 0 (S (v5 + v15)) = sigma v1 0 v5 + sigma v1 (S v5) (S (v5 + v15)) := sigma_split v1 v21 v20 in let v23 : sum_f_R0 (fun v23 : @nat => v1 (0 + v23)%nat) (S (v5 + v15)) = sum_f_R0 (fun v23 : @nat => v1 (0 + v23)%nat) (v5 - 0) + sum_f_R0 (fun v23 : @nat => v1 (S v5 + v23)%nat) (S (v5 + v15) - S v5) := eq_ind_r (fun v23 : @nat => sum_f_R0 (fun v24 : @nat => v1 (0 + v24)%nat) v23 = sum_f_R0 (fun v24 : @nat => v1 (0 + v24)%nat) (v5 - 0) + sum_f_R0 (fun v24 : @nat => v1 (S v5 + v24)%nat) (S (v5 + v15) - S v5)) v22 (minus_n_O (S (v5 + v15))) in let v24 : sum_f_R0 (fun v24 : @nat => v1 (0 + v24)%nat) (S (v5 + v15)) = sum_f_R0 (fun v24 : @nat => v1 (0 + v24)%nat) v5 + sum_f_R0 (fun v24 : @nat => v1 (S v5 + v24)%nat) (S (v5 + v15) - S v5) := eq_ind_r (fun v24 : @nat => sum_f_R0 (fun v25 : @nat => v1 (0 + v25)%nat) (S (v5 + v15)) = sum_f_R0 (fun v25 : @nat => v1 (0 + v25)%nat) v24 + sum_f_R0 (fun v25 : @nat => v1 (S v5 + v25)%nat) (S (v5 + v15) - S v5)) v23 (minus_n_O v5) in let v25 : sum_f_R0 (fun v25 : @nat => v1 (0 + v25)%nat) (S (v5 + v15)) = sum_f_R0 v1 (S (v5 + v15)) := sum_eq (fun v25 : @nat => v1 (0 + v25)%nat) v1 (S (v5 + v15)) (fun (v25 : @nat) (v26 : (v25 <= S (v5 + v15))%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v26 : @nat => v1 (0 + v26)%nat) (S (v5 + v15))) (fun v26 : @R => v26 = sum_f_R0 v1 v5 + sum_f_R0 (fun v27 : @nat => v1 (S v5 + v27)%nat) v15) (let v26 : sum_f_R0 (fun v26 : @nat => v1 (0 + v26)%nat) v5 = sum_f_R0 v1 v5 := sum_eq (fun v26 : @nat => v1 (0 + v26)%nat) v1 v5 (fun (v26 : @nat) (v27 : (v26 <= v5)%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v27 : @nat => v1 (0 + v27)%nat) v5) (fun v27 : @R => sum_f_R0 (fun v28 : @nat => v1 (0 + v28)%nat) (S (v5 + v15)) = v27 + sum_f_R0 (fun v28 : @nat => v1 (S v5 + v28)%nat) v15) (let v27 : (S (v5 + v15) - S v5)%nat = v15 := INR_eq (S (v5 + v15) - S v5) v15 (eq_ind_r (fun v27 : @R => v27 = INR v15) (eq_ind_r (fun v27 : @R => v27 - INR (S v5) = INR v15) (eq_ind_r (fun v27 : @R => INR (v5 + v15) + IZR 1 - v27 = INR v15) (eq_ind_r (fun v27 : @R => v27 + IZR 1 - (INR v5 + IZR 1) = INR v15) (let v27 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v28 : list (@R) := (INR v5 :: INR v15 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v28 v27 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEX (@Z) 2) (@I) (eq_refl : (let v29 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v27 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v29 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v29 (Ring_polynom.PEX (@Z) 2))) = @true)) (plus_INR v5 v15)) (S_INR v5)) (S_INR (v5 + v15))) (minus_INR (S (v5 + v15)) (S v5) (le_n_S v5 (v5 + v15) (le_plus_l v5 v15)))) in (fun v28 : (S (v5 + v15) - S v5)%nat = v15 => let v29 : sum_f_R0 (fun v29 : @nat => v1 (0 + v29)%nat) (S (v5 + v15)) = sum_f_R0 (fun v29 : @nat => v1 (0 + v29)%nat) v5 + sum_f_R0 (fun v29 : @nat => v1 (S v5 + v29)%nat) v15 := eq_ind (S (v5 + v15) - S v5)%nat (fun v29 : @nat => sum_f_R0 (fun v30 : @nat => v1 (0 + v30)%nat) (S (v5 + v15)) = sum_f_R0 (fun v30 : @nat => v1 (0 + v30)%nat) v5 + sum_f_R0 (fun v30 : @nat => v1 (S v5 + v30)%nat) v29) v24 v15 v28 in v29) v27) (sum_f_R0 v1 v5) v26) (sum_f_R0 v1 (S (v5 + v15))) v25) v19) v18 in eq_ind (sum_f_R0 v1 (S (v5 + v15))) (fun v19 : @R => Rabs (v19 - v4) < v11) (v14 (S (v5 + v15)) (Nat.le_trans v13 v15 (S (v5 + v15)) v16 (Nat.le_trans v15 (v5 + v15) (S (v5 + v15)) (le_plus_r v5 v15) (Nat.le_succ_diag_r (v5 + v15))) : (S (v5 + v15) >= v13)%nat)) (sum_f_R0 v1 v5 + sum_f_R0 (fun v19 : @nat => v1 (S v5 + v19)%nat) v15) v18) (sum_f_R0 (fun v18 : @nat => v1 (S v5 + v18)%nat) v15 - (v4 - sum_f_R0 v1 v5)) v17) : R_dist (sum_f_R0 (fun v17 : @nat => v1 (S v5 + v17)%nat) v15) (v4 - sum_f_R0 v1 v5) < v11)) (v7 v11 v12)) : Un_cv (fun v11 : @nat => sum_f_R0 (fun v12 : @nat => v1 (S v5 + v12)%nat) v11) (v4 - sum_f_R0 v1 v5)) in (fun v12 : {v12 : @R | Un_cv (fun v13 : @nat => sum_f_R0 (fun v14 : @nat => v1 (S v5 + v14)%nat) v13) v12} => sig_ind (fun v13 : {v13 : @R | Un_cv (fun v14 : @nat => sum_f_R0 (fun v15 : @nat => v0 (S v5 + v15)%nat v2) v14) v13} => Rabs (v3 - SP v0 v5 v2) <= v4 - sum_f_R0 v1 v5) (fun (v13 : @R) (v14 : Un_cv (fun v14 : @nat => sum_f_R0 (fun v15 : @nat => v0 (S v5 + v15)%nat v2) v14) v13) => sig_ind (fun v15 : {v15 : @R | Un_cv (fun v16 : @nat => sum_f_R0 (fun v17 : @nat => v1 (S v5 + v17)%nat) v16) v15} => Rabs (v3 - SP v0 v5 v2) <= v4 - sum_f_R0 v1 v5) (fun (v15 : @R) (v16 : Un_cv (fun v16 : @nat => sum_f_R0 (fun v17 : @nat => v1 (S v5 + v17)%nat) v16) v15) => let v17 : v3 - SP v0 v5 v2 = v13 := eq_sym (UL_sequence (fun v17 : @nat => sum_f_R0 (fun v18 : @nat => v0 (S v5 + v18)%nat v2) v17) v13 (v3 - SP v0 v5 v2) v14 ((fun (v17 : @R) (v18 : v17 > IZR 0) => ex_ind (fun (v19 : @nat) (v20 : forall (v20 : @nat) (v21 : (v20 >= v19)%nat), R_dist (SP v0 v20 v2) v3 < v17) => ex_intro (fun v21 : @nat => forall (v22 : @nat) (v23 : (v22 >= v21)%nat), R_dist (sum_f_R0 (fun v24 : @nat => v0 (S v5 + v24)%nat v2) v22) (v3 - SP v0 v5 v2) < v17) v19 (fun (v21 : @nat) (v22 : (v21 >= v19)%nat) => ((let v23 : sum_f_R0 (fun v23 : @nat => v0 v23 v2) v5 + sum_f_R0 (fun v23 : @nat => v0 (S v5 + v23)%nat v2) v21 - v3 = sum_f_R0 (fun v23 : @nat => v0 (S v5 + v23)%nat v2) v21 - (v3 - sum_f_R0 (fun v23 : @nat => v0 v23 v2) v5) := let v23 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v24 : list (@R) := (sum_f_R0 (fun v24 : @nat => v0 v24 v2) v5 :: sum_f_R0 (fun v24 : @nat => v0 (S v5 + v24)%nat v2) v21 :: v3 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v24 v23 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))) (@I) (eq_refl : (let v25 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v23 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v25 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v25 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))))) = @true) in eq_ind (sum_f_R0 (fun v24 : @nat => v0 v24 v2) v5 + sum_f_R0 (fun v24 : @nat => v0 (S v5 + v24)%nat v2) v21 - v3) (fun v24 : @R => Rabs v24 < v17) (let v24 : sum_f_R0 (fun v24 : @nat => v0 v24 v2) (S (v5 + v21)) = sum_f_R0 (fun v24 : @nat => v0 v24 v2) v5 + sum_f_R0 (fun v24 : @nat => v0 (S v5 + v24)%nat v2) v21 := let v24 : (0 <= v5)%nat := Nat.le_0_l v5 in (let v25 : (v5 < S (v5 + v21))%nat := le_lt_n_Sm v5 (v5 + v21) (le_plus_l v5 v21) in (fun (v26 : (v5 < S (v5 + v21))%nat) (v27 : (0 <= v5)%nat) => let v28 : sigma (fun v28 : @nat => v0 v28 v2) 0 (S (v5 + v21)) = sigma (fun v28 : @nat => v0 v28 v2) 0 v5 + sigma (fun v28 : @nat => v0 v28 v2) (S v5) (S (v5 + v21)) := sigma_split (fun v28 : @nat => v0 v28 v2) v27 v26 in let v29 : sum_f_R0 (fun v29 : @nat => v0 (0 + v29)%nat v2) (S (v5 + v21)) = sum_f_R0 (fun v29 : @nat => v0 (0 + v29)%nat v2) (v5 - 0) + sum_f_R0 (fun v29 : @nat => v0 (S v5 + v29)%nat v2) (S (v5 + v21) - S v5) := eq_ind_r (fun v29 : @nat => sum_f_R0 (fun v30 : @nat => v0 (0 + v30)%nat v2) v29 = sum_f_R0 (fun v30 : @nat => v0 (0 + v30)%nat v2) (v5 - 0) + sum_f_R0 (fun v30 : @nat => v0 (S v5 + v30)%nat v2) (S (v5 + v21) - S v5)) v28 (minus_n_O (S (v5 + v21))) in let v30 : sum_f_R0 (fun v30 : @nat => v0 (0 + v30)%nat v2) (S (v5 + v21)) = sum_f_R0 (fun v30 : @nat => v0 (0 + v30)%nat v2) v5 + sum_f_R0 (fun v30 : @nat => v0 (S v5 + v30)%nat v2) (S (v5 + v21) - S v5) := eq_ind_r (fun v30 : @nat => sum_f_R0 (fun v31 : @nat => v0 (0 + v31)%nat v2) (S (v5 + v21)) = sum_f_R0 (fun v31 : @nat => v0 (0 + v31)%nat v2) v30 + sum_f_R0 (fun v31 : @nat => v0 (S v5 + v31)%nat v2) (S (v5 + v21) - S v5)) v29 (minus_n_O v5) in let v31 : sum_f_R0 (fun v31 : @nat => v0 (0 + v31)%nat v2) (S (v5 + v21)) = sum_f_R0 (fun v31 : @nat => v0 v31 v2) (S (v5 + v21)) := sum_eq (fun v31 : @nat => v0 (0 + v31)%nat v2) (fun v31 : @nat => v0 v31 v2) (S (v5 + v21)) (fun (v31 : @nat) (v32 : (v31 <= S (v5 + v21))%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v32 : @nat => v0 (0 + v32)%nat v2) (S (v5 + v21))) (fun v32 : @R => v32 = sum_f_R0 (fun v33 : @nat => v0 v33 v2) v5 + sum_f_R0 (fun v33 : @nat => v0 (S v5 + v33)%nat v2) v21) (let v32 : sum_f_R0 (fun v32 : @nat => v0 (0 + v32)%nat v2) v5 = sum_f_R0 (fun v32 : @nat => v0 v32 v2) v5 := sum_eq (fun v32 : @nat => v0 (0 + v32)%nat v2) (fun v32 : @nat => v0 v32 v2) v5 (fun (v32 : @nat) (v33 : (v32 <= v5)%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v33 : @nat => v0 (0 + v33)%nat v2) v5) (fun v33 : @R => sum_f_R0 (fun v34 : @nat => v0 (0 + v34)%nat v2) (S (v5 + v21)) = v33 + sum_f_R0 (fun v34 : @nat => v0 (S v5 + v34)%nat v2) v21) (let v33 : (S (v5 + v21) - S v5)%nat = v21 := INR_eq (S (v5 + v21) - S v5) v21 (eq_ind_r (fun v33 : @R => v33 = INR v21) (eq_ind_r (fun v33 : @R => v33 - INR (S v5) = INR v21) (eq_ind_r (fun v33 : @R => INR (v5 + v21) + IZR 1 - v33 = INR v21) (eq_ind_r (fun v33 : @R => v33 + IZR 1 - (INR v5 + IZR 1) = INR v21) (let v33 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v34 : list (@R) := (INR v5 :: INR v21 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v34 v33 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEX (@Z) 2) (@I) (eq_refl : (let v35 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v33 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v35 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v35 (Ring_polynom.PEX (@Z) 2))) = @true)) (plus_INR v5 v21)) (S_INR v5)) (S_INR (v5 + v21))) (minus_INR (S (v5 + v21)) (S v5) (le_n_S v5 (v5 + v21) (le_plus_l v5 v21)))) in (fun v34 : (S (v5 + v21) - S v5)%nat = v21 => let v35 : sum_f_R0 (fun v35 : @nat => v0 (0 + v35)%nat v2) (S (v5 + v21)) = sum_f_R0 (fun v35 : @nat => v0 (0 + v35)%nat v2) v5 + sum_f_R0 (fun v35 : @nat => v0 (S v5 + v35)%nat v2) v21 := eq_ind (S (v5 + v21) - S v5)%nat (fun v35 : @nat => sum_f_R0 (fun v36 : @nat => v0 (0 + v36)%nat v2) (S (v5 + v21)) = sum_f_R0 (fun v36 : @nat => v0 (0 + v36)%nat v2) v5 + sum_f_R0 (fun v36 : @nat => v0 (S v5 + v36)%nat v2) v35) v30 v21 v34 in v35) v33) (sum_f_R0 (fun v33 : @nat => v0 v33 v2) v5) v32) (sum_f_R0 (fun v32 : @nat => v0 v32 v2) (S (v5 + v21))) v31) v25) v24 in eq_ind (sum_f_R0 (fun v25 : @nat => v0 v25 v2) (S (v5 + v21))) (fun v25 : @R => Rabs (v25 - v3) < v17) (v20 (S (v5 + v21)) (Nat.le_trans v19 v21 (S (v5 + v21)) v22 (Nat.le_trans v21 (v5 + v21) (S (v5 + v21)) (le_plus_r v5 v21) (Nat.le_succ_diag_r (v5 + v21))) : (S (v5 + v21) >= v19)%nat)) (sum_f_R0 (fun v25 : @nat => v0 v25 v2) v5 + sum_f_R0 (fun v25 : @nat => v0 (S v5 + v25)%nat v2) v21) v24) (sum_f_R0 (fun v24 : @nat => v0 (S v5 + v24)%nat v2) v21 - (v3 - sum_f_R0 (fun v24 : @nat => v0 v24 v2) v5)) v23) : Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v5 + v23)%nat v2) v21 - (v3 - SP v0 v5 v2)) < v17) : R_dist (sum_f_R0 (fun v23 : @nat => v0 (S v5 + v23)%nat v2) v21) (v3 - SP v0 v5 v2) < v17)) (v6 v17 v18)) : Un_cv (fun v17 : @nat => sum_f_R0 (fun v18 : @nat => v0 (S v5 + v18)%nat v2) v17) (v3 - SP v0 v5 v2))) in (fun v18 : v3 - SP v0 v5 v2 = v13 => let v19 : v4 - sum_f_R0 v1 v5 = v15 := eq_sym (UL_sequence (fun v19 : @nat => sum_f_R0 (fun v20 : @nat => v1 (S v5 + v20)%nat) v19) v15 (v4 - sum_f_R0 v1 v5) v16 ((fun (v19 : @R) (v20 : v19 > IZR 0) => ex_ind (fun (v21 : @nat) (v22 : forall (v22 : @nat) (v23 : (v22 >= v21)%nat), R_dist (sum_f_R0 v1 v22) v4 < v19) => ex_intro (fun v23 : @nat => forall (v24 : @nat) (v25 : (v24 >= v23)%nat), R_dist (sum_f_R0 (fun v26 : @nat => v1 (S v5 + v26)%nat) v24) (v4 - sum_f_R0 v1 v5) < v19) v21 (fun (v23 : @nat) (v24 : (v23 >= v21)%nat) => (let v25 : sum_f_R0 v1 v5 + sum_f_R0 (fun v25 : @nat => v1 (S v5 + v25)%nat) v23 - v4 = sum_f_R0 (fun v25 : @nat => v1 (S v5 + v25)%nat) v23 - (v4 - sum_f_R0 v1 v5) := let v25 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v26 : list (@R) := (sum_f_R0 v1 v5 :: sum_f_R0 (fun v26 : @nat => v1 (S v5 + v26)%nat) v23 :: v4 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v26 v25 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))) (@I) (eq_refl : (let v27 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v25 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 1))))) = @true) in eq_ind (sum_f_R0 v1 v5 + sum_f_R0 (fun v26 : @nat => v1 (S v5 + v26)%nat) v23 - v4) (fun v26 : @R => Rabs v26 < v19) (let v26 : sum_f_R0 v1 (S (v5 + v23)) = sum_f_R0 v1 v5 + sum_f_R0 (fun v26 : @nat => v1 (S v5 + v26)%nat) v23 := let v26 : (0 <= v5)%nat := Nat.le_0_l v5 in (let v27 : (v5 < S (v5 + v23))%nat := le_lt_n_Sm v5 (v5 + v23) (le_plus_l v5 v23) in (fun (v28 : (v5 < S (v5 + v23))%nat) (v29 : (0 <= v5)%nat) => let v30 : sigma v1 0 (S (v5 + v23)) = sigma v1 0 v5 + sigma v1 (S v5) (S (v5 + v23)) := sigma_split v1 v29 v28 in let v31 : sum_f_R0 (fun v31 : @nat => v1 (0 + v31)%nat) (S (v5 + v23)) = sum_f_R0 (fun v31 : @nat => v1 (0 + v31)%nat) (v5 - 0) + sum_f_R0 (fun v31 : @nat => v1 (S v5 + v31)%nat) (S (v5 + v23) - S v5) := eq_ind_r (fun v31 : @nat => sum_f_R0 (fun v32 : @nat => v1 (0 + v32)%nat) v31 = sum_f_R0 (fun v32 : @nat => v1 (0 + v32)%nat) (v5 - 0) + sum_f_R0 (fun v32 : @nat => v1 (S v5 + v32)%nat) (S (v5 + v23) - S v5)) v30 (minus_n_O (S (v5 + v23))) in let v32 : sum_f_R0 (fun v32 : @nat => v1 (0 + v32)%nat) (S (v5 + v23)) = sum_f_R0 (fun v32 : @nat => v1 (0 + v32)%nat) v5 + sum_f_R0 (fun v32 : @nat => v1 (S v5 + v32)%nat) (S (v5 + v23) - S v5) := eq_ind_r (fun v32 : @nat => sum_f_R0 (fun v33 : @nat => v1 (0 + v33)%nat) (S (v5 + v23)) = sum_f_R0 (fun v33 : @nat => v1 (0 + v33)%nat) v32 + sum_f_R0 (fun v33 : @nat => v1 (S v5 + v33)%nat) (S (v5 + v23) - S v5)) v31 (minus_n_O v5) in let v33 : sum_f_R0 (fun v33 : @nat => v1 (0 + v33)%nat) (S (v5 + v23)) = sum_f_R0 v1 (S (v5 + v23)) := sum_eq (fun v33 : @nat => v1 (0 + v33)%nat) v1 (S (v5 + v23)) (fun (v33 : @nat) (v34 : (v33 <= S (v5 + v23))%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v34 : @nat => v1 (0 + v34)%nat) (S (v5 + v23))) (fun v34 : @R => v34 = sum_f_R0 v1 v5 + sum_f_R0 (fun v35 : @nat => v1 (S v5 + v35)%nat) v23) (let v34 : sum_f_R0 (fun v34 : @nat => v1 (0 + v34)%nat) v5 = sum_f_R0 v1 v5 := sum_eq (fun v34 : @nat => v1 (0 + v34)%nat) v1 v5 (fun (v34 : @nat) (v35 : (v34 <= v5)%nat) => eq_refl) in eq_ind (sum_f_R0 (fun v35 : @nat => v1 (0 + v35)%nat) v5) (fun v35 : @R => sum_f_R0 (fun v36 : @nat => v1 (0 + v36)%nat) (S (v5 + v23)) = v35 + sum_f_R0 (fun v36 : @nat => v1 (S v5 + v36)%nat) v23) (let v35 : (S (v5 + v23) - S v5)%nat = v23 := INR_eq (S (v5 + v23) - S v5) v23 (eq_ind_r (fun v35 : @R => v35 = INR v23) (eq_ind_r (fun v35 : @R => v35 - INR (S v5) = INR v23) (eq_ind_r (fun v35 : @R => INR (v5 + v23) + IZR 1 - v35 = INR v23) (eq_ind_r (fun v35 : @R => v35 + IZR 1 - (INR v5 + IZR 1) = INR v23) (let v35 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v36 : list (@R) := (INR v5 :: INR v23 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v36 v35 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEX (@Z) 2) (@I) (eq_refl : (let v37 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v35 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v37 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 1%Z)) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 1%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v37 (Ring_polynom.PEX (@Z) 2))) = @true)) (plus_INR v5 v23)) (S_INR v5)) (S_INR (v5 + v23))) (minus_INR (S (v5 + v23)) (S v5) (le_n_S v5 (v5 + v23) (le_plus_l v5 v23)))) in (fun v36 : (S (v5 + v23) - S v5)%nat = v23 => let v37 : sum_f_R0 (fun v37 : @nat => v1 (0 + v37)%nat) (S (v5 + v23)) = sum_f_R0 (fun v37 : @nat => v1 (0 + v37)%nat) v5 + sum_f_R0 (fun v37 : @nat => v1 (S v5 + v37)%nat) v23 := eq_ind (S (v5 + v23) - S v5)%nat (fun v37 : @nat => sum_f_R0 (fun v38 : @nat => v1 (0 + v38)%nat) (S (v5 + v23)) = sum_f_R0 (fun v38 : @nat => v1 (0 + v38)%nat) v5 + sum_f_R0 (fun v38 : @nat => v1 (S v5 + v38)%nat) v37) v32 v23 v36 in v37) v35) (sum_f_R0 v1 v5) v34) (sum_f_R0 v1 (S (v5 + v23))) v33) v27) v26 in eq_ind (sum_f_R0 v1 (S (v5 + v23))) (fun v27 : @R => Rabs (v27 - v4) < v19) (v22 (S (v5 + v23)) (Nat.le_trans v21 v23 (S (v5 + v23)) v24 (Nat.le_trans v23 (v5 + v23) (S (v5 + v23)) (le_plus_r v5 v23) (Nat.le_succ_diag_r (v5 + v23))) : (S (v5 + v23) >= v21)%nat)) (sum_f_R0 v1 v5 + sum_f_R0 (fun v27 : @nat => v1 (S v5 + v27)%nat) v23) v26) (sum_f_R0 (fun v26 : @nat => v1 (S v5 + v26)%nat) v23 - (v4 - sum_f_R0 v1 v5)) v25) : R_dist (sum_f_R0 (fun v25 : @nat => v1 (S v5 + v25)%nat) v23) (v4 - sum_f_R0 v1 v5) < v19)) (v7 v19 v20)) : Un_cv (fun v19 : @nat => sum_f_R0 (fun v20 : @nat => v1 (S v5 + v20)%nat) v19) (v4 - sum_f_R0 v1 v5))) in (fun v20 : v4 - sum_f_R0 v1 v5 = v15 => eq_ind_r (fun v21 : @R => Rabs v21 <= v4 - sum_f_R0 v1 v5) (eq_ind_r (fun v21 : @R => Rabs v13 <= v21) (sum_cv_maj (fun v21 : @nat => v1 (S v5 + v21)%nat) (fun (v21 : @nat) (v22 : @R) => v0 (S v5 + v21)%nat v22) v2 v13 v15 (v14 : Un_cv (fun v21 : @nat => SP (fun (v22 : @nat) (v23 : @R) => v0 (S v5 + v22)%nat v23) v21 v2) v13) v16 (fun v21 : @nat => v8 (S v5 + v21)%nat)) v20) v18) v19) v17) v12) v10) v11) v9)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.SeqSeries.Rseries_CV_comp	100	1.359749	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @nat, @R) (v2 : forall v2 : @nat, IZR 0 <= v0 v2 <= v1 v2) (v3 : {v3 : @R | Un_cv (fun v4 : @nat => sum_f_R0 v1 v4) v3}) => cv_cauchy_2 v0 (let v4 : Cauchy_crit_series v1 := cv_cauchy_1 v1 v3 in ((fun (v5 : @R) (v6 : v5 > IZR 0) => ex_ind (fun (v7 : @nat) (v8 : forall (v8 v9 : @nat) (v10 : (v8 >= v7)%nat) (v11 : (v9 >= v7)%nat), R_dist (sum_f_R0 v1 v8) (sum_f_R0 v1 v9) < v5) => ex_intro (fun v9 : @nat => forall (v10 v11 : @nat) (v12 : (v10 >= v9)%nat) (v13 : (v11 >= v9)%nat), R_dist (sum_f_R0 v0 v10) (sum_f_R0 v0 v11) < v5) v7 (fun (v9 v10 : @nat) (v11 : (v9 >= v7)%nat) (v12 : (v10 >= v7)%nat) => let v13 : R_dist (sum_f_R0 v0 v9) (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v10) := let v13 : {(v9 < v10)%nat} + {v9 = v10} + {(v10 < v9)%nat} := lt_eq_lt_dec v9 v10 in match v13 as v14 in (_ + {_}) return (R_dist (sum_f_R0 v0 v9) (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v10)) with | inleft v14 => (fun v14 : {(v9 < v10)%nat} + {v9 = v10} => match v14 as v15 in ({_} + {_}) return (R_dist (sum_f_R0 v0 v9) (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v10)) with | left v15 => (fun v15 : (v9 < v10)%nat => eq_ind_r (fun v16 : @R => R_dist (sum_f_R0 v0 v9) v16 <= R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v10)) (eq_ind_r (fun v16 : @R => R_dist (sum_f_R0 v0 v9) (sum_f_R0 v0 v9 + sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9)) <= R_dist (sum_f_R0 v1 v9) v16) ((eq_ind_r (fun v16 : @R => Rabs (sum_f_R0 v0 v9 + v16) <= Rabs (sum_f_R0 v1 v9 + - (sum_f_R0 v1 v9 + sum_f_R0 (fun v17 : @nat => v1 (S v9 + v17)%nat) (v10 - S v9)))) (eq_ind_r (fun v16 : @R => Rabs (sum_f_R0 v0 v9 + (- sum_f_R0 v0 v9 + - sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9))) <= Rabs (sum_f_R0 v1 v9 + v16)) (eq_ind (sum_f_R0 v0 v9 + - sum_f_R0 v0 v9 + - sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9)) (fun v16 : @R => Rabs v16 <= Rabs (sum_f_R0 v1 v9 + (- sum_f_R0 v1 v9 + - sum_f_R0 (fun v17 : @nat => v1 (S v9 + v17)%nat) (v10 - S v9)))) (eq_ind (sum_f_R0 v1 v9 + - sum_f_R0 v1 v9 + - sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)) (fun v16 : @R => Rabs (sum_f_R0 v0 v9 + - sum_f_R0 v0 v9 + - sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9)) <= Rabs v16) (eq_ind_r (fun v16 : @R => Rabs (v16 + - sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9)) <= Rabs (sum_f_R0 v1 v9 + - sum_f_R0 v1 v9 + - sum_f_R0 (fun v17 : @nat => v1 (S v9 + v17)%nat) (v10 - S v9))) (eq_ind_r (fun v16 : @R => Rabs (IZR 0 + - sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9)) <= Rabs (v16 + - sum_f_R0 (fun v17 : @nat => v1 (S v9 + v17)%nat) (v10 - S v9))) (eq_ind_r (fun v16 : @R => Rabs v16 <= Rabs (IZR 0 + - sum_f_R0 (fun v17 : @nat => v1 (S v9 + v17)%nat) (v10 - S v9))) (eq_ind_r (fun v16 : @R => Rabs (- sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9)) <= Rabs v16) (eq_ind_r (fun v16 : @R => v16 <= Rabs (- sum_f_R0 (fun v17 : @nat => v1 (S v9 + v17)%nat) (v10 - S v9))) (eq_ind_r (fun v16 : @R => Rabs (sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9)) <= v16) (eq_ind_r (fun v16 : @R => v16 <= Rabs (sum_f_R0 (fun v17 : @nat => v1 (S v9 + v17)%nat) (v10 - S v9))) (eq_ind_r (fun v16 : @R => sum_f_R0 (fun v17 : @nat => v0 (S v9 + v17)%nat) (v10 - S v9) <= v16) (sum_Rle (fun v16 : @nat => v0 (S v9 + v16)%nat) (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9) (fun (v16 : @nat) (v17 : (v16 <= v10 - S v9)%nat) => and_ind (fun (v18 : IZR 0 <= v0 (S v9 + v16)%nat) (v19 : v0 (S v9 + v16)%nat <= v1 (S v9 + v16)%nat) => v19) (v2 (S v9 + v16)%nat))) (Rabs_right (sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)) (Rle_ge (IZR 0) (sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)) (cond_pos_sum (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9) (fun v16 : @nat => and_ind (fun (v17 : IZR 0 <= v0 (S v9 + v16)%nat) (v18 : v0 (S v9 + v16)%nat <= v1 (S v9 + v16)%nat) => Rle_trans (IZR 0) (v0 (S v9 + v16)%nat) (v1 (S v9 + v16)%nat) v17 v18) (v2 (S v9 + v16)%nat)))))) (Rabs_right (sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9)) (Rle_ge (IZR 0) (sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9)) (cond_pos_sum (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9) (fun v16 : @nat => and_ind (fun (v17 : IZR 0 <= v0 (S v9 + v16)%nat) (v18 : v0 (S v9 + v16)%nat <= v1 (S v9 + v16)%nat) => v17) (v2 (S v9 + v16)%nat)))))) (Rabs_Ropp (sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)))) (Rabs_Ropp (sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9)))) (Rplus_0_l (- sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)))) (Rplus_0_l (- sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9)))) (Rplus_opp_r (sum_f_R0 v1 v9))) (Rplus_opp_r (sum_f_R0 v0 v9))) (sum_f_R0 v1 v9 + (- sum_f_R0 v1 v9 + - sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9))) (Rplus_assoc (sum_f_R0 v1 v9) (- sum_f_R0 v1 v9) (- sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)))) (sum_f_R0 v0 v9 + (- sum_f_R0 v0 v9 + - sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9))) (Rplus_assoc (sum_f_R0 v0 v9) (- sum_f_R0 v0 v9) (- sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9)))) (Ropp_plus_distr (sum_f_R0 v1 v9) (sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)))) (Ropp_plus_distr (sum_f_R0 v0 v9) (sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9))) : Rabs (sum_f_R0 v0 v9 - (sum_f_R0 v0 v9 + sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9))) <= Rabs (sum_f_R0 v1 v9 - (sum_f_R0 v1 v9 + sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9)))) : R_dist (sum_f_R0 v0 v9) (sum_f_R0 v0 v9 + sum_f_R0 (fun v16 : @nat => v0 (S v9 + v16)%nat) (v10 - S v9)) <= R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v9 + sum_f_R0 (fun v16 : @nat => v1 (S v9 + v16)%nat) (v10 - S v9))) (tech2 v1 v9 v10 v15)) (tech2 v0 v9 v10 v15)) v15 | right v15 => (fun v15 : v9 = v10 => eq_ind_r (fun v16 : @nat => forall v17 : (v16 >= v7)%nat, R_dist (sum_f_R0 v0 v16) (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v16) (sum_f_R0 v1 v10)) (fun v16 : (v10 >= v7)%nat => (eq_ind_r (fun v17 : @R => Rabs v17 <= Rabs (sum_f_R0 v1 v10 + - sum_f_R0 v1 v10)) (eq_ind_r (fun v17 : @R => Rabs (IZR 0) <= Rabs v17) (eq_ind_r (fun v17 : @R => v17 <= v17) (or_intror eq_refl) (@Rabs_R0)) (Rplus_opp_r (sum_f_R0 v1 v10))) (Rplus_opp_r (sum_f_R0 v0 v10)) : Rabs (sum_f_R0 v0 v10 - sum_f_R0 v0 v10) <= Rabs (sum_f_R0 v1 v10 - sum_f_R0 v1 v10)) : R_dist (sum_f_R0 v0 v10) (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v10) (sum_f_R0 v1 v10)) v15 v11) v15 end) v14 | inright v14 => (fun v14 : (v10 < v9)%nat => eq_ind_r (fun v15 : @R => R_dist v15 (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v10)) (eq_ind_r (fun v15 : @R => R_dist (sum_f_R0 v0 v10 + sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10)) (sum_f_R0 v0 v10) <= R_dist v15 (sum_f_R0 v1 v10)) ((eq_ind_r (fun v15 : @R => Rabs v15 <= Rabs (sum_f_R0 v1 v10 + sum_f_R0 (fun v16 : @nat => v1 (S v10 + v16)%nat) (v9 - S v10) + - sum_f_R0 v1 v10)) (eq_ind_r (fun v15 : @R => Rabs (sum_f_R0 v0 v10 + (sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10) + - sum_f_R0 v0 v10)) <= Rabs v15) (eq_ind_r (fun v15 : @R => Rabs v15 <= Rabs (sum_f_R0 v1 v10 + (sum_f_R0 (fun v16 : @nat => v1 (S v10 + v16)%nat) (v9 - S v10) + - sum_f_R0 v1 v10))) (eq_ind_r (fun v15 : @R => Rabs (sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10) + - sum_f_R0 v0 v10 + sum_f_R0 v0 v10) <= Rabs v15) (eq_ind_r (fun v15 : @R => Rabs v15 <= Rabs (sum_f_R0 (fun v16 : @nat => v1 (S v10 + v16)%nat) (v9 - S v10) + - sum_f_R0 v1 v10 + sum_f_R0 v1 v10)) (eq_ind_r (fun v15 : @R => Rabs (sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10) + (- sum_f_R0 v0 v10 + sum_f_R0 v0 v10)) <= Rabs v15) (eq_ind_r (fun v15 : @R => Rabs (sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10) + v15) <= Rabs (sum_f_R0 (fun v16 : @nat => v1 (S v10 + v16)%nat) (v9 - S v10) + (- sum_f_R0 v1 v10 + sum_f_R0 v1 v10))) (eq_ind_r (fun v15 : @R => Rabs (sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10) + IZR 0) <= Rabs (sum_f_R0 (fun v16 : @nat => v1 (S v10 + v16)%nat) (v9 - S v10) + v15)) (eq_ind_r (fun v15 : @R => Rabs v15 <= Rabs (sum_f_R0 (fun v16 : @nat => v1 (S v10 + v16)%nat) (v9 - S v10) + IZR 0)) (eq_ind_r (fun v15 : @R => Rabs (sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10)) <= Rabs v15) (eq_ind_r (fun v15 : @R => v15 <= Rabs (sum_f_R0 (fun v16 : @nat => v1 (S v10 + v16)%nat) (v9 - S v10))) (eq_ind_r (fun v15 : @R => sum_f_R0 (fun v16 : @nat => v0 (S v10 + v16)%nat) (v9 - S v10) <= v15) (sum_Rle (fun v15 : @nat => v0 (S v10 + v15)%nat) (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10) (fun (v15 : @nat) (v16 : (v15 <= v9 - S v10)%nat) => and_ind (fun (v17 : IZR 0 <= v0 (S v10 + v15)%nat) (v18 : v0 (S v10 + v15)%nat <= v1 (S v10 + v15)%nat) => v18) (v2 (S v10 + v15)%nat))) (Rabs_right (sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10)) (Rle_ge (IZR 0) (sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10)) (cond_pos_sum (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10) (fun v15 : @nat => and_ind (fun (v16 : IZR 0 <= v0 (S v10 + v15)%nat) (v17 : v0 (S v10 + v15)%nat <= v1 (S v10 + v15)%nat) => Rle_trans (IZR 0) (v0 (S v10 + v15)%nat) (v1 (S v10 + v15)%nat) v16 v17) (v2 (S v10 + v15)%nat)))))) (Rabs_right (sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10)) (Rle_ge (IZR 0) (sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10)) (cond_pos_sum (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10) (fun v15 : @nat => and_ind (fun (v16 : IZR 0 <= v0 (S v10 + v15)%nat) (v17 : v0 (S v10 + v15)%nat <= v1 (S v10 + v15)%nat) => v16) (v2 (S v10 + v15)%nat)))))) (Rplus_0_r (sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10)))) (Rplus_0_r (sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10)))) (Rplus_opp_l (sum_f_R0 v1 v10))) (Rplus_opp_l (sum_f_R0 v0 v10))) (Rplus_assoc (sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10)) (- sum_f_R0 v1 v10) (sum_f_R0 v1 v10))) (Rplus_assoc (sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10)) (- sum_f_R0 v0 v10) (sum_f_R0 v0 v10))) (Rplus_comm (sum_f_R0 v1 v10) (sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10) + - sum_f_R0 v1 v10))) (Rplus_comm (sum_f_R0 v0 v10) (sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10) + - sum_f_R0 v0 v10))) (Rplus_assoc (sum_f_R0 v1 v10) (sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10)) (- sum_f_R0 v1 v10))) (Rplus_assoc (sum_f_R0 v0 v10) (sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10)) (- sum_f_R0 v0 v10)) : Rabs (sum_f_R0 v0 v10 + sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10) - sum_f_R0 v0 v10) <= Rabs (sum_f_R0 v1 v10 + sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10) - sum_f_R0 v1 v10)) : R_dist (sum_f_R0 v0 v10 + sum_f_R0 (fun v15 : @nat => v0 (S v10 + v15)%nat) (v9 - S v10)) (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v10 + sum_f_R0 (fun v15 : @nat => v1 (S v10 + v15)%nat) (v9 - S v10)) (sum_f_R0 v1 v10)) (tech2 v1 v10 v9 v14)) (tech2 v0 v10 v9 v14)) v14 end in (fun v14 : R_dist (sum_f_R0 v0 v9) (sum_f_R0 v0 v10) <= R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v10) => Rle_lt_trans (R_dist (sum_f_R0 v0 v9) (sum_f_R0 v0 v10)) (R_dist (sum_f_R0 v1 v9) (sum_f_R0 v1 v10)) v5 v14 (v8 v9 v10 v11 v12)) v13)) (v4 v5 v6)) : Cauchy_crit (fun v5 : @nat => sum_f_R0 v0 v5)) : Cauchy_crit_series v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.SeqSeries.Cesaro	100	3.269438	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @nat, @R) (v2 : @R) (v3 : forall (v3 : @R) (v4 : v3 > IZR 0), exists v5 : @nat, forall (v6 : @nat) (v7 : (v6 >= v5)%nat), R_dist (v1 v6) v2 < v3) (v4 : forall v4 : @nat, IZR 0 < v0 v4) (v5 : cv_infty (fun v5 : @nat => sum_f_R0 v0 v5)) (v6 : @R) (v7 : v6 > IZR 0) => let v8 : forall v8 : @nat, IZR 0 < sum_f_R0 v0 v8 := fun v8 : @nat => tech1 v0 v8 (fun (v9 : @nat) (v10 : (v9 <= v8)%nat) => v4 v9) in let v9 : forall v9 : @nat, sum_f_R0 v0 v9 <> IZR 0 := fun v9 : @nat => (fun v10 : sum_f_R0 v0 v9 = IZR 0 => let v11 : IZR 0 < sum_f_R0 v0 v9 := v8 v9 in let v12 : IZR 0 < IZR 0 := eq_ind (sum_f_R0 v0 v9) (fun v12 : @R => IZR 0 < v12) v11 (IZR 0) v10 in False_ind (@False) (Rlt_irrefl (IZR 0) v12)) : sum_f_R0 v0 v9 <> IZR 0 in let v10 : Un_cv (fun v10 : @nat => / sum_f_R0 v0 v10) (IZR 0) := cv_infty_cv_R0 (sum_f_R0 v0) v9 v5 in let v11 : IZR 0 < v6 / IZR 2 := Rmult_lt_0_compat v6 (/ IZR 2) v7 (Rinv_0_lt_compat (IZR 2) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1))) : IZR 0 < v6 / IZR 2 in ex_ind (fun (v12 : @nat) (v13 : forall (v13 : @nat) (v14 : (v13 >= v12)%nat), R_dist (v1 v13) v2 < v6 / IZR 2) => let v14 : @R := Rabs (sum_f_R0 (fun v14 : @nat => v0 v14 * (v1 v14 - v2)) v12) in let v15 : exists v15 : @nat, forall (v16 : @nat) (v17 : (v15 <= v16)%nat), v14 / sum_f_R0 v0 v16 < v6 / IZR 2 := match Req_dec v14 (IZR 0) as v15 in (_ \/ _) return (exists v16 : @nat, forall (v17 : @nat) (v18 : (v16 <= v17)%nat), v14 / sum_f_R0 v0 v17 < v6 / IZR 2) with | or_introl v15 => (fun v15 : v14 = IZR 0 => ex_intro (fun v16 : @nat => forall (v17 : @nat) (v18 : (v16 <= v17)%nat), v14 / sum_f_R0 v0 v17 < v6 / IZR 2) 0%nat (fun (v16 : @nat) (v17 : (0 <= v16)%nat) => eq_ind_r (fun v18 : @R => v18 / sum_f_R0 v0 v16 < v6 / IZR 2) (eq_ind_r (fun v18 : @R => v18 < v6 * / IZR 2) (Rmult_lt_0_compat v6 (/ IZR 2) v7 (Rinv_0_lt_compat (IZR 2) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)))) (Rmult_0_l (/ sum_f_R0 v0 v16)) : IZR 0 / sum_f_R0 v0 v16 < v6 / IZR 2) v15)) v15 | or_intror v15 => (fun v15 : v14 <> IZR 0 => let v16 : IZR 0 < v6 / (IZR 2 * Rabs v14) := Rmult_lt_0_compat v6 (/ (IZR 2 * Rabs v14)) v7 (Rinv_0_lt_compat (IZR 2 * Rabs v14) (Rmult_lt_0_compat (IZR 2) (Rabs v14) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (Rabs_pos_lt v14 v15))) : IZR 0 < v6 / (IZR 2 * Rabs v14) in ex_ind (fun (v17 : @nat) (v18 : forall (v18 : @nat) (v19 : (v18 >= v17)%nat), R_dist (/ sum_f_R0 v0 v18) (IZR 0) < v6 / (IZR 2 * Rabs v14)) => ex_intro (fun v19 : @nat => forall (v20 : @nat) (v21 : (v19 <= v20)%nat), v14 / sum_f_R0 v0 v20 < v6 / IZR 2) v17 (fun (v19 : @nat) (v20 : (v17 <= v19)%nat) => let v21 : R_dist (/ sum_f_R0 v0 v19) (IZR 0) < v6 / (IZR 2 * Rabs v14) := v18 v19 v20 in let v22 : Rabs (/ sum_f_R0 v0 v19 + IZR 0) < v6 / (IZR 2 * Rabs v14) := eq_ind (- IZR 0) (fun v22 : @R => Rabs (/ sum_f_R0 v0 v19 + v22) < v6 / (IZR 2 * Rabs v14)) v21 (IZR 0) (@Ropp_0) in let v23 : Rabs (/ sum_f_R0 v0 v19) < v6 / (IZR 2 * Rabs v14) := eq_ind (/ sum_f_R0 v0 v19 + IZR 0) (fun v23 : @R => Rabs v23 < v6 / (IZR 2 * Rabs v14)) v22 (/ sum_f_R0 v0 v19) (Rplus_0_r (/ sum_f_R0 v0 v19)) in Rle_lt_trans (v14 / sum_f_R0 v0 v19) (Rabs (v14 / sum_f_R0 v0 v19)) (v6 / IZR 2) (RRle_abs (v14 / sum_f_R0 v0 v19)) (eq_ind_r (fun v24 : @R => v24 < v6 * / IZR 2) (Rmult_lt_reg_l (/ Rabs v14) (Rabs v14 * Rabs (/ sum_f_R0 v0 v19)) (v6 * / IZR 2) (Rinv_0_lt_compat (Rabs v14) (Rabs_pos_lt v14 v15)) (eq_ind (/ Rabs v14 * Rabs v14 * Rabs (/ sum_f_R0 v0 v19)) (fun v24 : @R => v24 < / Rabs v14 * (v6 * / IZR 2)) (eq_ind (IZR 1) (fun v24 : @R => v24 * Rabs (/ sum_f_R0 v0 v19) < / Rabs v14 * (v6 * / IZR 2)) (eq_ind_r (fun v24 : @R => v24 < / Rabs v14 * (v6 * / IZR 2)) (let v24 : v6 / (IZR 2 * Rabs v14) = / Rabs v14 * (v6 * / IZR 2) := eq_ind_r (fun v24 : @R => v6 * v24 = / Rabs v14 * (v6 * / IZR 2)) (let v24 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v25 : list (@R) := (v6 :: / IZR 2 :: / Rabs v14 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v25 v24 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (@I) (eq_refl : (let v26 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v24 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v26 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v26 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))))) = @true)) (Rinv_mult_distr (IZR 2) (Rabs v14) (IZR_neq 2 0 ((fun v24 : 2%Z = 0%Z => let v25 : @False := eq_ind 2%Z (fun v25 : @Z => match v25 as v26 in Z return Prop with | 0%Z => @False | Z.pos v26 => (fun v26 : @positive => @True) v26 | Z.neg v26 => (fun v26 : @positive => @False) v26 end) (@I) 0%Z v24 in False_ind (@False) v25) : 2%Z <> 0%Z)) (Rabs_no_R0 v14 v15)) : v6 / (IZR 2 * Rabs v14) = / Rabs v14 * (v6 * / IZR 2) in eq_ind (v6 / (IZR 2 * Rabs v14)) (fun v25 : @R => Rabs (/ sum_f_R0 v0 v19) < v25) v23 (/ Rabs v14 * (v6 * / IZR 2)) v24) (Rmult_1_l (Rabs (/ sum_f_R0 v0 v19)))) (/ Rabs v14 * Rabs v14) (Rinv_l_sym (Rabs v14) (Rabs_no_R0 v14 v15))) (/ Rabs v14 * (Rabs v14 * Rabs (/ sum_f_R0 v0 v19))) (Rmult_assoc (/ Rabs v14) (Rabs v14) (Rabs (/ sum_f_R0 v0 v19))))) (Rabs_mult v14 (/ sum_f_R0 v0 v19)) : Rabs (v14 / sum_f_R0 v0 v19) < v6 / IZR 2))) (v10 (v6 / (IZR 2 * Rabs v14)) v16)) v15 end in ex_ind (fun (v16 : @nat) (v17 : forall (v17 : @nat) (v18 : (v16 <= v17)%nat), v14 / sum_f_R0 v0 v17 < v6 / IZR 2) => let v18 : @nat := Init.Nat.max v12 v16 in ex_intro (fun v19 : @nat => forall (v20 : @nat) (v21 : (v20 >= v19)%nat), R_dist (sum_f_R0 (fun v22 : @nat => v0 v22 * v1 v22) v20 / sum_f_R0 v0 v20) v2 < v6) (S v18) (fun (v19 : @nat) (v20 : (v19 >= S v18)%nat) => (let v21 : sum_f_R0 (fun v21 : @nat => v0 v21 * (v1 v21 - v2)) v19 / sum_f_R0 v0 v19 = sum_f_R0 (fun v21 : @nat => v0 v21 * v1 v21) v19 / sum_f_R0 v0 v19 - v2 := let v21 : sum_f_R0 (fun v21 : @nat => v0 v21 * v1 v21) v19 + sum_f_R0 (fun v21 : @nat => v0 v21 * - v2) v19 = sum_f_R0 (fun v21 : @nat => v0 v21 * (v1 v21 - v2)) v19 := eq_ind (sum_f_R0 (fun v21 : @nat => v0 v21 * v1 v21 + v0 v21 * - v2) v19) (fun v21 : @R => v21 = sum_f_R0 (fun v22 : @nat => v0 v22 * (v1 v22 - v2)) v19) (sum_eq (fun v21 : @nat => v0 v21 * v1 v21 + v0 v21 * - v2) (fun v21 : @nat => v0 v21 * (v1 v21 - v2)) v19 (fun (v21 : @nat) (v22 : (v21 <= v19)%nat) => let v23 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v24 : list (@R) := (v0 v21 :: v1 v21 :: v2 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v24 v23 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (@I) (eq_refl : (let v25 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v23 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v25 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v25 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))))) = @true))) (sum_f_R0 (fun v21 : @nat => v0 v21 * v1 v21) v19 + sum_f_R0 (fun v21 : @nat => v0 v21 * - v2) v19) (plus_sum (fun v21 : @nat => v0 v21 * v1 v21) (fun v21 : @nat => v0 v21 * - v2) v19) in eq_ind (sum_f_R0 (fun v22 : @nat => v0 v22 * v1 v22) v19 + sum_f_R0 (fun v22 : @nat => v0 v22 * - v2) v19) (fun v22 : @R => v22 / sum_f_R0 v0 v19 = sum_f_R0 (fun v23 : @nat => v0 v23 * v1 v23) v19 / sum_f_R0 v0 v19 - v2) (eq_ind (- v2 * sum_f_R0 v0 v19) (fun v22 : @R => (sum_f_R0 (fun v23 : @nat => v0 v23 * v1 v23) v19 + v22) / sum_f_R0 v0 v19 = sum_f_R0 (fun v23 : @nat => v0 v23 * v1 v23) v19 / sum_f_R0 v0 v19 - v2) (let v22 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v23 : forall (v23 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v24 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v22 = v23) (v25 : linear (@Z)) (v26 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEadd (FEX (@Z) 1) (FEmul (FEopp (FEX (@Z) 2)) (FEX (@Z) 3))) (FEX (@Z) 3)) = v25) (v27 : linear (@Z)) (v28 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEsub (FEdiv (FEX (@Z) 1) (FEX (@Z) 3)) (FEX (@Z) 2)) = v27) (v29 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v23 (Ring_polynom.PEmul (num v25) (denum v27))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v23 (Ring_polynom.PEmul (num v27) (denum v25))) = @true) (v30 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (sum_f_R0 (fun v30 : @nat => v0 v30 * v1 v30) v19 :: v2 :: sum_f_R0 v0 v19 :: nil) (condition v25 ++ condition v27)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) (sum_f_R0 (fun v31 : @nat => v0 v31 * v1 v31) v19 :: v2 :: sum_f_R0 v0 v19 :: nil) (FEdiv (FEadd (FEX (@Z) 1) (FEmul (FEopp (FEX (@Z) 2)) (FEX (@Z) 3))) (FEX (@Z) 3)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) (sum_f_R0 (fun v31 : @nat => v0 v31 * v1 v31) v19 :: v2 :: sum_f_R0 v0 v19 :: nil) (FEsub (FEdiv (FEX (@Z) 1) (FEX (@Z) 3)) (FEX (@Z) 2)) := RField_field_lemma1 (@ring_subst_niter) (sum_f_R0 (fun v23 : @nat => v0 v23 * v1 v23) v19 :: v2 :: sum_f_R0 v0 v19 :: nil) v22 (FEdiv (FEadd (FEX (@Z) 1) (FEmul (FEopp (FEX (@Z) 2)) (FEX (@Z) 3))) (FEX (@Z) 3)) (FEsub (FEdiv (FEX (@Z) 1) (FEX (@Z) 3)) (FEX (@Z) 2)) (@I) in let v24 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v25 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v22 = v24 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v22 = v24 in let v26 : linear (@Z) := {| num := Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)); denum := Ring_polynom.PEX (@Z) 3; condition := Ring_polynom.PEX (@Z) 3 :: nil |} in let v27 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEadd (FEX (@Z) 1) (FEmul (FEopp (FEX (@Z) 2)) (FEX (@Z) 3))) (FEX (@Z) 3)) = v26 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEadd (FEX (@Z) 1) (FEmul (FEopp (FEX (@Z) 2)) (FEX (@Z) 3))) (FEX (@Z) 3)) = v26 in let v28 : linear (@Z) := {| num := Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)); denum := Ring_polynom.PEX (@Z) 3; condition := Ring_polynom.PEX (@Z) 3 :: nil |} in let v29 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEsub (FEdiv (FEX (@Z) 1) (FEX (@Z) 3)) (FEX (@Z) 2)) = v28 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEsub (FEdiv (FEX (@Z) 1) (FEX (@Z) 3)) (FEX (@Z) 2)) = v28 in v23 v24 v25 v26 v27 v28 v29 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEmul (num v26) (denum v28))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEmul (num v28) (denum v26))) = @true) (RField_lemma5 (sum_f_R0 (fun v30 : @nat => v0 v30 * v1 v30) v19 :: v2 :: sum_f_R0 v0 v19 :: nil) (condition v26 ++ condition v28) (fun (v30 : forall v30 : list (Ring_polynom.PExpr (@Z)), Prop) (v31 : v30 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (sum_f_R0 (fun v31 : @nat => v0 v31 * v1 v31) v19 :: v2 :: sum_f_R0 v0 v19 :: nil)) => eq_ind_r (fun v32 : forall v32 : list (Ring_polynom.PExpr (@Z)), Prop => v32 (Ring_polynom.PEX (@Z) 3 :: nil)%list) (v9 v19 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (sum_f_R0 (fun v32 : @nat => v0 v32 * v1 v32) v19 :: v2 :: sum_f_R0 v0 v19 :: nil) (Ring_polynom.PEX (@Z) 3 :: nil)) v31 : v30 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v26 ++ condition v28) nil)))) (sum_f_R0 (fun v22 : @nat => v0 v22 * - v2) v19) (scal_sum v0 v19 (- v2))) (sum_f_R0 (fun v22 : @nat => v0 v22 * (v1 v22 - v2)) v19) v21 in eq_ind (sum_f_R0 (fun v22 : @nat => v0 v22 * (v1 v22 - v2)) v19 / sum_f_R0 v0 v19) (fun v22 : @R => Rabs v22 < v6) (let v22 : (v12 < v19)%nat := Nat.lt_le_trans v12 (S v18) v19 (le_lt_n_Sm v12 v18 (le_max_l v12 v16 : (v12 <= v18)%nat)) v20 in eq_ind_r (fun v23 : @R => Rabs (v23 / sum_f_R0 v0 v19) < v6) (eq_ind_r (fun v23 : @R => Rabs v23 < v6) (Rle_lt_trans (Rabs (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12 * / sum_f_R0 v0 v19 + sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12) * / sum_f_R0 v0 v19)) (Rabs (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12 / sum_f_R0 v0 v19) + Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12) / sum_f_R0 v0 v19)) v6 (Rabs_triang (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12 / sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12) / sum_f_R0 v0 v19)) (eq_ind_r (fun v23 : @R => Rabs (sum_f_R0 (fun v24 : @nat => v0 v24 * (v1 v24 - v2)) v12 / sum_f_R0 v0 v19) + Rabs (sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat * (v1 (S v12 + v24)%nat - v2)) (v19 - S v12) / sum_f_R0 v0 v19) < v23) (Rplus_lt_compat (Rabs (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12 / sum_f_R0 v0 v19)) (v6 / IZR 2) (Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12) / sum_f_R0 v0 v19)) (v6 / IZR 2) (eq_ind_r (fun v23 : @R => v23 < v6 * / IZR 2) (eq_ind_r (fun v23 : @R => v14 * v23 < v6 * / IZR 2) (v17 v19 (Nat.le_trans v16 (S v18) v19 (Nat.le_trans v16 v18 (S v18) (le_max_r v12 v16 : (v16 <= v18)%nat) (Nat.le_succ_diag_r v18)) v20)) (Rabs_right (/ sum_f_R0 v0 v19) (Rle_ge (IZR 0) (/ sum_f_R0 v0 v19) (or_introl (Rinv_0_lt_compat (sum_f_R0 v0 v19) (v8 v19))))) : Rabs (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12) * Rabs (/ sum_f_R0 v0 v19) < v6 * / IZR 2) (Rabs_mult (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12) (/ sum_f_R0 v0 v19)) : Rabs (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12 / sum_f_R0 v0 v19) < v6 / IZR 2) (eq_ind_r (fun v23 : @R => v23 < v6 * / IZR 2) (eq_ind_r (fun v23 : @R => Rabs (sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat * (v1 (S v12 + v24)%nat - v2)) (v19 - S v12)) * v23 < v6 * / IZR 2) (Rle_lt_trans (Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12)) * / sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12) * / sum_f_R0 v0 v19) (v6 * / IZR 2) (eq_ind (/ sum_f_R0 v0 v19 * Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12))) (fun v23 : @R => v23 <= sum_f_R0 (fun v24 : @nat => Rabs (v0 (S v12 + v24)%nat * (v1 (S v12 + v24)%nat - v2))) (v19 - S v12) * / sum_f_R0 v0 v19) (eq_ind (/ sum_f_R0 v0 v19 * sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12)) (fun v23 : @R => / sum_f_R0 v0 v19 * Rabs (sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat * (v1 (S v12 + v24)%nat - v2)) (v19 - S v12)) <= v23) (Rmult_le_compat_l (/ sum_f_R0 v0 v19) (Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12))) (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12)) (or_introl (Rinv_0_lt_compat (sum_f_R0 v0 v19) (v8 v19))) (Rsum_abs (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12))) (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12) * / sum_f_R0 v0 v19) (Rmult_comm (/ sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12)))) (Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12)) * / sum_f_R0 v0 v19) (Rmult_comm (/ sum_f_R0 v0 v19) (Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12))))) (Rle_lt_trans (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12) * / sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v6 / IZR 2)) (v19 - S v12) * / sum_f_R0 v0 v19) (v6 * / IZR 2) (eq_ind (/ sum_f_R0 v0 v19 * sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12)) (fun v23 : @R => v23 <= sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat * (v6 / IZR 2)) (v19 - S v12) * / sum_f_R0 v0 v19) (eq_ind (/ sum_f_R0 v0 v19 * sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v6 / IZR 2)) (v19 - S v12)) (fun v23 : @R => / sum_f_R0 v0 v19 * sum_f_R0 (fun v24 : @nat => Rabs (v0 (S v12 + v24)%nat * (v1 (S v12 + v24)%nat - v2))) (v19 - S v12) <= v23) (Rmult_le_compat_l (/ sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12)) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v6 / IZR 2)) (v19 - S v12)) (or_introl (Rinv_0_lt_compat (sum_f_R0 v0 v19) (v8 v19))) (sum_Rle (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (fun v23 : @nat => v0 (S v12 + v23)%nat * (v6 / IZR 2)) (v19 - S v12) (fun (v23 : @nat) (v24 : (v23 <= v19 - S v12)%nat) => eq_ind_r (fun v25 : @R => v25 <= v0 (S v12 + v23)%nat * (v6 / IZR 2)) (eq_ind (Rabs (v0 (S v12 + v23)%nat)) (fun v25 : @R => Rabs (v0 (S v12 + v23)%nat) * Rabs (v1 (S v12 + v23)%nat - v2) <= v25 * (v6 / IZR 2)) (Rmult_le_compat_l (Rabs (v0 (S v12 + v23)%nat)) (Rabs (v1 (S v12 + v23)%nat - v2)) (v6 / IZR 2) (Rabs_pos (v0 (S v12 + v23)%nat)) (or_introl (v13 (S v12 + v23)%nat (Nat.le_trans v12 (S v12) (S v12 + v23) (Nat.le_succ_diag_r v12) (le_plus_l (S v12) v23) : (S v12 + v23 >= v12)%nat)))) (v0 (S v12 + v23)%nat) (Rabs_right (v0 (S v12 + v23)%nat) (Rle_ge (IZR 0) (v0 (S v12 + v23)%nat) (or_introl (v4 (S v12 + v23)%nat)))) : Rabs (v0 (S v12 + v23)%nat) * Rabs (v1 (S v12 + v23)%nat - v2) <= v0 (S v12 + v23)%nat * (v6 / IZR 2)) (Rabs_mult (v0 (S v12 + v23)%nat) (v1 (S v12 + v23)%nat - v2))))) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v6 / IZR 2)) (v19 - S v12) * / sum_f_R0 v0 v19) (Rmult_comm (/ sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v6 / IZR 2)) (v19 - S v12)))) (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12) * / sum_f_R0 v0 v19) (Rmult_comm (/ sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => Rabs (v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2))) (v19 - S v12)))) (eq_ind (v6 / IZR 2 * sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)) (fun v23 : @R => v23 * / sum_f_R0 v0 v19 < v6 * / IZR 2) (eq_ind_r (fun v23 : @R => v23 < v6 * / IZR 2) (eq_ind_r (fun v23 : @R => v23 < v6 * / IZR 2) (Rmult_lt_compat_l v6 (/ IZR 2 * (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) * / sum_f_R0 v0 v19)) (/ IZR 2) v7 (eq_ind (/ IZR 2 * IZR 1) (fun v23 : @R => / IZR 2 * (sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat) (v19 - S v12) * / sum_f_R0 v0 v19) < v23) (Rmult_lt_compat_l (/ IZR 2) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) * / sum_f_R0 v0 v19) (IZR 1) (Rinv_0_lt_compat (IZR 2) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1))) (eq_ind_r (fun v23 : @R => v23 < IZR 1) (Rmult_lt_reg_l (sum_f_R0 v0 v19) (/ sum_f_R0 v0 v19 * sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)) (IZR 1) (v8 v19) (eq_ind (sum_f_R0 v0 v19 * / sum_f_R0 v0 v19 * sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)) (fun v23 : @R => v23 < sum_f_R0 v0 v19 * IZR 1) (eq_ind (IZR 1) (fun v23 : @R => v23 * sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat) (v19 - S v12) < sum_f_R0 v0 v19 * IZR 1) (eq_ind_r (fun v23 : @R => v23 < sum_f_R0 v0 v19 * IZR 1) (eq_ind_r (fun v23 : @R => sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat) (v19 - S v12) < v23) (eq_ind_r (fun v23 : @R => sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat) (v19 - S v12) < v23) (eq_ind_r (fun v23 : @R => sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat) (v19 - S v12) < v23) (eq_ind (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) + IZR 0) (fun v23 : @R => v23 < sum_f_R0 (fun v24 : @nat => v0 (S v12 + v24)%nat) (v19 - S v12) + sum_f_R0 v0 v12) (Rplus_lt_compat_l (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)) (IZR 0) (sum_f_R0 v0 v12) (v8 v12)) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)) (Rplus_0_r (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12))) : sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) < sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) + sum_f_R0 v0 v12) (Rplus_comm (sum_f_R0 v0 v12) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)))) (tech2 v0 v12 v19 v22)) (Rmult_1_r (sum_f_R0 v0 v19))) (Rmult_1_l (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)))) (sum_f_R0 v0 v19 * / sum_f_R0 v0 v19) (Rinv_r_sym (sum_f_R0 v0 v19) (v9 v19))) (sum_f_R0 v0 v19 * (/ sum_f_R0 v0 v19 * sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12))) (Rmult_assoc (sum_f_R0 v0 v19) (/ sum_f_R0 v0 v19) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12))))) (Rmult_comm (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)) (/ sum_f_R0 v0 v19)))) (/ IZR 2) (Rmult_1_r (/ IZR 2)) : / IZR 2 * (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) * / sum_f_R0 v0 v19) < / IZR 2)) (Rmult_assoc v6 (/ IZR 2) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) * / sum_f_R0 v0 v19))) (Rmult_assoc (v6 * / IZR 2) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12)) (/ sum_f_R0 v0 v19)) : v6 / IZR 2 * sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) * / sum_f_R0 v0 v19 < v6 * / IZR 2) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v6 / IZR 2)) (v19 - S v12)) (scal_sum (fun v23 : @nat => v0 (S v12 + v23)%nat) (v19 - S v12) (v6 / IZR 2))))) (Rabs_right (/ sum_f_R0 v0 v19) (Rle_ge (IZR 0) (/ sum_f_R0 v0 v19) (or_introl (Rinv_0_lt_compat (sum_f_R0 v0 v19) (v8 v19)))))) (Rabs_mult (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12)) (/ sum_f_R0 v0 v19)) : Rabs (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12) / sum_f_R0 v0 v19) < v6 / IZR 2)) (double_var v6))) (Rmult_plus_distr_r (sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12) (sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12)) (/ sum_f_R0 v0 v19)) : Rabs ((sum_f_R0 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12 + sum_f_R0 (fun v23 : @nat => v0 (S v12 + v23)%nat * (v1 (S v12 + v23)%nat - v2)) (v19 - S v12)) / sum_f_R0 v0 v19) < v6) (tech2 (fun v23 : @nat => v0 v23 * (v1 v23 - v2)) v12 v19 v22)) (sum_f_R0 (fun v22 : @nat => v0 v22 * v1 v22) v19 / sum_f_R0 v0 v19 - v2) v21) : R_dist (sum_f_R0 (fun v21 : @nat => v0 v21 * v1 v21) v19 / sum_f_R0 v0 v19) v2 < v6)) v15) (v3 (v6 / IZR 2) v11)) : forall (v0 : forall v0 : @nat, @R) (v1 : forall v1 : @nat, @R) (v2 : @R) (v3 : Un_cv v1 v2) (v4 : forall v4 : @nat, IZR 0 < v0 v4) (v5 : cv_infty (fun v5 : @nat => sum_f_R0 v0 v5)), Un_cv (fun v6 : @nat => sum_f_R0 (fun v7 : @nat => v0 v7 * v1 v7) v6 / sum_f_R0 v0 v6) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.SeqSeries.Cesaro_1	100	0.670496	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @nat, @R) (v1 : @R) (v2 : Un_cv v0 v1) => let v3 : forall v3 : @nat, @R := fun v3 : @nat => IZR 1 in let v4 : forall v4 : @nat, IZR 0 < v3 v4 := fun v4 : @nat => @Rlt_0_1 : IZR 0 < v3 v4 in let v5 : forall v5 : @nat, IZR 0 < sum_f_R0 v3 v5 := fun v5 : @nat => tech1 v3 v5 (fun (v6 : @nat) (v7 : (v6 <= v5)%nat) => v4 v6) in let v6 : cv_infty (fun v6 : @nat => sum_f_R0 v3 v6) := (fun v6 : @R => let v7 : {v6 <= IZR 0} + {~ v6 <= IZR 0} := Rle_dec v6 (IZR 0) in match v7 as v8 in ({_} + {_}) return (exists v9 : @nat, forall (v10 : @nat) (v11 : (v9 <= v10)%nat), v6 < sum_f_R0 v3 v10) with | left v8 => (fun v8 : v6 <= IZR 0 => ex_intro (fun v9 : @nat => forall (v10 : @nat) (v11 : (v9 <= v10)%nat), v6 < sum_f_R0 v3 v10) 0%nat (fun (v9 : @nat) (v10 : (0 <= v9)%nat) => Rle_lt_trans v6 (IZR 0) (sum_f_R0 v3 v9) v8 (v5 v9))) v8 | right v8 => (fun v8 : ~ v6 <= IZR 0 => let v9 : IZR 0 < v6 := Rnot_le_lt v6 (IZR 0) v8 in let v10 : @Z := up v6 in and_ind (fun (v11 : IZR (up v6) > v6) (v12 : IZR (up v6) - v6 <= IZR 1) => let v13 : (0 <= v10)%Z := le_IZR 0 v10 ((or_introl (Rlt_trans (IZR 0) v6 (IZR (up v6)) v9 v11) : IZR 0 <= IZR (up v6)) : IZR 0 <= IZR v10) in ex_ind (fun (v14 : @nat) (v15 : v10 = BinIntDef.Z.of_nat v14) => ex_intro (fun v16 : @nat => forall (v17 : @nat) (v18 : (v16 <= v17)%nat), v6 < sum_f_R0 v3 v17) v14 (fun (v16 : @nat) (v17 : (v14 <= v16)%nat) => eq_ind_r (fun v18 : @R => v6 < v18) (eq_ind_r (fun v18 : @R => v6 < v18) (Rlt_trans v6 (IZR (up v6)) (INR (S v16)) v11 (Rle_lt_trans (IZR (up v6)) (INR v14) (INR (S v16)) (eq_ind_r (fun v18 : @R => IZR (up v6) <= v18) (eq_ind v10 (fun v18 : @Z => IZR v10 <= IZR v18) (or_intror eq_refl) (BinIntDef.Z.of_nat v14) v15 : IZR (up v6) <= IZR (BinIntDef.Z.of_nat v14)) (INR_IZR_INZ v14)) (lt_INR v14 (S v16) (le_lt_n_Sm v14 v16 v17)))) (Rmult_1_l (INR (S v16)))) (sum_cte (IZR 1) v16) : v6 < sum_f_R0 v3 v16)) (IZN v10 v13)) (archimed v6)) v8 end) : cv_infty (fun v6 : @nat => sum_f_R0 v3 v6) in let v7 : Un_cv (fun v7 : @nat => sum_f_R0 (fun v8 : @nat => v3 v8 * v0 v8) v7 / sum_f_R0 v3 v7) v1 := Cesaro v3 v0 v1 v2 v4 v6 in (fun (v8 : @R) (v9 : v8 > IZR 0) => ex_ind (fun (v10 : @nat) (v11 : forall (v11 : @nat) (v12 : (v11 >= v10)%nat), R_dist (sum_f_R0 (fun v13 : @nat => v3 v13 * v0 v13) v11 / sum_f_R0 v3 v11) v1 < v8) => ex_intro (fun v12 : @nat => forall (v13 : @nat) (v14 : (v13 >= v12)%nat), R_dist (sum_f_R0 v0 (Init.Nat.pred v13) / INR v13) v1 < v8) (S v10) (fun (v12 : @nat) (v13 : (v12 >= S v10)%nat) => Rle_lt_trans (Rabs (sum_f_R0 v0 (Init.Nat.pred v12) / INR v12 - v1)) (Rabs (sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) - v1)) v8 (or_intror (let v14 : sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) - v1 = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12 - v1 := eq_ind (- v1 + sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12)) (fun v14 : @R => v14 = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12 + - v1) (eq_ind (- v1 + sum_f_R0 v0 (Init.Nat.pred v12) / INR v12) (fun v14 : @R => - v1 + sum_f_R0 (fun v15 : @nat => v3 v15 * v0 v15) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) = v14) (Rplus_eq_compat_l (- v1) (sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12)) (sum_f_R0 v0 (Init.Nat.pred v12) / INR v12) ((let v14 : sum_f_R0 v0 (Init.Nat.pred v12) = sum_f_R0 (fun v14 : @nat => IZR 1 * v0 v14) (Init.Nat.pred v12) := sum_eq v0 (fun v14 : @nat => IZR 1 * v0 v14) (Init.Nat.pred v12) (fun (v14 : @nat) (v15 : (v14 <= Init.Nat.pred v12)%nat) => let v16 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v17 : list (@R) := (v0 v14 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v17 v16 (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z) (Ring_polynom.PEX (@Z) 1)) (@I) (eq_refl : (let v18 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v16 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v18 (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v18 (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z) (Ring_polynom.PEX (@Z) 1)))) = @true)) in eq_ind (sum_f_R0 v0 (Init.Nat.pred v12)) (fun v15 : @R => v15 / sum_f_R0 (fun v16 : @nat => IZR 1) (Init.Nat.pred v12) = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12) (eq_ind_r (fun v15 : @R => sum_f_R0 v0 (Init.Nat.pred v12) / v15 = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12) (eq_ind_r (fun v15 : @R => sum_f_R0 v0 (Init.Nat.pred v12) / v15 = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12) (let v15 : v12 = S (Init.Nat.pred v12) := S_pred v12 0 (Nat.lt_le_trans 0 (S v10) v12 (Nat.lt_0_succ v10) v13) in eq_ind v12 (fun v16 : @nat => sum_f_R0 v0 (Init.Nat.pred v12) / INR v16 = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12) eq_refl (S (Init.Nat.pred v12)) v15) (Rmult_1_l (INR (S (Init.Nat.pred v12))))) (sum_cte (IZR 1) (Init.Nat.pred v12))) (sum_f_R0 (fun v15 : @nat => IZR 1 * v0 v15) (Init.Nat.pred v12)) v14) : sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12)) (sum_f_R0 v0 (Init.Nat.pred v12) / INR v12 + - v1) (Rplus_comm (- v1) (sum_f_R0 v0 (Init.Nat.pred v12) / INR v12))) (sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) + - v1) (Rplus_comm (- v1) (sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12))) : sum_f_R0 (fun v14 : @nat => v3 v14 * v0 v14) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) - v1 = sum_f_R0 v0 (Init.Nat.pred v12) / INR v12 - v1 in eq_ind (sum_f_R0 (fun v15 : @nat => v3 v15 * v0 v15) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) - v1) (fun v15 : @R => Rabs v15 = Rabs (sum_f_R0 (fun v16 : @nat => v3 v16 * v0 v16) (Init.Nat.pred v12) / sum_f_R0 v3 (Init.Nat.pred v12) - v1)) eq_refl (sum_f_R0 v0 (Init.Nat.pred v12) / INR v12 - v1) v14)) (v11 (Init.Nat.pred v12) (le_S_n v10 (Init.Nat.pred v12) (let v14 : v12 = S (Init.Nat.pred v12) := S_pred v12 0 (Nat.lt_le_trans 0 (S v10) v12 (Nat.lt_0_succ v10) v13) in eq_ind v12 (fun v15 : @nat => (S v10 <= v15)%nat) v13 (S (Init.Nat.pred v12)) v14) : (Init.Nat.pred v12 >= v10)%nat)) : R_dist (sum_f_R0 v0 (Init.Nat.pred v12) / INR v12) v1 < v8)) (v7 v8 v9)) : Un_cv (fun v8 : @nat => sum_f_R0 v0 (Init.Nat.pred v8) / INR v8) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Cos_plus.Majxy_cv_R0	100	0.743941	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : @R := Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1)) in let v3 : @R := v2 ^ 4 in let v4 : IZR 0 < v2 := Rlt_le_trans (IZR 0) (IZR 1) v2 (@Rlt_0_1) (Rmax_l (IZR 1) (Rmax (Rabs v0) (Rabs v1)) : IZR 1 <= v2) in (fun v5 : IZR 0 < v2 => let v6 : IZR 0 < v3 := pow_lt v2 4 v5 : IZR 0 < v3 in (fun v7 : IZR 0 < v3 => let v8 : Un_cv (fun v8 : @nat => v3 ^ v8 / INR (fact v8)) (IZR 0) := cv_speed_pow_fact v3 in ((fun (v9 : @R) (v10 : v9 > IZR 0) => let v11 : IZR 0 < v9 / v3 := Rmult_lt_0_compat v9 (/ v3) v10 (Rinv_0_lt_compat v3 v7) : IZR 0 < v9 / v3 in (fun v12 : IZR 0 < v9 / v3 => ex_ind (fun (v13 : @nat) (v14 : forall (v14 : @nat) (v15 : (v14 >= v13)%nat), Rabs (v3 ^ v14 / INR (fact v14) - IZR 0) < v9 / v3) => ex_intro (fun v15 : @nat => forall (v16 : @nat) (v17 : (v16 >= v15)%nat), Rabs (Majxy v0 v1 v16 - IZR 0) < v9) v13 (fun (v15 : @nat) (v16 : (v15 >= v13)%nat) => let v17 : v3 ^ S v15 / INR (fact v15) = Majxy v0 v1 v15 := (eq_ind_r (fun v17 : @R => (v2 ^ 4) ^ S v15 / INR (fact v15) = v17 / INR (fact v15)) (eq_refl : (v2 ^ 4) ^ S v15 / INR (fact v15) = (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1)) ^ 4) ^ S v15 / INR (fact v15)) (pow_mult (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1))) 4 (S v15)) : v3 ^ S v15 / INR (fact v15) = Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1)) ^ (4 * S v15) / INR (fact v15)) : v3 ^ S v15 / INR (fact v15) = Majxy v0 v1 v15 in eq_ind (v3 ^ S v15 / INR (fact v15)) (fun v18 : @R => Rabs (v18 - IZR 0) < v9) (Rmult_lt_reg_l (Rabs (/ v3)) (Rabs (v3 * v3 ^ v15 / INR (fact v15) - IZR 0)) v9 (Rabs_pos_lt (/ v3) (Rinv_neq_0_compat v3 ((fun v18 : v3 = IZR 0 => let v19 : IZR 0 < IZR 0 := eq_ind v3 (fun v19 : @R => IZR 0 < v19) v7 (IZR 0) v18 in False_ind (@False) (Rlt_irrefl (IZR 0) v19)) : v3 <> IZR 0))) (eq_ind (Rabs (/ v3 * (v3 * v3 ^ v15 / INR (fact v15) - IZR 0))) (fun v18 : @R => v18 < Rabs (/ v3) * v9) (eq_ind_r (fun v18 : @R => Rabs v18 < Rabs (/ v3) * v9) (eq_ind_r (fun v18 : @R => Rabs (/ v3 * (v3 * v3 ^ v15 / INR (fact v15)) + / v3 * v18) < Rabs (/ v3) * v9) (eq_ind_r (fun v18 : @R => Rabs (/ v3 * (v3 * v3 ^ v15 / INR (fact v15)) + v18) < Rabs (/ v3) * v9) (eq_ind (/ v3 * (v3 * v3 ^ v15) * / INR (fact v15)) (fun v18 : @R => Rabs (v18 + IZR 0) < Rabs (/ v3) * v9) (eq_ind (/ v3 * v3 * v3 ^ v15) (fun v18 : @R => Rabs (v18 * / INR (fact v15) + IZR 0) < Rabs (/ v3) * v9) (eq_ind (IZR 1) (fun v18 : @R => Rabs (v18 * v3 ^ v15 * / INR (fact v15) + IZR 0) < Rabs (/ v3) * v9) (eq_ind_r (fun v18 : @R => Rabs (v18 * / INR (fact v15) + IZR 0) < Rabs (/ v3) * v9) (eq_ind_r (fun v18 : @R => Rabs (v3 ^ v15 * / INR (fact v15) + IZR 0) < v18 * v9) (eq_ind (v9 * / v3) (fun v18 : @R => Rabs (v3 ^ v15 * / INR (fact v15) + IZR 0) < v18) (let v18 : v3 ^ v15 * / INR (fact v15) - IZR 0 = v3 ^ v15 * / INR (fact v15) + IZR 0 := let v18 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v19 : list (@R) := (v3 ^ v15 :: / INR (fact v15) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v19 v18 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 0%Z)) (@I) (eq_refl : (let v20 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v18 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v20 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEc 0%Z)))) = @true) in eq_ind (v3 ^ v15 * / INR (fact v15) - IZR 0) (fun v19 : @R => Rabs v19 < v9 * / v3) (v14 v15 v16) (v3 ^ v15 * / INR (fact v15) + IZR 0) v18) (/ v3 * v9) (Rmult_comm v9 (/ v3))) (Rabs_right (/ v3) (Rle_ge (IZR 0) (/ v3) (or_introl (Rinv_0_lt_compat v3 v7))))) (Rmult_1_l (v3 ^ v15))) (/ v3 * v3) (Rinv_l_sym v3 ((fun v18 : v3 = IZR 0 => let v19 : IZR 0 < IZR 0 := eq_ind v3 (fun v19 : @R => IZR 0 < v19) v7 (IZR 0) v18 in False_ind (@False) (Rlt_irrefl (IZR 0) v19)) : v3 <> IZR 0))) (/ v3 * (v3 * v3 ^ v15)) (Rmult_assoc (/ v3) v3 (v3 ^ v15))) (/ v3 * (v3 * v3 ^ v15 * / INR (fact v15))) (Rmult_assoc (/ v3) (v3 * v3 ^ v15) (/ INR (fact v15))) : Rabs (/ v3 * (v3 * v3 ^ v15 / INR (fact v15)) + IZR 0) < Rabs (/ v3) * v9) (Rmult_0_r (/ v3))) (@Ropp_0)) (Rmult_plus_distr_l (/ v3) (v3 * v3 ^ v15 / INR (fact v15)) (- IZR 0)) : Rabs (/ v3 * (v3 * v3 ^ v15 / INR (fact v15) - IZR 0)) < Rabs (/ v3) * v9) (Rabs (/ v3) * Rabs (v3 * v3 ^ v15 / INR (fact v15) - IZR 0)) (Rabs_mult (/ v3) (v3 * v3 ^ v15 / INR (fact v15) - IZR 0))) : Rabs (v3 ^ S v15 / INR (fact v15) - IZR 0) < v9) (Majxy v0 v1 v15) v17)) (v8 (v9 / v3) v12)) v11) : forall (v9 : @R) (v10 : v9 > IZR 0), exists v11 : @nat, forall (v12 : @nat) (v13 : (v12 >= v11)%nat), R_dist (Majxy v0 v1 v12) (IZR 0) < v9) : Un_cv (Majxy v0 v1) (IZR 0)) v6) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Cos_plus.reste1_maj	100	18.198995	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Cos_plus.reste2_maj	100	25.326046	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Cos_plus.reste1_cv_R0	100	0.265731	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : Un_cv (Majxy v0 v1) (IZR 0) := Majxy_cv_R0 v0 v1 in ((fun (v3 : @R) (v4 : v3 > IZR 0) => ex_ind (fun (v5 : @nat) (v6 : forall (v6 : @nat) (v7 : (v6 >= v5)%nat), Rabs (Majxy v0 v1 v6 - IZR 0) < v3) => ex_intro (fun v7 : @nat => forall (v8 : @nat) (v9 : (v8 >= v7)%nat), Rabs (Reste1 v0 v1 v8 - IZR 0) < v3) (S v5) (fun (v7 : @nat) (v8 : (v7 >= S v5)%nat) => eq_ind_r (fun v9 : @R => Rabs (Reste1 v0 v1 v7 + v9) < v3) (eq_ind_r (fun v9 : @R => Rabs v9 < v3) (Rle_lt_trans (Rabs (Reste1 v0 v1 v7)) (Rabs (Majxy v0 v1 (Init.Nat.pred v7))) v3 (eq_ind_r (fun v9 : @R => Rabs (Reste1 v0 v1 v7) <= v9) (reste1_maj v0 v1 v7 (Nat.lt_le_trans 0 (S v5) v7 (Nat.lt_0_succ v5) v8)) (Rabs_right (Majxy v0 v1 (Init.Nat.pred v7)) (Rle_ge (IZR 0) (Majxy v0 v1 (Init.Nat.pred v7)) ((Rmult_le_pos (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1)) ^ (4 * S (Init.Nat.pred v7))) (/ INR (fact (Init.Nat.pred v7))) (pow_le (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1))) (4 * S (Init.Nat.pred v7)) (Rle_trans (IZR 0) (IZR 1) (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1))) (or_introl (@Rlt_0_1)) (Rmax_l (IZR 1) (Rmax (Rabs v0) (Rabs v1))))) (or_introl (Rinv_0_lt_compat (INR (fact (Init.Nat.pred v7))) (INR_fact_lt_0 (Init.Nat.pred v7)))) : IZR 0 <= Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1)) ^ (4 * S (Init.Nat.pred v7)) / INR (fact (Init.Nat.pred v7))) : IZR 0 <= Majxy v0 v1 (Init.Nat.pred v7))))) (let v9 : Majxy v0 v1 (Init.Nat.pred v7) - IZR 0 = Majxy v0 v1 (Init.Nat.pred v7) := let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v10 : list (@R) := (Majxy v0 v1 (Init.Nat.pred v7) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEX (@Z) 1))) = @true) in eq_ind (Majxy v0 v1 (Init.Nat.pred v7) - IZR 0) (fun v10 : @R => Rabs v10 < v3) (v6 (Init.Nat.pred v7) (le_S_n v5 (Init.Nat.pred v7) (let v10 : v7 = S (Init.Nat.pred v7) := S_pred v7 0 (Nat.lt_le_trans 0 (S v5) v7 (Nat.lt_0_succ v5) v8) in eq_ind v7 (fun v11 : @nat => (S v5 <= v11)%nat) v8 (S (Init.Nat.pred v7)) v10) : (Init.Nat.pred v7 >= v5)%nat)) (Majxy v0 v1 (Init.Nat.pred v7)) v9)) (Rplus_0_r (Reste1 v0 v1 v7))) (@Ropp_0) : Rabs (Reste1 v0 v1 v7 - IZR 0) < v3)) (v2 v3 v4)) : forall (v3 : @R) (v4 : v3 > IZR 0), exists v5 : @nat, forall (v6 : @nat) (v7 : (v6 >= v5)%nat), R_dist (Reste1 v0 v1 v6) (IZR 0) < v3) : Un_cv (Reste1 v0 v1) (IZR 0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Cos_plus.reste2_cv_R0	100	0.247679	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : Un_cv (Majxy v0 v1) (IZR 0) := Majxy_cv_R0 v0 v1 in ((fun (v3 : @R) (v4 : v3 > IZR 0) => ex_ind (fun (v5 : @nat) (v6 : forall (v6 : @nat) (v7 : (v6 >= v5)%nat), Rabs (Majxy v0 v1 v6 - IZR 0) < v3) => ex_intro (fun v7 : @nat => forall (v8 : @nat) (v9 : (v8 >= v7)%nat), Rabs (Reste2 v0 v1 v8 - IZR 0) < v3) (S v5) (fun (v7 : @nat) (v8 : (v7 >= S v5)%nat) => eq_ind_r (fun v9 : @R => Rabs (Reste2 v0 v1 v7 + v9) < v3) (eq_ind_r (fun v9 : @R => Rabs v9 < v3) (Rle_lt_trans (Rabs (Reste2 v0 v1 v7)) (Rabs (Majxy v0 v1 v7)) v3 (eq_ind_r (fun v9 : @R => Rabs (Reste2 v0 v1 v7) <= v9) (reste2_maj v0 v1 v7 (Nat.lt_le_trans 0 (S v5) v7 (Nat.lt_0_succ v5) v8)) (Rabs_right (Majxy v0 v1 v7) (Rle_ge (IZR 0) (Majxy v0 v1 v7) ((Rmult_le_pos (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1)) ^ (4 * S v7)) (/ INR (fact v7)) (pow_le (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1))) (4 * S v7) (Rle_trans (IZR 0) (IZR 1) (Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1))) (or_introl (@Rlt_0_1)) (Rmax_l (IZR 1) (Rmax (Rabs v0) (Rabs v1))))) (or_introl (Rinv_0_lt_compat (INR (fact v7)) (INR_fact_lt_0 v7))) : IZR 0 <= Rmax (IZR 1) (Rmax (Rabs v0) (Rabs v1)) ^ (4 * S v7) / INR (fact v7)) : IZR 0 <= Majxy v0 v1 v7)))) (let v9 : Majxy v0 v1 v7 - IZR 0 = Majxy v0 v1 v7 := let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v10 : list (@R) := (Majxy v0 v1 v7 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEX (@Z) 1))) = @true) in eq_ind (Majxy v0 v1 v7 - IZR 0) (fun v10 : @R => Rabs v10 < v3) (v6 v7 (Nat.le_trans v5 (S v5) v7 (Nat.le_succ_diag_r v5) v8 : (v7 >= v5)%nat)) (Majxy v0 v1 v7) v9)) (Rplus_0_r (Reste2 v0 v1 v7))) (@Ropp_0) : Rabs (Reste2 v0 v1 v7 - IZR 0) < v3)) (v2 v3 v4)) : forall (v3 : @R) (v4 : v3 > IZR 0), exists v5 : @nat, forall (v6 : @nat) (v7 : (v6 >= v5)%nat), R_dist (Reste2 v0 v1 v6) (IZR 0) < v3) : Un_cv (Reste2 v0 v1) (IZR 0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Cos_plus.reste_cv_R0	100	0.229288	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => (let v2 : forall v2 : @nat, @R := fun v2 : @nat => Reste2 v0 v1 v2 in let v3 : forall v3 : @nat, @R := fun v3 : @nat => Reste1 v0 v1 (S v3) in let v4 : forall v4 : Un_cv (fun v4 : @nat => v2 v4 - v3 v4) (IZR 0 - IZR 0), Un_cv (fun v5 : @nat => Reste2 v0 v1 v5 - Reste1 v0 v1 (S v5)) (IZR 0) := ((fun v4 : Un_cv (fun v4 : @nat => Reste2 v0 v1 v4 - Reste1 v0 v1 (S v4)) (IZR 0 - IZR 0) => let v5 : IZR 0 - IZR 0 = IZR 0 := let v5 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v6 : list (@R) := nil in RField_ring_lemma1 (@ring_subst_niter) v6 v5 (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEc 0%Z) (@I) (eq_refl : (let v7 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v5 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEsub (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEc 0%Z))) = @true) in eq_ind (IZR 0 - IZR 0) (fun v6 : @R => Un_cv (fun v7 : @nat => Reste2 v0 v1 v7 - Reste1 v0 v1 (S v7)) v6) v4 (IZR 0) v5) : forall v4 : Un_cv (fun v4 : @nat => Reste2 v0 v1 v4 - v3 v4) (IZR 0 - IZR 0), Un_cv (fun v5 : @nat => Reste2 v0 v1 v5 - Reste1 v0 v1 (S v5)) (IZR 0)) : forall v4 : Un_cv (fun v4 : @nat => v2 v4 - v3 v4) (IZR 0 - IZR 0), Un_cv (fun v5 : @nat => Reste2 v0 v1 v5 - Reste1 v0 v1 (S v5)) (IZR 0) in (fun v5 : forall v5 : Un_cv (fun v5 : @nat => v2 v5 - v3 v5) (IZR 0 - IZR 0), Un_cv (fun v6 : @nat => Reste2 v0 v1 v6 - Reste1 v0 v1 (S v6)) (IZR 0) => v5 (CV_minus v2 v3 (IZR 0) (IZR 0) ((let v6 : Reste2 v0 v1 = (fun v6 : @nat => Reste2 v0 v1 v6) := eq_refl in eq_ind (Reste2 v0 v1) (fun v7 : forall v7 : @nat, @R => Un_cv v7 (IZR 0)) (reste2_cv_R0 v0 v1) (fun v7 : @nat => Reste2 v0 v1 v7) v6) : Un_cv v2 (IZR 0)) ((let v6 : Un_cv (Reste1 v0 v1) (IZR 0) := reste1_cv_R0 v0 v1 in ((fun (v7 : @R) (v8 : v7 > IZR 0) => ex_ind (fun (v9 : @nat) (v10 : forall (v10 : @nat) (v11 : (v10 >= v9)%nat), Rabs (Reste1 v0 v1 v10 - IZR 0) < v7) => ex_intro (fun v11 : @nat => forall (v12 : @nat) (v13 : (v12 >= v11)%nat), Rabs (Reste1 v0 v1 (S v12) - IZR 0) < v7) v9 (fun (v11 : @nat) (v12 : (v11 >= v9)%nat) => v10 (S v11) (Nat.le_trans v9 (S v9) (S v11) (Nat.le_succ_diag_r v9) (le_n_S v9 v11 v12) : (S v11 >= v9)%nat))) (v6 v7 v8)) : forall (v7 : @R) (v8 : v7 > IZR 0), exists v9 : @nat, forall (v10 : @nat) (v11 : (v10 >= v9)%nat), R_dist (Reste1 v0 v1 (S v10)) (IZR 0) < v7) : Un_cv (fun v7 : @nat => Reste1 v0 v1 (S v7)) (IZR 0)) : Un_cv v3 (IZR 0)))) v4) : Un_cv (Reste v0 v1) (IZR 0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Cos_plus.cos_plus	100	1.489477	1	1	0	synth with cache (only 1: refine (fun v0 v1 : @R => let v2 : Un_cv (C1 v0 v1) (cos v0 * cos v1 - sin v0 * sin v1) := ((fun (v2 : @R) (v3 : v2 > IZR 0) => let v4 : Un_cv (A1 v0) (cos v0) := A1_cvg v0 in let v5 : Un_cv (A1 v1) (cos v1) := A1_cvg v1 in let v6 : Un_cv (B1 v0) (sin v0) := B1_cvg v0 in let v7 : Un_cv (B1 v1) (sin v1) := B1_cvg v1 in let v8 : Un_cv (fun v8 : @nat => A1 v0 v8 * A1 v1 v8) (cos v0 * cos v1) := CV_mult (A1 v0) (A1 v1) (cos v0) (cos v1) v4 v5 in let v9 : Un_cv (fun v9 : @nat => B1 v0 v9 * B1 v1 v9) (sin v0 * sin v1) := CV_mult (B1 v0) (B1 v1) (sin v0) (sin v1) v6 v7 in let v10 : Un_cv (Reste v0 v1) (IZR 0) := reste_cv_R0 v0 v1 in let v11 : IZR 0 < v2 / IZR 3 := Rmult_lt_0_compat v2 (/ IZR 3) v3 (Rinv_0_lt_compat (IZR 3) (Rplus_lt_0_compat (@R1) (IPR_2 1) (@Rlt_0_1) (@Rlt_R0_R2))) : IZR 0 < v2 / IZR 3 in (fun v12 : IZR 0 < v2 / IZR 3 => ex_ind (fun (v13 : @nat) (v14 : forall (v14 : @nat) (v15 : (v14 >= v13)%nat), Rabs (A1 v0 v14 * A1 v1 v14 - cos v0 * cos v1) < v2 / IZR 3) => ex_ind (fun (v15 : @nat) (v16 : forall (v16 : @nat) (v17 : (v16 >= v15)%nat), Rabs (B1 v0 v16 * B1 v1 v16 - sin v0 * sin v1) < v2 / IZR 3) => ex_ind (fun (v17 : @nat) (v18 : forall (v18 : @nat) (v19 : (v18 >= v17)%nat), Rabs (Reste v0 v1 v18 - IZR 0) < v2 / IZR 3) => let v19 : @nat := S (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) in ex_intro (fun v20 : @nat => forall (v21 : @nat) (v22 : (v21 >= v20)%nat), Rabs (C1 v0 v1 v21 - (cos v0 * cos v1 - sin v0 * sin v1)) < v2) v19 (fun (v20 : @nat) (v21 : (v20 >= v19)%nat) => let v22 : v20 = S (Init.Nat.pred v20) := let v22 : (0 < v19)%nat := Nat.lt_0_succ (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) : (0 < v19)%nat in (fun v23 : (0 < v19)%nat => let v24 : (0 < v20)%nat := Nat.lt_le_trans 0 v19 v20 v23 v21 in (fun v25 : (0 < v20)%nat => S_pred v20 0 v25) v24) v22 in (fun v23 : v20 = S (Init.Nat.pred v20) => eq_ind_r (fun v24 : @nat => Rabs (C1 v0 v1 v24 - (cos v0 * cos v1 - sin v0 * sin v1)) < v2) (eq_ind (A1 v0 (S (Init.Nat.pred v20)) * A1 v1 (S (Init.Nat.pred v20)) - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20)) (fun v24 : @R => Rabs (v24 - (cos v0 * cos v1 - sin v0 * sin v1)) < v2) (eq_ind v20 (fun v24 : @nat => Rabs (A1 v0 v24 * A1 v1 v24 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20) - (cos v0 * cos v1 - sin v0 * sin v1)) < v2) (Rle_lt_trans (Rabs (A1 v0 v20 * A1 v1 v20 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20) - (cos v0 * cos v1 - sin v0 * sin v1))) (Rabs (A1 v0 v20 * A1 v1 v20 - cos v0 * cos v1) + Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20))) v2 (let v24 : A1 v0 v20 * A1 v1 v20 - cos v0 * cos v1 + (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20)) = A1 v0 v20 * A1 v1 v20 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20) - (cos v0 * cos v1 - sin v0 * sin v1) := let v24 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v25 : list (@R) := (A1 v0 v20 :: A1 v1 v20 :: cos v0 :: cos v1 :: sin v0 :: sin v1 :: B1 v0 (Init.Nat.pred v20) :: B1 v1 (Init.Nat.pred v20) :: Reste v0 v1 (Init.Nat.pred v20) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v25 v24 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 8))) (Ring_polynom.PEX (@Z) 9))) (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 8))) (Ring_polynom.PEX (@Z) 9)) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 6)))) (@I) (eq_refl : (let v26 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v24 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v26 (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 8))) (Ring_polynom.PEX (@Z) 9)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v26 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 7) (Ring_polynom.PEX (@Z) 8))) (Ring_polynom.PEX (@Z) 9)) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 5) (Ring_polynom.PEX (@Z) 6)))))) = @true) in eq_ind (A1 v0 v20 * A1 v1 v20 - cos v0 * cos v1 + (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20))) (fun v25 : @R => Rabs v25 <= Rabs (A1 v0 v20 * A1 v1 v20 - cos v0 * cos v1) + Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20))) (Rabs_triang (A1 v0 v20 * A1 v1 v20 - cos v0 * cos v1) (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20))) (A1 v0 v20 * A1 v1 v20 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20) - (cos v0 * cos v1 - sin v0 * sin v1)) v24) (let v24 : v2 / IZR 3 + (v2 / IZR 3 + v2 / IZR 3) = v2 := (let v24 : IZR 3 * (v2 / IZR 3) = v2 := eq_ind (IZR 3 * v2 * / IZR 3) (fun v24 : @R => v24 = v2) (Rinv_r_simpl_m (IZR 3) v2 (IZR_neq 3 0 ((fun v24 : 3%Z = 0%Z => let v25 : @False := eq_ind 3%Z (fun v25 : @Z => match v25 as v26 in Z return Prop with | 0%Z => @False | Z.pos v26 => (fun v26 : @positive => @True) v26 | Z.neg v26 => (fun v26 : @positive => @False) v26 end) (@I) 0%Z v24 in False_ind (@False) v25) : 3%Z <> 0%Z))) (IZR 3 * (v2 * / IZR 3)) (Rmult_assoc (IZR 3) v2 (/ IZR 3)) : IZR 3 * (v2 / IZR 3) = v2 in eq_ind (IZR 3 * (v2 / IZR 3)) (fun v25 : @R => v2 / IZR 3 + (v2 / IZR 3 + v2 / IZR 3) = v25) (let v25 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v26 : list (@R) := (v2 / IZR 3 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v26 v25 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 1))) (Ring_polynom.PEmul (Ring_polynom.PEc 3%Z) (Ring_polynom.PEX (@Z) 1)) (@I) (eq_refl : (let v27 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v25 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 1)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEmul (Ring_polynom.PEc 3%Z) (Ring_polynom.PEX (@Z) 1)))) = @true)) v2 v24) : v2 / IZR 3 + (v2 / IZR 3 + v2 / IZR 3) = v2 in eq_ind (v2 / IZR 3 + (v2 / IZR 3 + v2 / IZR 3)) (fun v25 : @R => Rabs (A1 v0 v20 * A1 v1 v20 - cos v0 * cos v1) + Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20)) < v25) (Rplus_lt_compat (Rabs (A1 v0 v20 * A1 v1 v20 - cos v0 * cos v1)) (v2 / IZR 3) (Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20))) (v2 / IZR 3 + v2 / IZR 3) (v14 v20 (Nat.le_trans v13 v19 v20 (Nat.le_trans v13 (Init.Nat.max v13 v15) (S (S (Init.Nat.max (Init.Nat.max v13 v15) v17))) (le_max_l v13 v15) (Nat.le_trans (Init.Nat.max v13 v15) (Init.Nat.max (Init.Nat.max v13 v15) v17) (S (S (Init.Nat.max (Init.Nat.max v13 v15) v17))) (le_max_l (Init.Nat.max v13 v15) v17) (Nat.le_trans (Init.Nat.max (Init.Nat.max v13 v15) v17) (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) (S (S (Init.Nat.max (Init.Nat.max v13 v15) v17))) (Nat.le_succ_diag_r (Init.Nat.max (Init.Nat.max v13 v15) v17)) (Nat.le_succ_diag_r (S (Init.Nat.max (Init.Nat.max v13 v15) v17))))) : (v13 <= v19)%nat) v21 : (v20 >= v13)%nat)) (Rle_lt_trans (Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20) + Reste v0 v1 (Init.Nat.pred v20))) (Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20)) + Rabs (Reste v0 v1 (Init.Nat.pred v20))) (v2 / IZR 3 + v2 / IZR 3) (Rabs_triang (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20)) (Reste v0 v1 (Init.Nat.pred v20))) (Rplus_lt_compat (Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20))) (v2 / IZR 3) (Rabs (Reste v0 v1 (Init.Nat.pred v20))) (v2 / IZR 3) (eq_ind (Rabs (- (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20)))) (fun v25 : @R => v25 < v2 / IZR 3) (eq_ind_r (fun v25 : @R => Rabs v25 < v2 / IZR 3) (v16 (Init.Nat.pred v20) (Nat.le_trans v15 (Init.Nat.max v13 v15) (Init.Nat.pred v20) (le_max_r v13 v15) (le_S_n (Init.Nat.max v13 v15) (Init.Nat.pred v20) (eq_ind v20 (fun v25 : @nat => (S (Init.Nat.max v13 v15) <= v25)%nat) (Nat.le_trans (S (Init.Nat.max v13 v15)) v19 v20 (le_n_S (Init.Nat.max v13 v15) (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) (Nat.le_trans (Init.Nat.max v13 v15) (Init.Nat.max (Init.Nat.max v13 v15) v17) (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) (le_max_l (Init.Nat.max v13 v15) v17) (Nat.le_succ_diag_r (Init.Nat.max (Init.Nat.max v13 v15) v17))) : (S (Init.Nat.max v13 v15) <= v19)%nat) v21) (S (Init.Nat.pred v20)) v23)) : (Init.Nat.pred v20 >= v15)%nat)) (Ropp_minus_distr (sin v0 * sin v1) (B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20)))) (Rabs (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20))) (Rabs_Ropp (sin v0 * sin v1 - B1 v0 (Init.Nat.pred v20) * B1 v1 (Init.Nat.pred v20)))) (let v25 : Reste v0 v1 (Init.Nat.pred v20) - IZR 0 = Reste v0 v1 (Init.Nat.pred v20) := let v25 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v26 : list (@R) := (Reste v0 v1 (Init.Nat.pred v20) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v26 v25 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEX (@Z) 1) (@I) (eq_refl : (let v27 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v25 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v27 (Ring_polynom.PEX (@Z) 1))) = @true) in eq_ind (Reste v0 v1 (Init.Nat.pred v20) - IZR 0) (fun v26 : @R => Rabs v26 < v2 / IZR 3) (v18 (Init.Nat.pred v20) (le_S_n v17 (Init.Nat.pred v20) (eq_ind v20 (fun v26 : @nat => (S v17 <= v26)%nat) (Nat.le_trans (S v17) v19 v20 (le_n_S v17 (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) (Nat.le_trans v17 (Init.Nat.max (Init.Nat.max v13 v15) v17) (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) (le_max_r (Init.Nat.max v13 v15) v17) (Nat.le_succ_diag_r (Init.Nat.max (Init.Nat.max v13 v15) v17))) : (S v17 <= v19)%nat) v21) (S (Init.Nat.pred v20)) v23) : (Init.Nat.pred v20 >= v17)%nat)) (Reste v0 v1 (Init.Nat.pred v20)) v25)))) v2 v24)) (S (Init.Nat.pred v20)) v23) (C1 v0 v1 (S (Init.Nat.pred v20))) (cos_plus_form v0 v1 (Init.Nat.pred v20) (Nat.lt_le_trans 0 (Init.Nat.pred v19) (Init.Nat.pred v20) ((Nat.lt_0_succ (Init.Nat.max (Init.Nat.max v13 v15) v17) : (0 < Init.Nat.pred (S (S (Init.Nat.max (Init.Nat.max v13 v15) v17))))%nat) : (0 < Init.Nat.pred v19)%nat) (le_S_n (Init.Nat.pred v19) (Init.Nat.pred v20) (eq_ind v20 (fun v24 : @nat => (S (Init.Nat.pred v19) <= v24)%nat) (let v24 : v19 = S (Init.Nat.pred v19) := (eq_refl : S (S (Init.Nat.max (Init.Nat.max v13 v15) v17)) = S (Init.Nat.pred (S (S (Init.Nat.max (Init.Nat.max v13 v15) v17))))) : v19 = S (Init.Nat.pred v19) in eq_ind v19 (fun v25 : @nat => (v25 <= v20)%nat) v21 (S (Init.Nat.pred v19)) v24) (S (Init.Nat.pred v20)) v23))))) v23) v22)) (v10 (v2 / IZR 3) v12)) (v9 (v2 / IZR 3) v12)) (v8 (v2 / IZR 3) v12)) v11) : forall (v2 : @R) (v3 : v2 > IZR 0), exists v4 : @nat, forall (v5 : @nat) (v6 : (v5 >= v4)%nat), R_dist (C1 v0 v1 v5) (cos v0 * cos v1 - sin v0 * sin v1) < v2) : Un_cv (C1 v0 v1) (cos v0 * cos v1 - sin v0 * sin v1) in (let v3 : Un_cv (C1 v0 v1) (cos (v0 + v1)) := C1_cvg v0 v1 in (fun (v4 : Un_cv (C1 v0 v1) (cos (v0 + v1))) (v5 : Un_cv (C1 v0 v1) (cos v0 * cos v1 - sin v0 * sin v1)) => UL_sequence (C1 v0 v1) (cos (v0 + v1)) (cos v0 * cos v1 - sin v0 * sin v1) v4 v5) v3) v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.IZN_var	100	0.052624	1	1	0	synth with cache (only 1: refine (fun (v0 : @Z) (v1 : (0 <= v0)%Z) => exist (fun v2 : @nat => v0 = BinIntDef.Z.of_nat v2) (BinIntDef.Z.to_nat v0) (eq_sym (Z2Nat.id v0 v1)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.Nzorn	100	1.852400	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P1	100	0.100760	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => (let v3 : (fun v3 : @Rlist => is_subdivision v2 v0 v1 v3) (projT1 (pre v2)) := projT2 (pre v2) in match v3 as v4 in (sigT _) return (adapted_couple v2 v0 v1 (subdivision v2) match v4 as v5 in (sigT _) return (@Rlist) with | existT _ v5 v6 => (fun (v5 : @Rlist) (v6 : adapted_couple v2 v0 v1 (projT1 (pre v2)) v5) => v5) v5 v6 end) with | existT _ v4 v5 => (fun (v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 (projT1 (pre v2)) v4) => v5) v4 v5 end) : adapted_couple v2 v0 v1 (subdivision v2) (subdivision_val v2))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P2	100	0.521267	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v5) (pos_Rl v3 (S v5))) (pos_Rl v4 v5))) => let v6 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v6) (pos_Rl v3 (S v6))) (pos_Rl v4 v6)) := v5 in (fun v7 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7)) => and_ind (fun (v8 : ordered_Rlist v3) (v9 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v9) (pos_Rl v3 (S v9))) (pos_Rl v4 v9))) => and_ind (fun (v10 : pos_Rl v3 0 = Rmin v0 v1) (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v11) (pos_Rl v3 (S v11))) (pos_Rl v4 v11))) => and_ind (fun (v12 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v13 : Rlength v3 = S (Rlength v4) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v13) (pos_Rl v3 (S v13))) (pos_Rl v4 v13))) => and_ind (fun (v14 : Rlength v3 = S (Rlength v4)) (v15 : forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v4 v15)) => conj v8 (conj (eq_ind_r (fun v16 : @R => v16 = Rmin v1 v0) (match Rle_dec v0 v1 as v16 in ({_} + {_}) return (match v16 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v0 <= v1 => v0) v17 | right v17 => (fun v17 : ~ v0 <= v1 => v1) v17 end = match Rle_dec v1 v0 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v1 <= v0 => v1) v17 | right v17 => (fun v17 : ~ v1 <= v0 => v0) v17 end) with | left v16 => (fun v16 : v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v0 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v1) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v0) v18 end) with | left v17 => (fun v17 : v1 <= v0 => Rle_antisym v0 v1 v16 v17) v17 | right v17 => (fun v17 : ~ v1 <= v0 => eq_refl) v17 end) v16 | right v16 => (fun v16 : ~ v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v1 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v1) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v0) v18 end) with | left v17 => (fun v17 : v1 <= v0 => eq_refl) v17 | right v17 => (fun v17 : ~ v1 <= v0 => Rle_antisym v1 v0 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v16)) (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v17))) v17 end) v16 end : Rmin v0 v1 = Rmin v1 v0) v10) (conj (eq_ind_r (fun v16 : @R => v16 = Rmax v1 v0) (match Rle_dec v0 v1 as v16 in ({_} + {_}) return (match v16 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v0 <= v1 => v1) v17 | right v17 => (fun v17 : ~ v0 <= v1 => v0) v17 end = match Rle_dec v1 v0 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v1 <= v0 => v0) v17 | right v17 => (fun v17 : ~ v1 <= v0 => v1) v17 end) with | left v16 => (fun v16 : v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v1 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v0) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v1) v18 end) with | left v17 => (fun v17 : v1 <= v0 => Rle_antisym v1 v0 v17 v16) v17 | right v17 => (fun v17 : ~ v1 <= v0 => eq_refl) v17 end) v16 | right v16 => (fun v16 : ~ v0 <= v1 => match Rle_dec v1 v0 as v17 in ({_} + {_}) return (v0 = match v17 as v18 in ({_} + {_}) return (@R) with | left v18 => (fun v18 : v1 <= v0 => v0) v18 | right v18 => (fun v18 : ~ v1 <= v0 => v1) v18 end) with | left v17 => (fun v17 : v1 <= v0 => eq_refl) v17 | right v17 => (fun v17 : ~ v1 <= v0 => Rle_antisym v0 v1 (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v17)) (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v16))) v17 end) v16 end : Rmax v0 v1 = Rmax v1 v0) v12) (conj v14 v15)))) v13) v11) v9) v7) v6) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4), adapted_couple v2 v1 v0 v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P3	100	0.429294	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : v0 <= v1) => conj ((fun (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat) => let v6 : forall v6 : 1%nat = 1%nat, pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4) := match v5 as v7 in (_ <= v6)%nat return (forall v8 : v6 = 1%nat, pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) with | le_n _ => fun v6 : S v4 = 1%nat => (fun v7 : S v4 = 1%nat => let v8 : v4 = 0%nat := f_equal (fun v8 : @nat => match v8 as v9 in nat return (@nat) with | 0%nat => v4 | S v9 => (fun v9 : @nat => v9) v9 end) v7 in (fun v9 : v4 = 0%nat => let v10 : v4 = 0%nat := v9 in eq_ind_r (fun v11 : @nat => pos_Rl (cons v0 (cons v1 (@nil))) v11 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v11)) (v3 : pos_Rl (cons v0 (cons v1 (@nil))) 0 <= pos_Rl (cons v0 (cons v1 (@nil))) 1) v10) v8) v6 | le_S _ v6 v7 => (fun (v6 : @nat) (v7 : (S v4 <= v6)%nat) (v8 : S v6 = 1%nat) => (fun v9 : S v6 = 1%nat => let v10 : v6 = 0%nat := f_equal (fun v10 : @nat => match v10 as v11 in nat return (@nat) with | 0%nat => v6 | S v11 => (fun v11 : @nat => v11) v11 end) v9 in (fun v11 : v6 = 0%nat => let v12 : v6 = 0%nat := v11 in eq_ind_r (fun v13 : @nat => forall v14 : (S v4 <= v13)%nat, pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) (fun v13 : (S v4 <= 0)%nat => False_ind (pos_Rl (cons v0 (cons v1 (@nil))) v4 <= pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) (Nat.nle_succ_0 v4 v13)) v12) v10) v8 v7) v6 v7 end in v6 eq_refl) : ordered_Rlist (cons v0 (cons v1 (@nil)))) (conj ((decide_left (Rle_dec v0 v1) v3 (fun v4 : {v0 <= v1} + {~ v0 <= v1} => v0 = match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v0) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v1) v5 end) (fun v4 : v0 <= v1 => eq_refl) : v0 = Rmin v0 v1) : pos_Rl (cons v0 (cons v1 (@nil))) 0 = Rmin v0 v1) (conj ((decide_left (Rle_dec v0 v1) v3 (fun v4 : {v0 <= v1} + {~ v0 <= v1} => v1 = match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => v1) v5 | right v5 => (fun v5 : ~ v0 <= v1 => v0) v5 end) (fun v4 : v0 <= v1 => eq_refl) : v1 = Rmax v0 v1) : pos_Rl (cons v0 (cons v1 (@nil))) (Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil))))) = Rmax v0 v1) (conj eq_refl (((fun (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat) (v6 : @R) (v7 : pos_Rl (cons v0 (cons v1 (@nil))) v4 < v6 < pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) => let v8 : forall v8 : 1%nat = 1%nat, fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4 := match v5 as v9 in (_ <= v8)%nat return (forall v10 : v8 = 1%nat, fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) with | le_n _ => fun v8 : S v4 = 1%nat => (fun v9 : S v4 = 1%nat => let v10 : v4 = 0%nat := f_equal (fun v10 : @nat => match v10 as v11 in nat return (@nat) with | 0%nat => v4 | S v11 => (fun v11 : @nat => v11) v11 end) v9 in (fun v11 : v4 = 0%nat => let v12 : v4 = 0%nat := v11 in eq_ind_r (fun v13 : @nat => fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v13) eq_refl v12) v10) v8 | le_S _ v8 v9 => (fun (v8 : @nat) (v9 : (S v4 <= v8)%nat) (v10 : S v8 = 1%nat) => (fun v11 : S v8 = 1%nat => let v12 : v8 = 0%nat := f_equal (fun v12 : @nat => match v12 as v13 in nat return (@nat) with | 0%nat => v8 | S v13 => (fun v13 : @nat => v13) v13 end) v11 in (fun v13 : v8 = 0%nat => let v14 : v8 = 0%nat := v13 in eq_ind_r (fun v15 : @nat => forall v16 : (S v4 <= v15)%nat, fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) (fun v15 : (S v4 <= 0)%nat => False_ind (fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) (Nat.nle_succ_0 v4 v15)) v14) v12) v10 v9) v8 v9 end in v8 eq_refl) : forall (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat) (v6 : @R) (v7 : open_interval (pos_Rl (cons v0 (cons v1 (@nil))) v4) (pos_Rl (cons v0 (cons v1 (@nil))) (S v4)) v6), fct_cte v2 v6 = pos_Rl (cons v2 (@nil)) v4) : forall (v4 : @nat) (v5 : (v4 < Init.Nat.pred (Rlength (cons v0 (cons v1 (@nil)))))%nat), constant_D_eq (fct_cte v2) (open_interval (pos_Rl (cons v0 (cons v1 (@nil))) v4) (pos_Rl (cons v0 (cons v1 (@nil))) (S v4))) (pos_Rl (cons v2 (@nil)) v4))))) : adapted_couple (fct_cte v2) v0 v1 (cons v0 (cons v1 (@nil))) (cons v2 (@nil)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P4	100	0.226537	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => (let v3 : {v0 <= v1} + {~ v0 <= v1} := Rle_dec v0 v1 in match v3 as v4 in ({_} + {_}) return {v5 : @Rlist & is_subdivision (fct_cte v2) v0 v1 v5} with | left v4 => (fun v4 : v0 <= v1 => existT (fun v5 : @Rlist => is_subdivision (fct_cte v2) v0 v1 v5) (cons v0 (cons v1 (@nil))) (existT (fun v5 : @Rlist => adapted_couple (fct_cte v2) v0 v1 (cons v0 (cons v1 (@nil))) v5) (cons v2 (@nil)) (StepFun_P3 v2 v4) : is_subdivision (fct_cte v2) v0 v1 (cons v0 (cons v1 (@nil))))) v4 | right v4 => (fun v4 : ~ v0 <= v1 => existT (fun v5 : @Rlist => is_subdivision (fct_cte v2) v0 v1 v5) (cons v1 (cons v0 (@nil))) (existT (fun v5 : @Rlist => adapted_couple (fct_cte v2) v0 v1 (cons v1 (cons v0 (@nil))) v5) (cons v2 (@nil)) (StepFun_P2 (StepFun_P3 v2 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v4)))) : is_subdivision (fct_cte v2) v0 v1 (cons v1 (cons v0 (@nil))))) v4 end) : IsStepFun (fct_cte v2) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P5	100	0.276563	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : @Rlist) (v4 : is_subdivision v2 v0 v1 v3) => match v4 as v5 in (sigT _) return (is_subdivision v2 v1 v0 v3) with | existT _ v5 v6 => (fun (v5 : @Rlist) (v6 : adapted_couple v2 v0 v1 v3 v5) => match v6 as v7 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v7 v8 => (fun (v7 : ordered_Rlist v3) (v8 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v5 v8))) => match v8 as v9 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v9 v10 => (fun (v9 : pos_Rl v3 0 = Rmin v0 v1) (v10 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v10) (pos_Rl v3 (S v10))) (pos_Rl v5 v10))) => match v10 as v11 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v11 v12 => (fun (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v12 : Rlength v3 = S (Rlength v5) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v12) (pos_Rl v3 (S v12))) (pos_Rl v5 v12))) => match v12 as v13 in (_ /\ _) return (is_subdivision v2 v1 v0 v3) with | conj v13 v14 => (fun (v13 : Rlength v3 = S (Rlength v5)) (v14 : forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v14) (pos_Rl v3 (S v14))) (pos_Rl v5 v14)) => existT (fun v15 : @Rlist => adapted_couple v2 v1 v0 v3 v15) v5 (conj v7 (conj (eq_ind_r (fun v15 : @R => v15 = Rmin v1 v0) (Rmin_comm v0 v1) v9) (conj (eq_ind_r (fun v15 : @R => v15 = Rmax v1 v0) (Rmax_comm v0 v1) v11) (conj v13 v14))))) v13 v14 end) v11 v12 end) v9 v10 end) v7 v8 end) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P6	100	0.103926	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : {v3 : @Rlist & is_subdivision v0 v1 v2 v3}) => sigT_rect (fun v4 : {v4 : @Rlist & is_subdivision v0 v1 v2 v4} => {v5 : @Rlist & is_subdivision v0 v2 v1 v5}) (fun (v4 : @Rlist) (v5 : is_subdivision v0 v1 v2 v4) => existT (fun v6 : @Rlist => is_subdivision v0 v2 v1 v6) v4 (StepFun_P5 v5)) v3) : forall (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : IsStepFun v0 v1 v2), IsStepFun v0 v2 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P7	100	0.917105	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 v2 v3 v4 : @R) (v5 : forall v5 : @R, @R) (v6 v7 : @Rlist) (v8 : v0 <= v1) (v9 : ordered_Rlist (cons v2 (cons v3 v6)) /\ pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v9) (pos_Rl (cons v2 (cons v3 v6)) (S v9))) (pos_Rl (cons v4 v7) v9))) => let v10 : ordered_Rlist (cons v2 (cons v3 v6)) /\ pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v10) (pos_Rl (cons v2 (cons v3 v6)) (S v10))) (pos_Rl (cons v4 v7) v10)) := v9 in (fun v11 : ordered_Rlist (cons v2 (cons v3 v6)) /\ pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v11) (pos_Rl (cons v2 (cons v3 v6)) (S v11))) (pos_Rl (cons v4 v7) v11)) => and_ind (fun (v12 : ordered_Rlist (cons v2 (cons v3 v6))) (v13 : pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1 /\ pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v13) (pos_Rl (cons v2 (cons v3 v6)) (S v13))) (pos_Rl (cons v4 v7) v13))) => and_ind (fun (v14 : pos_Rl (cons v2 (cons v3 v6)) 0 = Rmin v0 v1) (v15 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1 /\ Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v15) (pos_Rl (cons v2 (cons v3 v6)) (S v15))) (pos_Rl (cons v4 v7) v15))) => and_ind (fun (v16 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = Rmax v0 v1) (v17 : Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7)) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v17) (pos_Rl (cons v2 (cons v3 v6)) (S v17))) (pos_Rl (cons v4 v7) v17))) => and_ind (fun (v18 : Rlength (cons v2 (cons v3 v6)) = S (Rlength (cons v4 v7))) (v19 : forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat), constant_D_eq v5 (open_interval (pos_Rl (cons v2 (cons v3 v6)) v19) (pos_Rl (cons v2 (cons v3 v6)) (S v19))) (pos_Rl (cons v4 v7) v19)) => let v20 : Rmax v0 v1 = v1 := decide_left (Rle_dec v0 v1) v8 (fun v20 : {v0 <= v1} + {~ v0 <= v1} => match v20 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v0 <= v1 => v1) v21 | right v21 => (fun v21 : ~ v0 <= v1 => v0) v21 end = v1) (fun v20 : v0 <= v1 => eq_refl) : Rmax v0 v1 = v1 in let v21 : v3 <= v1 := let v21 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v1 := eq_ind (Rmax v0 v1) (fun v21 : @R => pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v21) v16 v1 v20 in eq_ind (pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))) (fun v22 : @R => v3 <= v22) (RList_P7 (cons v2 (cons v3 v6)) v3 v12 (or_intror (or_introl eq_refl) : In v3 (cons v2 (cons v3 v6)))) v1 v21 in conj (RList_P4 (cons v3 v6) v2 v12) (conj (let v22 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v1 := eq_ind (Rmax v0 v1) (fun v22 : @R => pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v22) v16 v1 v20 in decide_left (Rle_dec v3 v1) v21 (fun v23 : {v3 <= v1} + {~ v3 <= v1} => pos_Rl (cons v3 v6) 0 = match v23 as v24 in ({_} + {_}) return (@R) with | left v24 => (fun v24 : v3 <= v1 => v3) v24 | right v24 => (fun v24 : ~ v3 <= v1 => v1) v24 end) (fun v23 : v3 <= v1 => eq_refl) : pos_Rl (cons v3 v6) 0 = Rmin v3 v1) (conj (decide_left (Rle_dec v3 v1) v21 (fun v22 : {v3 <= v1} + {~ v3 <= v1} => pos_Rl (cons v3 v6) (Init.Nat.pred (Rlength (cons v3 v6))) = match v22 as v23 in ({_} + {_}) return (@R) with | left v23 => (fun v23 : v3 <= v1 => v1) v23 | right v23 => (fun v23 : ~ v3 <= v1 => v3) v23 end) (fun v22 : v3 <= v1 => let v23 : pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v1 := eq_ind (Rmax v0 v1) (fun v23 : @R => pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6)))) = v23) v16 v1 v20 in eq_ind (pos_Rl (cons v2 (cons v3 v6)) (Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))) (fun v24 : @R => pos_Rl (cons v3 v6) (Init.Nat.pred (Rlength (cons v3 v6))) = v24) eq_refl v1 v23) : pos_Rl (cons v3 v6) (Init.Nat.pred (Rlength (cons v3 v6))) = Rmax v3 v1) (conj (INR_eq (S (Rlength v6)) (S (Rlength v7)) (Rplus_eq_reg_l (IZR 1) (INR (S (Rlength v6))) (INR (S (Rlength v7))) (eq_ind_r (fun v22 : @R => v22 = IZR 1 + INR (S (Rlength v7))) (eq_ind_r (fun v22 : @R => INR (S (Rlength v6)) + IZR 1 = v22) (eq_ind (INR (S (S (Rlength v6)))) (fun v22 : @R => v22 = INR (S (Rlength v7)) + IZR 1) (eq_ind (INR (S (S (Rlength v7)))) (fun v22 : @R => INR (S (S (Rlength v6))) = v22) (eq_ind_r (fun v22 : @nat => INR v22 = INR (S (S (Rlength v7)))) eq_refl v18) (INR (S (Rlength v7)) + IZR 1) (S_INR (S (Rlength v7)))) (INR (S (Rlength v6)) + IZR 1) (S_INR (S (Rlength v6)))) (Rplus_comm (IZR 1) (INR (S (Rlength v7))))) (Rplus_comm (IZR 1) (INR (S (Rlength v6)))))) : Rlength (cons v3 v6) = S (Rlength v7)) (fun (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (cons v3 v6)))%nat) => ((fun (v24 : @R) (v25 : pos_Rl (cons v3 v6) v22 < v24 < pos_Rl (cons v3 v6) (S v22)) => let v26 : (S v22 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat := lt_n_S v22 (Rlength v6) v23 : (S v22 < Init.Nat.pred (Rlength (cons v2 (cons v3 v6))))%nat in let v27 : forall (v27 : @R) (v28 : pos_Rl (cons v2 (cons v3 v6)) (S v22) < v27 < pos_Rl (cons v2 (cons v3 v6)) (S (S v22))), v5 v27 = pos_Rl (cons v4 v7) (S v22) := v19 (S v22) v26 in v27 v24 v25) : forall (v24 : @R) (v25 : open_interval (pos_Rl (cons v3 v6) v22) (pos_Rl (cons v3 v6) (S v22)) v24), v5 v24 = pos_Rl v7 v22) : constant_D_eq v5 (open_interval (pos_Rl (cons v3 v6) v22) (pos_Rl (cons v3 v6) (S v22))) (pos_Rl v7 v22)))))) v17) v15) v13) v11) v10) : forall (v0 v1 v2 v3 v4 : @R) (v5 : forall v5 : @R, @R) (v6 v7 : @Rlist) (v8 : v0 <= v1) (v9 : adapted_couple v5 v0 v1 (cons v2 (cons v3 v6)) (cons v4 v7)), adapted_couple v5 v3 v1 (cons v3 v6) v7)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P8	100	1.668777	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : @Rlist) => Rlist_ind (fun v2 : @Rlist => forall (v3 : @Rlist) (v4 v5 : @R) (v6 : adapted_couple v0 v4 v5 v2 v3) (v7 : v4 = v5), Int_SF v3 v2 = IZR 0) (fun (v2 : @Rlist) (v3 v4 : @R) (v5 : adapted_couple v0 v3 v4 (@nil) v2) (v6 : v3 = v4) => Rlist_ind (fun v7 : @Rlist => forall v8 : adapted_couple v0 v3 v4 (@nil) v7, Int_SF v7 (@nil) = IZR 0) (fun v7 : adapted_couple v0 v3 v4 (@nil) (@nil) => eq_refl) (fun (v7 : @R) (v8 : @Rlist) (v9 : forall v9 : adapted_couple v0 v3 v4 (@nil) v8, Int_SF v8 (@nil) = IZR 0) (v10 : adapted_couple v0 v3 v4 (@nil) (cons v7 v8)) => eq_refl) v2 v5) (fun (v2 : @R) (v3 : @Rlist) => Rlist_ind (fun v4 : @Rlist => forall (v5 : forall (v5 : @Rlist) (v6 v7 : @R) (v8 : adapted_couple v0 v6 v7 v4 v5) (v9 : v6 = v7), Int_SF v5 v4 = IZR 0) (v6 : @Rlist) (v7 v8 : @R) (v9 : adapted_couple v0 v7 v8 (cons v2 v4) v6) (v10 : v7 = v8), Int_SF v6 (cons v2 v4) = IZR 0) (fun (v4 : forall (v4 : @Rlist) (v5 v6 : @R) (v7 : adapted_couple v0 v5 v6 (@nil) v4) (v8 : v5 = v6), Int_SF v4 (@nil) = IZR 0) (v5 : @Rlist) (v6 v7 : @R) (v8 : adapted_couple v0 v6 v7 (cons v2 (@nil)) v5) (v9 : v6 = v7) => Rlist_ind (fun v10 : @Rlist => forall v11 : adapted_couple v0 v6 v7 (cons v2 (@nil)) v10, Int_SF v10 (cons v2 (@nil)) = IZR 0) (fun v10 : adapted_couple v0 v6 v7 (cons v2 (@nil)) (@nil) => eq_refl) (fun (v10 : @R) (v11 : @Rlist) (v12 : forall v12 : adapted_couple v0 v6 v7 (cons v2 (@nil)) v11, Int_SF v11 (cons v2 (@nil)) = IZR 0) (v13 : adapted_couple v0 v6 v7 (cons v2 (@nil)) (cons v10 v11)) => let v14 : ordered_Rlist (cons v2 (@nil)) /\ pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7 /\ pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v14) (pos_Rl (cons v2 (@nil)) (S v14))) (pos_Rl (cons v10 v11) v14)) := v13 in (fun v15 : ordered_Rlist (cons v2 (@nil)) /\ pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7 /\ pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v15) (pos_Rl (cons v2 (@nil)) (S v15))) (pos_Rl (cons v10 v11) v15)) => and_ind (fun (v16 : ordered_Rlist (cons v2 (@nil))) (v17 : pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7 /\ pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v17) (pos_Rl (cons v2 (@nil)) (S v17))) (pos_Rl (cons v10 v11) v17))) => and_ind (fun (v18 : pos_Rl (cons v2 (@nil)) 0 = Rmin v6 v7) (v19 : pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7 /\ Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v19) (pos_Rl (cons v2 (@nil)) (S v19))) (pos_Rl (cons v10 v11) v19))) => and_ind (fun (v20 : pos_Rl (cons v2 (@nil)) (Init.Nat.pred (Rlength (cons v2 (@nil)))) = Rmax v6 v7) (v21 : Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11)) /\ (forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v21) (pos_Rl (cons v2 (@nil)) (S v21))) (pos_Rl (cons v10 v11) v21))) => and_ind (fun (v22 : Rlength (cons v2 (@nil)) = S (Rlength (cons v10 v11))) (v23 : forall (v23 : @nat) (v24 : (v23 < Init.Nat.pred (Rlength (cons v2 (@nil))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (@nil)) v23) (pos_Rl (cons v2 (@nil)) (S v23))) (pos_Rl (cons v10 v11) v23)) => let v24 : @False := eq_ind 1%nat (fun v24 : @nat => match v24 as v25 in nat return Prop with | 0%nat => @False | S v25 => (fun v25 : @nat => match v25 as v26 in nat return Prop with | 0%nat => @True | S v26 => (fun v26 : @nat => @False) v26 end) v25 end) (@I) (S (S (Rlength v11))) v22 in False_ind (Int_SF (cons v10 v11) (cons v2 (@nil)) = IZR 0) v24) v21) v19) v17) v15) v14) v5 v8) (fun (v4 : @R) (v5 : @Rlist) (v6 : forall (v6 : forall (v6 : @Rlist) (v7 v8 : @R) (v9 : adapted_couple v0 v7 v8 v5 v6) (v10 : v7 = v8), Int_SF v6 v5 = IZR 0) (v7 : @Rlist) (v8 v9 : @R) (v10 : adapted_couple v0 v8 v9 (cons v2 v5) v7) (v11 : v8 = v9), Int_SF v7 (cons v2 v5) = IZR 0) (v7 : forall (v7 : @Rlist) (v8 v9 : @R) (v10 : adapted_couple v0 v8 v9 (cons v4 v5) v7) (v11 : v8 = v9), Int_SF v7 (cons v4 v5) = IZR 0) (v8 : @Rlist) (v9 v10 : @R) (v11 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) v8) (v12 : v9 = v10) => Rlist_ind (fun v13 : @Rlist => forall v14 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) v13, Int_SF v13 (cons v2 (cons v4 v5)) = IZR 0) (fun v13 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) (@nil) => eq_refl) (fun (v13 : @R) (v14 : @Rlist) (v15 : forall v15 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) v14, Int_SF v14 (cons v2 (cons v4 v5)) = IZR 0) (v16 : adapted_couple v0 v9 v10 (cons v2 (cons v4 v5)) (cons v13 v14)) => (let v17 : v2 = v4 := let v17 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v17) (pos_Rl (cons v2 (cons v4 v5)) (S v17))) (pos_Rl (cons v13 v14) v17)) := v16 in (fun v18 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v18 : @nat) (v19 : (v18 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v18) (pos_Rl (cons v2 (cons v4 v5)) (S v18))) (pos_Rl (cons v13 v14) v18)) => and_ind (fun (v19 : ordered_Rlist (cons v2 (cons v4 v5))) (v20 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v20 : @nat) (v21 : (v20 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v20) (pos_Rl (cons v2 (cons v4 v5)) (S v20))) (pos_Rl (cons v13 v14) v20))) => and_ind (fun (v21 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10) (v22 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v22) (pos_Rl (cons v2 (cons v4 v5)) (S v22))) (pos_Rl (cons v13 v14) v22))) => and_ind (fun (v23 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10) (v24 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v24) (pos_Rl (cons v2 (cons v4 v5)) (S v24))) (pos_Rl (cons v13 v14) v24))) => and_ind (fun (v25 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14))) (v26 : forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v26) (pos_Rl (cons v2 (cons v4 v5)) (S v26))) (pos_Rl (cons v13 v14) v26)) => Rle_antisym v2 v4 (v19 0%nat (Nat.lt_0_succ (Rlength v5) : (0 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat)) (let v27 : v2 = Rmin v10 v10 := eq_ind v9 (fun v27 : @R => v2 = Rmin v27 v10) v21 v10 v12 in eq_ind_r (fun v28 : @R => v4 <= v28) (let v28 : Rmax v9 v10 = Rmin v10 v10 := (match Rle_dec v10 v10 as v28 in ({_} + {_}) return (match Rle_dec v9 v10 as v29 in ({_} + {_}) return (@R) with | left v29 => (fun v29 : v9 <= v10 => v10) v29 | right v29 => (fun v29 : ~ v9 <= v10 => v9) v29 end = match v28 as v29 in ({_} + {_}) return (@R) with | left v29 => (fun v29 : v10 <= v10 => v10) v29 | right v29 => (fun v29 : ~ v10 <= v10 => v10) v29 end) with | left v28 => match Rle_dec v9 v10 as v28 in ({_} + {_}) return (forall v29 : v10 <= v10, match v28 as v30 in ({_} + {_}) return (@R) with | left v30 => (fun v30 : v9 <= v10 => v10) v30 | right v30 => (fun v30 : ~ v9 <= v10 => v9) v30 end = v10) with | left v28 => (fun (v28 : v9 <= v10) (v29 : v10 <= v10) => eq_refl) v28 | right v28 => (fun (v28 : ~ v9 <= v10) (v29 : v10 <= v10) => v12) v28 end v28 | right v28 => match Rle_dec v9 v10 as v28 in ({_} + {_}) return (forall v29 : ~ v10 <= v10, match v28 as v30 in ({_} + {_}) return (@R) with | left v30 => (fun v30 : v9 <= v10 => v10) v30 | right v30 => (fun v30 : ~ v9 <= v10 => v9) v30 end = v10) with | left v28 => (fun (v28 : v9 <= v10) (v29 : ~ v10 <= v10) => eq_refl) v28 | right v28 => (fun (v28 : ~ v9 <= v10) (v29 : ~ v10 <= v10) => v12) v28 end v28 end : Rmax v9 v10 = match Rle_dec v10 v10 as v28 in ({_} + {_}) return (@R) with | left v28 => (fun v28 : v10 <= v10 => v10) v28 | right v28 => (fun v28 : ~ v10 <= v10 => v10) v28 end) : Rmax v9 v10 = Rmin v10 v10 in eq_ind (Rmax v9 v10) (fun v29 : @R => v4 <= v29) (eq_ind (pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))) (fun v29 : @R => v4 <= v29) (RList_P7 (cons v2 (cons v4 v5)) v4 v19 (or_intror (or_introl eq_refl) : In v4 (cons v2 (cons v4 v5)))) (Rmax v9 v10) v23) (Rmin v10 v10) v28) v27)) v24) v22) v20) v18) v17 in (fun v18 : v2 = v4 => eq_ind_r (fun v19 : @R => v13 * (v4 - v19) + Int_SF v14 (cons v4 v5) = IZR 0) (eq_ind_r (fun v19 : @R => v13 * (v4 - v4) + v19 = IZR 0) (let v19 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v20 : list (@R) := (v13 :: v4 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v20 v19 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEc 0%Z) (@I) (eq_refl : (let v21 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v19 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v21 (Ring_polynom.PEc 0%Z))) = @true)) (v7 v14 v2 v10 (eq_ind_r (fun v19 : @R => adapted_couple v0 v19 v10 (cons v4 v5) v14) (StepFun_P7 (or_intror v12) v16) v18) (let v19 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v19) (pos_Rl (cons v2 (cons v4 v5)) (S v19))) (pos_Rl (cons v13 v14) v19)) := v16 in (fun v20 : ordered_Rlist (cons v2 (cons v4 v5)) /\ pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v20 : @nat) (v21 : (v20 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v20) (pos_Rl (cons v2 (cons v4 v5)) (S v20))) (pos_Rl (cons v13 v14) v20)) => and_ind (fun (v21 : ordered_Rlist (cons v2 (cons v4 v5))) (v22 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10 /\ pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v22) (pos_Rl (cons v2 (cons v4 v5)) (S v22))) (pos_Rl (cons v13 v14) v22))) => and_ind (fun (v23 : pos_Rl (cons v2 (cons v4 v5)) 0 = Rmin v9 v10) (v24 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10 /\ Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v24) (pos_Rl (cons v2 (cons v4 v5)) (S v24))) (pos_Rl (cons v13 v14) v24))) => and_ind (fun (v25 : pos_Rl (cons v2 (cons v4 v5)) (Init.Nat.pred (Rlength (cons v2 (cons v4 v5)))) = Rmax v9 v10) (v26 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14)) /\ (forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v26) (pos_Rl (cons v2 (cons v4 v5)) (S v26))) (pos_Rl (cons v13 v14) v26))) => and_ind (fun (v27 : Rlength (cons v2 (cons v4 v5)) = S (Rlength (cons v13 v14))) (v28 : forall (v28 : @nat) (v29 : (v28 < Init.Nat.pred (Rlength (cons v2 (cons v4 v5))))%nat), constant_D_eq v0 (open_interval (pos_Rl (cons v2 (cons v4 v5)) v28) (pos_Rl (cons v2 (cons v4 v5)) (S v28))) (pos_Rl (cons v13 v14) v28)) => eq_ind_r (fun v29 : @R => v29 = v10) (match Rle_dec v9 v10 as v29 in ({_} + {_}) return (match v29 as v30 in ({_} + {_}) return (@R) with | left v30 => (fun v30 : v9 <= v10 => v9) v30 | right v30 => (fun v30 : ~ v9 <= v10 => v10) v30 end = v10) with | left v29 => (fun v29 : v9 <= v10 => v12) v29 | right v29 => (fun v29 : ~ v9 <= v10 => eq_refl) v29 end : Rmin v9 v10 = v10) v23) v26) v24) v22) v20) v19))) v18) v17) : Int_SF (cons v13 v14) (cons v2 (cons v4 v5)) = IZR 0) v8 v11) v3) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P9	100	0.875567	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4) (v6 : v0 <> v1) => let v7 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7)) := v5 in (fun v8 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v4 v8)) => and_ind (fun (v9 : ordered_Rlist v3) (v10 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v10) (pos_Rl v3 (S v10))) (pos_Rl v4 v10))) => and_ind (fun (v11 : pos_Rl v3 0 = Rmin v0 v1) (v12 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v12) (pos_Rl v3 (S v12))) (pos_Rl v4 v12))) => and_ind (fun (v13 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v14 : Rlength v3 = S (Rlength v4) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v14) (pos_Rl v3 (S v14))) (pos_Rl v4 v14))) => and_ind (fun (v15 : Rlength v3 = S (Rlength v4)) (v16 : forall (v16 : @nat) (v17 : (v16 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v16) (pos_Rl v3 (S v16))) (pos_Rl v4 v16)) => Rlist_ind (fun v17 : @Rlist => forall (v18 : ordered_Rlist v17) (v19 : pos_Rl v17 0 = Rmin v0 v1) (v20 : pos_Rl v17 (Init.Nat.pred (Rlength v17)) = Rmax v0 v1) (v21 : Rlength v17 = S (Rlength v4)) (v22 : forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength v17))%nat), constant_D_eq v2 (open_interval (pos_Rl v17 v22) (pos_Rl v17 (S v22))) (pos_Rl v4 v22)), (2 <= Rlength v17)%nat) (fun (v17 : ordered_Rlist (@nil)) (v18 : pos_Rl (@nil) 0 = Rmin v0 v1) (v19 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v0 v1) (v20 : Rlength (@nil) = S (Rlength v4)) (v21 : forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v2 (open_interval (pos_Rl (@nil) v21) (pos_Rl (@nil) (S v21))) (pos_Rl v4 v21)) => let v22 : @False := eq_ind 0%nat (fun v22 : @nat => match v22 as v23 in nat return Prop with | 0%nat => @True | S v23 => (fun v23 : @nat => @False) v23 end) (@I) (S (Rlength v4)) v20 in False_ind (2 <= Rlength (@nil))%nat v22) (fun (v17 : @R) (v18 : @Rlist) (v19 : forall (v19 : ordered_Rlist v18) (v20 : pos_Rl v18 0 = Rmin v0 v1) (v21 : pos_Rl v18 (Init.Nat.pred (Rlength v18)) = Rmax v0 v1) (v22 : Rlength v18 = S (Rlength v4)) (v23 : forall (v23 : @nat) (v24 : (v23 < Init.Nat.pred (Rlength v18))%nat), constant_D_eq v2 (open_interval (pos_Rl v18 v23) (pos_Rl v18 (S v23))) (pos_Rl v4 v23)), (2 <= Rlength v18)%nat) (v20 : ordered_Rlist (cons v17 v18)) (v21 : pos_Rl (cons v17 v18) 0 = Rmin v0 v1) (v22 : pos_Rl (cons v17 v18) (Init.Nat.pred (Rlength (cons v17 v18))) = Rmax v0 v1) (v23 : Rlength (cons v17 v18) = S (Rlength v4)) (v24 : forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v17 v18)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 v18) v24) (pos_Rl (cons v17 v18) (S v24))) (pos_Rl v4 v24)) => Rlist_ind (fun v25 : @Rlist => forall (v26 : ordered_Rlist (cons v17 v25)) (v27 : pos_Rl (cons v17 v25) 0 = Rmin v0 v1) (v28 : pos_Rl (cons v17 v25) (Init.Nat.pred (Rlength (cons v17 v25))) = Rmax v0 v1) (v29 : Rlength (cons v17 v25) = S (Rlength v4)) (v30 : forall (v30 : @nat) (v31 : (v30 < Init.Nat.pred (Rlength (cons v17 v25)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 v25) v30) (pos_Rl (cons v17 v25) (S v30))) (pos_Rl v4 v30)) (v31 : forall (v31 : ordered_Rlist v25) (v32 : pos_Rl v25 0 = Rmin v0 v1) (v33 : pos_Rl v25 (Init.Nat.pred (Rlength v25)) = Rmax v0 v1) (v34 : Rlength v25 = S (Rlength v4)) (v35 : forall (v35 : @nat) (v36 : (v35 < Init.Nat.pred (Rlength v25))%nat), constant_D_eq v2 (open_interval (pos_Rl v25 v35) (pos_Rl v25 (S v35))) (pos_Rl v4 v35)), (2 <= Rlength v25)%nat), (2 <= Rlength (cons v17 v25))%nat) (fun (v25 : ordered_Rlist (cons v17 (@nil))) (v26 : pos_Rl (cons v17 (@nil)) 0 = Rmin v0 v1) (v27 : pos_Rl (cons v17 (@nil)) (Init.Nat.pred (Rlength (cons v17 (@nil)))) = Rmax v0 v1) (v28 : Rlength (cons v17 (@nil)) = S (Rlength v4)) (v29 : forall (v29 : @nat) (v30 : (v29 < Init.Nat.pred (Rlength (cons v17 (@nil))))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 (@nil)) v29) (pos_Rl (cons v17 (@nil)) (S v29))) (pos_Rl v4 v29)) (v30 : forall (v30 : ordered_Rlist (@nil)) (v31 : pos_Rl (@nil) 0 = Rmin v0 v1) (v32 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v0 v1) (v33 : Rlength (@nil) = S (Rlength v4)) (v34 : forall (v34 : @nat) (v35 : (v34 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v2 (open_interval (pos_Rl (@nil) v34) (pos_Rl (@nil) (S v34))) (pos_Rl v4 v34)), (2 <= Rlength (@nil))%nat) => ((match Rle_dec v0 v1 as v31 in ({_} + {_}) return (forall (v32 : v17 = match v31 as v32 in ({_} + {_}) return (@R) with | left v32 => (fun v32 : v0 <= v1 => v1) v32 | right v32 => (fun v32 : ~ v0 <= v1 => v0) v32 end) (v33 : v17 = match v31 as v33 in ({_} + {_}) return (@R) with | left v33 => (fun v33 : v0 <= v1 => v0) v33 | right v33 => (fun v33 : ~ v0 <= v1 => v1) v33 end), (2 <= Rlength (cons v17 (@nil)))%nat) with | left v31 => (fun (v31 : v0 <= v1) (v32 : v17 = v1) (v33 : v17 = v0) => False_ind (2 <= Rlength (cons v17 (@nil)))%nat (v6 (eq_ind v17 (fun v34 : @R => v0 = v34) (eq_ind v17 (fun v34 : @R => v34 = v17) eq_refl v0 v33) v1 v32))) v31 | right v31 => (fun (v31 : ~ v0 <= v1) (v32 : v17 = v0) (v33 : v17 = v1) => False_ind (2 <= Rlength (cons v17 (@nil)))%nat (v6 (eq_ind v17 (fun v34 : @R => v34 = v1) (eq_ind v17 (fun v34 : @R => v17 = v34) eq_refl v1 v33) v0 v32))) v31 end : forall (v31 : v17 = Rmax v0 v1) (v32 : v17 = match Rle_dec v0 v1 as v32 in ({_} + {_}) return (@R) with | left v32 => (fun v32 : v0 <= v1 => v0) v32 | right v32 => (fun v32 : ~ v0 <= v1 => v1) v32 end), (2 <= Rlength (cons v17 (@nil)))%nat) : forall (v31 : v17 = Rmax v0 v1) (v32 : v17 = Rmin v0 v1), (2 <= Rlength (cons v17 (@nil)))%nat) v27 v26) (fun (v25 : @R) (v26 : @Rlist) (v27 : forall (v27 : ordered_Rlist (cons v17 v26)) (v28 : pos_Rl (cons v17 v26) 0 = Rmin v0 v1) (v29 : pos_Rl (cons v17 v26) (Init.Nat.pred (Rlength (cons v17 v26))) = Rmax v0 v1) (v30 : Rlength (cons v17 v26) = S (Rlength v4)) (v31 : forall (v31 : @nat) (v32 : (v31 < Init.Nat.pred (Rlength (cons v17 v26)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 v26) v31) (pos_Rl (cons v17 v26) (S v31))) (pos_Rl v4 v31)) (v32 : forall (v32 : ordered_Rlist v26) (v33 : pos_Rl v26 0 = Rmin v0 v1) (v34 : pos_Rl v26 (Init.Nat.pred (Rlength v26)) = Rmax v0 v1) (v35 : Rlength v26 = S (Rlength v4)) (v36 : forall (v36 : @nat) (v37 : (v36 < Init.Nat.pred (Rlength v26))%nat), constant_D_eq v2 (open_interval (pos_Rl v26 v36) (pos_Rl v26 (S v36))) (pos_Rl v4 v36)), (2 <= Rlength v26)%nat), (2 <= Rlength (cons v17 v26))%nat) (v28 : ordered_Rlist (cons v17 (cons v25 v26))) (v29 : pos_Rl (cons v17 (cons v25 v26)) 0 = Rmin v0 v1) (v30 : pos_Rl (cons v17 (cons v25 v26)) (Init.Nat.pred (Rlength (cons v17 (cons v25 v26)))) = Rmax v0 v1) (v31 : Rlength (cons v17 (cons v25 v26)) = S (Rlength v4)) (v32 : forall (v32 : @nat) (v33 : (v32 < Init.Nat.pred (Rlength (cons v17 (cons v25 v26))))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v17 (cons v25 v26)) v32) (pos_Rl (cons v17 (cons v25 v26)) (S v32))) (pos_Rl v4 v32)) (v33 : forall (v33 : ordered_Rlist (cons v25 v26)) (v34 : pos_Rl (cons v25 v26) 0 = Rmin v0 v1) (v35 : pos_Rl (cons v25 v26) (Init.Nat.pred (Rlength (cons v25 v26))) = Rmax v0 v1) (v36 : Rlength (cons v25 v26) = S (Rlength v4)) (v37 : forall (v37 : @nat) (v38 : (v37 < Init.Nat.pred (Rlength (cons v25 v26)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v25 v26) v37) (pos_Rl (cons v25 v26) (S v37))) (pos_Rl v4 v37)), (2 <= Rlength (cons v25 v26))%nat) => le_n_S 1 (S (Rlength v26)) (le_n_S 0 (Rlength v26) (Nat.le_0_l (Rlength v26))) : (2 <= Rlength (cons v17 (cons v25 v26)))%nat) v18 v20 v21 v22 v23 v24 v19) v3 v9 v11 v13 v15 v16) v14) v12) v10) v8) v7)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P10	100	10.825915	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P11	100	3.390264	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P12	100	1.326431	1	1	0	synth with cache (only 1: refine (((fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : (ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v5) (pos_Rl v3 (S v5))) (pos_Rl v4 v5))) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v5 <> pos_Rl v4 (S v5) \/ v2 (pos_Rl v3 (S v5)) <> pos_Rl v4 v5) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v5 <> pos_Rl v3 (S v5))) => let v6 : (ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v6) (pos_Rl v3 (S v6))) (pos_Rl v4 v6))) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v6 <> pos_Rl v4 (S v6) \/ v2 (pos_Rl v3 (S v6)) <> pos_Rl v4 v6) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v6 <> pos_Rl v3 (S v6)) := v5 in (fun v7 : (ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7))) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v7 <> pos_Rl v4 (S v7) \/ v2 (pos_Rl v3 (S v7)) <> pos_Rl v4 v7) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v7 <> pos_Rl v3 (S v7)) => and_ind (fun (v8 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v4 v8))) (v9 : (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v9 <> pos_Rl v4 (S v9) \/ v2 (pos_Rl v3 (S v9)) <> pos_Rl v4 v9) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v9 <> pos_Rl v3 (S v9))) => and_ind (fun (v10 : ordered_Rlist v3) (v11 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v11) (pos_Rl v3 (S v11))) (pos_Rl v4 v11))) => and_ind (fun (v12 : pos_Rl v3 0 = Rmin v0 v1) (v13 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v13) (pos_Rl v3 (S v13))) (pos_Rl v4 v13))) => and_ind (fun (v14 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v15 : Rlength v3 = S (Rlength v4) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v4 v15))) => and_ind (fun (v16 : Rlength v3 = S (Rlength v4)) (v17 : forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v17) (pos_Rl v3 (S v17))) (pos_Rl v4 v17)) => and_ind (fun (v18 : forall (v18 : @nat) (v19 : (v18 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v18 <> pos_Rl v4 (S v18) \/ v2 (pos_Rl v3 (S v18)) <> pos_Rl v4 v18) (v19 : forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v19 <> pos_Rl v3 (S v19)) => conj (conj v10 (conj (eq_ind_r (fun v20 : @R => v20 = Rmin v1 v0) (match Rle_dec v0 v1 as v20 in ({_} + {_}) return (match v20 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v0 <= v1 => v0) v21 | right v21 => (fun v21 : ~ v0 <= v1 => v1) v21 end = match Rle_dec v1 v0 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v1 <= v0 => v1) v21 | right v21 => (fun v21 : ~ v1 <= v0 => v0) v21 end) with | left v20 => (fun v20 : v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v0 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v1) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v0) v22 end) with | left v21 => (fun v21 : v1 <= v0 => Rle_antisym v0 v1 v20 v21) v21 | right v21 => (fun v21 : ~ v1 <= v0 => eq_refl) v21 end) v20 | right v20 => (fun v20 : ~ v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v1 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v1) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v0) v22 end) with | left v21 => (fun v21 : v1 <= v0 => eq_refl) v21 | right v21 => (fun v21 : ~ v1 <= v0 => Rle_antisym v1 v0 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v20)) (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v21))) v21 end) v20 end : Rmin v0 v1 = Rmin v1 v0) v12) (conj (eq_ind_r (fun v20 : @R => v20 = Rmax v1 v0) (match Rle_dec v0 v1 as v20 in ({_} + {_}) return (match v20 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v0 <= v1 => v1) v21 | right v21 => (fun v21 : ~ v0 <= v1 => v0) v21 end = match Rle_dec v1 v0 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v1 <= v0 => v0) v21 | right v21 => (fun v21 : ~ v1 <= v0 => v1) v21 end) with | left v20 => (fun v20 : v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v1 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v0) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v1) v22 end) with | left v21 => (fun v21 : v1 <= v0 => Rle_antisym v1 v0 v21 v20) v21 | right v21 => (fun v21 : ~ v1 <= v0 => eq_refl) v21 end) v20 | right v20 => (fun v20 : ~ v0 <= v1 => match Rle_dec v1 v0 as v21 in ({_} + {_}) return (v0 = match v21 as v22 in ({_} + {_}) return (@R) with | left v22 => (fun v22 : v1 <= v0 => v0) v22 | right v22 => (fun v22 : ~ v1 <= v0 => v1) v22 end) with | left v21 => (fun v21 : v1 <= v0 => eq_refl) v21 | right v21 => (fun v21 : ~ v1 <= v0 => Rle_antisym v0 v1 (Rlt_le v0 v1 (Rnot_le_lt v1 v0 v21)) (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v20))) v21 end) v20 end : Rmax v0 v1 = Rmax v1 v0) v14) (conj v16 v17)))) (conj v18 v19)) v9) v15) v13) v11) v8) v7) v6) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4 /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v5 <> pos_Rl v4 (S v5) \/ v2 (pos_Rl v3 (S v5)) <> pos_Rl v4 v5) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v5 <> pos_Rl v3 (S v5))), adapted_couple v2 v1 v0 v3 v4 /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v4))%nat), pos_Rl v4 v6 <> pos_Rl v4 (S v6) \/ v2 (pos_Rl v3 (S v6)) <> pos_Rl v4 v6) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), pos_Rl v3 v6 <> pos_Rl v3 (S v6))) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple_opt v2 v0 v1 v3 v4), adapted_couple_opt v2 v1 v0 v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P13	100	0.186804	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 v3 v4 v5 v6 v7 : @R) (v8 v9 v10 v11 : @Rlist) (v12 : forall v12 : @R, @R) (v13 : v0 <> v1) (v14 : adapted_couple v12 v0 v1 (cons v2 (cons v3 v8)) (cons v4 v9)) (v15 : adapted_couple_opt v12 v0 v1 (cons v5 (cons v6 v10)) (cons v7 v11)) => let v16 : {v0 < v1} + {v0 = v1} + {v1 < v0} := total_order_T v0 v1 in match v16 as v17 in (_ + {_}) return (v3 <= v6) with | inleft v17 => (fun v17 : {v0 < v1} + {v0 = v1} => match v17 as v18 in ({_} + {_}) return (v3 <= v6) with | left v18 => (fun v18 : v0 < v1 => StepFun_P11 v18 v14 v15) v18 | right v18 => (fun v18 : v0 = v1 => False_ind (v3 <= v6) (v13 v18)) v18 end) v17 | inright v17 => (fun v17 : v1 < v0 => StepFun_P11 v17 (StepFun_P2 v14) (StepFun_P12 v15)) v17 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P14	100	8.444157	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P15	100	0.147026	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 v4 : @Rlist) (v5 v6 : @R) (v7 : adapted_couple v0 v5 v6 v1 v3) (v8 : adapted_couple_opt v0 v5 v6 v2 v4) => let v9 : {v5 <= v6} + {~ v5 <= v6} := Rle_dec v5 v6 in match v9 as v10 in ({_} + {_}) return (Int_SF v3 v1 = Int_SF v4 v2) with | left v10 => (fun v10 : v5 <= v6 => StepFun_P14 v10 v7 v8) v10 | right v10 => (fun v10 : ~ v5 <= v6 => let v11 : v6 <= v5 := Rlt_le v6 v5 (Rnot_le_lt v5 v6 v10) in StepFun_P14 v11 (StepFun_P2 v7) (StepFun_P12 v8)) v10 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P16	100	0.109403	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 : @Rlist) (v3 v4 : @R) (v5 : adapted_couple v0 v3 v4 v1 v2) => let v6 : {v3 <= v4} + {~ v3 <= v4} := Rle_dec v3 v4 in match v6 as v7 in ({_} + {_}) return (exists v8 v9 : @Rlist, adapted_couple_opt v0 v3 v4 v8 v9) with | left v7 => (fun v7 : v3 <= v4 => StepFun_P10 v7 v5) v7 | right v7 => (fun v7 : ~ v3 <= v4 => let v8 : v4 <= v3 := Rlt_le v4 v3 (Rnot_le_lt v3 v4 v7) in let v9 : exists v9 v10 : @Rlist, adapted_couple_opt v0 v4 v3 v9 v10 := StepFun_P10 v8 (StepFun_P2 v5) in ex_ind (fun (v10 : @Rlist) (v11 : exists v11 : @Rlist, adapted_couple_opt v0 v4 v3 v10 v11) => match v11 as v12 in (ex _) return (exists v13 v14 : @Rlist, adapted_couple_opt v0 v3 v4 v13 v14) with | ex_intro _ v12 v13 => (fun (v12 : @Rlist) (v13 : adapted_couple_opt v0 v4 v3 v10 v12) => ex_intro (fun v14 : @Rlist => exists v15 : @Rlist, adapted_couple_opt v0 v3 v4 v14 v15) v10 (ex_intro (fun v14 : @Rlist => adapted_couple_opt v0 v3 v4 v10 v14) v12 (StepFun_P12 v13))) v12 v13 end) v9) v7 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P17	100	0.096280	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 v4 : @Rlist) (v5 v6 : @R) (v7 : adapted_couple v0 v5 v6 v1 v3) (v8 : adapted_couple v0 v5 v6 v2 v4) => ex_ind (fun (v9 : @Rlist) (v10 : exists v10 : @Rlist, adapted_couple_opt v0 v5 v6 v9 v10) => match v10 as v11 in (ex _) return (Int_SF v3 v1 = Int_SF v4 v2) with | ex_intro _ v11 v12 => (fun (v11 : @Rlist) (v12 : adapted_couple_opt v0 v5 v6 v9 v11) => eq_ind_r (fun v13 : @R => v13 = Int_SF v4 v2) (eq_ind_r (fun v13 : @R => Int_SF v11 v9 = v13) eq_refl (StepFun_P15 v8 v12)) (StepFun_P15 v7 v12)) v11 v12 end) (StepFun_P16 v7))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P18	100	0.347363	1	1	0	synth with cache (only 1: refine (fun v0 v1 v2 : @R => match Rle_dec v0 v1 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 <= v1 => Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4 | right v4 => (fun v4 : ~ v0 <= v1 => - Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4 end = v2 * (v1 - v0)) with | left v3 => (fun v3 : v0 <= v1 => let v4 : Int_SF (cons v2 (@nil)) (cons v0 (cons v1 (@nil))) = Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) := StepFun_P17 (StepFun_P3 v2 v3) (StepFun_P1 {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) in eq_ind (Int_SF (cons v2 (@nil)) (cons v0 (cons v1 (@nil)))) (fun v5 : @R => v5 = v2 * (v1 - v0)) ((let v5 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v6 : list (@R) := (v2 :: v1 :: v0 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v6 v5 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (@I) (eq_refl : (let v7 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v5 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))))) = @true)) : Int_SF (cons v2 (@nil)) (cons v0 (cons v1 (@nil))) = v2 * (v1 - v0)) (Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4) v3 | right v3 => (fun v3 : ~ v0 <= v1 => let v4 : Int_SF (cons v2 (@nil)) (cons v1 (cons v0 (@nil))) = Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) := StepFun_P17 (StepFun_P2 (StepFun_P3 v2 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v3)))) (StepFun_P1 {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) in eq_ind (Int_SF (cons v2 (@nil)) (cons v1 (cons v0 (@nil)))) (fun v5 : @R => - v5 = v2 * (v1 - v0)) ((let v5 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v6 : list (@R) := (v2 :: v0 :: v1 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v6 v5 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z))) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 2))) (@I) (eq_refl : (let v7 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v5 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEc 0%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v7 (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 2))))) = @true)) : - Int_SF (cons v2 (@nil)) (cons v1 (cons v0 (@nil))) = v2 * (v1 - v0)) (Int_SF (subdivision_val {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |}) (subdivision {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |})) v4) v3 end : RiemannInt_SF {| fe := fct_cte v2; pre := StepFun_P4 v0 v1 v2 |} = v2 * (v1 - v0))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P19	100	0.516183	1	1	0	synth with cache (only 1: refine (fun (v0 : @Rlist) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 : @R) => Rlist_ind (fun v4 : @Rlist => Int_SF (FF v4 (fun v5 : @R => v1 v5 + v3 * v2 v5)) v4 = Int_SF (FF v4 v1) v4 + v3 * Int_SF (FF v4 v2) v4) ((let v4 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v5 : list (@R) := (v3 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v5 v4 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))) (@I) (eq_refl : (let v6 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))))) = @true)) : Int_SF (FF (@nil) (fun v4 : @R => v1 v4 + v3 * v2 v4)) (@nil) = Int_SF (FF (@nil) v1) (@nil) + v3 * Int_SF (FF (@nil) v2) (@nil)) (fun (v4 : @R) (v5 : @Rlist) (v6 : Int_SF (FF v5 (fun v6 : @R => v1 v6 + v3 * v2 v6)) v5 = Int_SF (FF v5 v1) v5 + v3 * Int_SF (FF v5 v2) v5) => Rlist_ind (fun v7 : @Rlist => forall v8 : Int_SF (FF v7 (fun v8 : @R => v1 v8 + v3 * v2 v8)) v7 = Int_SF (FF v7 v1) v7 + v3 * Int_SF (FF v7 v2) v7, Int_SF (FF (cons v4 v7) (fun v9 : @R => v1 v9 + v3 * v2 v9)) (cons v4 v7) = Int_SF (FF (cons v4 v7) v1) (cons v4 v7) + v3 * Int_SF (FF (cons v4 v7) v2) (cons v4 v7)) (fun v7 : Int_SF (FF (@nil) (fun v7 : @R => v1 v7 + v3 * v2 v7)) (@nil) = Int_SF (FF (@nil) v1) (@nil) + v3 * Int_SF (FF (@nil) v2) (@nil) => (let v8 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v9 : list (@R) := (v3 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v9 v8 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))) (@I) (eq_refl : (let v10 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v8 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v10 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEc 0%Z))))) = @true)) : Int_SF (FF (cons v4 (@nil)) (fun v8 : @R => v1 v8 + v3 * v2 v8)) (cons v4 (@nil)) = Int_SF (FF (cons v4 (@nil)) v1) (cons v4 (@nil)) + v3 * Int_SF (FF (cons v4 (@nil)) v2) (cons v4 (@nil))) (fun (v7 : @R) (v8 : @Rlist) (v9 : forall v9 : Int_SF (FF v8 (fun v9 : @R => v1 v9 + v3 * v2 v9)) v8 = Int_SF (FF v8 v1) v8 + v3 * Int_SF (FF v8 v2) v8, Int_SF (FF (cons v4 v8) (fun v10 : @R => v1 v10 + v3 * v2 v10)) (cons v4 v8) = Int_SF (FF (cons v4 v8) v1) (cons v4 v8) + v3 * Int_SF (FF (cons v4 v8) v2) (cons v4 v8)) (v10 : Int_SF (FF (cons v7 v8) (fun v10 : @R => v1 v10 + v3 * v2 v10)) (cons v7 v8) = Int_SF (FF (cons v7 v8) v1) (cons v7 v8) + v3 * Int_SF (FF (cons v7 v8) v2) (cons v7 v8)) => eq_ind_r (fun v11 : @R => (v1 ((v4 + v7) / IZR 2) + v3 * v2 ((v4 + v7) / IZR 2)) * (v7 - v4) + v11 = v1 ((v4 + v7) / IZR 2) * (v7 - v4) + Int_SF (app_Rlist (mid_Rlist v8 v7) v1) (cons v7 v8) + v3 * (v2 ((v4 + v7) / IZR 2) * (v7 - v4) + Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8))) (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v12 : list (@R) := (v1 ((v4 + v7) / IZR 2) :: v3 :: v2 ((v4 + v7) / IZR 2) :: v7 :: v4 :: Int_SF (app_Rlist (mid_Rlist v8 v7) v1) (cons v7 v8) :: Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v12 v11 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 7)))) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 7)))) (@I) (eq_refl : (let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 6) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 7))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEX (@Z) 7)))))) = @true)) v10 : Int_SF (FF (cons v4 (cons v7 v8)) (fun v11 : @R => v1 v11 + v3 * v2 v11)) (cons v4 (cons v7 v8)) = Int_SF (FF (cons v4 (cons v7 v8)) v1) (cons v4 (cons v7 v8)) + v3 * Int_SF (FF (cons v4 (cons v7 v8)) v2) (cons v4 (cons v7 v8))) v5 v6) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P20	100	0.079047	1	1	0	synth with cache (only 1: refine (fun (v0 : @Rlist) (v1 : forall v1 : @R, @R) (v2 : (0 < Rlength v0)%nat) => Rlist_ind (fun v3 : @Rlist => forall v4 : (0 < Rlength v3)%nat, Rlength v3 = S (Rlength (FF v3 v1))) (fun v3 : (0 < Rlength (@nil))%nat => False_ind (Rlength (@nil) = S (Rlength (FF (@nil) v1))) (Nat.lt_irrefl 0 v3)) (fun (v3 : @R) (v4 : @Rlist) (v5 : forall v5 : (0 < Rlength v4)%nat, Rlength v4 = S (Rlength (FF v4 v1))) (v6 : (0 < Rlength (cons v3 v4))%nat) => eq_ind_r (fun v7 : @nat => S (Rlength v4) = S v7) (eq_ind_r (fun v7 : @nat => S (Rlength v4) = S v7) eq_refl (RList_P14 v4 v3)) (RList_P18 (mid_Rlist v4 v3) v1) : Rlength (cons v3 v4) = S (Rlength (FF (cons v3 v4) v1))) v0 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P21	100	1.464339	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : @Rlist) (v4 : is_subdivision v2 v0 v1 v3) => match v4 as v5 in (sigT _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | existT _ v5 v6 => (fun (v5 : @Rlist) (v6 : adapted_couple v2 v0 v1 v3 v5) => match v6 as v7 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v7 v8 => (fun (v7 : ordered_Rlist v3) (v8 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v8 : @nat) (v9 : (v8 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v8) (pos_Rl v3 (S v8))) (pos_Rl v5 v8))) => match v8 as v9 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v9 v10 => (fun (v9 : pos_Rl v3 0 = Rmin v0 v1) (v10 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v5) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v10) (pos_Rl v3 (S v10))) (pos_Rl v5 v10))) => match v10 as v11 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v11 v12 => (fun (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v12 : Rlength v3 = S (Rlength v5) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v12) (pos_Rl v3 (S v12))) (pos_Rl v5 v12))) => match v12 as v13 in (_ /\ _) return (adapted_couple v2 v0 v1 v3 (FF v3 v2)) with | conj v13 v14 => (fun (v13 : Rlength v3 = S (Rlength v5)) (v14 : forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v14) (pos_Rl v3 (S v14))) (pos_Rl v5 v14)) => conj v7 (conj v9 (conj v11 (conj (StepFun_P20 v3 v2 (eq_ind_r (fun v15 : @nat => (0 < v15)%nat) (Nat.lt_0_succ (Rlength v5)) v13)) (fun (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat) => let v17 : constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v5 v15) := v14 v15 v16 in ((fun (v18 : @R) (v19 : pos_Rl v3 v15 < v18 < pos_Rl v3 (S v15)) => Rlist_ind (fun v20 : @Rlist => forall (v21 : ordered_Rlist v20) (v22 : pos_Rl v20 0 = Rmin v0 v1) (v23 : pos_Rl v20 (Init.Nat.pred (Rlength v20)) = Rmax v0 v1) (v24 : Rlength v20 = S (Rlength v5)) (v25 : forall (v25 : @nat) (v26 : (v25 < Init.Nat.pred (Rlength v20))%nat), constant_D_eq v2 (open_interval (pos_Rl v20 v25) (pos_Rl v20 (S v25))) (pos_Rl v5 v25)) (v26 : (v15 < Init.Nat.pred (Rlength v20))%nat) (v27 : forall (v27 : @R) (v28 : pos_Rl v20 v15 < v27 < pos_Rl v20 (S v15)), v2 v27 = pos_Rl v5 v15) (v28 : pos_Rl v20 v15 < v18 < pos_Rl v20 (S v15)), v2 v18 = pos_Rl (FF v20 v2) v15) (fun (v20 : ordered_Rlist (@nil)) (v21 : pos_Rl (@nil) 0 = Rmin v0 v1) (v22 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v0 v1) (v23 : Rlength (@nil) = S (Rlength v5)) (v24 : forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v2 (open_interval (pos_Rl (@nil) v24) (pos_Rl (@nil) (S v24))) (pos_Rl v5 v24)) (v25 : (v15 < Init.Nat.pred (Rlength (@nil)))%nat) (v26 : forall (v26 : @R) (v27 : pos_Rl (@nil) v15 < v26 < pos_Rl (@nil) (S v15)), v2 v26 = pos_Rl v5 v15) (v27 : pos_Rl (@nil) v15 < v18 < pos_Rl (@nil) (S v15)) => let v28 : @False := eq_ind (Rlength (@nil)) (fun v28 : @nat => match v28 as v29 in nat return Prop with | 0%nat => @True | S v29 => (fun v29 : @nat => @False) v29 end) (@I) (S (Rlength v5)) v23 in False_ind (v2 v18 = pos_Rl (FF (@nil) v2) v15) v28) (fun (v20 : @R) (v21 : @Rlist) (v22 : forall (v22 : ordered_Rlist v21) (v23 : pos_Rl v21 0 = Rmin v0 v1) (v24 : pos_Rl v21 (Init.Nat.pred (Rlength v21)) = Rmax v0 v1) (v25 : Rlength v21 = S (Rlength v5)) (v26 : forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength v21))%nat), constant_D_eq v2 (open_interval (pos_Rl v21 v26) (pos_Rl v21 (S v26))) (pos_Rl v5 v26)) (v27 : (v15 < Init.Nat.pred (Rlength v21))%nat) (v28 : forall (v28 : @R) (v29 : pos_Rl v21 v15 < v28 < pos_Rl v21 (S v15)), v2 v28 = pos_Rl v5 v15) (v29 : pos_Rl v21 v15 < v18 < pos_Rl v21 (S v15)), v2 v18 = pos_Rl (FF v21 v2) v15) (v23 : ordered_Rlist (cons v20 v21)) (v24 : pos_Rl (cons v20 v21) 0 = Rmin v0 v1) (v25 : pos_Rl (cons v20 v21) (Init.Nat.pred (Rlength (cons v20 v21))) = Rmax v0 v1) (v26 : Rlength (cons v20 v21) = S (Rlength v5)) (v27 : forall (v27 : @nat) (v28 : (v27 < Init.Nat.pred (Rlength (cons v20 v21)))%nat), constant_D_eq v2 (open_interval (pos_Rl (cons v20 v21) v27) (pos_Rl (cons v20 v21) (S v27))) (pos_Rl v5 v27)) (v28 : (v15 < Init.Nat.pred (Rlength (cons v20 v21)))%nat) (v29 : forall (v29 : @R) (v30 : pos_Rl (cons v20 v21) v15 < v29 < pos_Rl (cons v20 v21) (S v15)), v2 v29 = pos_Rl v5 v15) (v30 : pos_Rl (cons v20 v21) v15 < v18 < pos_Rl (cons v20 v21) (S v15)) => eq_ind_r (fun v31 : @R => v2 v18 = v31) (eq_ind_r (fun v31 : @R => v2 v18 = v2 v31) (eq_ind_r (fun v31 : @R => v31 = v2 ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2)) (eq_ind_r (fun v31 : @R => pos_Rl v5 v15 = v31) eq_refl (v29 ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) (conj (Rmult_lt_reg_l (IZR 2) (pos_Rl (cons v20 v21) v15) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < IZR 2 * v31) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < v31) (eq_ind (IZR 1) (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < v31 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (eq_ind_r (fun v31 : @R => IZR 2 * pos_Rl (cons v20 v21) v15 < v31) (eq_ind_r (fun v31 : @R => v31 < pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) (Rplus_lt_compat_l (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) (S v15)) (and_ind (fun (v31 : pos_Rl (cons v20 v21) v15 < v18) (v32 : v18 < pos_Rl (cons v20 v21) (S v15)) => Rlt_trans (pos_Rl (cons v20 v21) v15) v18 (pos_Rl (cons v20 v21) (S v15)) v31 v32) v30)) (double (pos_Rl (cons v20 v21) v15))) (Rmult_1_l (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v31 : 2%Z = 0%Z => let v32 : @False := eq_ind 2%Z (fun v32 : @Z => match v32 as v33 in Z return Prop with | 0%Z => @False | Z.pos v33 => (fun v33 : @positive => @True) v33 | Z.neg v33 => (fun v33 : @positive => @False) v33 end) (@I) 0%Z v31 in False_ind (@False) v32) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) : IZR 2 * pos_Rl (cons v20 v21) v15 < IZR 2 * ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2))) (Rmult_lt_reg_l (IZR 2) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) (pos_Rl (cons v20 v21) (S v15)) (Rplus_lt_0_compat (@R1) (@R1) (@Rlt_0_1) (@Rlt_0_1)) (eq_ind (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => IZR 2 * v31 < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind (IZR 2 * / IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) (fun v31 : @R => v31 < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind (IZR 1) (fun v31 : @R => v31 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind_r (fun v31 : @R => v31 < IZR 2 * pos_Rl (cons v20 v21) (S v15)) (eq_ind_r (fun v31 : @R => pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15) < v31) (eq_ind_r (fun v31 : @R => v31 < pos_Rl (cons v20 v21) (S v15) + pos_Rl (cons v20 v21) (S v15)) (Rplus_lt_compat_l (pos_Rl (cons v20 v21) (S v15)) (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) (S v15)) (and_ind (fun (v31 : pos_Rl (cons v20 v21) v15 < v18) (v32 : v18 < pos_Rl (cons v20 v21) (S v15)) => Rlt_trans (pos_Rl (cons v20 v21) v15) v18 (pos_Rl (cons v20 v21) (S v15)) v31 v32) v30)) (Rplus_comm (pos_Rl (cons v20 v21) v15) (pos_Rl (cons v20 v21) (S v15)))) (double (pos_Rl (cons v20 v21) (S v15)))) (Rmult_1_l (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (IZR 2 * / IZR 2) (Rinv_r_sym (IZR 2) (IZR_neq 2 0 ((fun v31 : 2%Z = 0%Z => let v32 : @False := eq_ind 2%Z (fun v32 : @Z => match v32 as v33 in Z return Prop with | 0%Z => @False | Z.pos v33 => (fun v33 : @positive => @True) v33 | Z.neg v33 => (fun v33 : @positive => @False) v33 end) (@I) 0%Z v31 in False_ind (@False) v32) : 2%Z <> 0%Z)))) (IZR 2 * (/ IZR 2 * (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) (Rmult_assoc (IZR 2) (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)))) ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) * / IZR 2) (Rmult_comm (/ IZR 2) (pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15))) : IZR 2 * ((pos_Rl (cons v20 v21) v15 + pos_Rl (cons v20 v21) (S v15)) / IZR 2) < IZR 2 * pos_Rl (cons v20 v21) (S v15)))))) (v29 v18 v30)) (RList_P13 (cons v20 v21) v15 v20 v28) : v2 v18 = v2 (pos_Rl (mid_Rlist v21 v20) v15)) (RList_P12 (mid_Rlist v21 v20) v15 v2 (eq_ind_r (fun v31 : @nat => (v15 < v31)%nat) v28 (RList_P14 v21 v20))) : v2 v18 = pos_Rl (FF (cons v20 v21) v2) v15) v3 v7 v9 v11 v13 v14 v16 v17 v19) : forall (v18 : @R) (v19 : open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15)) v18), v2 v18 = pos_Rl (FF v3 v2) v15) : constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl (FF v3 v2) v15)))))) v13 v14 end) v11 v12 end) v9 v10 end) v7 v8 end) v5 v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P22	100	6.262272	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P23	100	0.123796	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 : @Rlist) (v6 : is_subdivision v2 v0 v1 v4) (v7 : is_subdivision v3 v0 v1 v5) => match Rle_dec v0 v1 as v8 in ({_} + {_}) return (is_subdivision v2 v0 v1 (cons_ORlist v4 v5)) with | left v8 => (fun v8 : v0 <= v1 => StepFun_P22 v8 v6 v7) v8 | right v8 => (fun v8 : ~ v0 <= v1 => StepFun_P5 (StepFun_P22 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v8)) (StepFun_P5 v6) (StepFun_P5 v7))) v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P24	100	6.460651	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P25	100	0.128099	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 : @Rlist) (v6 : is_subdivision v2 v0 v1 v4) (v7 : is_subdivision v3 v0 v1 v5) => match Rle_dec v0 v1 as v8 in ({_} + {_}) return (is_subdivision v3 v0 v1 (cons_ORlist v4 v5)) with | left v8 => (fun v8 : v0 <= v1 => StepFun_P24 v8 v6 v7) v8 | right v8 => (fun v8 : ~ v0 <= v1 => StepFun_P5 (StepFun_P24 (Rlt_le v1 v0 (Rnot_le_lt v0 v1 v8)) (StepFun_P5 v6) (StepFun_P5 v7))) v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P26	100	2.188357	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P27	100	0.109020	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 : forall v3 : @R, @R) (v4 : forall v4 : @R, @R) (v5 v6 : @Rlist) (v7 : is_subdivision v3 v0 v1 v5) (v8 : is_subdivision v4 v0 v1 v6) => StepFun_P26 v2 (StepFun_P23 v7 v8) (StepFun_P25 v7 v8))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P28	100	0.111208	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 v4 : StepFun v0 v1) => (let v5 : IsStepFun v3 v0 v1 := pre v3 in let v6 : IsStepFun v4 v0 v1 := pre v4 in sigT_rect (fun v7 : {v7 : @Rlist & is_subdivision v3 v0 v1 v7} => {v8 : @Rlist & is_subdivision (fun v9 : @R => v3 v9 + v2 * v4 v9) v0 v1 v8}) (sigT_rect (fun v7 : {v7 : @Rlist & is_subdivision v4 v0 v1 v7} => forall (v8 : @Rlist) (v9 : is_subdivision v3 v0 v1 v8), {v10 : @Rlist & is_subdivision (fun v11 : @R => v3 v11 + v2 * v4 v11) v0 v1 v10}) (fun (v7 : @Rlist) (v8 : is_subdivision v4 v0 v1 v7) (v9 : @Rlist) (v10 : is_subdivision v3 v0 v1 v9) => existT (fun v11 : @Rlist => is_subdivision (fun v12 : @R => v3 v12 + v2 * v4 v12) v0 v1 v11) (cons_ORlist v9 v7) (StepFun_P27 v2 v10 v8)) v6) v5) : IsStepFun (fun v5 : @R => v3 v5 + v2 * v4 v5) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P29	100	0.071981	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => existT (fun v3 : @Rlist => adapted_couple v2 v0 v1 (subdivision v2) v3) (subdivision_val v2) (StepFun_P1 v2) : is_subdivision v2 v0 v1 (subdivision v2))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P30	100	1.236897	1	1	0	synth with cache (only 1: refine (fun (v0 v1 v2 : @R) (v3 v4 : StepFun v0 v1) => match Rle_dec v0 v1 as v5 in ({_} + {_}) return (match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6 | right v6 => (fun v6 : ~ v0 <= v1 => - Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6 end = match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => Int_SF (subdivision_val v3) (subdivision v3)) v6 | right v6 => (fun v6 : ~ v0 <= v1 => - Int_SF (subdivision_val v3) (subdivision v3)) v6 end + v2 * match v5 as v6 in ({_} + {_}) return (@R) with | left v6 => (fun v6 : v0 <= v1 => Int_SF (subdivision_val v4) (subdivision v4)) v6 | right v6 => (fun v6 : ~ v0 <= v1 => - Int_SF (subdivision_val v4) (subdivision v4)) v6 end) with | left v5 => (fun v5 : v0 <= v1 => let v6 : Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v6 : @R => v3 v6 + v2 * v4 v6)) (cons_ORlist (subdivision v3) (subdivision v4)) = Int_SF (subdivision_val {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) := StepFun_P17 (StepFun_P21 (StepFun_P27 v2 (StepFun_P29 v3) (StepFun_P29 v4))) (StepFun_P1 {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) in eq_ind (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v7 : @R => v3 v7 + v2 * v4 v7)) (cons_ORlist (subdivision v3) (subdivision v4))) (fun v7 : @R => v7 = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (eq_ind_r (fun v7 : @R => v7 = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (let v7 : Int_SF (subdivision_val v3) (subdivision v3) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v3) (StepFun_P21 (StepFun_P23 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v3) (subdivision v3)) (fun v8 : @R => v8 + v2 * Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4)) = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (let v8 : Int_SF (subdivision_val v4) (subdivision v4) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v4) (StepFun_P21 (StepFun_P25 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v4) (subdivision v4)) (fun v9 : @R => Int_SF (subdivision_val v3) (subdivision v3) + v2 * v9 = Int_SF (subdivision_val v3) (subdivision v3) + v2 * Int_SF (subdivision_val v4) (subdivision v4)) (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v10 : list (@R) := (Int_SF (subdivision_val v3) (subdivision v3) :: v2 :: Int_SF (subdivision_val v4) (subdivision v4) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))))) = @true)) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4))) v8) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4))) v7) (StepFun_P19 (cons_ORlist (subdivision v3) (subdivision v4)) v3 v4 v2)) (Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6) v5 | right v5 => (fun v5 : ~ v0 <= v1 => let v6 : Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v6 : @R => v3 v6 + v2 * v4 v6)) (cons_ORlist (subdivision v3) (subdivision v4)) = Int_SF (subdivision_val {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) := StepFun_P17 (StepFun_P21 (StepFun_P27 v2 (StepFun_P29 v3) (StepFun_P29 v4))) (StepFun_P1 {| fe := fun v6 : @R => v3 v6 + v2 * v4 v6; pre := StepFun_P28 v2 v3 v4 |}) in eq_ind (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) (fun v7 : @R => v3 v7 + v2 * v4 v7)) (cons_ORlist (subdivision v3) (subdivision v4))) (fun v7 : @R => - v7 = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (eq_ind_r (fun v7 : @R => - v7 = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (let v7 : Int_SF (subdivision_val v3) (subdivision v3) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v3) (StepFun_P21 (StepFun_P23 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v3) (subdivision v3)) (fun v8 : @R => - (v8 + v2 * Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4))) = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (let v8 : Int_SF (subdivision_val v4) (subdivision v4) = Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4)) := StepFun_P17 (StepFun_P1 v4) (StepFun_P21 (StepFun_P25 (StepFun_P29 v3) (StepFun_P29 v4))) in eq_ind (Int_SF (subdivision_val v4) (subdivision v4)) (fun v9 : @R => - (Int_SF (subdivision_val v3) (subdivision v3) + v2 * v9) = - Int_SF (subdivision_val v3) (subdivision v3) + v2 * - Int_SF (subdivision_val v4) (subdivision v4)) (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v10 : list (@R) := (Int_SF (subdivision_val v3) (subdivision v3) :: v2 :: Int_SF (subdivision_val v4) (subdivision v4) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3)))) (Ring_polynom.PEadd (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3)))) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEopp (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEadd (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 3)))))) = @true)) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v4) (cons_ORlist (subdivision v3) (subdivision v4))) v8) (Int_SF (FF (cons_ORlist (subdivision v3) (subdivision v4)) v3) (cons_ORlist (subdivision v3) (subdivision v4))) v7) (StepFun_P19 (cons_ORlist (subdivision v3) (subdivision v4)) v3 v4 v2)) (Int_SF (subdivision_val {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |}) (subdivision {| fe := fun v7 : @R => v3 v7 + v2 * v4 v7; pre := StepFun_P28 v2 v3 v4 |})) v6) v5 end : RiemannInt_SF {| fe := fun v5 : @R => v3 v5 + v2 * v4 v5; pre := StepFun_P28 v2 v3 v4 |} = RiemannInt_SF v3 + v2 * RiemannInt_SF v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P31	100	0.440848	1	1	0	synth with cache (only 1: refine ((fun (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v5 : @nat) (v6 : (v5 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v5) (pos_Rl v3 (S v5))) (pos_Rl v4 v5))) => let v6 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v6 : @nat) (v7 : (v6 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v6) (pos_Rl v3 (S v6))) (pos_Rl v4 v6)) := v5 in (fun v7 : ordered_Rlist v3 /\ pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v7 : @nat) (v8 : (v7 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v7) (pos_Rl v3 (S v7))) (pos_Rl v4 v7)) => and_ind (fun (v8 : ordered_Rlist v3) (v9 : pos_Rl v3 0 = Rmin v0 v1 /\ pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v9) (pos_Rl v3 (S v9))) (pos_Rl v4 v9))) => and_ind (fun (v10 : pos_Rl v3 0 = Rmin v0 v1) (v11 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1 /\ Rlength v3 = S (Rlength v4) /\ (forall (v11 : @nat) (v12 : (v11 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v11) (pos_Rl v3 (S v11))) (pos_Rl v4 v11))) => and_ind (fun (v12 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = Rmax v0 v1) (v13 : Rlength v3 = S (Rlength v4) /\ (forall (v13 : @nat) (v14 : (v13 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v13) (pos_Rl v3 (S v13))) (pos_Rl v4 v13))) => and_ind (fun (v14 : Rlength v3 = S (Rlength v4)) (v15 : forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v3))%nat), constant_D_eq v2 (open_interval (pos_Rl v3 v15) (pos_Rl v3 (S v15))) (pos_Rl v4 v15)) => conj v8 (conj v10 (conj v12 (conj (eq_sym (eq_ind_r (fun v16 : @nat => S (Rlength (app_Rlist v4 (@Rabs))) = v16) (eq_ind_r (fun v16 : @nat => S v16 = S (Rlength v4)) eq_refl (RList_P18 v4 (@Rabs))) v14)) (fun (v16 : @nat) (v17 : (v16 < Init.Nat.pred (Rlength v3))%nat) => ((fun (v18 : @R) (v19 : pos_Rl v3 v16 < v18 < pos_Rl v3 (S v16)) => eq_ind_r (fun v20 : @R => Rabs v20 = pos_Rl (app_Rlist v4 (@Rabs)) v16) (eq_ind_r (fun v20 : @R => Rabs (pos_Rl v4 v16) = v20) eq_refl (RList_P12 v4 v16 (@Rabs) (let v20 : (v16 < Init.Nat.pred (S (Rlength v4)))%nat := eq_ind (Rlength v3) (fun v20 : @nat => (v16 < Init.Nat.pred v20)%nat) v17 (S (Rlength v4)) v14 in v20))) (v15 v16 v17 v18 v19)) : forall (v18 : @R) (v19 : open_interval (pos_Rl v3 v16) (pos_Rl v3 (S v16)) v18), Rabs (v2 v18) = pos_Rl (app_Rlist v4 (@Rabs)) v16) : constant_D_eq (fun v18 : @R => Rabs (v2 v18)) (open_interval (pos_Rl v3 v16) (pos_Rl v3 (S v16))) (pos_Rl (app_Rlist v4 (@Rabs)) v16)))))) v13) v11) v9) v7) v6) : forall (v0 v1 : @R) (v2 : forall v2 : @R, @R) (v3 v4 : @Rlist) (v5 : adapted_couple v2 v0 v1 v3 v4), adapted_couple (fun v6 : @R => Rabs (v2 v6)) v0 v1 v3 (app_Rlist v4 (@Rabs)))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P32	100	0.072546	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => existT (fun v3 : @Rlist => is_subdivision (fun v4 : @R => Rabs (v2 v4)) v0 v1 v3) (subdivision v2) (existT (fun v3 : @Rlist => adapted_couple (fun v4 : @R => Rabs (v2 v4)) v0 v1 (subdivision v2) v3) (app_Rlist (subdivision_val v2) (@Rabs)) (StepFun_P31 (StepFun_P1 v2)) : is_subdivision (fun v3 : @R => Rabs (v2 v3)) v0 v1 (subdivision v2)) : IsStepFun (fun v3 : @R => Rabs (v2 v3)) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P33	100	0.491856	1	1	0	synth with cache (only 1: refine (fun v0 : @Rlist => Rlist_ind (fun v1 : @Rlist => forall (v2 : @Rlist) (v3 : ordered_Rlist v2), Rabs (Int_SF v1 v2) <= Int_SF (app_Rlist v1 (@Rabs)) v2) (fun (v1 : @Rlist) (v2 : ordered_Rlist v1) => eq_ind_r (fun v3 : @R => v3 <= IZR 0) (or_intror eq_refl) (@Rabs_R0) : Rabs (Int_SF (@nil) v1) <= Int_SF (app_Rlist (@nil) (@Rabs)) v1) (fun (v1 : @R) (v2 : @Rlist) (v3 : forall (v3 : @Rlist) (v4 : ordered_Rlist v3), Rabs (Int_SF v2 v3) <= Int_SF (app_Rlist v2 (@Rabs)) v3) (v4 : @Rlist) (v5 : ordered_Rlist v4) => Rlist_ind (fun v6 : @Rlist => forall v7 : ordered_Rlist v6, Rabs match v6 as v8 in Rlist return (@R) with | nil => IZR 0 | cons v8 v9 => (fun (v8 : @R) (v9 : @Rlist) => match v9 as v10 in Rlist return (@R) with | nil => IZR 0 | cons v10 v11 => (fun (v10 : @R) (v11 : @Rlist) => v1 * (v10 - v8) + Int_SF v2 (cons v10 v11)) v10 v11 end) v8 v9 end <= match v6 as v8 in Rlist return (@R) with | nil => IZR 0 | cons v8 v9 => (fun (v8 : @R) (v9 : @Rlist) => match v9 as v10 in Rlist return (@R) with | nil => IZR 0 | cons v10 v11 => (fun (v10 : @R) (v11 : @Rlist) => Rabs v1 * (v10 - v8) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) v10 v11 end) v8 v9 end) (fun v6 : ordered_Rlist (@nil) => eq_ind_r (fun v7 : @R => v7 <= IZR 0) (or_intror eq_refl) (@Rabs_R0)) (fun (v6 : @R) (v7 : @Rlist) (v8 : forall v8 : ordered_Rlist v7, Rabs match v7 as v9 in Rlist return (@R) with | nil => IZR 0 | cons v9 v10 => (fun (v9 : @R) (v10 : @Rlist) => match v10 as v11 in Rlist return (@R) with | nil => IZR 0 | cons v11 v12 => (fun (v11 : @R) (v12 : @Rlist) => v1 * (v11 - v9) + Int_SF v2 (cons v11 v12)) v11 v12 end) v9 v10 end <= match v7 as v9 in Rlist return (@R) with | nil => IZR 0 | cons v9 v10 => (fun (v9 : @R) (v10 : @Rlist) => match v10 as v11 in Rlist return (@R) with | nil => IZR 0 | cons v11 v12 => (fun (v11 : @R) (v12 : @Rlist) => Rabs v1 * (v11 - v9) + Int_SF (app_Rlist v2 (@Rabs)) (cons v11 v12)) v11 v12 end) v9 v10 end) (v9 : ordered_Rlist (cons v6 v7)) => Rlist_ind (fun v10 : @Rlist => forall (v11 : ordered_Rlist (cons v6 v10)) (v12 : forall v12 : ordered_Rlist v10, Rabs match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => match v14 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => v1 * (v15 - v13) + Int_SF v2 (cons v15 v16)) v15 v16 end) v13 v14 end <= match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => match v14 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => Rabs v1 * (v15 - v13) + Int_SF (app_Rlist v2 (@Rabs)) (cons v15 v16)) v15 v16 end) v13 v14 end), Rabs match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => v1 * (v13 - v6) + Int_SF v2 (cons v13 v14)) v13 v14 end <= match v10 as v13 in Rlist return (@R) with | nil => IZR 0 | cons v13 v14 => (fun (v13 : @R) (v14 : @Rlist) => Rabs v1 * (v13 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v13 v14)) v13 v14 end) (fun (v10 : ordered_Rlist (cons v6 (@nil))) (v11 : forall v11 : ordered_Rlist (@nil), Rabs (IZR 0) <= IZR 0) => eq_ind_r (fun v12 : @R => v12 <= IZR 0) (or_intror eq_refl) (@Rabs_R0)) (fun (v10 : @R) (v11 : @Rlist) (v12 : forall (v12 : ordered_Rlist (cons v6 v11)) (v13 : forall v13 : ordered_Rlist v11, Rabs match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => match v15 as v16 in Rlist return (@R) with | nil => IZR 0 | cons v16 v17 => (fun (v16 : @R) (v17 : @Rlist) => v1 * (v16 - v14) + Int_SF v2 (cons v16 v17)) v16 v17 end) v14 v15 end <= match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => match v15 as v16 in Rlist return (@R) with | nil => IZR 0 | cons v16 v17 => (fun (v16 : @R) (v17 : @Rlist) => Rabs v1 * (v16 - v14) + Int_SF (app_Rlist v2 (@Rabs)) (cons v16 v17)) v16 v17 end) v14 v15 end), Rabs match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => v1 * (v14 - v6) + Int_SF v2 (cons v14 v15)) v14 v15 end <= match v11 as v14 in Rlist return (@R) with | nil => IZR 0 | cons v14 v15 => (fun (v14 : @R) (v15 : @Rlist) => Rabs v1 * (v14 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v14 v15)) v14 v15 end) (v13 : ordered_Rlist (cons v6 (cons v10 v11))) (v14 : forall v14 : ordered_Rlist (cons v10 v11), Rabs match v11 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => v1 * (v15 - v10) + Int_SF v2 (cons v15 v16)) v15 v16 end <= match v11 as v15 in Rlist return (@R) with | nil => IZR 0 | cons v15 v16 => (fun (v15 : @R) (v16 : @Rlist) => Rabs v1 * (v15 - v10) + Int_SF (app_Rlist v2 (@Rabs)) (cons v15 v16)) v15 v16 end) => Rle_trans (Rabs (v1 * (v10 - v6) + Int_SF v2 (cons v10 v11))) (Rabs (v1 * (v10 - v6)) + Rabs (Int_SF v2 (cons v10 v11))) (Rabs v1 * (v10 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (Rabs_triang (v1 * (v10 - v6)) (Int_SF v2 (cons v10 v11))) (eq_ind_r (fun v15 : @R => v15 + Rabs (Int_SF v2 (cons v10 v11)) <= Rabs v1 * (v10 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (eq_ind_r (fun v15 : @R => Rabs v1 * v15 + Rabs (Int_SF v2 (cons v10 v11)) <= Rabs v1 * (v10 - v6) + Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (Rplus_le_compat_l (Rabs v1 * (v10 - v6)) (Rabs (Int_SF v2 (cons v10 v11))) (Int_SF (app_Rlist v2 (@Rabs)) (cons v10 v11)) (v3 (cons v10 v11) (RList_P4 (cons v10 v11) v6 v13))) (Rabs_right (v10 - v6) (Rge_minus v10 v6 (Rle_ge v6 v10 (v13 0%nat (Nat.lt_0_succ (Rlength v11) : (0 < Init.Nat.pred (Rlength (cons v6 (cons v10 v11))))%nat)))))) (Rabs_mult v1 (v10 - v6)))) v7 v9 v8) v4 v5 : Rabs (Int_SF (cons v1 v2) v4) <= Int_SF (app_Rlist (cons v1 v2) (@Rabs)) v4) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P34	100	0.433490	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) (v3 : v0 <= v1) => decide_left (Rle_dec v0 v1) v3 (fun v4 : {v0 <= v1} + {~ v0 <= v1} => Rabs match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => Int_SF (subdivision_val v2) (subdivision v2)) v5 | right v5 => (fun v5 : ~ v0 <= v1 => - Int_SF (subdivision_val v2) (subdivision v2)) v5 end <= match v4 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v0 <= v1 => Int_SF (subdivision_val {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |})) v5 | right v5 => (fun v5 : ~ v0 <= v1 => - Int_SF (subdivision_val {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |})) v5 end) (fun v4 : v0 <= v1 => let v5 : Int_SF (app_Rlist (subdivision_val v2) (@Rabs)) (subdivision v2) = Int_SF (subdivision_val {| fe := fun v5 : @R => Rabs (v2 v5); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v5 : @R => Rabs (v2 v5); pre := StepFun_P32 v2 |}) := StepFun_P17 (StepFun_P31 (StepFun_P1 v2)) (StepFun_P1 {| fe := fun v5 : @R => Rabs (v2 v5); pre := StepFun_P32 v2 |}) in eq_ind (Int_SF (app_Rlist (subdivision_val v2) (@Rabs)) (subdivision v2)) (fun v6 : @R => Rabs (Int_SF (subdivision_val v2) (subdivision v2)) <= v6) (StepFun_P33 (subdivision_val v2) (let v6 : is_subdivision v2 v0 v1 (subdivision v2) := StepFun_P29 v2 in sigT_ind (fun v7 : {v7 : @Rlist & adapted_couple v2 v0 v1 (subdivision v2) v7} => ordered_Rlist (subdivision v2)) (fun (v7 : @Rlist) (v8 : adapted_couple v2 v0 v1 (subdivision v2) v7) => let v9 : ordered_Rlist (subdivision v2) /\ pos_Rl (subdivision v2) 0 = Rmin v0 v1 /\ pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v9 : @nat) (v10 : (v9 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v9) (pos_Rl (subdivision v2) (S v9))) (pos_Rl v7 v9)) := v8 in (fun v10 : ordered_Rlist (subdivision v2) /\ pos_Rl (subdivision v2) 0 = Rmin v0 v1 /\ pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v10 : @nat) (v11 : (v10 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v10) (pos_Rl (subdivision v2) (S v10))) (pos_Rl v7 v10)) => and_ind (fun (v11 : ordered_Rlist (subdivision v2)) (v12 : pos_Rl (subdivision v2) 0 = Rmin v0 v1 /\ pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v12 : @nat) (v13 : (v12 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v12) (pos_Rl (subdivision v2) (S v12))) (pos_Rl v7 v12))) => and_ind (fun (v13 : pos_Rl (subdivision v2) 0 = Rmin v0 v1) (v14 : pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1 /\ Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v14) (pos_Rl (subdivision v2) (S v14))) (pos_Rl v7 v14))) => and_ind (fun (v15 : pos_Rl (subdivision v2) (Init.Nat.pred (Rlength (subdivision v2))) = Rmax v0 v1) (v16 : Rlength (subdivision v2) = S (Rlength v7) /\ (forall (v16 : @nat) (v17 : (v16 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v16) (pos_Rl (subdivision v2) (S v16))) (pos_Rl v7 v16))) => and_ind (fun (v17 : Rlength (subdivision v2) = S (Rlength v7)) (v18 : forall (v18 : @nat) (v19 : (v18 < Init.Nat.pred (Rlength (subdivision v2)))%nat), constant_D_eq v2 (open_interval (pos_Rl (subdivision v2) v18) (pos_Rl (subdivision v2) (S v18))) (pos_Rl v7 v18)) => v11) v16) v14) v12) v10) v9) v6)) (Int_SF (subdivision_val {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |}) (subdivision {| fe := fun v6 : @R => Rabs (v2 v6); pre := StepFun_P32 v2 |})) v5) : Rabs (RiemannInt_SF v2) <= RiemannInt_SF {| fe := fun v4 : @R => Rabs (v2 v4); pre := StepFun_P32 v2 |})).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P35	100	1.007761	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P36	100	0.450368	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 v3 : StepFun v0 v1) (v4 : @Rlist) (v5 : v0 <= v1) (v6 : is_subdivision v2 v0 v1 v4) (v7 : is_subdivision v3 v0 v1 v4) (v8 : forall (v8 : @R) (v9 : v0 < v8 < v1), v2 v8 <= v3 v8) => decide_left (Rle_dec v0 v1) v5 (fun v9 : {v0 <= v1} + {~ v0 <= v1} => match v9 as v10 in ({_} + {_}) return (@R) with | left v10 => (fun v10 : v0 <= v1 => Int_SF (subdivision_val v2) (subdivision v2)) v10 | right v10 => (fun v10 : ~ v0 <= v1 => - Int_SF (subdivision_val v2) (subdivision v2)) v10 end <= match v9 as v10 in ({_} + {_}) return (@R) with | left v10 => (fun v10 : v0 <= v1 => Int_SF (subdivision_val v3) (subdivision v3)) v10 | right v10 => (fun v10 : ~ v0 <= v1 => - Int_SF (subdivision_val v3) (subdivision v3)) v10 end) (fun v9 : v0 <= v1 => let v10 : Int_SF (FF v4 v2) v4 = Int_SF (subdivision_val v2) (subdivision v2) := StepFun_P17 (StepFun_P21 v6) (StepFun_P1 v2) in eq_ind (Int_SF (FF v4 v2) v4) (fun v11 : @R => v11 <= Int_SF (subdivision_val v3) (subdivision v3)) (let v11 : Int_SF (FF v4 v3) v4 = Int_SF (subdivision_val v3) (subdivision v3) := StepFun_P17 (StepFun_P21 v7) (StepFun_P1 v3) in eq_ind (Int_SF (FF v4 v3) v4) (fun v12 : @R => Int_SF (FF v4 v2) v4 <= v12) (sigT_ind (fun v12 : {v12 : @Rlist & adapted_couple v2 v0 v1 v4 v12} => Int_SF (FF v4 v2) v4 <= Int_SF (FF v4 v3) v4) (fun (v12 : @Rlist) (v13 : adapted_couple v2 v0 v1 v4 v12) => let v14 : ordered_Rlist v4 /\ pos_Rl v4 0 = Rmin v0 v1 /\ pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v14 : @nat) (v15 : (v14 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v14) (pos_Rl v4 (S v14))) (pos_Rl v12 v14)) := v13 in (fun v15 : ordered_Rlist v4 /\ pos_Rl v4 0 = Rmin v0 v1 /\ pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v15 : @nat) (v16 : (v15 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v15) (pos_Rl v4 (S v15))) (pos_Rl v12 v15)) => and_ind (fun (v16 : ordered_Rlist v4) (v17 : pos_Rl v4 0 = Rmin v0 v1 /\ pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v17 : @nat) (v18 : (v17 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v17) (pos_Rl v4 (S v17))) (pos_Rl v12 v17))) => and_ind (fun (v18 : pos_Rl v4 0 = Rmin v0 v1) (v19 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1 /\ Rlength v4 = S (Rlength v12) /\ (forall (v19 : @nat) (v20 : (v19 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v19) (pos_Rl v4 (S v19))) (pos_Rl v12 v19))) => and_ind (fun (v20 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = Rmax v0 v1) (v21 : Rlength v4 = S (Rlength v12) /\ (forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v21) (pos_Rl v4 (S v21))) (pos_Rl v12 v21))) => and_ind (fun (v22 : Rlength v4 = S (Rlength v12)) (v23 : forall (v23 : @nat) (v24 : (v23 < Init.Nat.pred (Rlength v4))%nat), constant_D_eq v2 (open_interval (pos_Rl v4 v23) (pos_Rl v4 (S v23))) (pos_Rl v12 v23)) => let v24 : Rmin v0 v1 = v0 := decide_left (Rle_dec v0 v1) v9 (fun v24 : {v0 <= v1} + {~ v0 <= v1} => match v24 as v25 in ({_} + {_}) return (@R) with | left v25 => (fun v25 : v0 <= v1 => v0) v25 | right v25 => (fun v25 : ~ v0 <= v1 => v1) v25 end = v0) (fun v24 : v0 <= v1 => eq_refl) : Rmin v0 v1 = v0 in let v25 : Rmax v0 v1 = v1 := decide_left (Rle_dec v0 v1) v9 (fun v25 : {v0 <= v1} + {~ v0 <= v1} => match v25 as v26 in ({_} + {_}) return (@R) with | left v26 => (fun v26 : v0 <= v1 => v1) v26 | right v26 => (fun v26 : ~ v0 <= v1 => v0) v26 end = v1) (fun v25 : v0 <= v1 => eq_refl) : Rmax v0 v1 = v1 in let v26 : pos_Rl v4 0 = v0 := eq_ind (Rmin v0 v1) (fun v26 : @R => pos_Rl v4 0 = v26) v18 v0 v24 in let v27 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = v1 := eq_ind (Rmax v0 v1) (fun v27 : @R => pos_Rl v4 (Init.Nat.pred (Rlength v4)) = v27) v20 v1 v25 in StepFun_P35 v2 v3 v16 v26 v27 v8) v21) v19) v17) v15) v14) v6) (Int_SF (subdivision_val v3) (subdivision v3)) v11) (Int_SF (subdivision_val v2) (subdivision v2)) v10) : RiemannInt_SF v2 <= RiemannInt_SF v3)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P37	100	0.087676	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 v3 : StepFun v0 v1) (v4 : v0 <= v1) (v5 : forall (v5 : @R) (v6 : v0 < v5 < v1), v2 v5 <= v3 v5) => StepFun_P36 v2 v3 v4 (StepFun_P25 (StepFun_P29 v3) (StepFun_P29 v2)) (StepFun_P23 (StepFun_P29 v3) (StepFun_P29 v2)) v5)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P38	100	2.828173	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P39	100	0.890603	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : StepFun v0 v1) => match Rle_dec v0 v1 as v3 in ({_} + {_}) return (match v3 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v0 <= v1 => Int_SF (subdivision_val v2) (subdivision v2)) v4 | right v4 => (fun v4 : ~ v0 <= v1 => - Int_SF (subdivision_val v2) (subdivision v2)) v4 end = - match Rle_dec v1 v0 as v4 in ({_} + {_}) return (@R) with | left v4 => (fun v4 : v1 <= v0 => Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v4 | right v4 => (fun v4 : ~ v1 <= v0 => - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v4 end) with | left v3 => match Rle_dec v1 v0 as v3 in ({_} + {_}) return (forall v4 : v0 <= v1, Int_SF (subdivision_val v2) (subdivision v2) = - match v3 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v0 => Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 | right v5 => (fun v5 : ~ v1 <= v0 => - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 end) with | left v3 => (fun (v3 : v1 <= v0) (v4 : v0 <= v1) => let v5 : adapted_couple v2 v0 v1 (subdivision v2) (subdivision_val v2) := StepFun_P1 v2 in let v6 : adapted_couple {| fe := v2; pre := StepFun_P6 (pre v2) |} v1 v0 (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) := StepFun_P1 {| fe := v2; pre := StepFun_P6 (pre v2) |} in let v7 : v0 = v1 := Rle_antisym v0 v1 v4 v3 in eq_ind_r (fun v8 : @R => v8 = - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) (let v8 : v1 = v0 := eq_sym v7 in eq_ind_r (fun v9 : @R => IZR 0 = - v9) (let v9 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v10 : list (@R) := Datatypes.nil in RField_ring_lemma1 (@ring_subst_niter) v10 v9 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEopp (Ring_polynom.PEc 0%Z)) (@I) (eq_refl : (let v11 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v9 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v11 (Ring_polynom.PEopp (Ring_polynom.PEc 0%Z)))) = @true)) (StepFun_P8 v6 v8)) (StepFun_P8 v5 v7)) v3 | right v3 => (fun (v3 : ~ v1 <= v0) (v4 : v0 <= v1) => eq_ind_r (fun v5 : @R => Int_SF (subdivision_val v2) (subdivision v2) = v5) (StepFun_P17 (StepFun_P1 v2) (StepFun_P2 (let v5 : IsStepFun v2 v1 v0 := StepFun_P6 (pre v2) in sigT_ind (fun v6 : {v6 : @Rlist & is_subdivision v2 v1 v0 v6} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := v6 |}) (subdivision_val {| fe := v2; pre := v6 |})) (fun (v6 : @Rlist) (v7 : is_subdivision v2 v1 v0 v6) => sigT_ind (fun v8 : {v8 : @Rlist & adapted_couple v2 v1 v0 v6 v8} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |}) (subdivision_val {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |})) (fun (v8 : @Rlist) (v9 : adapted_couple v2 v1 v0 v6 v8) => v9) v7 : adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |}) (subdivision_val {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |})) v5))) (Ropp_involutive (Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})))) v3 end v3 | right v3 => match Rle_dec v1 v0 as v3 in ({_} + {_}) return (forall v4 : ~ v0 <= v1, - Int_SF (subdivision_val v2) (subdivision v2) = - match v3 as v5 in ({_} + {_}) return (@R) with | left v5 => (fun v5 : v1 <= v0 => Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 | right v5 => (fun v5 : ~ v1 <= v0 => - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) v5 end) with | left v3 => (fun (v3 : v1 <= v0) (v4 : ~ v0 <= v1) => Ropp_eq_compat (Int_SF (subdivision_val v2) (subdivision v2)) (Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) (StepFun_P17 (StepFun_P1 v2) (StepFun_P2 (let v5 : IsStepFun v2 v1 v0 := StepFun_P6 (pre v2) in sigT_ind (fun v6 : {v6 : @Rlist & is_subdivision v2 v1 v0 v6} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := v6 |}) (subdivision_val {| fe := v2; pre := v6 |})) (fun (v6 : @Rlist) (v7 : is_subdivision v2 v1 v0 v6) => sigT_ind (fun v8 : {v8 : @Rlist & adapted_couple v2 v1 v0 v6 v8} => adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |}) (subdivision_val {| fe := v2; pre := existT (fun v9 : @Rlist => {v10 : @Rlist & adapted_couple v2 v1 v0 v9 v10}) v6 v8 |})) (fun (v8 : @Rlist) (v9 : adapted_couple v2 v1 v0 v6 v8) => v9) v7 : adapted_couple v2 v1 v0 (subdivision {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |}) (subdivision_val {| fe := v2; pre := existT (fun v8 : @Rlist => is_subdivision v2 v1 v0 v8) v6 v7 |})) v5)))) v3 | right v3 => (fun (v3 : ~ v1 <= v0) (v4 : ~ v0 <= v1) => let v5 : v0 < v1 := Rnot_le_lt v1 v0 v3 in let v6 : v1 < v0 := Rnot_le_lt v0 v1 v4 in False_ind (- Int_SF (subdivision_val v2) (subdivision v2) = - - Int_SF (subdivision_val {| fe := v2; pre := StepFun_P6 (pre v2) |}) (subdivision {| fe := v2; pre := StepFun_P6 (pre v2) |})) (Rlt_irrefl v0 (Rlt_trans v0 v1 v0 v5 v6))) v3 end v3 end : RiemannInt_SF v2 = - RiemannInt_SF {| fe := v2; pre := StepFun_P6 (pre v2) |})).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P40	100	5.156192	0	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P41	100	0.197720	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : v1 <= v2) (v5 : v2 <= v3) (v6 : IsStepFun v0 v1 v2) => match v6 as v7 in (sigT _) return (forall v8 : IsStepFun v0 v2 v3, IsStepFun v0 v1 v3) with | existT _ v7 v8 => (fun (v7 : @Rlist) (v8 : is_subdivision v0 v1 v2 v7) => match v8 as v9 in (sigT _) return (forall v10 : IsStepFun v0 v2 v3, IsStepFun v0 v1 v3) with | existT _ v9 v10 => (fun (v9 : @Rlist) (v10 : adapted_couple v0 v1 v2 v7 v9) (v11 : IsStepFun v0 v2 v3) => match v11 as v12 in (sigT _) return (IsStepFun v0 v1 v3) with | existT _ v12 v13 => (fun (v12 : @Rlist) (v13 : is_subdivision v0 v2 v3 v12) => match v13 as v14 in (sigT _) return (IsStepFun v0 v1 v3) with | existT _ v14 v15 => (fun (v14 : @Rlist) (v15 : adapted_couple v0 v2 v3 v12 v14) => let v16 : {v1 < v2} + {v1 = v2} + {v2 < v1} := total_order_T v1 v2 in match v16 as v17 in (_ + {_}) return (IsStepFun v0 v1 v3) with | inleft v17 => (fun v17 : {v1 < v2} + {v1 = v2} => match v17 as v18 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v18 => (fun v18 : v1 < v2 => let v19 : {v2 < v3} + {v2 = v3} + {v3 < v2} := total_order_T v2 v3 in match v19 as v20 in (_ + {_}) return (IsStepFun v0 v1 v3) with | inleft v20 => (fun v20 : {v2 < v3} + {v2 = v3} => match v20 as v21 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v21 => (fun v21 : v2 < v3 => existT (fun v22 : @Rlist => is_subdivision v0 v1 v3 v22) (cons_Rlist v7 v12) (existT (fun v22 : @Rlist => adapted_couple v0 v1 v3 (cons_Rlist v7 v12) v22) (FF (cons_Rlist v7 v12) v0) (StepFun_P40 v18 v21 v10 v15))) v21 | right v21 => (fun v21 : v2 = v3 => existT (fun v22 : @Rlist => is_subdivision v0 v1 v3 v22) v7 (existT (fun v22 : @Rlist => adapted_couple v0 v1 v3 v7 v22) v9 (let v22 : adapted_couple v0 v1 v3 v7 v9 := eq_ind v2 (fun v22 : @R => adapted_couple v0 v1 v22 v7 v9) v10 v3 v21 in v22))) v21 end) v20 | inright v20 => (fun v20 : v3 < v2 => False_rect (IsStepFun v0 v1 v3) (Rlt_irrefl v2 (Rle_lt_trans v2 v3 v2 v5 v20))) v20 end) v18 | right v18 => (fun v18 : v1 = v2 => existT (fun v19 : @Rlist => is_subdivision v0 v1 v3 v19) v12 (existT (fun v19 : @Rlist => adapted_couple v0 v1 v3 v12 v19) v14 (let v19 : adapted_couple v0 v1 v3 v12 v14 := eq_ind_r (fun v19 : @R => adapted_couple v0 v19 v3 v12 v14) v15 v18 in v19))) v18 end) v17 | inright v17 => (fun v17 : v2 < v1 => False_rect (IsStepFun v0 v1 v3) (Rlt_irrefl v1 (Rle_lt_trans v1 v2 v1 v4 v17))) v17 end) v14 v15 end) v12 v13 end) v9 v10 end) v7 v8 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P42	100	0.884073	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @Rlist) (v2 : forall v2 : @R, @R) => Rlist_ind (fun v3 : @Rlist => forall v4 : pos_Rl v3 (Init.Nat.pred (Rlength v3)) = pos_Rl v1 0, Int_SF (FF (cons_Rlist v3 v1) v2) (cons_Rlist v3 v1) = Int_SF (FF v3 v2) v3 + Int_SF (FF v1 v2) v1) (fun v3 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl v1 0 => (let v4 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v5 : list (@R) := (Int_SF (FF v1 v2) v1 :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v5 v4 (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (@I) (eq_refl : (let v6 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)))) = @true)) : Int_SF (FF (cons_Rlist (@nil) v1) v2) (cons_Rlist (@nil) v1) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF v1 v2) v1) (fun (v3 : @R) (v4 : @Rlist) (v5 : forall v5 : pos_Rl v4 (Init.Nat.pred (Rlength v4)) = pos_Rl v1 0, Int_SF (FF (cons_Rlist v4 v1) v2) (cons_Rlist v4 v1) = Int_SF (FF v4 v2) v4 + Int_SF (FF v1 v2) v1) (v6 : pos_Rl (cons v3 v4) (Init.Nat.pred (Rlength (cons v3 v4))) = pos_Rl v1 0) => match v4 as v7 in Rlist return (forall (v8 : forall v8 : pos_Rl v7 (Init.Nat.pred (Rlength v7)) = pos_Rl v1 0, Int_SF (FF (cons_Rlist v7 v1) v2) (cons_Rlist v7 v1) = Int_SF (FF v7 v2) v7 + Int_SF (FF v1 v2) v1) (v9 : pos_Rl (cons v3 v7) (Init.Nat.pred (Rlength (cons v3 v7))) = pos_Rl v1 0), Int_SF (FF (cons_Rlist (cons v3 v7) v1) v2) (cons_Rlist (cons v3 v7) v1) = Int_SF (FF (cons v3 v7) v2) (cons v3 v7) + Int_SF (FF v1 v2) v1) with | nil => fun (v7 : forall v7 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl v1 0, Int_SF (FF (cons_Rlist (@nil) v1) v2) (cons_Rlist (@nil) v1) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF v1 v2) v1) (v8 : pos_Rl (cons v3 (@nil)) (Init.Nat.pred (Rlength (cons v3 (@nil)))) = pos_Rl v1 0) => match v1 as v9 in Rlist return (forall (v10 : forall v10 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl v9 0, Int_SF (FF (cons_Rlist (@nil) v9) v2) (cons_Rlist (@nil) v9) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF v9 v2) v9) (v11 : v3 = pos_Rl v9 0), Int_SF (app_Rlist (mid_Rlist v9 v3) v2) (cons v3 v9) = IZR 0 + Int_SF (FF v9 v2) v9) with | nil => fun (v9 : forall v9 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl (@nil) 0, Int_SF (FF (cons_Rlist (@nil) (@nil)) v2) (cons_Rlist (@nil) (@nil)) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF (@nil) v2) (@nil)) (v10 : v3 = pos_Rl (@nil) 0) => (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v12 : list (@R) := Datatypes.nil in RField_ring_lemma1 (@ring_subst_niter) v12 v11 (Ring_polynom.PEc 0%Z) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 0%Z)) (@I) (eq_refl : (let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEc 0%Z)) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEc 0%Z)))) = @true)) : Int_SF (app_Rlist (mid_Rlist (@nil) v3) v2) (cons v3 (@nil)) = IZR 0 + Int_SF (FF (@nil) v2) (@nil) | cons v9 v10 => (fun (v9 : @R) (v10 : @Rlist) (v11 : forall v11 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = pos_Rl (cons v9 v10) 0, Int_SF (FF (cons_Rlist (@nil) (cons v9 v10)) v2) (cons_Rlist (@nil) (cons v9 v10)) = Int_SF (FF (@nil) v2) (@nil) + Int_SF (FF (cons v9 v10) v2) (cons v9 v10)) (v12 : v3 = pos_Rl (cons v9 v10) 0) => eq_ind_r (fun v13 : @R => v2 ((v13 + v9) / IZR 2) * (v9 - v13) + Int_SF (app_Rlist (mid_Rlist v10 v9) v2) (cons v9 v10) = IZR 0 + Int_SF (app_Rlist (mid_Rlist v10 v9) v2) (cons v9 v10)) (let v13 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := Datatypes.nil in let v14 : list (@R) := (v2 ((v9 + v9) / IZR 2) :: v9 :: Int_SF (app_Rlist (mid_Rlist v10 v9) v2) (cons v9 v10) :: Datatypes.nil)%list in RField_ring_lemma1 (@ring_subst_niter) v14 v13 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 3)) (@I) (eq_refl : (let v15 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v13 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v15 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v15 (Ring_polynom.PEadd (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 3)))) = @true)) v12 : Int_SF (app_Rlist (mid_Rlist (cons v9 v10) v3) v2) (cons v3 (cons v9 v10)) = IZR 0 + Int_SF (FF (cons v9 v10) v2) (cons v9 v10)) v9 v10 end v7 v8 : Int_SF (FF (cons_Rlist (cons v3 (@nil)) v1) v2) (cons_Rlist (cons v3 (@nil)) v1) = Int_SF (FF (cons v3 (@nil)) v2) (cons v3 (@nil)) + Int_SF (FF v1 v2) v1 | cons v7 v8 => (fun (v7 : @R) (v8 : @Rlist) (v9 : forall v9 : pos_Rl (cons v7 v8) (Init.Nat.pred (Rlength (cons v7 v8))) = pos_Rl v1 0, Int_SF (FF (cons_Rlist (cons v7 v8) v1) v2) (cons_Rlist (cons v7 v8) v1) = Int_SF (FF (cons v7 v8) v2) (cons v7 v8) + Int_SF (FF v1 v2) v1) (v10 : pos_Rl (cons v3 (cons v7 v8)) (Init.Nat.pred (Rlength (cons v3 (cons v7 v8)))) = pos_Rl v1 0) => eq_ind_r (fun v11 : @R => v2 ((v3 + v7) / IZR 2) * (v7 - v3) + Int_SF (app_Rlist (mid_Rlist (cons_Rlist v8 v1) v7) v2) (cons v7 (cons_Rlist v8 v1)) = v11) (Rplus_eq_compat_l (v2 ((v3 + v7) / IZR 2) * (v7 - v3)) (Int_SF (app_Rlist (mid_Rlist (cons_Rlist v8 v1) v7) v2) (cons v7 (cons_Rlist v8 v1))) (Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8) + Int_SF (FF v1 v2) v1) (v9 (eq_ind (pos_Rl (cons v3 (cons v7 v8)) (Init.Nat.pred (Rlength (cons v3 (cons v7 v8))))) (fun v11 : @R => pos_Rl (cons v7 v8) (Init.Nat.pred (Rlength (cons v7 v8))) = v11) eq_refl (pos_Rl v1 0) v10))) (Rplus_assoc (v2 ((v3 + v7) / IZR 2) * (v7 - v3)) (Int_SF (app_Rlist (mid_Rlist v8 v7) v2) (cons v7 v8)) (Int_SF (FF v1 v2) v1)) : Int_SF (FF (cons_Rlist (cons v3 (cons v7 v8)) v1) v2) (cons_Rlist (cons v3 (cons v7 v8)) v1) = Int_SF (FF (cons v3 (cons v7 v8)) v2) (cons v3 (cons v7 v8)) + Int_SF (FF v1 v2) v1) v7 v8 end v5 v6) v0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P43	100	6.908552	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P44	100	4.196945	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P45	100	2.352934	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : IsStepFun v0 v1 v2) (v5 : v1 <= v3 <= v2) => let v6 : v1 <= v2 := and_ind (fun (v6 : v1 <= v3) (v7 : v3 <= v2) => Rle_trans v1 v3 v2 v6 v7) v5 in and_rect (fun (v7 : v1 <= v3) (v8 : v3 <= v2) => sigT_rect (fun v9 : {v9 : @Rlist & {v10 : @Rlist & adapted_couple v0 v1 v2 v9 v10}} => IsStepFun v0 v3 v2) (fun (v9 : @Rlist) (v10 : {v10 : @Rlist & adapted_couple v0 v1 v2 v9 v10}) => match v10 as v11 in (sigT _) return (IsStepFun v0 v3 v2) with | existT _ v11 v12 => (fun (v11 : @Rlist) (v12 : adapted_couple v0 v1 v2 v9 v11) => let v13 : forall (v13 v14 : @Rlist) (v15 v16 v17 : @R) (v18 : forall v18 : @R, @R) (v19 : adapted_couple v18 v15 v16 v13 v14) (v20 : v15 <= v17 <= v16), {v21 : @Rlist & {v22 : @Rlist & adapted_couple v18 v17 v16 v21 v22}} := fun v13 : @Rlist => Rlist_rec (fun v14 : @Rlist => forall (v15 : @Rlist) (v16 v17 v18 : @R) (v19 : forall v19 : @R, @R) (v20 : adapted_couple v19 v16 v17 v14 v15) (v21 : v16 <= v18 <= v17), {v22 : @Rlist & {v23 : @Rlist & adapted_couple v19 v18 v17 v22 v23}}) (fun (v14 : @Rlist) (v15 v16 v17 : @R) (v18 : forall v18 : @R, @R) (v19 : adapted_couple v18 v15 v16 (@nil) v14) (v20 : v15 <= v17 <= v16) => let v21 : ordered_Rlist (@nil) /\ pos_Rl (@nil) 0 = Rmin v15 v16 /\ pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v21 : @nat) (v22 : (v21 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v21) (pos_Rl (@nil) (S v21))) (pos_Rl v14 v21)) := v19 in (fun v22 : ordered_Rlist (@nil) /\ pos_Rl (@nil) 0 = Rmin v15 v16 /\ pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v22 : @nat) (v23 : (v22 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v22) (pos_Rl (@nil) (S v22))) (pos_Rl v14 v22)) => and_rec (fun (v23 : ordered_Rlist (@nil)) (v24 : pos_Rl (@nil) 0 = Rmin v15 v16 /\ pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v24) (pos_Rl (@nil) (S v24))) (pos_Rl v14 v24))) => and_rec (fun (v25 : pos_Rl (@nil) 0 = Rmin v15 v16) (v26 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16 /\ Rlength (@nil) = S (Rlength v14) /\ (forall (v26 : @nat) (v27 : (v26 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v26) (pos_Rl (@nil) (S v26))) (pos_Rl v14 v26))) => and_rec (fun (v27 : pos_Rl (@nil) (Init.Nat.pred (Rlength (@nil))) = Rmax v15 v16) (v28 : Rlength (@nil) = S (Rlength v14) /\ (forall (v28 : @nat) (v29 : (v28 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v28) (pos_Rl (@nil) (S v28))) (pos_Rl v14 v28))) => and_rec (fun (v29 : Rlength (@nil) = S (Rlength v14)) (v30 : forall (v30 : @nat) (v31 : (v30 < Init.Nat.pred (Rlength (@nil)))%nat), constant_D_eq v18 (open_interval (pos_Rl (@nil) v30) (pos_Rl (@nil) (S v30))) (pos_Rl v14 v30)) => let v31 : @False := eq_ind 0%nat (fun v31 : @nat => match v31 as v32 in nat return Prop with | 0%nat => @True | S v32 => (fun v32 : @nat => @False) v32 end) (@I) (S (Rlength v14)) v29 in False_rec {v32 : @Rlist & {v33 : @Rlist & adapted_couple v18 v17 v16 v32 v33}} v31) v28) v26) v24) v22) v21) (fun (v14 : @R) (v15 : @Rlist) => Rlist_rec (fun v16 : @Rlist => forall (v17 : forall (v17 : @Rlist) (v18 v19 v20 : @R) (v21 : forall v21 : @R, @R) (v22 : adapted_couple v21 v18 v19 v16 v17) (v23 : v18 <= v20 <= v19), {v24 : @Rlist & {v25 : @Rlist & adapted_couple v21 v20 v19 v24 v25}}) (v18 : @Rlist) (v19 v20 v21 : @R) (v22 : forall v22 : @R, @R) (v23 : adapted_couple v22 v19 v20 (cons v14 v16) v18) (v24 : v19 <= v21 <= v20), {v25 : @Rlist & {v26 : @Rlist & adapted_couple v22 v21 v20 v25 v26}}) (fun (v16 : forall (v16 : @Rlist) (v17 v18 v19 : @R) (v20 : forall v20 : @R, @R) (v21 : adapted_couple v20 v17 v18 (@nil) v16) (v22 : v17 <= v19 <= v18), {v23 : @Rlist & {v24 : @Rlist & adapted_couple v20 v19 v18 v23 v24}}) (v17 : @Rlist) (v18 v19 v20 : @R) (v21 : forall v21 : @R, @R) (v22 : adapted_couple v21 v18 v19 (cons v14 (@nil)) v17) (v23 : v18 <= v20 <= v19) => let v24 : v18 = v19 := let v24 : ordered_Rlist (cons v14 (@nil)) /\ pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19 /\ pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v24 : @nat) (v25 : (v24 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v24) (pos_Rl (cons v14 (@nil)) (S v24))) (pos_Rl v17 v24)) := v22 in (fun v25 : ordered_Rlist (cons v14 (@nil)) /\ pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19 /\ pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v25 : @nat) (v26 : (v25 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v25) (pos_Rl (cons v14 (@nil)) (S v25))) (pos_Rl v17 v25)) => and_ind (fun (v26 : ordered_Rlist (cons v14 (@nil))) (v27 : pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19 /\ pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v27 : @nat) (v28 : (v27 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v27) (pos_Rl (cons v14 (@nil)) (S v27))) (pos_Rl v17 v27))) => and_ind (fun (v28 : pos_Rl (cons v14 (@nil)) 0 = Rmin v18 v19) (v29 : pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19 /\ Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v29 : @nat) (v30 : (v29 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v29) (pos_Rl (cons v14 (@nil)) (S v29))) (pos_Rl v17 v29))) => and_ind (fun (v30 : pos_Rl (cons v14 (@nil)) (Init.Nat.pred (Rlength (cons v14 (@nil)))) = Rmax v18 v19) (v31 : Rlength (cons v14 (@nil)) = S (Rlength v17) /\ (forall (v31 : @nat) (v32 : (v31 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v31) (pos_Rl (cons v14 (@nil)) (S v31))) (pos_Rl v17 v31))) => and_ind (fun (v32 : Rlength (cons v14 (@nil)) = S (Rlength v17)) (v33 : forall (v33 : @nat) (v34 : (v33 < Init.Nat.pred (Rlength (cons v14 (@nil))))%nat), constant_D_eq v21 (open_interval (pos_Rl (cons v14 (@nil)) v33) (pos_Rl (cons v14 (@nil)) (S v33))) (pos_Rl v17 v33)) => let v34 : v18 <= v19 := and_ind (fun (v34 : v18 <= v20) (v35 : v20 <= v19) => Rle_trans v18 v20 v19 v34 v35) v23 in let v35 : Rmin v18 v19 = v18 := decide_left (Rle_dec v18 v19) v34 (fun v35 : {v18 <= v19} + {~ v18 <= v19} => match v35 as v36 in ({_} + {_}) return (@R) with | left v36 => (fun v36 : v18 <= v19 => v18) v36 | right v36 => (fun v36 : ~ v18 <= v19 => v19) v36 end = v18) (fun v35 : v18 <= v19 => eq_refl) : Rmin v18 v19 = v18 in eq_ind (Rmin v18 v19) (fun v36 : @R => v36 = v19) ((let v36 : Rmax v18 v19 = v19 := decide_left (Rle_dec v18 v19) v34 (fun v36 : {v18 <= v19} + {~ v18 <= v19} => match v36 as v37 in ({_} + {_}) return (@R) with | left v37 => (fun v37 : v18 <= v19 => v19) v37 | right v37 => (fun v37 : ~ v18 <= v19 => v18) v37 end = v19) (fun v36 : v18 <= v19 => eq_refl) : Rmax v18 v19 = v19 in eq_ind (Rmax v18 v19) (fun v37 : @R => Rmin v18 v19 = v37) (eq_ind v14 (fun v37 : @R => Rmin v18 v19 = v37) (eq_ind_r (fun v37 : @R => Rmin v18 v19 = v37) eq_refl v28) (Rmax v18 v19) v30) v19 v36) : Rmin v18 v19 = v19) v18 v35) v31) v29) v27) v25) v24 in existT (fun v25 : @Rlist => {v26 : @Rlist & adapted_couple v21 v20 v19 v25 v26}) (cons v14 (@nil)) (existT (fun v25 : @Rlist => adapted_couple v21 v20 v19 (cons v14 (@nil)) v25) v17 (let v25 : v20 = v19 := let v25 : v19 <= v20 <= v19 := eq_ind v18 (fun v25 : @R => v25 <= v20 <= v19) v23 v19 v24 in and_ind (fun (v26 : v19 <= v20) (v27 : v20 <= v19) => Rle_antisym v20 v19 v27 v26) v25 in let v26 : v18 = v20 := eq_ind_r (fun v26 : @R => v18 = v26) v24 v25 in eq_ind v18 (fun v27 : @R => adapted_couple v21 v27 v19 (cons v14 (@nil)) v17) v22 v20 v26))) (fun (v16 : @R) (v17 : @Rlist) (v18 : forall (v18 : forall (v18 : @Rlist) (v19 v20 v21 : @R) (v22 : forall v22 : @R, @R) (v23 : adapted_couple v22 v19 v20 v17 v18) (v24 : v19 <= v21 <= v20), {v25 : @Rlist & {v26 : @Rlist & adapted_couple v22 v21 v20 v25 v26}}) (v19 : @Rlist) (v20 v21 v22 : @R) (v23 : forall v23 : @R, @R) (v24 : adapted_couple v23 v20 v21 (cons v14 v17) v19) (v25 : v20 <= v22 <= v21), {v26 : @Rlist & {v27 : @Rlist & adapted_couple v23 v22 v21 v26 v27}}) (v19 : forall (v19 : @Rlist) (v20 v21 v22 : @R) (v23 : forall v23 : @R, @R) (v24 : adapted_couple v23 v20 v21 (cons v16 v17) v19) (v25 : v20 <= v22 <= v21), {v26 : @Rlist & {v27 : @Rlist & adapted_couple v23 v22 v21 v26 v27}}) (v20 : @Rlist) (v21 v22 v23 : @R) (v24 : forall v24 : @R, @R) (v25 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) v20) (v26 : v21 <= v23 <= v22) => Rlist_rec (fun v27 : @Rlist => forall v28 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) v27, {v29 : @Rlist & {v30 : @Rlist & adapted_couple v24 v23 v22 v29 v30}}) (fun v27 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) (@nil) => let v28 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v28 : @nat) (v29 : (v28 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v28) (pos_Rl (cons v14 (cons v16 v17)) (S v28))) (pos_Rl (@nil) v28)) := v27 in (fun v29 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v29 : @nat) (v30 : (v29 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v29) (pos_Rl (cons v14 (cons v16 v17)) (S v29))) (pos_Rl (@nil) v29)) => and_rec (fun (v30 : ordered_Rlist (cons v14 (cons v16 v17))) (v31 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v31 : @nat) (v32 : (v31 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v31) (pos_Rl (cons v14 (cons v16 v17)) (S v31))) (pos_Rl (@nil) v31))) => and_rec (fun (v32 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22) (v33 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v33 : @nat) (v34 : (v33 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v33) (pos_Rl (cons v14 (cons v16 v17)) (S v33))) (pos_Rl (@nil) v33))) => and_rec (fun (v34 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22) (v35 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil)) /\ (forall (v35 : @nat) (v36 : (v35 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v35) (pos_Rl (cons v14 (cons v16 v17)) (S v35))) (pos_Rl (@nil) v35))) => and_rec (fun (v36 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (@nil))) (v37 : forall (v37 : @nat) (v38 : (v37 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v37) (pos_Rl (cons v14 (cons v16 v17)) (S v37))) (pos_Rl (@nil) v37)) => let v38 : @False := eq_ind (S (S (Rlength v17))) (fun v38 : @nat => match v38 as v39 in nat return Prop with | 0%nat => @False | S v39 => (fun v39 : @nat => match v39 as v40 in nat return Prop with | 0%nat => @False | S v40 => (fun v40 : @nat => @True) v40 end) v39 end) (@I) 1%nat v36 in False_rec {v39 : @Rlist & {v40 : @Rlist & adapted_couple v24 v23 v22 v39 v40}} v38) v35) v33) v31) v29) v28) (fun (v27 : @R) (v28 : @Rlist) (v29 : forall v29 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) v28, {v30 : @Rlist & {v31 : @Rlist & adapted_couple v24 v23 v22 v30 v31}}) (v30 : adapted_couple v24 v21 v22 (cons v14 (cons v16 v17)) (cons v27 v28)) => let v31 : {v23 <= v16} + {v16 < v23} := match Rle_dec v23 v16 as v31 in ({_} + {_}) return ({v23 <= v16} + {v16 < v23}) with | left v31 => (fun v31 : v23 <= v16 => left v31) v31 | right v31 => (fun v31 : ~ v23 <= v16 => right (Rnot_le_lt v23 v16 v31)) v31 end in sumbool_rec (fun v32 : {v23 <= v16} + {v16 < v23} => {v33 : @Rlist & {v34 : @Rlist & adapted_couple v24 v23 v22 v33 v34}}) (fun v32 : v23 <= v16 => existT (fun v33 : @Rlist => {v34 : @Rlist & adapted_couple v24 v23 v22 v33 v34}) (cons v23 (cons v16 v17)) (existT (fun v33 : @Rlist => adapted_couple v24 v23 v22 (cons v23 (cons v16 v17)) v33) (cons v27 v28) (let v33 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v33 : @nat) (v34 : (v33 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v33) (pos_Rl (cons v14 (cons v16 v17)) (S v33))) (pos_Rl (cons v27 v28) v33)) := v30 in (fun v34 : ordered_Rlist (cons v14 (cons v16 v17)) /\ pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v34 : @nat) (v35 : (v34 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v34) (pos_Rl (cons v14 (cons v16 v17)) (S v34))) (pos_Rl (cons v27 v28) v34)) => and_ind (fun (v35 : ordered_Rlist (cons v14 (cons v16 v17))) (v36 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22 /\ pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v36 : @nat) (v37 : (v36 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v36) (pos_Rl (cons v14 (cons v16 v17)) (S v36))) (pos_Rl (cons v27 v28) v36))) => and_ind (fun (v37 : pos_Rl (cons v14 (cons v16 v17)) 0 = Rmin v21 v22) (v38 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22 /\ Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v38 : @nat) (v39 : (v38 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v38) (pos_Rl (cons v14 (cons v16 v17)) (S v38))) (pos_Rl (cons v27 v28) v38))) => and_ind (fun (v39 : pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17)))) = Rmax v21 v22) (v40 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28)) /\ (forall (v40 : @nat) (v41 : (v40 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v40) (pos_Rl (cons v14 (cons v16 v17)) (S v40))) (pos_Rl (cons v27 v28) v40))) => and_ind (fun (v41 : Rlength (cons v14 (cons v16 v17)) = S (Rlength (cons v27 v28))) (v42 : forall (v42 : @nat) (v43 : (v42 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat), constant_D_eq v24 (open_interval (pos_Rl (cons v14 (cons v16 v17)) v42) (pos_Rl (cons v14 (cons v16 v17)) (S v42))) (pos_Rl (cons v27 v28) v42)) => conj ((fun (v43 : @nat) (v44 : (v43 < Init.Nat.pred (Rlength (cons v23 (cons v16 v17))))%nat) => nat_ind (fun v45 : @nat => forall v46 : (v45 < S (Rlength v17))%nat, pos_Rl (cons v23 (cons v16 v17)) v45 <= pos_Rl (cons v23 (cons v16 v17)) (S v45)) (fun v45 : (0 < S (Rlength v17))%nat => v32 : pos_Rl (cons v23 (cons v16 v17)) 0 <= pos_Rl (cons v23 (cons v16 v17)) 1) (fun (v45 : @nat) (v46 : forall v46 : (v45 < S (Rlength v17))%nat, pos_Rl (cons v23 (cons v16 v17)) v45 <= pos_Rl (cons v23 (cons v16 v17)) (S v45)) (v47 : (S v45 < S (Rlength v17))%nat) => v35 (S v45) (v47 : (S v45 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat)) v43 v44) : ordered_Rlist (cons v23 (cons v16 v17))) (conj (((let v43 : {v23 <= v22} + {~ v23 <= v22} := Rle_dec v23 v22 in match v43 as v44 in ({_} + {_}) return (v23 = match v44 as v45 in ({_} + {_}) return (@R) with | left v45 => (fun v45 : v23 <= v22 => v23) v45 | right v45 => (fun v45 : ~ v23 <= v22 => v22) v45 end) with | left v44 => (fun v44 : v23 <= v22 => eq_refl) v44 | right v44 => (fun v44 : ~ v23 <= v22 => let v45 : @False := v44 (and_ind (fun (v45 : v21 <= v23) (v46 : v23 <= v22) => v46) v26) in match v45 as v46 in False return (v23 = v22) with end) v44 end) : v23 = Rmin v23 v22) : pos_Rl (cons v23 (cons v16 v17)) 0 = Rmin v23 v22) (conj (let v43 : Rmax v21 v22 = Rmax v23 v22 := (let v43 : {v23 <= v22} + {~ v23 <= v22} := Rle_dec v23 v22 in match v43 as v44 in ({_} + {_}) return (match Rle_dec v21 v22 as v45 in ({_} + {_}) return (@R) with | left v45 => (fun v45 : v21 <= v22 => v22) v45 | right v45 => (fun v45 : ~ v21 <= v22 => v21) v45 end = match v44 as v45 in ({_} + {_}) return (@R) with | left v45 => (fun v45 : v23 <= v22 => v22) v45 | right v45 => (fun v45 : ~ v23 <= v22 => v23) v45 end) with | left v44 => (fun v44 : v23 <= v22 => let v45 : {v21 <= v22} + {~ v21 <= v22} := Rle_dec v21 v22 in match v45 as v46 in ({_} + {_}) return (match v46 as v47 in ({_} + {_}) return (@R) with | left v47 => (fun v47 : v21 <= v22 => v22) v47 | right v47 => (fun v47 : ~ v21 <= v22 => v21) v47 end = v22) with | left v46 => (fun v46 : v21 <= v22 => eq_refl) v46 | right v46 => (fun v46 : ~ v21 <= v22 => let v47 : @False := v46 (and_ind (fun (v47 : v21 <= v23) (v48 : v23 <= v22) => Rle_trans v21 v23 v22 v47 v48) v26) in match v47 as v48 in False return (v21 = v22) with end) v46 end) v44 | right v44 => (fun v44 : ~ v23 <= v22 => let v45 : @False := v44 (let v45 : {v21 <= v22} + {~ v21 <= v22} := Rle_dec v21 v22 in match v45 as v46 in ({_} + {_}) return (v23 <= v22) with | left v46 => (fun v46 : v21 <= v22 => and_ind (fun (v47 : v21 <= v23) (v48 : v23 <= v22) => v48) v26) v46 | right v46 => (fun v46 : ~ v21 <= v22 => let v47 : @False := v46 (and_ind (fun (v47 : v21 <= v23) (v48 : v23 <= v22) => Rle_trans v21 v23 v22 v47 v48) v26) in match v47 as v48 in False return (v23 <= v22) with end) v46 end) in match v45 as v46 in False return (match Rle_dec v21 v22 as v47 in ({_} + {_}) return (@R) with | left v47 => (fun v47 : v21 <= v22 => v22) v47 | right v47 => (fun v47 : ~ v21 <= v22 => v21) v47 end = v23) with end) v44 end) : Rmax v21 v22 = Rmax v23 v22 in eq_ind (Rmax v21 v22) (fun v44 : @R => pos_Rl (cons v23 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v23 (cons v16 v17)))) = v44) (eq_ind (pos_Rl (cons v14 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))) (fun v44 : @R => pos_Rl (cons v23 (cons v16 v17)) (Init.Nat.pred (Rlength (cons v23 (cons v16 v17)))) = v44) eq_refl (Rmax v21 v22) v39) (Rmax v23 v22) v43) (conj (v41 : Rlength (cons v23 (cons v16 v17)) = S (Rlength (cons v27 v28))) (fun (v43 : @nat) (v44 : (v43 < Init.Nat.pred (Rlength (cons v23 (cons v16 v17))))%nat) => nat_ind (fun v45 : @nat => forall v46 : (v45 < S (Rlength v17))%nat, constant_D_eq v24 (open_interval (pos_Rl (cons v23 (cons v16 v17)) v45) (pos_Rl (cons v23 (cons v16 v17)) (S v45))) (pos_Rl (cons v27 v28) v45)) (fun v45 : (0 < S (Rlength v17))%nat => ((fun (v46 : @R) (v47 : pos_Rl (cons v23 (cons v16 v17)) 0 < v46 < pos_Rl (cons v23 (cons v16 v17)) 1) => v42 0%nat (Nat.lt_0_succ (Rlength v17) : (0 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat) v46 ((and_ind (fun (v48 : v23 < v46) (v49 : v46 < v16) => conj (Rle_lt_trans v14 v23 v46 (let v50 : v21 = v14 := eq_ind_r (fun v50 : @R => v21 = v50) ((let v50 : {v21 <= v22} + {~ v21 <= v22} := Rle_dec v21 v22 in match v50 as v51 in ({_} + {_}) return (v21 = match v51 as v52 in ({_} + {_}) return (@R) with | left v52 => (fun v52 : v21 <= v22 => v21) v52 | right v52 => (fun v52 : ~ v21 <= v22 => v22) v52 end) with | left v51 => (fun v51 : v21 <= v22 => eq_refl) v51 | right v51 => (fun v51 : ~ v21 <= v22 => let v52 : @False := v51 (and_ind (fun (v52 : v21 <= v23) (v53 : v23 <= v22) => Rle_trans v21 v23 v22 v52 v53) v26) in match v52 as v53 in False return (v21 = v22) with end) v51 end) : v21 = Rmin v21 v22) v37 in eq_ind v21 (fun v51 : @R => v51 <= v23) (and_ind (fun (v51 : v21 <= v23) (v52 : v23 <= v22) => v51) v26) v14 v50) v48) v49) v47 : pos_Rl (cons v14 (cons v16 v17)) 0 < v46 < pos_Rl (cons v14 (cons v16 v17)) 1) : open_interval (pos_Rl (cons v14 (cons v16 v17)) 0) (pos_Rl (cons v14 (cons v16 v17)) 1) v46) : v24 v46 = pos_Rl (cons v27 v28) 0) : forall (v46 : @R) (v47 : open_interval (pos_Rl (cons v23 (cons v16 v17)) 0) (pos_Rl (cons v23 (cons v16 v17)) 1) v46), v24 v46 = pos_Rl (cons v27 v28) 0) : constant_D_eq v24 (open_interval (pos_Rl (cons v23 (cons v16 v17)) 0) (pos_Rl (cons v23 (cons v16 v17)) 1)) (pos_Rl (cons v27 v28) 0)) (fun (v45 : @nat) (v46 : forall v46 : (v45 < S (Rlength v17))%nat, constant_D_eq v24 (open_interval (pos_Rl (cons v23 (cons v16 v17)) v45) (pos_Rl (cons v23 (cons v16 v17)) (S v45))) (pos_Rl (cons v27 v28) v45)) (v47 : (S v45 < S (Rlength v17))%nat) => v42 (S v45) (v47 : (S v45 < Init.Nat.pred (Rlength (cons v14 (cons v16 v17))))%nat)) v43 v44)))) : adapted_couple v24 v23 v22 (cons v23 (cons v16 v17)) (cons v27 v28)) v40) v38) v36) v34) v33))) (fun v32 : v16 < v23 => let v33 : adapted_couple v24 v16 v22 (cons v16 v17) v28 := StepFun_P7 (and_ind (fun (v33 : v21 <= v23) (v34 : v23 <= v22) => Rle_trans v21 v23 v22 v33 v34) v26) v30 in (let v34 : v16 <= v23 <= v22 := conj (or_introl v32) (and_ind (fun (v34 : v21 <= v23) (v35 : v23 <= v22) => v35) v26) in (fun (v35 : v16 <= v23 <= v22) (v36 : adapted_couple v24 v16 v22 (cons v16 v17) v28) => sigT_rec (fun v37 : {v37 : @Rlist & {v38 : @Rlist & adapted_couple v24 v23 v22 v37 v38}} => {v38 : @Rlist & {v39 : @Rlist & adapted_couple v24 v23 v22 v38 v39}}) (fun (v37 : @Rlist) (v38 : {v38 : @Rlist & adapted_couple v24 v23 v22 v37 v38}) => match v38 as v39 in (sigT _) return {v40 : @Rlist & {v41 : @Rlist & adapted_couple v24 v23 v22 v40 v41}} with | existT _ v39 v40 => (fun (v39 : @Rlist) (v40 : adapted_couple v24 v23 v22 v37 v39) => existT (fun v41 : @Rlist => {v42 : @Rlist & adapted_couple v24 v23 v22 v41 v42}) v37 (existT (fun v41 : @Rlist => adapted_couple v24 v23 v22 v37 v41) v39 v40)) v39 v40 end) (v19 v28 v16 v22 v23 v24 v36 v35)) v34) v33) v31) v20 v25) v15) v13 in (fun v14 : forall (v14 v15 : @Rlist) (v16 v17 v18 : @R) (v19 : forall v19 : @R, @R) (v20 : adapted_couple v19 v16 v17 v14 v15) (v21 : v16 <= v18 <= v17), {v22 : @Rlist & {v23 : @Rlist & adapted_couple v19 v18 v17 v22 v23}} => (v14 v9 v11 v1 v2 v3 v0 v12 (conj v7 v8) : {v15 : @Rlist & is_subdivision v0 v3 v2 v15}) : IsStepFun v0 v3 v2) v13) v11 v12 end) v4) v5)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.RiemannInt_SF.StepFun_P46	100	0.147539	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : IsStepFun v0 v1 v2) (v5 : IsStepFun v0 v2 v3) => match Rle_dec v1 v2 as v6 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v6 => match Rle_dec v2 v3 as v6 in ({_} + {_}) return (forall v7 : v1 <= v2, IsStepFun v0 v1 v3) with | left v6 => (fun (v6 : v2 <= v3) (v7 : v1 <= v2) => StepFun_P41 v7 v6 v4 v5) v6 | right v6 => (fun (v6 : ~ v2 <= v3) (v7 : v1 <= v2) => match Rle_dec v1 v3 as v8 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v8 => (fun v8 : v1 <= v3 => StepFun_P44 v4 (conj v8 (Rlt_le v3 v2 (Rnot_le_lt v2 v3 v6)))) v8 | right v8 => (fun v8 : ~ v1 <= v3 => StepFun_P6 (StepFun_P44 (StepFun_P6 v5) (conj (Rlt_le v3 v1 (Rnot_le_lt v1 v3 v8)) v7))) v8 end) v6 end v6 | right v6 => match Rle_dec v2 v3 as v6 in ({_} + {_}) return (forall v7 : ~ v1 <= v2, IsStepFun v0 v1 v3) with | left v6 => (fun (v6 : v2 <= v3) (v7 : ~ v1 <= v2) => match Rle_dec v1 v3 as v8 in ({_} + {_}) return (IsStepFun v0 v1 v3) with | left v8 => (fun v8 : v1 <= v3 => StepFun_P45 v5 (conj (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v7)) v8)) v8 | right v8 => (fun v8 : ~ v1 <= v3 => StepFun_P6 (StepFun_P45 (StepFun_P6 v4) (conj v6 (Rlt_le v3 v1 (Rnot_le_lt v1 v3 v8))))) v8 end) v6 | right v6 => (fun (v6 : ~ v2 <= v3) (v7 : ~ v1 <= v2) => StepFun_P6 (StepFun_P41 (Rlt_le v3 v2 (Rnot_le_lt v2 v3 v6)) (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v7)) (StepFun_P6 v5) (StepFun_P6 v4))) v6 end v6 end)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.psos_r1b	100	1.070556	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : v0 - v1 == 0) => let v3 : default_relation v0 (v0 - v1 + v1) := (((fun v3 : forall (v3 v4 : PExpr (@Z)) (v5 : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v5 : @N => v5) (pow_N 1 _*_) (v0 :: v1 :: nil) nil) (v6 : (let v6 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v6 v3) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v6 v4)) = @true), Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v7 : @N => v7) (pow_N 1 _*_) (v0 :: v1 :: nil) v3 == Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v7 : @N => v7) (pow_N 1 _*_) (v0 :: v1 :: nil) v4 => v3 (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEadd (PEsub (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))) (@I : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v4 : @N => v4) (pow_N 1 _*_) (v0 :: v1 :: nil) nil) (eq_refl : (let v4 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v4 (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v4 (PEadd (PEsub (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))))) = @true)) (Ring_polynom.ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 (v0 :: v1 :: nil) nil) : v0 == v0 - v1 + v1) : v0 == v0 - v1 + v1) : default_relation v0 (v0 - v1 + v1) in ((fun v4 : v0 == v0 - v1 + v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive v0 (v0 - v1 + v1) v4 v1 v1 (eq_proper_proxy v1) (trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 - v1 + v1) (0 + v1) (ring_plus_comp (v0 - v1) 0 v2 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) v1 v1 (eq_proper_proxy v1) ((fun v5 : forall (v5 v6 : PExpr (@Z)) (v7 : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v7 : @N => v7) (pow_N 1 _*_) (v1 :: nil) nil) (v8 : (let v8 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v8 v5) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v8 v6)) = @true), Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v9 : @N => v9) (pow_N 1 _*_) (v1 :: nil) v5 == Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v9 : @N => v9) (pow_N 1 _*_) (v1 :: nil) v6 => v5 (PEadd (PEc 0%Z) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0))) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (@I : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v6 : @N => v6) (pow_N 1 _*_) (v1 :: nil) nil) (eq_refl : (let v6 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v6 (PEadd (PEc 0%Z) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v6 (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)))) = @true)) (Ring_polynom.ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 (v1 :: nil) nil) : 0 + v1 == v1) : v0 - v1 + v1 == v1)) : forall v4 : default_relation v0 (v0 - v1 + v1), v0 == v1) v3)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.psos_r1	100	0.450129	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : v0 == v1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 - v1) (v1 - v1) (ring_sub_comp v0 v1 v2 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) 0 0 (eq_proper_proxy 0) ((fun v3 : forall (v3 v4 : PExpr (@Z)) (v5 : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v5 : @N => v5) (pow_N 1 _*_) (v1 :: nil) nil) (v6 : (let v6 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v6 v3) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v6 v4)) = @true), Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v7 : @N => v7) (pow_N 1 _*_) (v1 :: nil) v3 == Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v7 : @N => v7) (pow_N 1 _*_) (v1 :: nil) v4 => v3 (PEsub (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0))) (PEc 0%Z) (@I : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v4 : @N => v4) (pow_N 1 _*_) (v1 :: nil) nil) (eq_refl : (let v4 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v4 (PEsub (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v4 (PEc 0%Z))) = @true)) (Ring_polynom.ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 (v1 :: nil) nil) : v1 - v1 == 0) : v0 - v1 == 0)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.nsatzR_diff	100	1.237601	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : ~ v0 == v1) => (fun v3 : v0 - v1 == 0 => v2 ((let v4 : default_relation v0 (v0 - v1 + v1) := (((fun v4 : forall (v4 v5 : PExpr (@Z)) (v6 : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v6 : @N => v6) (pow_N 1 _*_) (v0 :: v1 :: nil) nil) (v7 : (let v7 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v7 v4) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v7 v5)) = @true), Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v8 : @N => v8) (pow_N 1 _*_) (v0 :: v1 :: nil) v4 == Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v8 : @N => v8) (pow_N 1 _*_) (v0 :: v1 :: nil) v5 => v4 (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEadd (PEsub (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))) (@I : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v5 : @N => v5) (pow_N 1 _*_) (v0 :: v1 :: nil) nil) (eq_refl : (let v5 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v5 (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v5 (PEadd (PEsub (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 1))))) = @true)) (Ring_polynom.ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 (v0 :: v1 :: nil) nil) : v0 == v0 - v1 + v1) : v0 == v0 - v1 + v1) : default_relation v0 (v0 - v1 + v1) in ((fun v5 : v0 == v0 - v1 + v1 => trans_co_eq_inv_impl_morphism Equivalence_Transitive v0 (v0 - v1 + v1) v5 v1 v1 (eq_proper_proxy v1) (trans_co_eq_inv_impl_morphism Equivalence_Transitive (v0 - v1 + v1) (0 + v1) (ring_plus_comp (v0 - v1) 0 v3 v1 v1 (reflexive_proper_proxy Equivalence_Reflexive v1)) v1 v1 (eq_proper_proxy v1) ((fun v6 : forall (v6 v7 : PExpr (@Z)) (v8 : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v8 : @N => v8) (pow_N 1 _*_) (v1 :: nil) nil) (v9 : (let v9 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v9 v6) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v9 v7)) = @true), Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v10 : @N => v10) (pow_N 1 _*_) (v1 :: nil) v6 == Ring_polynom.PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v10 : @N => v10) (pow_N 1 _*_) (v1 :: nil) v7 => v6 (PEadd (PEc 0%Z) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0))) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (@I : Ring_polynom.interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v7 : @N => v7) (pow_N 1 _*_) (v1 :: nil) nil) (eq_refl : (let v7 : list (@Z * @Mon * Ring_polynom.Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v7 (PEadd (PEc 0%Z) (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v7 (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)))) = @true)) (Ring_polynom.ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 (v1 :: nil) nil) : 0 + v1 == v1) : v0 - v1 + v1 == v1)) : forall v5 : default_relation v0 (v0 - v1 + v1), v0 == v1) v4) : v0 == v1)) : ~ v0 - v1 == 0)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.P0Z_correct	100	0.059440	1	1	0	synth with cache (only 1: refine (fun v0 : list (@R) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.Rext	100	0.385193	1	1	0	synth with cache (only 1: refine {| Radd_ext := ((fun (v0 v1 : @R) (v2 : v0 == v1) => (fun (v3 v4 : @R) (v5 : v3 == v4) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (add v0 v3) (add v0 v4) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive v0) v3 v4 v5) (add v1 v4) (add v1 v4) (eq_proper_proxy (add v1 v4)) (trans_co_eq_inv_impl_morphism Equivalence_Transitive (add v0 v4) (add v1 v4) (ring_plus_comp v0 v1 v2 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) (add v1 v4) (add v1 v4) (eq_proper_proxy (add v1 v4)) (reflexivity (add v1 v4)))) : (_==_ ==> _==_)%signature (add v0) (add v1)) : (_==_ ==> _==_ ==> _==_)%signature (@add) (@add)) : Proper (_==_ ==> _==_ ==> _==_) (@add); Rmul_ext := ((fun (v0 v1 : @R) (v2 : v0 == v1) => (fun (v3 v4 : @R) (v5 : v3 == v4) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (mul v0 v3) (mul v0 v4) (Reflexive_partial_app_morphism ring_mult_comp (reflexive_proper_proxy Equivalence_Reflexive v0) v3 v4 v5) (mul v1 v4) (mul v1 v4) (eq_proper_proxy (mul v1 v4)) (trans_co_eq_inv_impl_morphism Equivalence_Transitive (mul v0 v4) (mul v1 v4) (ring_mult_comp v0 v1 v2 v4 v4 (reflexive_proper_proxy Equivalence_Reflexive v4)) (mul v1 v4) (mul v1 v4) (eq_proper_proxy (mul v1 v4)) (reflexivity (mul v1 v4)))) : (_==_ ==> _==_)%signature (mul v0) (mul v1)) : (_==_ ==> _==_ ==> _==_)%signature (@mul) (@mul)) : Proper (_==_ ==> _==_ ==> _==_) (@mul); Ropp_ext := ((fun (v0 v1 : @R) (v2 : v0 == v1) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (opp v0) (opp v1) (ring_opp_comp v0 v1 v2) (opp v1) (opp v1) (eq_proper_proxy (opp v1)) (reflexivity (opp v1))) : (_==_ ==> _==_)%signature (@opp) (@opp)) : Proper (_==_ ==> _==_) (@opp) |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.Rset	100	0.052007	1	1	0	synth with cache (only 1: refine ring_setoid).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.Rtheory	100	0.097097	1	1	0	synth with cache (only 1: refine {| Radd_0_l := ring_add_0_l; Radd_comm := ring_add_comm; Radd_assoc := ring_add_assoc; Rmul_1_l := ring_mul_1_l; Rmul_comm := cring_mul_comm; Rmul_assoc := ring_mul_assoc; Rdistr_l := ring_distr_l; Rsub_def := ring_sub_def; Ropp_def := ring_opp_def |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.PolZadd_correct	100	0.145164	1	1	0	synth with cache (only 1: refine (((fun (v0 v1 : @PolZ) (v2 : list (@R)) => Padd_ok (@Rset) (@Rext) (Rth_ARth (@Rset) (@Rext) (@Rtheory)) (gen_phiZ_morph (@Rset) (@Rext) (@Rtheory)) v0 v1 v2 : Pphi (@ring0) (@add) (@mul) (gen_phiZ (@ring0) (@ring1) (@add) (@mul) (@opp)) v2 (Padd 0%Z (@BinIntDef.Z.add) (@Zeq_bool) v1 v0) == Pphi (@ring0) (@add) (@mul) (gen_phiZ (@ring0) (@ring1) (@add) (@mul) (@opp)) v2 v1 + Pphi (@ring0) (@add) (@mul) (gen_phiZ (@ring0) (@ring1) (@add) (@mul) (@opp)) v2 v0) : forall (v0 v1 : @PolZ) (v2 : list (@R)), PhiR v2 (Padd 0%Z (@BinIntDef.Z.add) (@Zeq_bool) v1 v0) == PhiR v2 v1 + PhiR v2 v0) : forall (v0 v1 : @PolZ) (v2 : list (@R)), PhiR v2 (PolZadd v1 v0) == PhiR v2 v1 + PhiR v2 v0)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.PolZmul_correct	100	0.126304	1	1	0	synth with cache (only 1: refine (((fun (v0 v1 : @PolZ) (v2 : list (@R)) => Pmul_ok (@Rset) (@Rext) (Rth_ARth (@Rset) (@Rext) (@Rtheory)) (gen_phiZ_morph (@Rset) (@Rext) (@Rtheory)) v0 v1 v2) : forall (v0 v1 : @PolZ) (v2 : list (@R)), PhiR v2 (Pmul 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@Zeq_bool) v0 v1) == PhiR v2 v0 * PhiR v2 v1) : forall (v0 v1 : @PolZ) (v2 : list (@R)), PhiR v2 (PolZmul v0 v1) == PhiR v2 v0 * PhiR v2 v1)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.R_power_theory	100	0.091152	1	1	0	synth with cache (only 1: refine {| rpow_pow_N := (fun (v0 : @R) (v1 : @N) => eq_ind_r (fun v2 : @N => pow_N 1 (@mul) v0 v2 == pow_N (@ring1) (@mul) v0 v1) (reflexivity (pow_N (@ring1) (@mul) v0 v1)) (Nnat.N2Nat.id v1)) : forall (v0 : @R) (v1 : @N), pow v0 (BinNatDef.N.to_nat v1) == pow_N (@ring1) (@mul) v0 v1 |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.norm_correct	100	0.075099	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@R)) (v1 : @PEZ) => norm_aux_spec (@Rset) (@Rext) (Rth_ARth (@Rset) (@Rext) (@Rtheory)) (gen_phiZ_morph (@Rset) (@Rext) (@Rtheory)) (@R_power_theory) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.PolZeq_correct	100	0.120129	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : Pol (@Z)) (v2 : list (@R)) (v3 : PolZeq v0 v1 = @true) => Peq_ok (@Rset) (@Rext) (gen_phiZ_morph (@Rset) (@Rext) (@Rtheory)) v0 v1 v3 v2)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.mult_l_correct	100	2.044266	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@R)) (v1 : list (@PEZ)) => list_ind (fun v2 : list (@PEZ) => forall (v3 : list (@PolZ)) (v4 : Cond0 (@PolZ) (PhiR v0) v3), PhiR v0 (mult_l v2 v3) == 0) ((fun (v2 : list (@PolZ)) (v3 : Cond0 (@PolZ) (PhiR v0) v2) => (fun v4 : forall (v4 v5 : PExpr (@Z)) (v6 : interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v6 : @N => v6) (pow_N 1 _*_) nil nil) (v7 : (let v7 : list (@Z * @Mon * Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Peq (@Zeq_bool) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v7 v4) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v7 v5)) = @true), PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v8 : @N => v8) (pow_N 1 _*_) nil v4 == PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v8 : @N => v8) (pow_N 1 _*_) nil v5 => v4 (PEc 0%Z) (PEc 0%Z) (@I : interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v5 : @N => v5) (pow_N 1 _*_) nil nil) (eq_refl : (let v5 : list (@Z * @Mon * Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Peq (@Zeq_bool) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v5 (PEc 0%Z)) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v5 (PEc 0%Z))) = @true)) (ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 nil nil)) : forall (v2 : list (@PolZ)) (v3 : Cond0 (@PolZ) (PhiR v0) v2), PhiR v0 (mult_l nil v2) == 0) (fun (v2 : @PEZ) (v3 : list (@PEZ)) (v4 : forall (v4 : list (@PolZ)) (v5 : Cond0 (@PolZ) (PhiR v0) v4), PhiR v0 (mult_l v3 v4) == 0) => (fun (v5 : list (@PolZ)) (v6 : Cond0 (@PolZ) (PhiR v0) v5) => match v5 as v7 in (list _) return (forall v8 : Cond0 (@PolZ) (PhiR v0) v7, PhiR v0 match v7 as v9 in (list _) return (@PolZ) with | nil => @P0Z | v9 :: v10 => (fun (v9 : @PolZ) (v10 : list (@PolZ)) => PolZadd (PolZmul (norm v2) v9) (mult_l v3 v10)) v9 v10 end == 0) with | nil => fun v7 : Cond0 (@PolZ) (PhiR v0) nil => (fun v8 : forall (v8 v9 : PExpr (@Z)) (v10 : interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v10 : @N => v10) (pow_N 1 _*_) nil nil) (v11 : (let v11 : list (@Z * @Mon * Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Peq (@Zeq_bool) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v11 v8) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v11 v9)) = @true), PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v12 : @N => v12) (pow_N 1 _*_) nil v8 == PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v12 : @N => v12) (pow_N 1 _*_) nil v9 => v8 (PEc 0%Z) (PEc 0%Z) (@I : interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v9 : @N => v9) (pow_N 1 _*_) nil nil) (eq_refl : (let v9 : list (@Z * @Mon * Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Peq (@Zeq_bool) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v9 (PEc 0%Z)) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v9 (PEc 0%Z))) = @true)) (ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 nil nil) : PhiR v0 (@P0Z) == 0 | v7 :: v8 => (fun (v7 : @PolZ) (v8 : list (@PolZ)) (v9 : Cond0 (@PolZ) (PhiR v0) (v7 :: v8)) => match v9 as v10 in (_ /\ _) return (PhiR v0 (PolZadd (PolZmul (norm v2) v7) (mult_l v3 v8)) == 0) with | conj v10 v11 => (fun (v10 : PhiR v0 v7 == 0) (v11 : Cond0 (@PolZ) (PhiR v0) v8) => (fun v12 : PhiR v0 (PolZadd (PolZmul (norm v2) v7) (mult_l v3 v8)) == PhiR v0 (PolZmul (norm v2) v7) + PhiR v0 (mult_l v3 v8) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (PhiR v0 (PolZadd (PolZmul (norm v2) v7) (mult_l v3 v8))) (PhiR v0 (PolZmul (norm v2) v7) + PhiR v0 (mult_l v3 v8)) v12 0 0 (eq_proper_proxy 0)) (PolZadd_correct (mult_l v3 v8) (PolZmul (norm v2) v7) v0) ((fun v12 : PhiR v0 (PolZmul (norm v2) v7) == PhiR v0 (norm v2) * PhiR v0 v7 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (PhiR v0 (PolZmul (norm v2) v7) + PhiR v0 (mult_l v3 v8)) (PhiR v0 (norm v2) * PhiR v0 v7 + PhiR v0 (mult_l v3 v8)) (ring_plus_comp (PhiR v0 (PolZmul (norm v2) v7)) (PhiR v0 (norm v2) * PhiR v0 v7) v12 (PhiR v0 (mult_l v3 v8)) (PhiR v0 (mult_l v3 v8)) (reflexive_proper_proxy Equivalence_Reflexive (PhiR v0 (mult_l v3 v8)))) 0 0 (eq_proper_proxy 0)) (PolZmul_correct (norm v2) v7 v0) ((fun v12 : PhiR v0 v7 == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (PhiR v0 (norm v2) * PhiR v0 v7 + PhiR v0 (mult_l v3 v8)) (PhiR v0 (norm v2) * 0 + PhiR v0 (mult_l v3 v8)) (ring_plus_comp (PhiR v0 (norm v2) * PhiR v0 v7) (PhiR v0 (norm v2) * 0) (Reflexive_partial_app_morphism ring_mult_comp (reflexive_proper_proxy Equivalence_Reflexive (PhiR v0 (norm v2))) (PhiR v0 v7) 0 v12) (PhiR v0 (mult_l v3 v8)) (PhiR v0 (mult_l v3 v8)) (reflexive_proper_proxy Equivalence_Reflexive (PhiR v0 (mult_l v3 v8)))) 0 0 (eq_proper_proxy 0)) v10 ((fun v12 : PhiR v0 (mult_l v3 v8) == 0 => trans_co_eq_inv_impl_morphism Equivalence_Transitive (PhiR v0 (norm v2) * 0 + PhiR v0 (mult_l v3 v8)) (PhiR v0 (norm v2) * 0 + 0) (Reflexive_partial_app_morphism ring_plus_comp (reflexive_proper_proxy Equivalence_Reflexive (PhiR v0 (norm v2) * 0)) (PhiR v0 (mult_l v3 v8)) 0 v12) 0 0 (eq_proper_proxy 0)) (v4 v8 v11) ((fun v12 : forall (v12 v13 : PExpr (@Z)) (v14 : interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v14 : @N => v14) (pow_N 1 _*_) (PhiR v0 (norm v2) :: nil) nil) (v15 : (let v15 : list (@Z * @Mon * Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Peq (@Zeq_bool) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v15 v12) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v15 v13)) = @true), PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v16 : @N => v16) (pow_N 1 _*_) (PhiR v0 (norm v2) :: nil) v12 == PEeval 0 1 _+_ _*_ _-_ -_ Ncring_initial.gen_phiZ (fun v16 : @N => v16) (pow_N 1 _*_) (PhiR v0 (norm v2) :: nil) v13 => v12 (PEadd (PEmul (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEc 0%Z)) (PEc 0%Z)) (PEc 0%Z) (@I : interp_PElist 0 1 _+_ _*_ _-_ -_ _==_ Ncring_initial.gen_phiZ (fun v13 : @N => v13) (pow_N 1 _*_) (PhiR v0 (norm v2) :: nil) nil) (eq_refl : (let v13 : list (@Z * @Mon * Pol (@Z)) := mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) nil in Peq (@Zeq_bool) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v13 (PEadd (PEmul (PEX (@Z) (BinPosDef.Pos.of_succ_nat 0)) (PEc 0%Z)) (PEc 0%Z))) (norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) 0 v13 (PEc 0%Z))) = @true)) (ring_correct ring_setoid cring_eq_ext cring_almost_ring_theory cring_morph cring_power_theory cring_div_theory 0 (PhiR v0 (norm v2) :: nil) nil))) : PhiR v0 (norm v2) * PhiR v0 v7 + PhiR v0 (mult_l v3 v8) == 0) : PhiR v0 (PolZmul (norm v2) v7) + PhiR v0 (mult_l v3 v8) == 0)) v10 v11 end) v7 v8 end v6) : forall (v5 : list (@PolZ)) (v6 : Cond0 (@PolZ) (PhiR v0) v5), PhiR v0 (mult_l (v2 :: v3) v5) == 0) v1)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.compute_list_correct	100	0.096401	1	1	0	synth with cache (only 1: refine (fun (v0 : list (@R)) (v1 : list (list (@PEZ))) => list_ind (fun v2 : list (list (@PEZ)) => forall (v3 : list (@PolZ)) (v4 : Cond0 (@PolZ) (PhiR v0) v3), Cond0 (@PolZ) (PhiR v0) (compute_list v2 v3)) ((fun (v2 : list (@PolZ)) (v3 : Cond0 (@PolZ) (PhiR v0) v2) => v3) : forall (v2 : list (@PolZ)) (v3 : Cond0 (@PolZ) (PhiR v0) v2), Cond0 (@PolZ) (PhiR v0) (compute_list nil v2)) (fun (v2 : list (@PEZ)) (v3 : list (list (@PEZ))) (v4 : forall (v4 : list (@PolZ)) (v5 : Cond0 (@PolZ) (PhiR v0) v4), Cond0 (@PolZ) (PhiR v0) (compute_list v3 v4)) => (fun (v5 : list (@PolZ)) (v6 : Cond0 (@PolZ) (PhiR v0) v5) => v4 (mult_l v2 v5 :: v5) (conj (mult_l_correct v0 v2 v5 v6) v6 : Cond0 (@PolZ) (PhiR v0) (mult_l v2 v5 :: v5))) : forall (v5 : list (@PolZ)) (v6 : Cond0 (@PolZ) (PhiR v0) v5), Cond0 (@PolZ) (PhiR v0) (compute_list (v2 :: v3) v5)) v1)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.nsatz1.check_correct	100	0.464055	1	1	0	synth with cache (only 1: refine ((fun (v0 : list (@R)) (v1 : list (@PEZ)) (v2 : @PEZ) (v3 : list (list (@PEZ)) * list (@PEZ)) => match v3 as v4 in (_ * _)%type return (forall (v5 : match v4 as v5 in (_ * _)%type return (@bool) with | (v5, v6) => (fun (v5 : list (list (@PEZ))) (v6 : list (@PEZ)) => PolZeq (norm v2) (mult_l v6 (compute_list v5 (map (@norm) v1)))) v5 v6 end = @true) (v6 : Cond0 (@PEZ) (PEevalR v0) v1), PEevalR v0 v2 == 0) with | (v4, v5) => (fun (v4 : list (list (@PEZ))) (v5 : list (@PEZ)) (v6 : PolZeq (norm v2) (mult_l v5 (compute_list v4 (map (@norm) v1))) = @true) (v7 : Cond0 (@PEZ) (PEevalR v0) v1) => let v8 : PhiR v0 (norm v2) == PhiR v0 (mult_l v5 (compute_list v4 (map (@norm) v1))) := PolZeq_correct (norm v2) (mult_l v5 (compute_list v4 (map (@norm) v1))) v0 v6 in (fun v9 : PEevalR v0 v2 == PhiR v0 (norm v2) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (PEevalR v0 v2) (PhiR v0 (norm v2)) v9 0 0 (eq_proper_proxy 0)) (norm_correct v0 v2) ((fun v9 : PhiR v0 (norm v2) == PhiR v0 (mult_l v5 (compute_list v4 (map (@norm) v1))) => trans_co_eq_inv_impl_morphism Equivalence_Transitive (PhiR v0 (norm v2)) (PhiR v0 (mult_l v5 (compute_list v4 (map (@norm) v1)))) v9 0 0 (eq_proper_proxy 0)) v8 (mult_l_correct v0 v5 (compute_list v4 (map (@norm) v1)) (compute_list_correct v0 v4 (map (@norm) v1) (list_ind (fun v9 : list (@PEZ) => forall v10 : Cond0 (@PEZ) (PEevalR v0) v9, Cond0 (@PolZ) (PhiR v0) (map (@norm) v9)) (fun v9 : Cond0 (@PEZ) (PEevalR v0) nil => v9 : Cond0 (@PolZ) (PhiR v0) (map (@norm) nil)) (fun (v9 : @PEZ) (v10 : list (@PEZ)) (v11 : forall v11 : Cond0 (@PEZ) (PEevalR v0) v10, Cond0 (@PolZ) (PhiR v0) (map (@norm) v10)) (v12 : Cond0 (@PEZ) (PEevalR v0) (v9 :: v10)) => match v12 as v13 in (_ /\ _) return (PhiR v0 (norm v9) == 0 /\ Cond0 (@PolZ) (PhiR v0) (map (@norm) v10)) with | conj v13 v14 => (fun (v13 : PEevalR v0 v9 == 0) (v14 : Cond0 (@PEZ) (PEevalR v0) v10) => (fun v15 : PEevalR v0 v9 == PhiR v0 (norm v9) => subrelation_proper (@Morphisms_Prop.and_iff_morphism) (@tt) (subrelation_respectful (subrelation_refl (@iff)) (subrelation_respectful (subrelation_refl (@iff)) (@iff_flip_impl_subrelation))) (PhiR v0 (norm v9) == 0) (PEevalR v0 v9 == 0) (PER_morphism (Equivalence_PER ring_setoid) (PhiR v0 (norm v9)) (PEevalR v0 v9) (symmetry v15) 0 0 (reflexive_proper_proxy Equivalence_Reflexive 0)) (Cond0 (@PolZ) (PhiR v0) (map (@norm) v10)) (Cond0 (@PolZ) (PhiR v0) (map (@norm) v10)) (reflexive_proper_proxy (@iff_Reflexive) (Cond0 (@PolZ) (PhiR v0) (map (@norm) v10)))) (norm_correct v0 v9) (conj v13 (v11 v14))) v13 v14 end : Cond0 (@PolZ) (PhiR v0) (map (@norm) (v9 :: v10))) v1 v7))))) v4 v5 end) : forall (v0 : list (@R)) (v1 : list (@PEZ)) (v2 : @PEZ) (v3 : list (list (@PEZ)) * list (@PEZ)) (v4 : check v1 v2 v3 = @true) (v5 : Cond0 (@PEZ) (PEevalR v0) v1), PEevalR v0 v2 == 0)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Rsth	100	0.058324	1	1	0	synth with cache (only 1: refine {| Equivalence_Reflexive := (fun v0 : @R => eq_refl) : Reflexive eq; Equivalence_Symmetric := (fun (v0 v1 : @R) (v2 : v0 = v1) => eq_ind_r (fun v3 : @R => v1 = v3) eq_refl v2) : Symmetric eq; Equivalence_Transitive := (fun (v0 v1 v2 : @R) (v3 : v0 = v1) (v4 : v1 = v2) => eq_ind_r (fun v5 : @R => v5 = v2) (eq_ind_r (fun v5 : @R => v5 = v2) eq_refl v4) v3) : Transitive eq |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Rri	100	1.752780	1	1	0	synth with cache (only 1: refine {| ring_setoid := @Rsth; ring_plus_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 + v3 = v1 + v4) (eq_ind_r (fun v6 : @R => v1 + v6 = v1 + v4) eq_refl v5) v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1) (v3 v4 : @R) (v5 : eq_notation v3 v4), eq_notation (v0 + v3) (v1 + v4)) : forall (v0 v1 : @R) (v2 : v0 == v1) (v3 v4 : @R) (v5 : v3 == v4), v0 + v3 == v1 + v4) : Proper (fun (v0 : forall v0 v1 : @R, @R) (v1 : forall v1 v2 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3) (v5 v6 : @R) (v7 : v5 == v6), v0 v2 v5 == v1 v3 v6) _+_) : Proper (_==_ ==> _==_ ==> _==_) _+_; ring_mult_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 * v3 = v1 * v4) (eq_ind_r (fun v6 : @R => v1 * v6 = v1 * v4) eq_refl v5) v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1) (v3 v4 : @R) (v5 : eq_notation v3 v4), eq_notation (v0 * v3) (v1 * v4)) : forall (v0 v1 : @R) (v2 : v0 == v1) (v3 v4 : @R) (v5 : v3 == v4), v0 * v3 == v1 * v4) : Proper (fun (v0 : forall v0 v1 : @R, @R) (v1 : forall v1 v2 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3) (v5 v6 : @R) (v7 : v5 == v6), v0 v2 v5 == v1 v3 v6) _*_) : Proper (_==_ ==> _==_ ==> _==_) _*_; ring_sub_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 - v3 = v1 - v4) (eq_ind_r (fun v6 : @R => v1 - v6 = v1 - v4) eq_refl v5) v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1) (v3 v4 : @R) (v5 : eq_notation v3 v4), eq_notation (v0 - v3) (v1 - v4)) : forall (v0 v1 : @R) (v2 : v0 == v1) (v3 v4 : @R) (v5 : v3 == v4), v0 - v3 == v1 - v4) : Proper (fun (v0 : forall v0 v1 : @R, @R) (v1 : forall v1 v2 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3) (v5 v6 : @R) (v7 : v5 == v6), v0 v2 v5 == v1 v3 v6) _-_) : Proper (_==_ ==> _==_ ==> _==_) _-_; ring_opp_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) => eq_ind_r (fun v3 : @R => - v3 = - v1) eq_refl v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1), eq_notation (- v0) (- v1)) : forall (v0 v1 : @R) (v2 : v0 == v1), - v0 == - v1) : Proper (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3), v0 v2 == v1 v3) -_) : Proper (_==_ ==> _==_) -_; ring_add_0_l := @Rplus_0_l; ring_add_comm := @Rplus_comm; ring_add_assoc := fun v0 v1 v2 : @R => symmetry (Rplus_assoc v0 v1 v2); ring_mul_1_l := @Rmult_1_l; ring_mul_1_r := @Rmult_1_r; ring_mul_assoc := fun v0 v1 v2 : @R => symmetry (Rmult_assoc v0 v1 v2); ring_distr_l := @Rmult_plus_distr_r; ring_distr_r := fun v0 v1 v2 : @R => Rmult_plus_distr_l v2 v0 v1; ring_sub_def := ((((fun v0 v1 : @R => eq_refl) : forall v0 v1 : @R, eq_notation (v0 - v1) (v0 + - v1)) : forall v0 v1 : @R, v0 - v1 == v0 + - v1) : forall v0 v1 : @R, v0 - v1 == v0 + - v1) : forall v0 v1 : @R, v0 - v1 == v0 + - v1; ring_opp_def := @Rplus_opp_r |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.R_one_zero	100	0.353615	1	1	0	synth with cache (only 1: refine ((fun v0 : IZR 1 = IZR 0 => let v1 : ConstructiveCauchyReals.CRealEq (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) := transitivity (symmetry (let v1 : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = IZR 1 := (eq_ind_r (fun v1 : @R => Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = v1) eq_refl (@R1_def) : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = IPR 1) : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = IZR 1 in eq_ind (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) (fun v2 : @R => ConstructiveCauchyReals.CRealEq (Rrepr v2) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) ((fun v2 : ConstructiveCauchyReals.CRealEq (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) => trans_co_eq_inv_impl_morphism (@ConstructiveCauchyReals.CRealEq_rel_Transitive) (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) v2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (eq_proper_proxy (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (Rquot2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) (reflexivity (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (IZR 1) v1)) (transitivity (eq_ind_r (fun v1 : @R => ConstructiveCauchyReals.CRealEq (Rrepr v1) (Rrepr (IZR 0))) (reflexivity (Rrepr (IZR 0))) v0) (let v1 : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) = IZR 0 := eq_ind_r (fun v1 : @R => Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) = v1) eq_refl (@R0_def) : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) = IZR 0 in eq_ind (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (fun v2 : @R => ConstructiveCauchyReals.CRealEq (Rrepr v2) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) ((fun v2 : ConstructiveCauchyReals.CRealEq (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) => trans_co_eq_inv_impl_morphism (@ConstructiveCauchyReals.CRealEq_rel_Transitive) (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) v2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (eq_proper_proxy (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (Rquot2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (reflexivity (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (IZR 0) v1)) in let v2 : CRelationClasses.iffT (ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) (ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) := ConstructiveCauchyReals.CRealLt_morph (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.CRealEq_refl (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) v1 in ConstructiveCauchyReals.CRealLt_irrefl (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (let v3 : forall v3 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) := match v2 as v3 in (_ * _)%type return (forall v4 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) with | (v3, v4) => (fun (v3 : forall v3 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (v4 : forall v4 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) => v3) v3 v4 end in v3 (@ConstructiveCauchyReals.CRealLt_0_1))) : IZR 1 <> IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Rcri	100	0.074376	1	1	0	synth with cache (only 1: refine (@Rmult_comm : Cring)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Rdi	100	0.080897	1	1	0	synth with cache (only 1: refine {| integral_domain_product := @Rmult_integral; integral_domain_one_zero := @R_one_zero |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Qri	100	0.096498	1	1	0	synth with cache (only 1: refine {| ring_setoid := @Q_Setoid; ring_plus_comp := @Qplus_comp; ring_mult_comp := @Qmult_comp; ring_sub_comp := @Qminus_comp; ring_opp_comp := @Qopp_comp; ring_add_0_l := @Qplus_0_l; ring_add_comm := @Qplus_comm; ring_add_assoc := @Qplus_assoc; ring_mul_1_l := @Qmult_1_l; ring_mul_1_r := @Qmult_1_r; ring_mul_assoc := @Qmult_assoc; ring_distr_l := @Qmult_plus_distr_l; ring_distr_r := fun v0 v1 v2 : @Q => Qmult_plus_distr_r v2 v0 v1; ring_sub_def := fun v0 v1 : @Q => reflexivity (_+_ v0 (-_ v1)); ring_opp_def := @Qplus_opp_r |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Q_one_zero	100	0.105312	1	1	0	synth with cache (only 1: refine (((fun v0 : (Qnum 1 * QDen 0)%Z = (Qnum 0 * QDen 1)%Z => let v1 : @False := eq_ind (Qnum 1 * QDen 0)%Z (fun v1 : @Z => match v1 as v2 in Z return Prop with | 0%Z => @False | Z.pos v2 => (fun v2 : @positive => @True) v2 | Z.neg v2 => (fun v2 : @positive => @False) v2 end) (@I) (Qnum 0 * QDen 1)%Z v0 in False_ind (@False) v1) : (Qnum 1 * QDen 0)%Z <> (Qnum 0 * QDen 1)%Z) : ~ 1 == 0)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Qcri	100	0.068586	1	1	0	synth with cache (only 1: refine (@Qmult_comm : Cring)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Qdi	100	0.077840	1	1	0	synth with cache (only 1: refine {| integral_domain_product := @Qmult_integral; integral_domain_one_zero := @Q_one_zero |}).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Z_one_zero	100	0.089603	1	1	0	synth with cache (only 1: refine ((fun v0 : 1%Z = 0%Z => (fun v1 : 1%Z = 0%Z => (fun v2 : 1%Z = 0%Z => let v3 : @False := eq_ind 1%Z (fun v3 : @Z => match v3 as v4 in Z return Prop with | 0%Z => @False | Z.pos v4 => (fun v4 : @positive => @True) v4 | Z.neg v4 => (fun v4 : @positive => @False) v4 end) (@I) 0%Z v2 in False_ind (@False) v3) v1) (Zegal_left 1 0 v0)) : 1%Z <> 0%Z)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Zcri	100	0.059111	1	1	0	synth with cache (only 1: refine (@Z.mul_comm : Cring)).
coq-tactician-stdlib.8.11.dev	Coq.nsatz.Nsatz.Zdi	100	0.064422	1	1	0	synth with cache (only 1: refine {| integral_domain_product := @Zmult_integral; integral_domain_one_zero := @Z_one_zero |}).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Rings_R.Rsth	100	0.056926	1	1	0	synth with cache (only 1: refine {| Equivalence_Reflexive := (fun v0 : @R => eq_refl) : Reflexive eq; Equivalence_Symmetric := (fun (v0 v1 : @R) (v2 : v0 = v1) => eq_ind_r (fun v3 : @R => v1 = v3) eq_refl v2) : Symmetric eq; Equivalence_Transitive := (fun (v0 v1 v2 : @R) (v3 : v0 = v1) (v4 : v1 = v2) => eq_ind_r (fun v5 : @R => v5 = v2) (eq_ind_r (fun v5 : @R => v5 = v2) eq_refl v4) v3) : Transitive eq |}).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Rings_R.Rri	100	1.771778	1	1	0	synth with cache (only 1: refine {| ring_setoid := @Rsth; ring_plus_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 + v3 = v1 + v4) (eq_ind_r (fun v6 : @R => v1 + v6 = v1 + v4) eq_refl v5) v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1) (v3 v4 : @R) (v5 : eq_notation v3 v4), eq_notation (v0 + v3) (v1 + v4)) : forall (v0 v1 : @R) (v2 : v0 == v1) (v3 v4 : @R) (v5 : v3 == v4), v0 + v3 == v1 + v4) : Proper (fun (v0 : forall v0 v1 : @R, @R) (v1 : forall v1 v2 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3) (v5 v6 : @R) (v7 : v5 == v6), v0 v2 v5 == v1 v3 v6) _+_) : Proper (_==_ ==> _==_ ==> _==_) _+_; ring_mult_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 * v3 = v1 * v4) (eq_ind_r (fun v6 : @R => v1 * v6 = v1 * v4) eq_refl v5) v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1) (v3 v4 : @R) (v5 : eq_notation v3 v4), eq_notation (v0 * v3) (v1 * v4)) : forall (v0 v1 : @R) (v2 : v0 == v1) (v3 v4 : @R) (v5 : v3 == v4), v0 * v3 == v1 * v4) : Proper (fun (v0 : forall v0 v1 : @R, @R) (v1 : forall v1 v2 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3) (v5 v6 : @R) (v7 : v5 == v6), v0 v2 v5 == v1 v3 v6) _*_) : Proper (_==_ ==> _==_ ==> _==_) _*_; ring_sub_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) (v3 v4 : @R) (v5 : v3 = v4) => eq_ind_r (fun v6 : @R => v6 - v3 = v1 - v4) (eq_ind_r (fun v6 : @R => v1 - v6 = v1 - v4) eq_refl v5) v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1) (v3 v4 : @R) (v5 : eq_notation v3 v4), eq_notation (v0 - v3) (v1 - v4)) : forall (v0 v1 : @R) (v2 : v0 == v1) (v3 v4 : @R) (v5 : v3 == v4), v0 - v3 == v1 - v4) : Proper (fun (v0 : forall v0 v1 : @R, @R) (v1 : forall v1 v2 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3) (v5 v6 : @R) (v7 : v5 == v6), v0 v2 v5 == v1 v3 v6) _-_) : Proper (_==_ ==> _==_ ==> _==_) _-_; ring_opp_comp := ((((fun (v0 v1 : @R) (v2 : v0 = v1) => eq_ind_r (fun v3 : @R => - v3 = - v1) eq_refl v2) : forall (v0 v1 : @R) (v2 : eq_notation v0 v1), eq_notation (- v0) (- v1)) : forall (v0 v1 : @R) (v2 : v0 == v1), - v0 == - v1) : Proper (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) => forall (v2 v3 : @R) (v4 : v2 == v3), v0 v2 == v1 v3) -_) : Proper (_==_ ==> _==_) -_; ring_add_0_l := @Rplus_0_l; ring_add_comm := @Rplus_comm; ring_add_assoc := fun v0 v1 v2 : @R => symmetry (Rplus_assoc v0 v1 v2); ring_mul_1_l := @Rmult_1_l; ring_mul_1_r := @Rmult_1_r; ring_mul_assoc := fun v0 v1 v2 : @R => symmetry (Rmult_assoc v0 v1 v2); ring_distr_l := @Rmult_plus_distr_r; ring_distr_r := fun v0 v1 v2 : @R => Rmult_plus_distr_l v2 v0 v1; ring_sub_def := ((((fun v0 v1 : @R => eq_refl) : forall v0 v1 : @R, eq_notation (v0 - v1) (v0 + - v1)) : forall v0 v1 : @R, v0 - v1 == v0 + - v1) : forall v0 v1 : @R, v0 - v1 == v0 + - v1) : forall v0 v1 : @R, v0 - v1 == v0 + - v1; ring_opp_def := @Rplus_opp_r |}).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Rings_R.Rcri	100	0.074335	1	1	0	synth with cache (only 1: refine (@Rmult_comm : Cring)).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Rings_R.R_one_zero	100	0.310546	1	1	0	synth with cache (only 1: refine ((fun v0 : IZR 1 = IZR 0 => let v1 : ConstructiveCauchyReals.CRealEq (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) := transitivity (symmetry (let v1 : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = IZR 1 := (eq_ind_r (fun v1 : @R => Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = v1) eq_refl (@R1_def) : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = IPR 1) : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) = IZR 1 in eq_ind (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) (fun v2 : @R => ConstructiveCauchyReals.CRealEq (Rrepr v2) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) ((fun v2 : ConstructiveCauchyReals.CRealEq (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) => trans_co_eq_inv_impl_morphism (@ConstructiveCauchyReals.CRealEq_rel_Transitive) (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) v2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (eq_proper_proxy (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (Rquot2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) (reflexivity (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}))) (IZR 1) v1)) (transitivity (eq_ind_r (fun v1 : @R => ConstructiveCauchyReals.CRealEq (Rrepr v1) (Rrepr (IZR 0))) (reflexivity (Rrepr (IZR 0))) v0) (let v1 : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) = IZR 0 := eq_ind_r (fun v1 : @R => Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) = v1) eq_refl (@R0_def) : Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) = IZR 0 in eq_ind (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (fun v2 : @R => ConstructiveCauchyReals.CRealEq (Rrepr v2) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) ((fun v2 : ConstructiveCauchyReals.CRealEq (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) => trans_co_eq_inv_impl_morphism (@ConstructiveCauchyReals.CRealEq_rel_Transitive) (Rrepr (Rabst (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) v2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (eq_proper_proxy (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (Rquot2 (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (reflexivity (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}))) (IZR 0) v1)) in let v2 : CRelationClasses.iffT (ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) (ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) := ConstructiveCauchyReals.CRealLt_morph (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.CRealEq_refl (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) v1 in ConstructiveCauchyReals.CRealLt_irrefl (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (let v3 : forall v3 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) := match v2 as v3 in (_ * _)%type return (forall v4 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) with | (v3, v4) => (fun (v3 : forall v3 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |})) (v4 : forall v4 : ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}), ConstructiveCauchyReals.CRealLt (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 0; QArith_base.Qden := 1 |}) (ConstructiveCauchyReals.inject_Q {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |})) => v3) v3 v4 end in v3 (@ConstructiveCauchyReals.CRealLt_0_1))) : IZR 1 <> IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.setoid_ring.Rings_R.Rdi	100	0.082062	1	1	0	synth with cache (only 1: refine {| integral_domain_product := @Rmult_integral; integral_domain_one_zero := @R_one_zero |}).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.FTCN_step1	100	0.249482	1	1	0	synth with cache (only 1: refine (fun (v0 : @Differential) (v1 v2 : @R) => exist (fun v3 : forall v3 : @R, @R => antiderivative (fun v4 : @R => derive_pt v0 v4 (cond_diff v0 v4)) v3 v1 v2 \/ antiderivative (fun v4 : @R => derive_pt v0 v4 (cond_diff v0 v4)) v3 v2 v1) v0 (match Rle_dec v1 v2 as v3 in ({_} + {_}) return ((forall (v4 : @R) (v5 : v1 <= v4 <= v2), exists v6 : derivable_pt v0 v4, derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) /\ v1 <= v2 \/ (forall (v4 : @R) (v5 : v2 <= v4 <= v1), exists v6 : derivable_pt v0 v4, derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) /\ v2 <= v1) with | left v3 => (fun v3 : v1 <= v2 => or_introl (conj (fun (v4 : @R) (v5 : v1 <= v4 <= v2) => ex_intro (fun v6 : derivable_pt v0 v4 => derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) (cond_diff v0 v4) eq_refl) v3)) v3 | right v3 => (fun v3 : ~ v1 <= v2 => or_intror (conj (fun (v4 : @R) (v5 : v2 <= v4 <= v1) => ex_intro (fun v6 : derivable_pt v0 v4 => derive_pt v0 v4 (cond_diff v0 v4) = derive_pt v0 v4 v6) (cond_diff v0 v4) eq_refl) (Rlt_le v2 v1 (Rnot_le_lt v1 v2 v3)))) v3 end : antiderivative (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v0 v1 v2 \/ antiderivative (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v0 v2 v1) : Newton_integrable (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v1 v2)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.FTC_Newton	100	0.086635	1	1	0	synth with cache (only 1: refine (fun (v0 : @Differential) (v1 v2 : @R) => eq_refl : NewtonInt (fun v3 : @R => derive_pt v0 v3 (cond_diff v0 v3)) v1 v2 (FTCN_step1 v0 v1 v2) = v0 v2 - v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P1	100	0.193688	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : @R) => exist (fun v2 : forall v2 : @R, @R => antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) (fct_cte (v0 v1) * @id)%F (or_introl (conj (fun (v2 : @R) (v3 : v1 <= v2 <= v1) => let v4 : derivable_pt (fct_cte (v0 v1) * @id) v2 := derivable_pt_mult (fct_cte (v0 v1)) (@id) v2 (derivable_pt_const (v0 v1) v2) (derivable_pt_id v2) in ex_intro (fun v5 : derivable_pt (fct_cte (v0 v1) * @id) v2 => v0 v2 = derive_pt (fct_cte (v0 v1) * @id) v2 v5) v4 (let v5 : v2 = v1 := and_ind (fun (v5 : v1 <= v2) (v6 : v2 <= v1) => Rle_antisym v2 v1 v6 v5) v3 in eq_sym (derive_pt_eq_0 (fct_cte (v0 v1) * @id)%F v2 (v0 v2) v4 (let v6 : IZR 0 * id v2 + fct_cte (v0 v1) v2 * IZR 1 = v0 v2 := (eq_ind_r (fun v6 : @R => IZR 0 * v6 + v0 v1 * IZR 1 = v0 v6) (let v6 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v7 : list (@R) := (v1 :: v0 v1 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v7 v6 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEc 1%Z))) (Ring_polynom.PEX (@Z) 2) (@I) (eq_refl : (let v8 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v6 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEc 1%Z)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEX (@Z) 2))) = @true)) v5 : IZR 0 * v2 + fct_cte (v0 v1) v2 * IZR 1 = v0 v2) : IZR 0 * id v2 + fct_cte (v0 v1) v2 * IZR 1 = v0 v2 in eq_ind (IZR 0 * id v2 + fct_cte (v0 v1) v2 * IZR 1) (fun v7 : @R => derivable_pt_lim (fct_cte (v0 v1) * @id) v2 v7) (derivable_pt_lim_mult (fct_cte (v0 v1)) (@id) v2 (IZR 0) (IZR 1) (derivable_pt_lim_const (v0 v1) v2) (derivable_pt_lim_id v2)) (v0 v2) v6)))) (or_intror eq_refl) : antiderivative v0 (fct_cte (v0 v1) * @id)%F v1 v1)) : Newton_integrable v0 v1 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P2	100	0.136965	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : @R) => (((((let v2 : Newton_integrable v0 v1 v1 := NewtonInt_P1 v0 v1 in match v2 as v3 in (sig _) return (match v3 as v4 in (sig _) return (@R) with | exist _ v4 v5 => (fun (v4 : forall v4 : @R, @R) (v5 : antiderivative v0 v4 v1 v1 \/ antiderivative v0 v4 v1 v1) => v4 v1 - v4 v1) v4 v5 end = IZR 0) with | exist _ v3 v4 => (fun (v3 : forall v3 : @R, @R) (v4 : antiderivative v0 v3 v1 v1 \/ antiderivative v0 v3 v1 v1) => Rminus_diag_eq (v3 v1) (v3 v1) eq_refl) v3 v4 end) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : match NewtonInt_P1 v0 v1 as v2 in (sig _) return (@R) with | exist _ v2 v3 => (fun (v2 : forall v2 : @R, @R) (v3 : antiderivative v0 v2 v1 v1 \/ antiderivative v0 v2 v1 v1) => v2 v1 - v2 v1) v2 v3 end = IZR 0) : NewtonInt v0 v1 v1 (NewtonInt_P1 v0 v1) = IZR 0)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P3	100	0.085361	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : {v3 : forall v3 : @R, @R | antiderivative v0 v3 v1 v2 \/ antiderivative v0 v3 v2 v1}) => sig_rec (fun v4 : {v4 : forall v4 : @R, @R | antiderivative v0 v4 v1 v2 \/ antiderivative v0 v4 v2 v1} => {v5 : forall v5 : @R, @R | antiderivative v0 v5 v2 v1 \/ antiderivative v0 v5 v1 v2}) (fun (v4 : forall v4 : @R, @R) (v5 : antiderivative v0 v4 v1 v2 \/ antiderivative v0 v4 v2 v1) => exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v2 v1 \/ antiderivative v0 v6 v1 v2) v4 (or_ind (fun v6 : antiderivative v0 v4 v1 v2 => or_intror v6) (fun v6 : antiderivative v0 v4 v2 v1 => or_introl v6) v5)) v3) : forall (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : Newton_integrable v0 v1 v2), Newton_integrable v0 v2 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P4	100	0.457820	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 : @R) (v3 : Newton_integrable v0 v1 v2) => match v3 as v4 in (sig _) return (NewtonInt v0 v1 v2 v4 = - NewtonInt v0 v2 v1 (NewtonInt_P3 v0 v1 v2 v4)) with | exist _ v4 v5 => (fun (v4 : forall v4 : @R, @R) (v5 : antiderivative v0 v4 v1 v2 \/ antiderivative v0 v4 v2 v1) => (((let v6 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v7 : list (@R) := (v4 v2 :: v4 v1 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v7 v6 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEopp (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 1))) (@I) (eq_refl : (let v8 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v6 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v8 (Ring_polynom.PEopp (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 1))))) = @true)) : v4 v2 - v4 v1 = - match sig_rec (fun v6 : {v6 : forall v6 : @R, @R | antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1} => {v7 : forall v7 : @R, @R | antiderivative v0 v7 v2 v1 \/ antiderivative v0 v7 v1 v2}) (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) => exist (fun v8 : forall v8 : @R, @R => antiderivative v0 v8 v2 v1 \/ antiderivative v0 v8 v1 v2) v6 (or_ind (fun v8 : antiderivative v0 v6 v1 v2 => or_intror v8) (fun v8 : antiderivative v0 v6 v2 v1 => or_introl v8) v7)) (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5) as v6 in (sig _) return (@R) with | exist _ v6 v7 => (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v2 v1 \/ antiderivative v0 v6 v1 v2) => v6 v1 - v6 v2) v6 v7 end) : v4 v2 - v4 v1 = - match NewtonInt_P3 v0 v1 v2 (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5) as v6 in (sig _) return (@R) with | exist _ v6 v7 => (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v2 v1 \/ antiderivative v0 v6 v1 v2) => v6 v1 - v6 v2) v6 v7 end) : NewtonInt v0 v1 v2 (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5) = - NewtonInt v0 v2 v1 (NewtonInt_P3 v0 v1 v2 (exist (fun v6 : forall v6 : @R, @R => antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) v4 v5))) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P5	100	5.406594	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 v3 v4 : @R) (v5 : {v5 : forall v5 : @R, @R | antiderivative v0 v5 v3 v4 \/ antiderivative v0 v5 v4 v3}) (v6 : {v6 : forall v6 : @R, @R | antiderivative v1 v6 v3 v4 \/ antiderivative v1 v6 v4 v3}) => sig_rec (fun v7 : {v7 : forall v7 : @R, @R | antiderivative v0 v7 v3 v4 \/ antiderivative v0 v7 v4 v3} => {v8 : forall v8 : @R, @R | antiderivative (fun v9 : @R => v2 * v0 v9 + v1 v9) v8 v3 v4 \/ antiderivative (fun v9 : @R => v2 * v0 v9 + v1 v9) v8 v4 v3}) (fun (v7 : forall v7 : @R, @R) (v8 : antiderivative v0 v7 v3 v4 \/ antiderivative v0 v7 v4 v3) => sig_rec (fun v9 : {v9 : forall v9 : @R, @R | antiderivative v1 v9 v3 v4 \/ antiderivative v1 v9 v4 v3} => {v10 : forall v10 : @R, @R | antiderivative (fun v11 : @R => v2 * v0 v11 + v1 v11) v10 v3 v4 \/ antiderivative (fun v11 : @R => v2 * v0 v11 + v1 v11) v10 v4 v3}) (fun (v9 : forall v9 : @R, @R) (v10 : antiderivative v1 v9 v3 v4 \/ antiderivative v1 v9 v4 v3) => exist (fun v11 : forall v11 : @R, @R => antiderivative (fun v12 : @R => v2 * v0 v12 + v1 v12) v11 v3 v4 \/ antiderivative (fun v12 : @R => v2 * v0 v12 + v1 v12) v11 v4 v3) (fun v11 : @R => v2 * v7 v11 + v9 v11) (or_ind (fun v11 : antiderivative v0 v7 v3 v4 => or_ind (fun v12 : antiderivative v1 v9 v3 v4 => or_introl (and_ind (fun (v13 : forall (v13 : @R) (v14 : v3 <= v13 <= v4), exists v15 : derivable_pt v7 v13, v0 v13 = derive_pt v7 v13 v15) (v14 : v3 <= v4) => and_ind (fun (v15 : forall (v15 : @R) (v16 : v3 <= v15 <= v4), exists v17 : derivable_pt v9 v15, v1 v15 = derive_pt v9 v15 v17) (v16 : v3 <= v4) => conj (fun (v17 : @R) (v18 : v3 <= v17 <= v4) => ex_ind (ex_ind (fun (v19 : derivable_pt v9 v17) (v20 : v1 v17 = derive_pt v9 v17 v19) (v21 : derivable_pt v7 v17) (v22 : v0 v17 = derive_pt v7 v17 v21) => let v23 : derivable_pt (fun v23 : @R => v2 * v7 v23 + v9 v23) v17 := derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19 in ex_intro (fun v24 : derivable_pt (fun v24 : @R => v2 * v7 v24 + v9 v24) v17 => v2 * v0 v17 + v1 v17 = derive_pt (fun v25 : @R => v2 * v7 v25 + v9 v25) v17 v24) v23 (eq_sym (let v24 : derive_pt (fct_cte v2 * v7 + v9) v17 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19) = derive_pt (fun v24 : @R => v2 * v7 v24 + v9 v24) v17 v23 := pr_nu (fun v24 : @R => v2 * v7 v24 + v9 v24) v17 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19) v23 in eq_ind (derive_pt (fct_cte v2 * v7 + v9) v17 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19)) (fun v25 : @R => v25 = v2 * v0 v17 + v1 v17) (eq_ind_r (fun v25 : @R => v25 = v2 * v0 v17 + v1 v17) (eq_ind_r (fun v25 : @R => v25 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) (eq_ind_r (fun v25 : @R => v25 * v7 v17 + fct_cte v2 v17 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) ((let v25 : list (@R) := (IZR 0 * v7 v17 + v2 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 :: v2 * v0 v17 + v1 v17 :: nil)%list in ((fun v26 : v25 = (IZR 0 * v7 v17 + v2 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 :: v2 * v0 v17 + v1 v17 :: nil)%list => let v27 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v28 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v29 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v27 = v28 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v27 = v28 in let v30 : forall (v30 : Ring_polynom.PExpr (@Z)) (v31 : Ring_polynom.Pol (@Z)) (v32 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 v30 = v31), Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v30 = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v31 := RField_ring_lemma2 (@ring_subst_niter) v27 (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) (@I) v28 v29 in let v31 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v32 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v31 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v31 in let v33 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v31 := v30 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) v31 v32 in eq_ind_r (fun v34 : @R => v34 = v2 * v0 v17 + v1 v17) (let v34 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v35 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v34 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v34 in let v36 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v34 := v30 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) v34 v35 in eq_ind (v1 v17) (fun v37 : @R => v2 * derive_pt v7 v17 v21 + v37 = v2 * v0 v17 + v1 v17) (eq_ind (v0 v17) (fun v37 : @R => v2 * v37 + v1 v17 = v2 * v0 v17 + v1 v17) eq_refl (derive_pt v7 v17 v21) v22) (derive_pt v9 v17 v19) v20) v33) : forall v26 : v25 = v25, IZR 0 * v7 v17 + v2 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) eq_refl) : IZR 0 * v7 v17 + fct_cte v2 v17 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) (derive_pt_const v2 v17)) (derive_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21)) (derive_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19)) (derive_pt (fun v25 : @R => v2 * v7 v25 + v9 v25) v17 v23) v24))) (v15 v17 v18)) (v13 v17 v18)) v14) v12) v11 : antiderivative (fun v13 : @R => v2 * v0 v13 + v1 v13) (fun v13 : @R => v2 * v7 v13 + v9 v13) v3 v4)) (fun v12 : antiderivative v1 v9 v4 v3 => and_ind (and_ind (fun (v13 : forall (v13 : @R) (v14 : v4 <= v13 <= v3), exists v15 : derivable_pt v9 v13, v1 v13 = derive_pt v9 v13 v15) (v14 : v4 <= v3) (v15 : forall (v15 : @R) (v16 : v3 <= v15 <= v4), exists v17 : derivable_pt v7 v15, v0 v15 = derive_pt v7 v15 v17) (v16 : v3 <= v4) => or_ind (fun v17 : v3 < v4 => False_ind (antiderivative (fun v18 : @R => v2 * v0 v18 + v1 v18) (fun v18 : @R => v2 * v7 v18 + v9 v18) v3 v4 \/ antiderivative (fun v18 : @R => v2 * v0 v18 + v1 v18) (fun v18 : @R => v2 * v7 v18 + v9 v18) v4 v3) (Rlt_irrefl v3 (Rlt_le_trans v3 v4 v3 v17 v14))) (fun v17 : v3 = v4 => or_introl (eq_ind v3 (fun v18 : @R => antiderivative (fun v19 : @R => v2 * v0 v19 + v1 v19) (fun v19 : @R => v2 * v7 v19 + v9 v19) v3 v18) (conj (fun (v18 : @R) (v19 : v3 <= v18 <= v3) => and_ind (fun (v20 : v3 <= v18) (v21 : v18 <= v3) => let v22 : v18 = v3 := Rle_antisym v18 v3 v21 v20 in let v23 : v3 <= v18 <= v4 := conj (or_intror (eq_sym v22)) (or_intror (eq_ind v3 (fun v23 : @R => v18 = v23) v22 v4 v17)) in let v24 : v4 <= v18 <= v3 := conj (or_intror (eq_ind v3 (fun v24 : @R => v24 = v18) (eq_sym v22) v4 v17)) (or_intror v22) in let v25 : derivable_pt v7 v18 := exist (fun v25 : @R => derivable_pt_abs v7 v18 v25) (v0 v18) (ex_ind (fun (v25 : derivable_pt v7 v18) (v26 : v0 v18 = derive_pt v7 v18 v25) => derive_pt_eq_1 v7 v18 (v0 v18) v25 (eq_sym v26)) (v15 v18 v23)) : derivable_pt v7 v18 in let v26 : derivable_pt v9 v18 := exist (fun v26 : @R => derivable_pt_abs v9 v18 v26) (v1 v18) (ex_ind (fun (v26 : derivable_pt v9 v18) (v27 : v1 v18 = derive_pt v9 v18 v26) => derive_pt_eq_1 v9 v18 (v1 v18) v26 (eq_sym v27)) (v13 v18 v24)) : derivable_pt v9 v18 in let v27 : derivable_pt (fun v27 : @R => v2 * v7 v27 + v9 v27) v18 := derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26 in ex_intro (fun v28 : derivable_pt (fun v28 : @R => v2 * v7 v28 + v9 v28) v18 => v2 * v0 v18 + v1 v18 = derive_pt (fun v29 : @R => v2 * v7 v29 + v9 v29) v18 v28) v27 (eq_sym (let v28 : derive_pt (fct_cte v2 * v7 + v9) v18 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26) = derive_pt (fun v28 : @R => v2 * v7 v28 + v9 v28) v18 v27 := pr_nu (fun v28 : @R => v2 * v7 v28 + v9 v28) v18 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26) v27 in eq_ind (derive_pt (fct_cte v2 * v7 + v9) v18 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26)) (fun v29 : @R => v29 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v29 : @R => v29 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v29 : @R => v29 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v29 : @R => v29 * v7 v18 + fct_cte v2 v18 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) ((let v29 : list (@R) := (IZR 0 * v7 v18 + v2 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 :: v2 * v0 v18 + v1 v18 :: nil)%list in ((fun v30 : v29 = (IZR 0 * v7 v18 + v2 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 :: v2 * v0 v18 + v1 v18 :: nil)%list => let v31 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v32 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v33 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v31 = v32 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v31 = v32 in let v34 : forall (v34 : Ring_polynom.PExpr (@Z)) (v35 : Ring_polynom.Pol (@Z)) (v36 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 v34 = v35), Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v34 = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v35 := RField_ring_lemma2 (@ring_subst_niter) v31 (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) (@I) v32 v33 in let v35 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v36 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v35 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v35 in let v37 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v35 := v34 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) v35 v36 in eq_ind_r (fun v38 : @R => v38 = v2 * v0 v18 + v1 v18) (let v38 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v39 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v38 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v38 in let v40 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v38 := v34 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) v38 v39 in let v41 : derive_pt v9 v18 v26 = v1 v18 := ex_ind (fun (v41 : derivable_pt v9 v18) (v42 : v1 v18 = derive_pt v9 v18 v41) => eq_ind_r (fun v43 : @R => derive_pt v9 v18 v26 = v43) (pr_nu v9 v18 v26 v41) v42) (v13 v18 v24) in let v42 : derive_pt v7 v18 v25 = v0 v18 := ex_ind (fun (v42 : derivable_pt v7 v18) (v43 : v0 v18 = derive_pt v7 v18 v42) => eq_ind_r (fun v44 : @R => derive_pt v7 v18 v25 = v44) (pr_nu v7 v18 v25 v42) v43) (v15 v18 v23) in eq_ind_r (fun v43 : @R => v2 * derive_pt v7 v18 v25 + v43 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v43 : @R => v2 * v43 + v1 v18 = v2 * v0 v18 + v1 v18) (let v43 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v44 : list (@R) := (v2 :: v0 v18 :: v1 v18 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v44 v43 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (@I) (eq_refl : (let v45 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v43 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v45 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v45 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)))) = @true)) v42) v41) v37) : forall v30 : v29 = v29, IZR 0 * v7 v18 + v2 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) eq_refl) : IZR 0 * v7 v18 + fct_cte v2 v18 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) (derive_pt_const v2 v18)) (derive_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25)) (derive_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26)) (derive_pt (fun v29 : @R => v2 * v7 v29 + v9 v29) v18 v27) v28))) v19) (or_intror eq_refl) : antiderivative (fun v18 : @R => v2 * v0 v18 + v1 v18) (fun v18 : @R => v2 * v7 v18 + v9 v18) v3 v3) v4 v17)) v16) v12) v11) v10) (fun v11 : antiderivative v0 v7 v4 v3 => or_ind (fun v12 : antiderivative v1 v9 v3 v4 => and_ind (and_ind (fun (v13 : forall (v13 : @R) (v14 : v3 <= v13 <= v4), exists v15 : derivable_pt v9 v13, v1 v13 = derive_pt v9 v13 v15) (v14 : v3 <= v4) (v15 : forall (v15 : @R) (v16 : v4 <= v15 <= v3), exists v17 : derivable_pt v7 v15, v0 v15 = derive_pt v7 v15 v17) (v16 : v4 <= v3) => or_ind (fun v17 : v4 < v3 => False_ind (antiderivative (fun v18 : @R => v2 * v0 v18 + v1 v18) (fun v18 : @R => v2 * v7 v18 + v9 v18) v3 v4 \/ antiderivative (fun v18 : @R => v2 * v0 v18 + v1 v18) (fun v18 : @R => v2 * v7 v18 + v9 v18) v4 v3) (Rlt_irrefl v4 (Rlt_le_trans v4 v3 v4 v17 v14))) (fun v17 : v4 = v3 => or_introl (eq_ind_r (fun v18 : @R => antiderivative (fun v19 : @R => v2 * v0 v19 + v1 v19) (fun v19 : @R => v2 * v7 v19 + v9 v19) v3 v18) (conj (fun (v18 : @R) (v19 : v3 <= v18 <= v3) => and_ind (fun (v20 : v3 <= v18) (v21 : v18 <= v3) => let v22 : v18 = v3 := Rle_antisym v18 v3 v21 v20 in let v23 : v3 <= v18 <= v4 := conj (or_intror (eq_sym v22)) (or_intror (eq_ind_r (fun v23 : @R => v18 = v23) v22 v17)) in let v24 : v4 <= v18 <= v3 := conj (or_intror (eq_ind_r (fun v24 : @R => v24 = v18) (eq_sym v22) v17)) (or_intror v22) in let v25 : derivable_pt v7 v18 := exist (fun v25 : @R => derivable_pt_abs v7 v18 v25) (v0 v18) (ex_ind (fun (v25 : derivable_pt v7 v18) (v26 : v0 v18 = derive_pt v7 v18 v25) => derive_pt_eq_1 v7 v18 (v0 v18) v25 (eq_sym v26)) (v15 v18 v24)) : derivable_pt v7 v18 in let v26 : derivable_pt v9 v18 := exist (fun v26 : @R => derivable_pt_abs v9 v18 v26) (v1 v18) (ex_ind (fun (v26 : derivable_pt v9 v18) (v27 : v1 v18 = derive_pt v9 v18 v26) => derive_pt_eq_1 v9 v18 (v1 v18) v26 (eq_sym v27)) (v13 v18 v23)) : derivable_pt v9 v18 in let v27 : derivable_pt (fun v27 : @R => v2 * v7 v27 + v9 v27) v18 := derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26 in ex_intro (fun v28 : derivable_pt (fun v28 : @R => v2 * v7 v28 + v9 v28) v18 => v2 * v0 v18 + v1 v18 = derive_pt (fun v29 : @R => v2 * v7 v29 + v9 v29) v18 v28) v27 (eq_sym (let v28 : derive_pt (fct_cte v2 * v7 + v9) v18 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26) = derive_pt (fun v28 : @R => v2 * v7 v28 + v9 v28) v18 v27 := pr_nu (fun v28 : @R => v2 * v7 v28 + v9 v28) v18 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26) v27 in eq_ind (derive_pt (fct_cte v2 * v7 + v9) v18 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26)) (fun v29 : @R => v29 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v29 : @R => v29 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v29 : @R => v29 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v29 : @R => v29 * v7 v18 + fct_cte v2 v18 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) ((let v29 : list (@R) := (IZR 0 * v7 v18 + v2 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 :: v2 * v0 v18 + v1 v18 :: nil)%list in ((fun v30 : v29 = (IZR 0 * v7 v18 + v2 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 :: v2 * v0 v18 + v1 v18 :: nil)%list => let v31 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v32 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v33 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v31 = v32 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v31 = v32 in let v34 : forall (v34 : Ring_polynom.PExpr (@Z)) (v35 : Ring_polynom.Pol (@Z)) (v36 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 v34 = v35), Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v34 = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v35 := RField_ring_lemma2 (@ring_subst_niter) v31 (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) (@I) v32 v33 in let v35 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v36 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v35 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v35 in let v37 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v35 := v34 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) v35 v36 in eq_ind_r (fun v38 : @R => v38 = v2 * v0 v18 + v1 v18) (let v38 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v39 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v38 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v32 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v38 in let v40 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v18 :: v2 :: derive_pt v7 v18 v25 :: derive_pt v9 v18 v26 :: v0 v18 :: v1 v18 :: nil) v38 := v34 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) v38 v39 in let v41 : derive_pt v9 v18 v26 = v1 v18 := ex_ind (fun (v41 : derivable_pt v9 v18) (v42 : v1 v18 = derive_pt v9 v18 v41) => eq_ind_r (fun v43 : @R => derive_pt v9 v18 v26 = v43) (pr_nu v9 v18 v26 v41) v42) (v13 v18 v23) in let v42 : derive_pt v7 v18 v25 = v0 v18 := ex_ind (fun (v42 : derivable_pt v7 v18) (v43 : v0 v18 = derive_pt v7 v18 v42) => eq_ind_r (fun v44 : @R => derive_pt v7 v18 v25 = v44) (pr_nu v7 v18 v25 v42) v43) (v15 v18 v24) in eq_ind_r (fun v43 : @R => v2 * derive_pt v7 v18 v25 + v43 = v2 * v0 v18 + v1 v18) (eq_ind_r (fun v43 : @R => v2 * v43 + v1 v18 = v2 * v0 v18 + v1 v18) (let v43 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v44 : list (@R) := (v2 :: v0 v18 :: v1 v18 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v44 v43 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (@I) (eq_refl : (let v45 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v43 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v45 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v45 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)))) = @true)) v42) v41) v37) : forall v30 : v29 = v29, IZR 0 * v7 v18 + v2 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) eq_refl) : IZR 0 * v7 v18 + fct_cte v2 v18 * derive_pt v7 v18 v25 + derive_pt v9 v18 v26 = v2 * v0 v18 + v1 v18) (derive_pt_const v2 v18)) (derive_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25)) (derive_pt_plus (fct_cte v2 * v7)%F v9 v18 (derivable_pt_mult (fct_cte v2) v7 v18 (derivable_pt_const v2 v18) v25) v26)) (derive_pt (fun v29 : @R => v2 * v7 v29 + v9 v29) v18 v27) v28))) v19) (or_intror eq_refl) : antiderivative (fun v18 : @R => v2 * v0 v18 + v1 v18) (fun v18 : @R => v2 * v7 v18 + v9 v18) v3 v3) v17)) v16) v12) v11) (fun v12 : antiderivative v1 v9 v4 v3 => or_intror (and_ind (fun (v13 : forall (v13 : @R) (v14 : v4 <= v13 <= v3), exists v15 : derivable_pt v7 v13, v0 v13 = derive_pt v7 v13 v15) (v14 : v4 <= v3) => and_ind (fun (v15 : forall (v15 : @R) (v16 : v4 <= v15 <= v3), exists v17 : derivable_pt v9 v15, v1 v15 = derive_pt v9 v15 v17) (v16 : v4 <= v3) => conj (fun (v17 : @R) (v18 : v4 <= v17 <= v3) => ex_ind (ex_ind (fun (v19 : derivable_pt v9 v17) (v20 : v1 v17 = derive_pt v9 v17 v19) (v21 : derivable_pt v7 v17) (v22 : v0 v17 = derive_pt v7 v17 v21) => let v23 : derivable_pt (fun v23 : @R => v2 * v7 v23 + v9 v23) v17 := derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19 in ex_intro (fun v24 : derivable_pt (fun v24 : @R => v2 * v7 v24 + v9 v24) v17 => v2 * v0 v17 + v1 v17 = derive_pt (fun v25 : @R => v2 * v7 v25 + v9 v25) v17 v24) v23 (eq_sym (let v24 : derive_pt (fct_cte v2 * v7 + v9) v17 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19) = derive_pt (fun v24 : @R => v2 * v7 v24 + v9 v24) v17 v23 := pr_nu (fun v24 : @R => v2 * v7 v24 + v9 v24) v17 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19) v23 in eq_ind (derive_pt (fct_cte v2 * v7 + v9) v17 (derivable_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19)) (fun v25 : @R => v25 = v2 * v0 v17 + v1 v17) (eq_ind_r (fun v25 : @R => v25 = v2 * v0 v17 + v1 v17) (eq_ind_r (fun v25 : @R => v25 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) (eq_ind_r (fun v25 : @R => v25 * v7 v17 + fct_cte v2 v17 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) ((let v25 : list (@R) := (IZR 0 * v7 v17 + v2 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 :: v2 * v0 v17 + v1 v17 :: nil)%list in ((fun v26 : v25 = (IZR 0 * v7 v17 + v2 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 :: v2 * v0 v17 + v1 v17 :: nil)%list => let v27 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v28 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v29 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v27 = v28 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v27 = v28 in let v30 : forall (v30 : Ring_polynom.PExpr (@Z)) (v31 : Ring_polynom.Pol (@Z)) (v32 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 v30 = v31), Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v30 = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v31 := RField_ring_lemma2 (@ring_subst_niter) v27 (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) (@I) v28 v29 in let v31 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v32 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v31 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v31 in let v33 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v31 := v30 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) v31 v32 in eq_ind_r (fun v34 : @R => v34 = v2 * v0 v17 + v1 v17) (let v34 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v35 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v34 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v28 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v34 in let v36 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v7 v17 :: v2 :: derive_pt v7 v17 v21 :: derive_pt v9 v17 v19 :: v0 v17 :: v1 v17 :: nil) v34 := v30 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) v34 v35 in eq_ind (v1 v17) (fun v37 : @R => v2 * derive_pt v7 v17 v21 + v37 = v2 * v0 v17 + v1 v17) (eq_ind (v0 v17) (fun v37 : @R => v2 * v37 + v1 v17 = v2 * v0 v17 + v1 v17) eq_refl (derive_pt v7 v17 v21) v22) (derive_pt v9 v17 v19) v20) v33) : forall v26 : v25 = v25, IZR 0 * v7 v17 + v2 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) eq_refl) : IZR 0 * v7 v17 + fct_cte v2 v17 * derive_pt v7 v17 v21 + derive_pt v9 v17 v19 = v2 * v0 v17 + v1 v17) (derive_pt_const v2 v17)) (derive_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21)) (derive_pt_plus (fct_cte v2 * v7)%F v9 v17 (derivable_pt_mult (fct_cte v2) v7 v17 (derivable_pt_const v2 v17) v21) v19)) (derive_pt (fun v25 : @R => v2 * v7 v25 + v9 v25) v17 v23) v24))) (v15 v17 v18)) (v13 v17 v18)) v14) v12) v11 : antiderivative (fun v13 : @R => v2 * v0 v13 + v1 v13) (fun v13 : @R => v2 * v7 v13 + v9 v13) v4 v3)) v10) v8)) v6) v5) : forall (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 v3 v4 : @R) (v5 : Newton_integrable v0 v3 v4) (v6 : Newton_integrable v1 v3 v4), Newton_integrable (fun v7 : @R => v2 * v0 v7 + v1 v7) v3 v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P1	100	1.017687	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 v6 : @R) (v7 : (forall (v7 : @R) (v8 : v5 <= v7 <= v6), exists v9 : derivable_pt v2 v7, v0 v7 = derive_pt v2 v7 v9) /\ v5 <= v6) (v8 : (forall (v8 : @R) (v9 : v5 <= v8 <= v6), exists v10 : derivable_pt v3 v8, v1 v8 = derive_pt v3 v8 v10) /\ v5 <= v6) => and_ind (and_ind (fun (v9 : forall (v9 : @R) (v10 : v5 <= v9 <= v6), exists v11 : derivable_pt v3 v9, v1 v9 = derive_pt v3 v9 v11) (v10 : v5 <= v6) (v11 : forall (v11 : @R) (v12 : v5 <= v11 <= v6), exists v13 : derivable_pt v2 v11, v0 v11 = derive_pt v2 v11 v13) (v12 : v5 <= v6) => conj (fun (v13 : @R) (v14 : v5 <= v13 <= v6) => ex_ind (ex_ind (fun (v15 : derivable_pt v2 v13) (v16 : v0 v13 = derive_pt v2 v13 v15) (v17 : derivable_pt v3 v13) (v18 : v1 v13 = derive_pt v3 v13 v17) => let v19 : derivable_pt (fun v19 : @R => v4 * v2 v19 + v3 v19) v13 := derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17 in ex_intro (fun v20 : derivable_pt (fun v20 : @R => v4 * v2 v20 + v3 v20) v13 => v4 * v0 v13 + v1 v13 = derive_pt (fun v21 : @R => v4 * v2 v21 + v3 v21) v13 v20) v19 (eq_sym (let v20 : derive_pt (fct_cte v4 * v2 + v3) v13 (derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17) = derive_pt (fun v20 : @R => v4 * v2 v20 + v3 v20) v13 v19 := pr_nu (fun v20 : @R => v4 * v2 v20 + v3 v20) v13 (derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17) v19 in eq_ind (derive_pt (fct_cte v4 * v2 + v3) v13 (derivable_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17)) (fun v21 : @R => v21 = v4 * v0 v13 + v1 v13) (eq_ind_r (fun v21 : @R => v21 = v4 * v0 v13 + v1 v13) (eq_ind_r (fun v21 : @R => v21 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) (eq_ind_r (fun v21 : @R => v21 * v2 v13 + fct_cte v4 v13 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) ((let v21 : list (@R) := (IZR 0 * v2 v13 + v4 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 :: v4 * v0 v13 + v1 v13 :: nil)%list in ((fun v22 : v21 = (IZR 0 * v2 v13 + v4 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 :: v4 * v0 v13 + v1 v13 :: nil)%list => let v23 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v24 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v25 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v23 = v24 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v23 = v24 in let v26 : forall (v26 : Ring_polynom.PExpr (@Z)) (v27 : Ring_polynom.Pol (@Z)) (v28 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 v26 = v27), Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v26 = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v27 := RField_ring_lemma2 (@ring_subst_niter) v23 (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) (@I) v24 v25 in let v27 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v28 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v27 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = v27 in let v29 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v27 := v26 (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 0%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEX (@Z) 4)) v27 v28 in eq_ind_r (fun v30 : @R => v30 = v4 * v0 v13 + v1 v13) (let v30 : Ring_polynom.Pol (@Z) := Ring_polynom.Pinj 1 (Ring_polynom.PX (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z))) 1 (Ring_polynom.Pinj 3 (Ring_polynom.PX (Ring_polynom.Pc 1%Z) 1 (Ring_polynom.Pc 0%Z)))) in let v31 : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v30 := eq_refl : Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v24 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = v30 in let v32 : Ring_polynom.PEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) = Ring_polynom.Pphi_pow (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) 0%Z 1%Z (@Zeq_bool) (@IZR) (@BinNatDef.N.to_nat) (@pow) (@get_signZ) (v2 v13 :: v4 :: derive_pt v2 v13 v15 :: derive_pt v3 v13 v17 :: v0 v13 :: v1 v13 :: nil) v30 := v26 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) v30 v31 in eq_ind (v0 v13) (fun v33 : @R => v4 * v33 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) (eq_ind (v1 v13) (fun v33 : @R => v4 * v0 v13 + v33 = v4 * v0 v13 + v1 v13) (let v33 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v34 : list (@R) := (v4 :: v0 v13 :: v1 v13 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v34 v33 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (@I) (eq_refl : (let v35 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v33 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v35 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v35 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)))) = @true)) (derive_pt v3 v13 v17) v18) (derive_pt v2 v13 v15) v16) v29) : forall v22 : v21 = v21, IZR 0 * v2 v13 + v4 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) eq_refl) : IZR 0 * v2 v13 + fct_cte v4 v13 * derive_pt v2 v13 v15 + derive_pt v3 v13 v17 = v4 * v0 v13 + v1 v13) (derive_pt_const v4 v13)) (derive_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15)) (derive_pt_plus (fct_cte v4 * v2)%F v3 v13 (derivable_pt_mult (fct_cte v4) v2 v13 (derivable_pt_const v4 v13) v15) v17)) (derive_pt (fun v21 : @R => v4 * v2 v21 + v3 v21) v13 v19) v20))) (v11 v13 v14)) (v9 v13 v14)) v12) v8) v7) : forall (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 : forall v3 : @R, @R) (v4 v5 v6 : @R) (v7 : antiderivative v0 v2 v5 v6) (v8 : antiderivative v1 v3 v5 v6), antiderivative (fun v9 : @R => v4 * v0 v9 + v1 v9) (fun v9 : @R => v4 * v2 v9 + v3 v9) v5 v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P6	100	1.294577	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 v3 v4 : @R) (v5 : Newton_integrable v0 v3 v4) (v6 : Newton_integrable v1 v3 v4) => (let v7 : Newton_integrable (fun v7 : @R => v2 * v0 v7 + v1 v7) v3 v4 := NewtonInt_P5 v0 v1 v2 v3 v4 v5 v6 in match v7 as v8 in (sig _) return (match v8 as v9 in (sig _) return (@R) with | exist _ v9 v10 => (fun (v9 : forall v9 : @R, @R) (v10 : antiderivative (fun v10 : @R => v2 * v0 v10 + v1 v10) v9 v3 v4 \/ antiderivative (fun v10 : @R => v2 * v0 v10 + v1 v10) v9 v4 v3) => v9 v4 - v9 v3) v9 v10 end = v2 * match v5 as v9 in (sig _) return (@R) with | exist _ v9 v10 => (fun (v9 : forall v9 : @R, @R) (v10 : antiderivative v0 v9 v3 v4 \/ antiderivative v0 v9 v4 v3) => v9 v4 - v9 v3) v9 v10 end + match v6 as v9 in (sig _) return (@R) with | exist _ v9 v10 => (fun (v9 : forall v9 : @R, @R) (v10 : antiderivative v1 v9 v3 v4 \/ antiderivative v1 v9 v4 v3) => v9 v4 - v9 v3) v9 v10 end) with | exist _ v8 v9 => (fun (v8 : forall v8 : @R, @R) (v9 : antiderivative (fun v9 : @R => v2 * v0 v9 + v1 v9) v8 v3 v4 \/ antiderivative (fun v9 : @R => v2 * v0 v9 + v1 v9) v8 v4 v3) => match v5 as v10 in (sig _) return (v8 v4 - v8 v3 = v2 * match v10 as v11 in (sig _) return (@R) with | exist _ v11 v12 => (fun (v11 : forall v11 : @R, @R) (v12 : antiderivative v0 v11 v3 v4 \/ antiderivative v0 v11 v4 v3) => v11 v4 - v11 v3) v11 v12 end + match v6 as v11 in (sig _) return (@R) with | exist _ v11 v12 => (fun (v11 : forall v11 : @R, @R) (v12 : antiderivative v1 v11 v3 v4 \/ antiderivative v1 v11 v4 v3) => v11 v4 - v11 v3) v11 v12 end) with | exist _ v10 v11 => (fun (v10 : forall v10 : @R, @R) (v11 : antiderivative v0 v10 v3 v4 \/ antiderivative v0 v10 v4 v3) => match v6 as v12 in (sig _) return (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + match v12 as v13 in (sig _) return (@R) with | exist _ v13 v14 => (fun (v13 : forall v13 : @R, @R) (v14 : antiderivative v1 v13 v3 v4 \/ antiderivative v1 v13 v4 v3) => v13 v4 - v13 v3) v13 v14 end) with | exist _ v12 v13 => (fun (v12 : forall v12 : @R, @R) (v13 : antiderivative v1 v12 v3 v4 \/ antiderivative v1 v12 v4 v3) => let v14 : {v3 < v4} + {v3 = v4} + {v4 < v3} := total_order_T v3 v4 in match v14 as v15 in (_ + {_}) return (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) with | inleft v15 => (fun v15 : {v3 < v4} + {v3 = v4} => match v15 as v16 in ({_} + {_}) return (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) with | left v16 => (fun v16 : v3 < v4 => or_ind (fun v17 : antiderivative (fun v17 : @R => v2 * v0 v17 + v1 v17) v8 v3 v4 => or_ind (fun v18 : antiderivative v0 v10 v3 v4 => or_ind (fun v19 : antiderivative v1 v12 v3 v4 => let v20 : antiderivative (fun v20 : @R => v2 * v0 v20 + v1 v20) (fun v20 : @R => v2 * v10 v20 + v12 v20) v3 v4 := antiderivative_P1 v0 v1 v10 v12 v2 v3 v4 v18 v19 in let v21 : exists v21 : @R, forall (v22 : @R) (v23 : v3 <= v22 <= v4), v8 v22 = (fun v24 : @R => v2 * v10 v24 + v12 v24) v22 + v21 := antiderivative_Ucte (fun v21 : @R => v2 * v0 v21 + v1 v21) v8 (fun v21 : @R => v2 * v10 v21 + v12 v21) v3 v4 v17 v20 in ex_ind (fun (v22 : @R) (v23 : forall (v23 : @R) (v24 : v3 <= v23 <= v4), v8 v23 = v2 * v10 v23 + v12 v23 + v22) => let v24 : v3 <= v3 <= v4 := conj (or_intror eq_refl) (or_introl v16) in let v25 : v3 <= v4 <= v4 := conj (or_introl v16) (or_intror eq_refl) in let v26 : v8 v3 = v2 * v10 v3 + v12 v3 + v22 := v23 v3 v24 in let v27 : v8 v4 = v2 * v10 v4 + v12 v4 + v22 := v23 v4 v25 in eq_ind_r (fun v28 : @R => v8 v4 - v28 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (eq_ind_r (fun v28 : @R => v28 - (v2 * v10 v3 + v12 v3 + v22) = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (let v28 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v29 : list (@R) := (v2 :: v10 v4 :: v12 v4 :: v22 :: v10 v3 :: v12 v3 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v29 v28 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))) (@I) (eq_refl : (let v30 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v28 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v30 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v30 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))))) = @true)) v27) v26) v21) (fun v19 : antiderivative v1 v12 v4 v3 => and_ind (fun (v20 : forall (v20 : @R) (v21 : v4 <= v20 <= v3), exists v22 : derivable_pt v12 v20, v1 v20 = derive_pt v12 v20 v22) (v21 : v4 <= v3) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v4 (Rle_lt_trans v4 v3 v4 v21 v16))) v19) v13) (fun v18 : antiderivative v0 v10 v4 v3 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v4 <= v19 <= v3), exists v21 : derivable_pt v10 v19, v0 v19 = derive_pt v10 v19 v21) (v20 : v4 <= v3) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v4 (Rle_lt_trans v4 v3 v4 v20 v16))) v18) v11) (fun v17 : antiderivative (fun v17 : @R => v2 * v0 v17 + v1 v17) v8 v4 v3 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v4 <= v18 <= v3), exists v20 : derivable_pt v8 v18, v2 * v0 v18 + v1 v18 = derive_pt v8 v18 v20) (v19 : v4 <= v3) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v4 (Rle_lt_trans v4 v3 v4 v19 v16))) v17) v9) v16 | right v16 => (fun v16 : v3 = v4 => eq_ind_r (fun v17 : @R => v8 v4 - v8 v17 = v2 * (v10 v4 - v10 v17) + (v12 v4 - v12 v17)) (let v17 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v18 : list (@R) := (v8 v4 :: v2 :: v10 v4 :: v12 v4 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v18 v17 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 4))) (@I) (eq_refl : (let v19 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v17 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 1))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v19 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 3))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 4) (Ring_polynom.PEX (@Z) 4))))) = @true)) v16) v16 end) v15 | inright v15 => (fun v15 : v4 < v3 => or_ind (fun v16 : antiderivative (fun v16 : @R => v2 * v0 v16 + v1 v16) v8 v3 v4 => and_ind (fun (v17 : forall (v17 : @R) (v18 : v3 <= v17 <= v4), exists v19 : derivable_pt v8 v17, v2 * v0 v17 + v1 v17 = derive_pt v8 v17 v19) (v18 : v3 <= v4) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v3 (Rle_lt_trans v3 v4 v3 v18 v15))) v16) (fun v16 : antiderivative (fun v16 : @R => v2 * v0 v16 + v1 v16) v8 v4 v3 => or_ind (fun v17 : antiderivative v0 v10 v3 v4 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v3 <= v18 <= v4), exists v20 : derivable_pt v10 v18, v0 v18 = derive_pt v10 v18 v20) (v19 : v3 <= v4) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v3 (Rle_lt_trans v3 v4 v3 v19 v15))) v17) (fun v17 : antiderivative v0 v10 v4 v3 => or_ind (fun v18 : antiderivative v1 v12 v3 v4 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v3 <= v19 <= v4), exists v21 : derivable_pt v12 v19, v1 v19 = derive_pt v12 v19 v21) (v20 : v3 <= v4) => False_ind (v8 v4 - v8 v3 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (Rlt_irrefl v3 (Rle_lt_trans v3 v4 v3 v20 v15))) v18) (fun v18 : antiderivative v1 v12 v4 v3 => let v19 : antiderivative (fun v19 : @R => v2 * v0 v19 + v1 v19) (fun v19 : @R => v2 * v10 v19 + v12 v19) v4 v3 := antiderivative_P1 v0 v1 v10 v12 v2 v4 v3 v17 v18 in let v20 : exists v20 : @R, forall (v21 : @R) (v22 : v4 <= v21 <= v3), v8 v21 = (fun v23 : @R => v2 * v10 v23 + v12 v23) v21 + v20 := antiderivative_Ucte (fun v20 : @R => v2 * v0 v20 + v1 v20) v8 (fun v20 : @R => v2 * v10 v20 + v12 v20) v4 v3 v16 v19 in ex_ind (fun (v21 : @R) (v22 : forall (v22 : @R) (v23 : v4 <= v22 <= v3), v8 v22 = v2 * v10 v22 + v12 v22 + v21) => let v23 : v4 <= v3 <= v3 := conj (or_introl v15) (or_intror eq_refl) in let v24 : v4 <= v4 <= v3 := conj (or_intror eq_refl) (or_introl v15) in let v25 : v8 v3 = v2 * v10 v3 + v12 v3 + v21 := v22 v3 v23 in let v26 : v8 v4 = v2 * v10 v4 + v12 v4 + v21 := v22 v4 v24 in eq_ind_r (fun v27 : @R => v8 v4 - v27 = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (eq_ind_r (fun v27 : @R => v27 - (v2 * v10 v3 + v12 v3 + v21) = v2 * (v10 v4 - v10 v3) + (v12 v4 - v12 v3)) (let v27 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v28 : list (@R) := (v2 :: v10 v4 :: v12 v4 :: v21 :: v10 v3 :: v12 v3 :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v28 v27 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))) (@I) (eq_refl : (let v29 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v27 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v29 (Ring_polynom.PEsub (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)) (Ring_polynom.PEX (@Z) 3)) (Ring_polynom.PEX (@Z) 4)) (Ring_polynom.PEadd (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 5)) (Ring_polynom.PEX (@Z) 6)) (Ring_polynom.PEX (@Z) 4)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v29 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEX (@Z) 5))) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 3) (Ring_polynom.PEX (@Z) 6))))) = @true)) v26) v25) v20) v13) v11) v9) v15 end) v12 v13 end) v10 v11 end) v8 v9 end) : NewtonInt (fun v7 : @R => v2 * v0 v7 + v1 v7) v3 v4 (NewtonInt_P5 v0 v1 v2 v3 v4 v5 v6) = v2 * NewtonInt v0 v3 v4 v5 + NewtonInt v1 v3 v4 v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P2	100	3.600233	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P3	100	0.272385	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 v4 v5 : @R) (v6 : antiderivative v0 v1 v3 v4) (v7 : antiderivative v0 v2 v5 v4) => and_ind (and_ind (fun (v8 : forall (v8 : @R) (v9 : v5 <= v8 <= v4), exists v10 : derivable_pt v2 v8, v0 v8 = derive_pt v2 v8 v10) (v9 : v5 <= v4) (v10 : forall (v10 : @R) (v11 : v3 <= v10 <= v4), exists v12 : derivable_pt v1 v10, v0 v10 = derive_pt v1 v10 v12) (v11 : v3 <= v4) => let v12 : {v3 < v5} + {v3 = v5} + {v5 < v3} := total_order_T v3 v5 in match v12 as v13 in (_ + {_}) return (antiderivative v0 v2 v5 v3 \/ antiderivative v0 v1 v3 v5) with | inleft v13 => (fun v13 : {v3 < v5} + {v3 = v5} => match v13 as v14 in ({_} + {_}) return (antiderivative v0 v2 v5 v3 \/ antiderivative v0 v1 v3 v5) with | left v14 => (fun v14 : v3 < v5 => or_intror (conj (fun (v15 : @R) (v16 : v3 <= v15 <= v5) => v10 v15 (and_ind (fun (v17 : v3 <= v15) (v18 : v15 <= v5) => conj v17 (Rle_trans v15 v5 v4 v18 v9)) v16)) (or_introl v14) : antiderivative v0 v1 v3 v5)) v14 | right v14 => (fun v14 : v3 = v5 => or_intror (conj (fun (v15 : @R) (v16 : v3 <= v15 <= v5) => v10 v15 (and_ind (fun (v17 : v3 <= v15) (v18 : v15 <= v5) => conj v17 (Rle_trans v15 v5 v4 v18 v9)) v16)) (or_intror v14) : antiderivative v0 v1 v3 v5)) v14 end) v13 | inright v13 => (fun v13 : v5 < v3 => or_introl (conj (fun (v14 : @R) (v15 : v5 <= v14 <= v3) => v8 v14 (and_ind (fun (v16 : v5 <= v14) (v17 : v14 <= v3) => conj v16 (Rle_trans v14 v3 v4 v17 v11)) v15)) (or_introl v13) : antiderivative v0 v2 v5 v3)) v13 end) v7) v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.antiderivative_P4	100	0.258612	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 : forall v1 : @R, @R) (v2 : forall v2 : @R, @R) (v3 v4 v5 : @R) (v6 : antiderivative v0 v1 v3 v4) (v7 : antiderivative v0 v2 v3 v5) => and_ind (and_ind (fun (v8 : forall (v8 : @R) (v9 : v3 <= v8 <= v5), exists v10 : derivable_pt v2 v8, v0 v8 = derive_pt v2 v8 v10) (v9 : v3 <= v5) (v10 : forall (v10 : @R) (v11 : v3 <= v10 <= v4), exists v12 : derivable_pt v1 v10, v0 v10 = derive_pt v1 v10 v12) (v11 : v3 <= v4) => let v12 : {v5 < v4} + {v5 = v4} + {v4 < v5} := total_order_T v5 v4 in match v12 as v13 in (_ + {_}) return (antiderivative v0 v2 v4 v5 \/ antiderivative v0 v1 v5 v4) with | inleft v13 => (fun v13 : {v5 < v4} + {v5 = v4} => match v13 as v14 in ({_} + {_}) return (antiderivative v0 v2 v4 v5 \/ antiderivative v0 v1 v5 v4) with | left v14 => (fun v14 : v5 < v4 => or_intror (conj (fun (v15 : @R) (v16 : v5 <= v15 <= v4) => v10 v15 (and_ind (fun (v17 : v5 <= v15) (v18 : v15 <= v4) => conj (Rle_trans v3 v5 v15 v9 v17) v18) v16)) (or_introl v14) : antiderivative v0 v1 v5 v4)) v14 | right v14 => (fun v14 : v5 = v4 => or_intror (conj (fun (v15 : @R) (v16 : v5 <= v15 <= v4) => v10 v15 (and_ind (fun (v17 : v5 <= v15) (v18 : v15 <= v4) => conj (Rle_trans v3 v5 v15 v9 v17) v18) v16)) (or_intror v14) : antiderivative v0 v1 v5 v4)) v14 end) v13 | inright v13 => (fun v13 : v4 < v5 => or_introl (conj (fun (v14 : @R) (v15 : v4 <= v14 <= v5) => v8 v14 (and_ind (fun (v16 : v4 <= v14) (v17 : v14 <= v5) => conj (Rle_trans v3 v4 v14 v11 v16) v17) v15)) (or_introl v13) : antiderivative v0 v2 v4 v5)) v13 end) v7) v6)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P7	100	0.229236	1	1	0	synth with cache (only 1: refine ((fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : v1 < v2) (v5 : v2 < v3) (v6 : {v6 : forall v6 : @R, @R | antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1}) (v7 : {v7 : forall v7 : @R, @R | antiderivative v0 v7 v2 v3 \/ antiderivative v0 v7 v3 v2}) => sig_rec (fun v8 : {v8 : forall v8 : @R, @R | antiderivative v0 v8 v1 v2 \/ antiderivative v0 v8 v2 v1} => {v9 : forall v9 : @R, @R | antiderivative v0 v9 v1 v3 \/ antiderivative v0 v9 v3 v1}) (fun (v8 : forall v8 : @R, @R) (v9 : antiderivative v0 v8 v1 v2 \/ antiderivative v0 v8 v2 v1) => sig_rec (fun v10 : {v10 : forall v10 : @R, @R | antiderivative v0 v10 v2 v3 \/ antiderivative v0 v10 v3 v2} => {v11 : forall v11 : @R, @R | antiderivative v0 v11 v1 v3 \/ antiderivative v0 v11 v3 v1}) (fun (v10 : forall v10 : @R, @R) (v11 : antiderivative v0 v10 v2 v3 \/ antiderivative v0 v10 v3 v2) => let v12 : forall v12 : @R, @R := fun v12 : @R => match Rle_dec v12 v2 as v13 in ({_} + {_}) return (@R) with | left v13 => (fun v13 : v12 <= v2 => v8 v12) v13 | right v13 => (fun v13 : ~ v12 <= v2 => v10 v12 + (v8 v2 - v10 v2)) v13 end in exist (fun v13 : forall v13 : @R, @R => antiderivative v0 v13 v1 v3 \/ antiderivative v0 v13 v3 v1) v12 (or_introl (antiderivative_P2 v0 v8 v10 v1 v2 v3 (or_ind (fun v13 : antiderivative v0 v8 v1 v2 => v13) (fun v13 : antiderivative v0 v8 v2 v1 => and_ind (fun (v14 : forall (v14 : @R) (v15 : v2 <= v14 <= v1), exists v16 : derivable_pt v8 v14, v0 v14 = derive_pt v8 v14 v16) (v15 : v2 <= v1) => False_ind (antiderivative v0 v8 v1 v2) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v15 v4))) v13) v9) (or_ind (fun v13 : antiderivative v0 v10 v2 v3 => v13) (fun v13 : antiderivative v0 v10 v3 v2 => and_ind (fun (v14 : forall (v14 : @R) (v15 : v3 <= v14 <= v2), exists v16 : derivable_pt v10 v14, v0 v14 = derive_pt v10 v14 v16) (v15 : v3 <= v2) => False_ind (antiderivative v0 v10 v2 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v15 v5))) v13) v11) : antiderivative v0 v12 v1 v3))) v7) v6) : forall (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : v1 < v2) (v5 : v2 < v3) (v6 : Newton_integrable v0 v1 v2) (v7 : Newton_integrable v0 v2 v3), Newton_integrable v0 v1 v3)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P8	100	1.014050	1	1	0	synth with cache (only 1: refine (fun (v0 : forall v0 : @R, @R) (v1 v2 v3 : @R) (v4 : Newton_integrable v0 v1 v2) (v5 : Newton_integrable v0 v2 v3) => sig_rect (fun v6 : {v6 : forall v6 : @R, @R | antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1} => Newton_integrable v0 v1 v3) (fun (v6 : forall v6 : @R, @R) (v7 : antiderivative v0 v6 v1 v2 \/ antiderivative v0 v6 v2 v1) => sig_rect (fun v8 : {v8 : forall v8 : @R, @R | antiderivative v0 v8 v2 v3 \/ antiderivative v0 v8 v3 v2} => Newton_integrable v0 v1 v3) (fun (v8 : forall v8 : @R, @R) (v9 : antiderivative v0 v8 v2 v3 \/ antiderivative v0 v8 v3 v2) => let v10 : {v1 < v2} + {v1 = v2} + {v2 < v1} := total_order_T v1 v2 in match v10 as v11 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v11 => (fun v11 : {v1 < v2} + {v1 = v2} => match v11 as v12 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v12 => (fun v12 : v1 < v2 => let v13 : {v2 < v3} + {v2 = v3} + {v3 < v2} := total_order_T v2 v3 in match v13 as v14 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v14 => (fun v14 : {v2 < v3} + {v2 = v3} => match v14 as v15 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v15 => (fun v15 : v2 < v3 => exist (fun v16 : forall v16 : @R, @R => antiderivative v0 v16 v1 v3 \/ antiderivative v0 v16 v3 v1) (fun v16 : @R => match Rle_dec v16 v2 as v17 in ({_} + {_}) return (@R) with | left v17 => (fun v17 : v16 <= v2 => v6 v16) v17 | right v17 => (fun v17 : ~ v16 <= v2 => v8 v16 + (v6 v2 - v8 v2)) v17 end) (or_ind (fun v16 : antiderivative v0 v6 v1 v2 => or_ind (fun v17 : antiderivative v0 v8 v2 v3 => or_introl (antiderivative_P2 v0 v6 v8 v1 v2 v3 v16 v17)) (fun v17 : antiderivative v0 v8 v3 v2 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v3 <= v18 <= v2), exists v20 : derivable_pt v8 v18, v0 v18 = derive_pt v8 v18 v20) (v19 : v3 <= v2) => False_ind (antiderivative v0 (fun v20 : @R => match Rle_dec v20 v2 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v20 <= v2 => v6 v20) v21 | right v21 => (fun v21 : ~ v20 <= v2 => v8 v20 + (v6 v2 - v8 v2)) v21 end) v1 v3 \/ antiderivative v0 (fun v20 : @R => match Rle_dec v20 v2 as v21 in ({_} + {_}) return (@R) with | left v21 => (fun v21 : v20 <= v2 => v6 v20) v21 | right v21 => (fun v21 : ~ v20 <= v2 => v8 v20 + (v6 v2 - v8 v2)) v21 end) v3 v1) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v19 v15))) v17) v9) (fun v16 : antiderivative v0 v6 v2 v1 => and_ind (fun (v17 : forall (v17 : @R) (v18 : v2 <= v17 <= v1), exists v19 : derivable_pt v6 v17, v0 v17 = derive_pt v6 v17 v19) (v18 : v2 <= v1) => False_ind (antiderivative v0 (fun v19 : @R => match Rle_dec v19 v2 as v20 in ({_} + {_}) return (@R) with | left v20 => (fun v20 : v19 <= v2 => v6 v19) v20 | right v20 => (fun v20 : ~ v19 <= v2 => v8 v19 + (v6 v2 - v8 v2)) v20 end) v1 v3 \/ antiderivative v0 (fun v19 : @R => match Rle_dec v19 v2 as v20 in ({_} + {_}) return (@R) with | left v20 => (fun v20 : v19 <= v2 => v6 v19) v20 | right v20 => (fun v20 : ~ v19 <= v2 => v8 v19 + (v6 v2 - v8 v2)) v20 end) v3 v1) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v18 v12))) v16) v7) : Newton_integrable v0 v1 v3) v15 | right v15 => (fun v15 : v2 = v3 => let v16 : Newton_integrable v0 v1 v3 := eq_rect v2 (fun v16 : @R => Newton_integrable v0 v1 v16) v4 v3 v15 in v16) v15 end) v14 | inright v14 => (fun v14 : v3 < v2 => let v15 : {v1 < v3} + {v1 = v3} + {v3 < v1} := total_order_T v1 v3 in match v15 as v16 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v16 => (fun v16 : {v1 < v3} + {v1 = v3} => match v16 as v17 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v17 => (fun v17 : v1 < v3 => exist (fun v18 : forall v18 : @R, @R => antiderivative v0 v18 v1 v3 \/ antiderivative v0 v18 v3 v1) v6 (or_introl (or_ind (fun v18 : antiderivative v0 v8 v2 v3 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v2 <= v19 <= v3), exists v21 : derivable_pt v8 v19, v0 v19 = derive_pt v8 v19 v21) (v20 : v2 <= v3) => False_ind (antiderivative v0 v6 v1 v3) (Rlt_irrefl v2 (Rle_lt_trans v2 v3 v2 v20 v14))) v18) (fun v18 : antiderivative v0 v8 v3 v2 => or_ind (fun v19 : antiderivative v0 v6 v1 v2 => let v20 : antiderivative v0 v8 v3 v1 \/ antiderivative v0 v6 v1 v3 := antiderivative_P3 v0 v6 v8 v1 v2 v3 v19 v18 in or_ind (fun v21 : antiderivative v0 v8 v3 v1 => and_ind (fun (v22 : forall (v22 : @R) (v23 : v3 <= v22 <= v1), exists v24 : derivable_pt v8 v22, v0 v22 = derive_pt v8 v22 v24) (v23 : v3 <= v1) => False_ind (antiderivative v0 v6 v1 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v1 v3 v23 v17))) v21) (fun v21 : antiderivative v0 v6 v1 v3 => v21) v20) (fun v19 : antiderivative v0 v6 v2 v1 => and_ind (fun (v20 : forall (v20 : @R) (v21 : v2 <= v20 <= v1), exists v22 : derivable_pt v6 v20, v0 v20 = derive_pt v6 v20 v22) (v21 : v2 <= v1) => False_ind (antiderivative v0 v6 v1 v3) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v21 v12))) v19) v7) v9)) : Newton_integrable v0 v1 v3) v17 | right v17 => (fun v17 : v1 = v3 => eq_rect_r (fun v18 : @R => Newton_integrable v0 v18 v3) (NewtonInt_P1 v0 v3) v17) v17 end) v16 | inright v16 => (fun v16 : v3 < v1 => exist (fun v17 : forall v17 : @R, @R => antiderivative v0 v17 v1 v3 \/ antiderivative v0 v17 v3 v1) v8 (or_intror (or_ind (fun v17 : antiderivative v0 v8 v2 v3 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v2 <= v18 <= v3), exists v20 : derivable_pt v8 v18, v0 v18 = derive_pt v8 v18 v20) (v19 : v2 <= v3) => False_ind (antiderivative v0 v8 v3 v1) (Rlt_irrefl v2 (Rle_lt_trans v2 v3 v2 v19 v14))) v17) (fun v17 : antiderivative v0 v8 v3 v2 => or_ind (fun v18 : antiderivative v0 v6 v1 v2 => let v19 : antiderivative v0 v8 v3 v1 \/ antiderivative v0 v6 v1 v3 := antiderivative_P3 v0 v6 v8 v1 v2 v3 v18 v17 in or_ind (fun v20 : antiderivative v0 v8 v3 v1 => v20) (fun v20 : antiderivative v0 v6 v1 v3 => and_ind (fun (v21 : forall (v21 : @R) (v22 : v1 <= v21 <= v3), exists v23 : derivable_pt v6 v21, v0 v21 = derive_pt v6 v21 v23) (v22 : v1 <= v3) => False_ind (antiderivative v0 v8 v3 v1) (Rlt_irrefl v1 (Rle_lt_trans v1 v3 v1 v22 v16))) v20) v19) (fun v18 : antiderivative v0 v6 v2 v1 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v2 <= v19 <= v1), exists v21 : derivable_pt v6 v19, v0 v19 = derive_pt v6 v19 v21) (v20 : v2 <= v1) => False_ind (antiderivative v0 v8 v3 v1) (Rlt_irrefl v2 (Rle_lt_trans v2 v1 v2 v20 v12))) v18) v7) v9)) : Newton_integrable v0 v1 v3) v16 end) v14 end) v12 | right v12 => (fun v12 : v1 = v2 => eq_rect_r (fun v13 : @R => Newton_integrable v0 v13 v3) v5 v12) v12 end) v11 | inright v11 => (fun v11 : v2 < v1 => let v12 : {v2 < v3} + {v2 = v3} + {v3 < v2} := total_order_T v2 v3 in match v12 as v13 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v13 => (fun v13 : {v2 < v3} + {v2 = v3} => match v13 as v14 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v14 => (fun v14 : v2 < v3 => let v15 : {v1 < v3} + {v1 = v3} + {v3 < v1} := total_order_T v1 v3 in match v15 as v16 in (_ + {_}) return (Newton_integrable v0 v1 v3) with | inleft v16 => (fun v16 : {v1 < v3} + {v1 = v3} => match v16 as v17 in ({_} + {_}) return (Newton_integrable v0 v1 v3) with | left v17 => (fun v17 : v1 < v3 => exist (fun v18 : forall v18 : @R, @R => antiderivative v0 v18 v1 v3 \/ antiderivative v0 v18 v3 v1) v8 (or_introl (or_ind (fun v18 : antiderivative v0 v8 v2 v3 => or_ind (fun v19 : antiderivative v0 v6 v1 v2 => and_ind (fun (v20 : forall (v20 : @R) (v21 : v1 <= v20 <= v2), exists v22 : derivable_pt v6 v20, v0 v20 = derive_pt v6 v20 v22) (v21 : v1 <= v2) => False_ind (antiderivative v0 v8 v1 v3) (Rlt_irrefl v1 (Rle_lt_trans v1 v2 v1 v21 v11))) v19) (fun v19 : antiderivative v0 v6 v2 v1 => let v20 : antiderivative v0 v8 v1 v3 \/ antiderivative v0 v6 v3 v1 := antiderivative_P4 v0 v6 v8 v2 v1 v3 v19 v18 in or_ind (fun v21 : antiderivative v0 v8 v1 v3 => v21) (fun v21 : antiderivative v0 v6 v3 v1 => and_ind (fun (v22 : forall (v22 : @R) (v23 : v3 <= v22 <= v1), exists v24 : derivable_pt v6 v22, v0 v22 = derive_pt v6 v22 v24) (v23 : v3 <= v1) => False_ind (antiderivative v0 v8 v1 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v1 v3 v23 v17))) v21) v20) v7) (fun v18 : antiderivative v0 v8 v3 v2 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v3 <= v19 <= v2), exists v21 : derivable_pt v8 v19, v0 v19 = derive_pt v8 v19 v21) (v20 : v3 <= v2) => False_ind (antiderivative v0 v8 v1 v3) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v20 v14))) v18) v9)) : Newton_integrable v0 v1 v3) v17 | right v17 => (fun v17 : v1 = v3 => eq_rect_r (fun v18 : @R => Newton_integrable v0 v18 v3) (NewtonInt_P1 v0 v3) v17) v17 end) v16 | inright v16 => (fun v16 : v3 < v1 => exist (fun v17 : forall v17 : @R, @R => antiderivative v0 v17 v1 v3 \/ antiderivative v0 v17 v3 v1) v6 (or_intror (or_ind (fun v17 : antiderivative v0 v6 v1 v2 => and_ind (fun (v18 : forall (v18 : @R) (v19 : v1 <= v18 <= v2), exists v20 : derivable_pt v6 v18, v0 v18 = derive_pt v6 v18 v20) (v19 : v1 <= v2) => False_ind (antiderivative v0 v6 v3 v1) (Rlt_irrefl v1 (Rle_lt_trans v1 v2 v1 v19 v11))) v17) (fun v17 : antiderivative v0 v6 v2 v1 => or_ind (fun v18 : antiderivative v0 v8 v2 v3 => let v19 : antiderivative v0 v8 v1 v3 \/ antiderivative v0 v6 v3 v1 := antiderivative_P4 v0 v6 v8 v2 v1 v3 v17 v18 in or_ind (fun v20 : antiderivative v0 v8 v1 v3 => and_ind (fun (v21 : forall (v21 : @R) (v22 : v1 <= v21 <= v3), exists v23 : derivable_pt v8 v21, v0 v21 = derive_pt v8 v21 v23) (v22 : v1 <= v3) => False_ind (antiderivative v0 v6 v3 v1) (Rlt_irrefl v1 (Rle_lt_trans v1 v3 v1 v22 v16))) v20) (fun v20 : antiderivative v0 v6 v3 v1 => v20) v19) (fun v18 : antiderivative v0 v8 v3 v2 => and_ind (fun (v19 : forall (v19 : @R) (v20 : v3 <= v19 <= v2), exists v21 : derivable_pt v8 v19, v0 v19 = derive_pt v8 v19 v21) (v20 : v3 <= v2) => False_ind (antiderivative v0 v6 v3 v1) (Rlt_irrefl v3 (Rle_lt_trans v3 v2 v3 v20 v14))) v18) v9) v7)) : Newton_integrable v0 v1 v3) v16 end) v14 | right v14 => (fun v14 : v2 = v3 => let v15 : Newton_integrable v0 v1 v3 := eq_rect v2 (fun v15 : @R => Newton_integrable v0 v1 v15) v4 v3 v14 in v15) v14 end) v13 | inright v13 => (fun v13 : v3 < v2 => let v14 : Newton_integrable v0 v2 v1 := NewtonInt_P3 v0 v1 v2 v4 in let v15 : Newton_integrable v0 v3 v2 := NewtonInt_P3 v0 v2 v3 v5 in NewtonInt_P3 v0 v3 v1 (NewtonInt_P7 v0 v3 v2 v1 v13 v11 v15 v14)) v13 end) v11 end) v5) v4)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.NewtonInt.NewtonInt_P9	100	6.630167	1	1
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.atan_sub_correct	100	0.870228	1	1	0	synth with cache (only 1: refine (fun (v0 v1 : @R) (v2 : IZR 1 + v0 * v1 <> IZR 0) (v3 : - @PI / IZR 2 < atan v0 - atan v1 < @PI / IZR 2) (v4 : - @PI / IZR 2 < atan (atan_sub v0 v1) < @PI / IZR 2) => let v5 : cos (atan v0) <> IZR 0 := let v5 : - @PI / IZR 2 < atan v0 < @PI / IZR 2 := atan_bound v0 in match v5 as v6 in (_ /\ _) return (cos (atan v0) <> IZR 0) with | conj v6 v7 => (fun (v6 : - @PI / IZR 2 < atan v0) (v7 : atan v0 < @PI / IZR 2) => Rgt_not_eq (cos (atan v0)) (IZR 0) (cos_gt_0 (atan v0) (eq_ind (- @PI / IZR 2) (fun v8 : @R => v8 < atan v0) v6 (- (@PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) v7)) v6 v7 end in let v6 : cos (atan v1) <> IZR 0 := let v6 : - @PI / IZR 2 < atan v1 < @PI / IZR 2 := atan_bound v1 in match v6 as v7 in (_ /\ _) return (cos (atan v1) <> IZR 0) with | conj v7 v8 => (fun (v7 : - @PI / IZR 2 < atan v1) (v8 : atan v1 < @PI / IZR 2) => Rgt_not_eq (cos (atan v1)) (IZR 0) (cos_gt_0 (atan v1) (eq_ind (- @PI / IZR 2) (fun v9 : @R => v9 < atan v1) v7 (- (@PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) v8)) v7 v8 end in let v7 : forall (v7 v8 v9 : @R) (v10 : v7 - v8 = v9), v7 = v8 + v9 := fun (v7 v8 v9 : @R) (v10 : v7 - v8 = v9) => eq_ind (v7 - v8) (fun v11 : @R => v7 = v8 + v11) (let v11 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v12 : forall (v12 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v13 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 = v12) (v14 : linear (@Z)) (v15 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEX (@Z) 1) = v14) (v16 : linear (@Z)) (v17 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) = v16) (v18 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v12 (Ring_polynom.PEmul (num v14) (denum v16))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v12 (Ring_polynom.PEmul (num v16) (denum v14))) = @true) (v19 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) (condition v14 ++ condition v16)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) (FEX (@Z) 1) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) := RField_field_lemma1 (@ring_subst_niter) (v7 :: v8 :: nil) v11 (FEX (@Z) 1) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) (@I) in let v13 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v14 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 = v13 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v11 = v13 in let v15 : linear (@Z) := {| num := Ring_polynom.PEX (@Z) 1; denum := Ring_polynom.PEc 1%Z; condition := nil |} in let v16 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEX (@Z) 1) = v15 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEX (@Z) 1) = v15 in let v17 : linear (@Z) := {| num := Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 2) (Ring_polynom.PEsub (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)); denum := Ring_polynom.PEc 1%Z; condition := nil |} in let v18 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) = v17 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEadd (FEX (@Z) 2) (FEsub (FEX (@Z) 1) (FEX (@Z) 2))) = v17 in v12 v13 v14 v15 v16 v17 v18 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEmul (num v15) (denum v17))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v13 (Ring_polynom.PEmul (num v17) (denum v15))) = @true) (RField_lemma5 (v7 :: v8 :: nil) (condition v15 ++ condition v17) (fun (v19 : forall v19 : list (Ring_polynom.PExpr (@Z)), Prop) (v20 : v19 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil)) => eq_ind_r (fun v21 : forall v21 : list (Ring_polynom.PExpr (@Z)), Prop => v21 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) (v7 :: v8 :: nil) nil) v20 : v19 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v15 ++ condition v17) nil)))) v9 v10 in v7 (atan v0) (atan v1) (atan (atan_sub v0 v1)) (tan_is_inj (atan v0 - atan v1) (atan (atan_sub v0 v1)) v3 v4 (eq_ind_r (fun v8 : @R => v8 = tan (atan (atan_sub v0 v1))) (eq_ind_r (fun v8 : @R => (v8 - tan (atan v1)) / (IZR 1 + v8 * tan (atan v1)) = tan (atan (atan_sub v0 v1))) (eq_ind_r (fun v8 : @R => (v0 - v8) / (IZR 1 + v0 * v8) = tan (atan (atan_sub v0 v1))) (eq_ind_r (fun v8 : @R => (v0 - v1) / (IZR 1 + v0 * v1) = v8) eq_refl (atan_right_inv (atan_sub v0 v1))) (atan_right_inv v1)) (atan_right_inv v0)) (tan_minus (atan v0) (atan v1) v5 v6 (Rgt_not_eq (cos (atan v0 - atan v1)) (IZR 0) (cos_gt_0 (atan v0 - atan v1) (eq_ind (- @PI / IZR 2) (fun v8 : @R => v8 < atan v0 - atan v1) (and_ind (fun (v8 : - @PI / IZR 2 < atan v0 - atan v1) (v9 : atan v0 - atan v1 < @PI / IZR 2) => and_ind (fun (v10 : - @PI / IZR 2 < atan (atan_sub v0 v1)) (v11 : atan (atan_sub v0 v1) < @PI / IZR 2) => v8) v4) v3) (- (@PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) (and_ind (fun (v8 : - @PI / IZR 2 < atan v0 - atan v1) (v9 : atan v0 - atan v1 < @PI / IZR 2) => and_ind (fun (v10 : - @PI / IZR 2 < atan (atan_sub v0 v1)) (v11 : atan (atan_sub v0 v1) < @PI / IZR 2) => v9) v4) v3))) (eq_ind_r (fun v8 : @R => IZR 1 + v8 * tan (atan v1) <> IZR 0) (eq_ind_r (fun v8 : @R => IZR 1 + v0 * v8 <> IZR 0) v2 (atan_right_inv v1)) (atan_right_inv v0))))))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.tech	100	0.727937	1	1	0	synth with cache (only 1: refine (let v0 : @PI > IZR 0 := @PI_RGT_0 in fun (v1 v2 : @R) (v3 : IZR (-1) <= v1 <= IZR 1) => match v3 as v4 in (_ /\ _) return (forall v5 : IZR (-1) < v2 < IZR 1, - @PI / IZR 2 < atan v1 - atan v2 < @PI / IZR 2) with | conj v4 v5 => (fun (v4 : IZR (-1) <= v1) (v5 : v1 <= IZR 1) (v6 : IZR (-1) < v2 < IZR 1) => match v6 as v7 in (_ /\ _) return (- @PI / IZR 2 < atan v1 - atan v2 < @PI / IZR 2) with | conj v7 v8 => (fun (v7 : IZR (-1) < v2) (v8 : v2 < IZR 1) => let v9 : - (@PI / IZR 4) <= atan v1 := match v4 as v9 in (_ \/ _) return (- (@PI / IZR 4) <= atan v1) with | or_introl v9 => (fun v9 : IZR (-1) < v1 => eq_ind (atan (IZR 1)) (fun v10 : @R => - v10 <= atan v1) (eq_ind (atan (- IZR 1)) (fun v10 : @R => v10 <= atan v1) (Rlt_le (atan (- IZR 1)) (atan v1) (atan_increasing (- IZR 1) v1 v9)) (- atan (IZR 1)) (atan_opp (IZR 1))) (@PI / IZR 4) (@atan_1)) v9 | or_intror v9 => (fun v9 : IZR (-1) = v1 => eq_ind (IZR (-1)) (fun v10 : @R => - (@PI / IZR 4) <= atan v10) (eq_ind_r (fun v10 : @R => - (@PI / IZR 4) <= v10) (eq_ind_r (fun v10 : @R => - (@PI / IZR 4) <= - v10) (Rle_refl (- (@PI / IZR 4))) (@atan_1)) (atan_opp (IZR 1))) v1 v9) v9 end in let v10 : - (@PI / IZR 4) < atan v2 := eq_ind (atan (IZR 1)) (fun v10 : @R => - v10 < atan v2) (eq_ind (atan (- IZR 1)) (fun v10 : @R => v10 < atan v2) (atan_increasing (- IZR 1) v2 v7) (- atan (IZR 1)) (atan_opp (IZR 1))) (@PI / IZR 4) (@atan_1) in let v11 : atan v1 <= @PI / IZR 4 := match v5 as v11 in (_ \/ _) return (atan v1 <= @PI / IZR 4) with | or_introl v11 => (fun v11 : v1 < IZR 1 => eq_ind (atan (IZR 1)) (fun v12 : @R => atan v1 <= v12) (Rlt_le (atan v1) (atan (IZR 1)) (atan_increasing v1 (IZR 1) v11)) (@PI / IZR 4) (@atan_1)) v11 | or_intror v11 => (fun v11 : v1 = IZR 1 => eq_ind_r (fun v12 : @R => atan v12 <= @PI / IZR 4) (eq_ind_r (fun v12 : @R => v12 <= @PI / IZR 4) (Rle_refl (@PI / IZR 4)) (@atan_1)) v11) v11 end in let v12 : atan v2 < @PI / IZR 4 := eq_ind (atan (IZR 1)) (fun v12 : @R => atan v2 < v12) (atan_increasing v2 (IZR 1) v8) (@PI / IZR 4) (@atan_1) in eq_ind_r (fun v13 : @R => v13 < atan v1 - atan v2 < @PI / IZR 2) (conj ((let v13 : forall (v13 v14 v15 : @R) (v16 : v13 < v15 * / IZR 4) (v17 : - (v15 * / IZR 4) <= v14), - (v15 * / IZR 2) < v14 - v13 := fun v13 v14 v15 : @R => let v16 : list (@QMicromega.QWitness) := (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 2) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 1) (RingMicromega.PsatzIn (@QArith_base.Q) 0)) :: nil)%list in let v17 : VarMap.t (@R) := VarMap.Branch (VarMap.Elt v14) v15 (VarMap.Elt v13) in let v18 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 3; RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4))) |} (@tt)) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4)))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEmul (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)))); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEsub (EnvRing.PEX 2) (EnvRing.PEX 3) |} (@tt))) in RMicromega.RTautoChecker_sound v18 v16 (eq_refl : RMicromega.RTautoChecker v18 v16 = @true) (VarMap.find (IZR 0) v17) in v13 (atan v2) (atan v1) (@PI) v12 v9) : - (@PI / IZR 2) < atan v1 - atan v2) ((let v13 : forall (v13 v14 v15 : @R) (v16 : v15 <= v13 * / IZR 4) (v17 : - (v13 * / IZR 4) < v14), v15 - v14 < v13 * / IZR 2 := fun v13 v14 v15 : @R => let v16 : list (@QMicromega.QWitness) := (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 2) (RingMicromega.PsatzAdd (RingMicromega.PsatzIn (@QArith_base.Q) 1) (RingMicromega.PsatzIn (@QArith_base.Q) 0)) :: nil)%list in let v17 : VarMap.t (@R) := VarMap.Branch (VarMap.Elt v14) v15 (VarMap.Elt v13) in let v18 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEX 1; RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 3) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4))) |} (@tt)) None (Tauto.I (Tauto.A {| RingMicromega.Flhs := EnvRing.PEopp (EnvRing.PEmul (EnvRing.PEX 3) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 4)))); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEX 2 |} (@tt)) None (Tauto.A {| RingMicromega.Flhs := EnvRing.PEsub (EnvRing.PEX 1) (EnvRing.PEX 2); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEmul (EnvRing.PEX 3) (EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2))) |} (@tt))) in RMicromega.RTautoChecker_sound v18 v16 (eq_refl : RMicromega.RTautoChecker v18 v16 = @true) (VarMap.find (IZR 0) v17) in v13 (@PI) (atan v2) (atan v1) v11 v10) : atan v1 - atan v2 < @PI / IZR 2)) (Ropp_div (@PI) (IZR 2))) v7 v8 end) v4 v5 end)).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.Machin_2_3	100	0.788740	1	1	0	synth with cache (only 1: refine (let v0 : IZR 0 < @PI / IZR 2 := @PI2_RGT_0 in eq_ind (atan (IZR 1)) (fun v1 : @R => v1 = atan (/ IZR 2) + atan (/ IZR 3)) (eq_ind_r (fun v1 : @R => v1 = atan (/ IZR 2) + atan (/ IZR 3)) (f_equal (Rplus (atan (/ IZR 2))) (f_equal (@atan) ((let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : forall (v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v3 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v2) (v4 : linear (@Z)) (v5 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 3%Z)) = v6) (v8 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v4) (denum v6))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v6) (denum v4))) = @true) (v9 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v4 ++ condition v6)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEinv (FEc 3%Z)) := RField_field_lemma1 (@ring_subst_niter) nil v1 (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) (FEinv (FEc 3%Z)) (@I) in let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 in let v5 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 3%Z; condition := Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 2%Z :: Ring_polynom.PEc 2%Z :: nil |} in let v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = v5 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 2%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 2%Z))))) = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 3%Z; condition := Ring_polynom.PEc 3%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 3%Z)) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 3%Z)) = v7 in v2 v3 v4 v5 v6 v7 v8 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (RField_lemma5 nil (condition v5 ++ condition v7) (fun (v9 : forall v9 : list (Ring_polynom.PExpr (@Z)), Prop) (v10 : v9 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop => v11 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v10 : v9 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v5 ++ condition v7) nil)))) : atan_sub (IZR 1) (/ IZR 2) = / IZR 3))) (atan_sub_correct (IZR 1) (/ IZR 2) (Rgt_not_eq (IZR 1 + IZR 1 * / IZR 2) (IZR 0) ((let v1 : IZR 1 + IZR 1 * / IZR 2 > IZR 0 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CZ 1) (RMicromega.CInv (RMicromega.CZ 2)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR 1 + IZR 1 * / IZR 2 > IZR 0)) (tech (IZR 1) (/ IZR 2) (conj ((let v1 : IZR (-1) <= IZR 1 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR (-1) <= IZR 1) ((let v1 : IZR 1 <= IZR 1 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ 1); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR 1 <= IZR 1)) (conj ((let v1 : IZR (-1) < / IZR 2 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : IZR (-1) < / IZR 2) ((let v1 : / IZR 2 < IZR 1 := let v1 : list (@QMicromega.QWitness) := nil in let v2 : VarMap.t (@R) := VarMap.Empty in let v3 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v3 v1 (eq_refl : RMicromega.RTautoChecker v3 v1 = @true) (VarMap.find (IZR 0) v2) in v1) : / IZR 2 < IZR 1))) (atan_bound (atan_sub (IZR 1) (/ IZR 2))))) (@PI / IZR 4) (@atan_1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.Machin_4_5_239	100	5.162218	1	1	0	synth with cache (only 1: refine (eq_ind (atan (IZR 1)) (fun v0 : @R => v0 = IZR 4 * atan (/ IZR 5) - atan (/ IZR 239)) (eq_ind_r (fun v0 : @R => v0 = IZR 4 * atan (/ IZR 5) - atan (/ IZR 239)) (let v0 : atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239)))) = IZR 4 * atan (/ IZR 5) - atan (/ IZR 239) := let v0 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v1 : list (@R) := (atan (/ IZR 5) :: atan (/ IZR 239) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v1 v0 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 2)))))) (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEc 4%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (@I) (eq_refl : (let v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v0 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEopp (Ring_polynom.PEX (@Z) 2))))))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEsub (Ring_polynom.PEmul (Ring_polynom.PEc 4%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)))) = @true) in eq_ind (atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239))))) (fun v1 : @R => atan (/ IZR 5) + atan (atan_sub (IZR 1) (/ IZR 5)) = v1) (f_equal (Rplus (atan (/ IZR 5))) (let v1 : IZR 2 / IZR 3 = atan_sub (IZR 1) (/ IZR 5) := (let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : forall (v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v3 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v2) (v4 : linear (@Z)) (v5 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 2%Z) (FEc 3%Z)) = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) = v6) (v8 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v4) (denum v6))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v6) (denum v4))) = @true) (v9 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v4 ++ condition v6)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEc 2%Z) (FEc 3%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v1 (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) (@I) in let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 in let v5 : linear (@Z) := {| num := Ring_polynom.PEc 2%Z; denum := Ring_polynom.PEc 3%Z; condition := Ring_polynom.PEc 3%Z :: nil |} in let v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 2%Z) (FEc 3%Z)) = v5 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 2%Z) (FEc 3%Z)) = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 4%Z; denum := Ring_polynom.PEc 6%Z; condition := Ring_polynom.PEc 6%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 5%Z))))) = v7 in v2 v3 v4 v5 v6 v7 v8 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (RField_lemma5 nil (condition v5 ++ condition v7) (fun (v9 : forall v9 : list (Ring_polynom.PExpr (@Z)), Prop) (v10 : v9 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop => v11 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v10 : v9 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v5 ++ condition v7) nil)))) : IZR 2 / IZR 3 = atan_sub (IZR 1) (/ IZR 5) in eq_ind (IZR 2 / IZR 3) (fun v2 : @R => atan v2 = atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239)))) (eq_ind_r (fun v2 : @R => v2 = atan (/ IZR 5) + (atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239)))) (f_equal (Rplus (atan (/ IZR 5))) (let v2 : IZR 7 / IZR 17 = atan_sub (IZR 2 / IZR 3) (/ IZR 5) := (let v2 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v3 : forall (v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v3) (v5 : linear (@Z)) (v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 7%Z) (FEc 17%Z)) = v5) (v7 : linear (@Z)) (v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) = v7) (v9 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (v10 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v5 ++ condition v7)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEc 7%Z) (FEc 17%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v2 (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) (@I) in let v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v5 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 in let v6 : linear (@Z) := {| num := Ring_polynom.PEc 7%Z; denum := Ring_polynom.PEc 17%Z; condition := Ring_polynom.PEc 17%Z :: nil |} in let v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 7%Z) (FEc 17%Z)) = v6 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 7%Z) (FEc 17%Z)) = v6 in let v8 : linear (@Z) := {| num := Ring_polynom.PEc 7%Z; denum := Ring_polynom.PEc 17%Z; condition := Ring_polynom.PEc 17%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) = v8 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 2%Z) (FEc 3%Z)) (FEinv (FEc 5%Z))))) = v8 in v3 v4 v5 v6 v7 v8 v9 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v6) (denum v8))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v8) (denum v6))) = @true) (RField_lemma5 nil (condition v6 ++ condition v8) (fun (v10 : forall v10 : list (Ring_polynom.PExpr (@Z)), Prop) (v11 : v10 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v12 : forall v12 : list (Ring_polynom.PExpr (@Z)), Prop => v12 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v11 : v10 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v6 ++ condition v8) nil)))) : IZR 7 / IZR 17 = atan_sub (IZR 2 / IZR 3) (/ IZR 5) in eq_ind (IZR 7 / IZR 17) (fun v3 : @R => atan v3 = atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239))) (eq_ind_r (fun v3 : @R => v3 = atan (/ IZR 5) + (atan (/ IZR 5) + - atan (/ IZR 239))) (f_equal (Rplus (atan (/ IZR 5))) (let v3 : IZR 9 / IZR 46 = atan_sub (IZR 7 / IZR 17) (/ IZR 5) := (let v3 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v4 : forall (v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v5 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 9%Z) (FEc 46%Z)) = v6) (v8 : linear (@Z)) (v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) = v8) (v10 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v6) (denum v8))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v8) (denum v6))) = @true) (v11 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v6 ++ condition v8)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEc 9%Z) (FEc 46%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v3 (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) (@I) in let v5 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v6 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 = v5 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v3 = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 9%Z; denum := Ring_polynom.PEc 46%Z; condition := Ring_polynom.PEc 46%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 9%Z) (FEc 46%Z)) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEc 9%Z) (FEc 46%Z)) = v7 in let v9 : linear (@Z) := {| num := Ring_polynom.PEc 18%Z; denum := Ring_polynom.PEc 92%Z; condition := Ring_polynom.PEc 92%Z :: Ring_polynom.PEc 17%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 17%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v10 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) = v9 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 7%Z) (FEc 17%Z)) (FEinv (FEc 5%Z))))) = v9 in v4 v5 v6 v7 v8 v9 v10 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v7) (denum v9))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v9) (denum v7))) = @true) (RField_lemma5 nil (condition v7 ++ condition v9) (fun (v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop) (v12 : v11 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v13 : forall v13 : list (Ring_polynom.PExpr (@Z)), Prop => v13 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v12 : v11 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v7 ++ condition v9) nil)))) : IZR 9 / IZR 46 = atan_sub (IZR 7 / IZR 17) (/ IZR 5) in eq_ind (IZR 9 / IZR 46) (fun v4 : @R => atan v4 = atan (/ IZR 5) + - atan (/ IZR 239)) (eq_ind_r (fun v4 : @R => v4 = atan (/ IZR 5) + - atan (/ IZR 239)) (f_equal (Rplus (atan (/ IZR 5))) (eq_ind (atan (- / IZR 239)) (fun v4 : @R => atan (atan_sub (IZR 9 / IZR 46) (/ IZR 5)) = v4) (f_equal (@atan) ((let v4 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v5 : forall (v5 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v6 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 = v5) (v7 : linear (@Z)) (v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = v7) (v9 : linear (@Z)) (v10 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEopp (FEinv (FEc 239%Z))) = v9) (v11 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v7) (denum v9))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v5 (Ring_polynom.PEmul (num v9) (denum v7))) = @true) (v12 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v7 ++ condition v9)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEopp (FEinv (FEc 239%Z))) := RField_field_lemma1 (@ring_subst_niter) nil v4 (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) (FEopp (FEinv (FEc 239%Z))) (@I) in let v6 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v7 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 = v6 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v4 = v6 in let v8 : linear (@Z) := {| num := Ring_polynom.PEc (-1)%Z; denum := Ring_polynom.PEc 239%Z; condition := Ring_polynom.PEc 239%Z :: Ring_polynom.PEc 46%Z :: Ring_polynom.PEc 5%Z :: Ring_polynom.PEc 46%Z :: Ring_polynom.PEc 5%Z :: nil |} in let v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = v8 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))) (FEadd (FEc 1%Z) (FEmul (FEdiv (FEc 9%Z) (FEc 46%Z)) (FEinv (FEc 5%Z))))) = v8 in let v10 : linear (@Z) := {| num := Ring_polynom.PEc (-1)%Z; denum := Ring_polynom.PEc 239%Z; condition := Ring_polynom.PEc 239%Z :: nil |} in let v11 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEopp (FEinv (FEc 239%Z))) = v10 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEopp (FEinv (FEc 239%Z))) = v10 in v5 v6 v7 v8 v9 v10 v11 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEmul (num v8) (denum v10))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v6 (Ring_polynom.PEmul (num v10) (denum v8))) = @true) (RField_lemma5 nil (condition v8 ++ condition v10) (fun (v12 : forall v12 : list (Ring_polynom.PExpr (@Z)), Prop) (v13 : v12 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v14 : forall v14 : list (Ring_polynom.PExpr (@Z)), Prop => v14 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v13 : v12 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v8 ++ condition v10) nil)))) : atan_sub (IZR 9 / IZR 46) (/ IZR 5) = - / IZR 239)) (- atan (/ IZR 239)) (atan_opp (/ IZR 239)))) (atan_sub_correct (IZR 9 / IZR 46) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 9 / IZR 46 * / IZR 5) (IZR 0) ((let v4 : IZR 1 + IZR 9 * / IZR 46 * / IZR 5 > IZR 0 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CMult (RMicromega.CZ 9) (RMicromega.CInv (RMicromega.CZ 46))) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR 1 + IZR 9 / IZR 46 * / IZR 5 > IZR 0)) (tech (IZR 9 / IZR 46) (/ IZR 5) (conj ((let v4 : IZR (-1) <= IZR 9 * / IZR 46 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 9) (RMicromega.CInv (RMicromega.CZ 46))) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR (-1) <= IZR 9 / IZR 46) ((let v4 : IZR 9 * / IZR 46 <= IZR 1 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 9) (RMicromega.CInv (RMicromega.CZ 46))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR 9 / IZR 46 <= IZR 1)) (conj ((let v4 : IZR (-1) < / IZR 5 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : IZR (-1) < / IZR 5) ((let v4 : / IZR 5 < IZR 1 := let v4 : list (@QMicromega.QWitness) := nil in let v5 : VarMap.t (@R) := VarMap.Empty in let v6 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v6 v4 (eq_refl : RMicromega.RTautoChecker v6 v4 = @true) (VarMap.find (IZR 0) v5) in v4) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 9 / IZR 46) (/ IZR 5))))) (atan_sub (IZR 7 / IZR 17) (/ IZR 5)) v3)) (atan_sub_correct (IZR 7 / IZR 17) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 7 / IZR 17 * / IZR 5) (IZR 0) ((let v3 : IZR 1 + IZR 7 * / IZR 17 * / IZR 5 > IZR 0 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CMult (RMicromega.CZ 7) (RMicromega.CInv (RMicromega.CZ 17))) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR 1 + IZR 7 / IZR 17 * / IZR 5 > IZR 0)) (tech (IZR 7 / IZR 17) (/ IZR 5) (conj ((let v3 : IZR (-1) <= IZR 7 * / IZR 17 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 7) (RMicromega.CInv (RMicromega.CZ 17))) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR (-1) <= IZR 7 / IZR 17) ((let v3 : IZR 7 * / IZR 17 <= IZR 1 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 7) (RMicromega.CInv (RMicromega.CZ 17))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR 7 / IZR 17 <= IZR 1)) (conj ((let v3 : IZR (-1) < / IZR 5 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : IZR (-1) < / IZR 5) ((let v3 : / IZR 5 < IZR 1 := let v3 : list (@QMicromega.QWitness) := nil in let v4 : VarMap.t (@R) := VarMap.Empty in let v5 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v5 v3 (eq_refl : RMicromega.RTautoChecker v5 v3 = @true) (VarMap.find (IZR 0) v4) in v3) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 7 / IZR 17) (/ IZR 5))))) (atan_sub (IZR 2 / IZR 3) (/ IZR 5)) v2)) (atan_sub_correct (IZR 2 / IZR 3) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 2 / IZR 3 * / IZR 5) (IZR 0) ((let v2 : IZR 1 + IZR 2 * / IZR 3 * / IZR 5 > IZR 0 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CMult (RMicromega.CZ 2) (RMicromega.CInv (RMicromega.CZ 3))) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR 1 + IZR 2 / IZR 3 * / IZR 5 > IZR 0)) (tech (IZR 2 / IZR 3) (/ IZR 5) (conj ((let v2 : IZR (-1) <= IZR 2 * / IZR 3 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 2) (RMicromega.CInv (RMicromega.CZ 3))) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) <= IZR 2 / IZR 3) ((let v2 : IZR 2 * / IZR 3 <= IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CMult (RMicromega.CZ 2) (RMicromega.CInv (RMicromega.CZ 3))); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR 2 / IZR 3 <= IZR 1)) (conj ((let v2 : IZR (-1) < / IZR 5 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) < / IZR 5) ((let v2 : / IZR 5 < IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 2 / IZR 3) (/ IZR 5))))) (atan_sub (IZR 1) (/ IZR 5)) v1)) (IZR 4 * atan (/ IZR 5) - atan (/ IZR 239)) v0) (atan_sub_correct (IZR 1) (/ IZR 5) (Rgt_not_eq (IZR 1 + IZR 1 * / IZR 5) (IZR 0) ((let v0 : IZR 1 + IZR 1 * / IZR 5 > IZR 0 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CZ 1) (RMicromega.CInv (RMicromega.CZ 5)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 + IZR 1 * / IZR 5 > IZR 0)) (tech (IZR 1) (/ IZR 5) (conj ((let v0 : IZR (-1) <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) <= IZR 1) ((let v0 : IZR 1 <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ 1); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 <= IZR 1)) (conj ((let v0 : IZR (-1) < / IZR 5 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) < / IZR 5) ((let v0 : / IZR 5 < IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 5)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : / IZR 5 < IZR 1))) (atan_bound (atan_sub (IZR 1) (/ IZR 5))))) (@PI / IZR 4) (@atan_1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.Machin_2_3_7	100	1.948048	1	1	0	synth with cache (only 1: refine (eq_ind (atan (IZR 1)) (fun v0 : @R => v0 = IZR 2 * atan (/ IZR 3) + atan (/ IZR 7)) (eq_ind_r (fun v0 : @R => v0 = IZR 2 * atan (/ IZR 3) + atan (/ IZR 7)) (let v0 : atan (/ IZR 3) + (atan (/ IZR 3) + atan (/ IZR 7)) = IZR 2 * atan (/ IZR 3) + atan (/ IZR 7) := let v0 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v1 : list (@R) := (atan (/ IZR 3) :: atan (/ IZR 7) :: nil)%list in RField_ring_lemma1 (@ring_subst_niter) v1 v0 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2))) (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 2%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)) (@I) (eq_refl : (let v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v0 in Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEadd (Ring_polynom.PEX (@Z) 1) (Ring_polynom.PEX (@Z) 2)))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEadd (Ring_polynom.PEmul (Ring_polynom.PEc 2%Z) (Ring_polynom.PEX (@Z) 1)) (Ring_polynom.PEX (@Z) 2)))) = @true) in eq_ind (atan (/ IZR 3) + (atan (/ IZR 3) + atan (/ IZR 7))) (fun v1 : @R => atan (/ IZR 3) + atan (atan_sub (IZR 1) (/ IZR 3)) = v1) (f_equal (Rplus (atan (/ IZR 3))) (let v1 : / IZR 2 = atan_sub (IZR 1) (/ IZR 3) := (let v1 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v2 : forall (v2 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v3 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v2) (v4 : linear (@Z)) (v5 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 2%Z)) = v4) (v6 : linear (@Z)) (v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) = v6) (v8 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v4) (denum v6))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v2 (Ring_polynom.PEmul (num v6) (denum v4))) = @true) (v9 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v4 ++ condition v6)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEinv (FEc 2%Z)) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) := RField_field_lemma1 (@ring_subst_niter) nil v1 (FEinv (FEc 2%Z)) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) (@I) in let v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v1 = v3 in let v5 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 2%Z; condition := Ring_polynom.PEc 2%Z :: nil |} in let v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 2%Z)) = v5 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 2%Z)) = v5 in let v7 : linear (@Z) := {| num := Ring_polynom.PEc 2%Z; denum := Ring_polynom.PEc 4%Z; condition := Ring_polynom.PEc 4%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 3%Z :: nil |} in let v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) = v7 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEc 1%Z) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEc 1%Z) (FEinv (FEc 3%Z))))) = v7 in v2 v3 v4 v5 v6 v7 v8 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (RField_lemma5 nil (condition v5 ++ condition v7) (fun (v9 : forall v9 : list (Ring_polynom.PExpr (@Z)), Prop) (v10 : v9 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v11 : forall v11 : list (Ring_polynom.PExpr (@Z)), Prop => v11 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v10 : v9 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v5 ++ condition v7) nil)))) : / IZR 2 = atan_sub (IZR 1) (/ IZR 3) in eq_ind (/ IZR 2) (fun v2 : @R => atan v2 = atan (/ IZR 3) + atan (/ IZR 7)) (eq_ind_r (fun v2 : @R => v2 = atan (/ IZR 3) + atan (/ IZR 7)) (f_equal (Rplus (atan (/ IZR 3))) (f_equal (@atan) ((let v2 : list (Ring_polynom.PExpr (@Z) * Ring_polynom.PExpr (@Z)) := nil in let v3 : forall (v3 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z))) (v4 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v3) (v5 : linear (@Z)) (v6 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = v5) (v7 : linear (@Z)) (v8 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 7%Z)) = v7) (v9 : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v5) (denum v7))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v3 (Ring_polynom.PEmul (num v7) (denum v5))) = @true) (v10 : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (condition v5 ++ condition v7)), FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = FEeval (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) (@Rdiv) (@RinvImpl.Rinv) (@IZR) (@BinNatDef.N.to_nat) (@pow) nil (FEinv (FEc 7%Z)) := RField_field_lemma1 (@ring_subst_niter) nil v2 (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) (FEinv (FEc 7%Z)) (@I) in let v4 : list (@Z * @Ring_polynom.Mon * Ring_polynom.Pol (@Z)) := nil in let v5 : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 := eq_refl : Ring_polynom.mk_monpol_list 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) v2 = v4 in let v6 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 7%Z; condition := Ring_polynom.PEc 7%Z :: Ring_polynom.PEc 2%Z :: Ring_polynom.PEc 3%Z :: Ring_polynom.PEc 2%Z :: Ring_polynom.PEc 3%Z :: nil |} in let v7 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = v6 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEdiv (FEsub (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))) (FEadd (FEc 1%Z) (FEmul (FEinv (FEc 2%Z)) (FEinv (FEc 3%Z))))) = v6 in let v8 : linear (@Z) := {| num := Ring_polynom.PEc 1%Z; denum := Ring_polynom.PEc 7%Z; condition := Ring_polynom.PEc 7%Z :: nil |} in let v9 : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 7%Z)) = v8 := eq_refl : Fnorm 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (FEinv (FEc 7%Z)) = v8 in v3 v4 v5 v6 v7 v8 v9 (eq_refl : Ring_polynom.Peq (@Zeq_bool) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v6) (denum v8))) (Ring_polynom.norm_subst 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem) (@ring_subst_niter) v4 (Ring_polynom.PEmul (num v8) (denum v6))) = @true) (RField_lemma5 nil (condition v6 ++ condition v8) (fun (v10 : forall v10 : list (Ring_polynom.PExpr (@Z)), Prop) (v11 : v10 = PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil) => eq_ind_r (fun v12 : forall v12 : list (Ring_polynom.PExpr (@Z)), Prop => v12 nil) (@I : PCond (IZR 0) (IZR 1) (@Rplus) (@Rmult) (@Rminus) (@Ropp) eq (@IZR) (@BinNatDef.N.to_nat) (@pow) nil nil) v11 : v10 (Fapp (Fcons2 0%Z 1%Z (@BinIntDef.Z.add) (@BinIntDef.Z.mul) (@BinIntDef.Z.sub) (@BinIntDef.Z.opp) (@Zeq_bool) (@BinIntDef.Z.quotrem)) (condition v6 ++ condition v8) nil)))) : atan_sub (/ IZR 2) (/ IZR 3) = / IZR 7))) (atan_sub_correct (/ IZR 2) (/ IZR 3) (Rgt_not_eq (IZR 1 + / IZR 2 * / IZR 3) (IZR 0) ((let v2 : IZR 1 + / IZR 2 * / IZR 3 > IZR 0 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CInv (RMicromega.CZ 2)) (RMicromega.CInv (RMicromega.CZ 3)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR 1 + / IZR 2 * / IZR 3 > IZR 0)) (tech (/ IZR 2) (/ IZR 3) (conj ((let v2 : IZR (-1) <= / IZR 2 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) <= / IZR 2) ((let v2 : / IZR 2 <= IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 2)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : / IZR 2 <= IZR 1)) (conj ((let v2 : IZR (-1) < / IZR 3 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : IZR (-1) < / IZR 3) ((let v2 : / IZR 3 < IZR 1 := let v2 : list (@QMicromega.QWitness) := nil in let v3 : VarMap.t (@R) := VarMap.Empty in let v4 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v4 v2 (eq_refl : RMicromega.RTautoChecker v4 v2 = @true) (VarMap.find (IZR 0) v3) in v2) : / IZR 3 < IZR 1))) (atan_bound (atan_sub (/ IZR 2) (/ IZR 3))))) (atan_sub (IZR 1) (/ IZR 3)) v1)) (IZR 2 * atan (/ IZR 3) + atan (/ IZR 7)) v0) (atan_sub_correct (IZR 1) (/ IZR 3) (Rgt_not_eq (IZR 1 + IZR 1 * / IZR 3) (IZR 0) ((let v0 : IZR 1 + IZR 1 * / IZR 3 > IZR 0 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CPlus (RMicromega.CZ 1) (RMicromega.CMult (RMicromega.CZ 1) (RMicromega.CInv (RMicromega.CZ 3)))); RingMicromega.Fop := @RingMicromega.OpGt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 0) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 + IZR 1 * / IZR 3 > IZR 0)) (tech (IZR 1) (/ IZR 3) (conj ((let v0 : IZR (-1) <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) <= IZR 1) ((let v0 : IZR 1 <= IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ 1); RingMicromega.Fop := @RingMicromega.OpLe; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR 1 <= IZR 1)) (conj ((let v0 : IZR (-1) < / IZR 3 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CZ (-1)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : IZR (-1) < / IZR 3) ((let v0 : / IZR 3 < IZR 1 := let v0 : list (@QMicromega.QWitness) := nil in let v1 : VarMap.t (@R) := VarMap.Empty in let v2 : Tauto.BFormula (RingMicromega.Formula (@RMicromega.Rcst)) := Tauto.A {| RingMicromega.Flhs := EnvRing.PEc (RMicromega.CInv (RMicromega.CZ 3)); RingMicromega.Fop := @RingMicromega.OpLt; RingMicromega.Frhs := EnvRing.PEc (RMicromega.CZ 1) |} (@tt) in RMicromega.RTautoChecker_sound v2 v0 (eq_refl : RMicromega.RTautoChecker v2 v0 = @true) (VarMap.find (IZR 0) v1) in v0) : / IZR 3 < IZR 1))) (atan_bound (atan_sub (IZR 1) (/ IZR 3))))) (@PI / IZR 4) (@atan_1))).
coq-tactician-stdlib.8.11.dev	Coq.Reals.Machin.PI_2_3_7_ineq	100	5.645899	1	1
